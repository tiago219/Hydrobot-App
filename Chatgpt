// Aplica P&B/qualidade/tamanho sem reinicializar (compat√≠vel com libs antigas)
bool applyCameraTweaks(bool gray, int quality /*10..63*/, int fs_code /*-1 = manter*/) {
  sensor_t* s = esp_camera_sensor_get();
  if (!s) return false;

  // P&B direto no sensor (2 = GRAYSCALE)
  if (s->set_special_effect) s->set_special_effect(s, gray ? 2 : 0);

  // Reduz satura√ß√£o quando cinza (ajuda encoder)
  if (s->set_saturation)     s->set_saturation(s, gray ? -2 : 0);

  // >>> AQUI EST√Å A MUDAN√áA: usar set_whitebal (algumas libs n√£o t√™m set_awb)
  if (s->set_whitebal)       s->set_whitebal(s, 0);   // 0 = desliga AWB (fixa balan√ßo)
  // (algumas vers√µes tamb√©m exp√µem set_wb_mode; mantenha sob guard)
  if (s->set_wb_mode)        s->set_wb_mode(s, 0);    // mant√©m modo base

  // Qualidade (n√∫mero MAIOR = MAIS compress√£o = arquivo menor)
  if (quality >= 10 && quality <= 63 && s->set_quality) {
    s->set_quality(s, quality);
  }

  // Tamanho do frame
  if (fs_code > 0 && s->set_framesize) {
    s->set_framesize(s, (framesize_t)fs_code);
  }

  return true;
}









Segue o firmware ESP32-CAM completo (compat√≠vel com vers√µes antigas da esp32-camera) j√° com o endpoint POST /cam para ligar/desligar preto-e-branco, ajustar qualidade e resolu√ß√£o sem reinicializar.


Cole tudo num √∫nico arquivo (ex.: hydrobot.ino) e compile para AI Thinker ESP32-CAM.


/*
  HydroBot - ESP32-CAM (STA, roteador externo)
  Endpoints:
    GET  /               -> p√°gina info
    GET  /status         -> JSON (uptime, RSSI, heap, ip, √∫ltimo STAT do Arduino)
    GET  /snapshot       -> JPEG √∫nico
    GET  /stream         -> MJPEG stream
    POST /uart?cmd=...   -> envia linha na UART2 pro Arduino (ex: CMD:FWD:ms=400:spd=70)
    POST /led?on=0|1     -> liga/desliga flash (GPIO 4)
    POST /restart        -> reinicia ESP
    POST /cam?gray=0|1[&q=10..63][&size=qqvga|qvga|vga|svga|xga|sxga|uxga]
                          -> ajusta c√¢mera em tempo real (P&B, qualidade, resolu√ß√£o)

  mDNS: http://hydrobot.local
  CORS: Access-Control-Allow-Origin: *
  UART: Serial2 (RX=15, TX=14 por padr√£o). ESP envia "REQ:STATUS\n" e guarda √∫ltima "STAT:..."
*/

#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>

// esp32-camera
#include "esp_camera.h"
#include "img_converters.h"
#include "esp_timer.h"
#include "fb_gfx.h"

// evitar brownout reset
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ====== CONFIG REDE ======
const char* WIFI_SSID = "HydroBot";
const char* WIFI_PASS = "loud2025emibr";

// (Opcional) IP fixo ‚Äì comente USE_STATIC_IP para DHCP
//#define USE_STATIC_IP
IPAddress local_IP(192,168,0,50);
IPAddress gateway (192,168,0,1);
IPAddress subnet  (255,255,255,0);
IPAddress dns1    (8,8,8,8);
IPAddress dns2    (1,1,1,1);

// mDNS
const char* MDNS_NAME = "hydrobot"; // http://hydrobot.local

// ====== UART com Arduino ======
#define UART_RX_PIN 15
#define UART_TX_PIN 14
#define UART_BAUD   115200
#define STATUS_POLL_MS 1000

// ====== Camera (AI Thinker) ======
#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

// ====== Globals ======
WebServer server(80);
String lastStatusLine = "";
static const int FLASH_PIN = 4;   // flash do m√≥dulo AI Thinker

static const char* STREAM_BOUNDARY = "frame";
static const char* STREAM_CONTENT_TYPE =
  "multipart/x-mixed-replace;boundary=frame";

unsigned long lastWiFiCheck = 0;
unsigned long lastStatusPoll = 0;

// ---------- Util / CORS ----------
void addCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}
void handleOptions() {
  addCORS();
  server.send(204);
}

// ---------- UART ----------
void initUART() {
  Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN);
}

void pollArduinoStatus() {
  static String rxBuf;
  Serial2.print("REQ:STATUS\n");
  while (Serial2.available()) {
    char c = (char)Serial2.read();
    if (c == '\n' || c == '\r') {
      if (rxBuf.length() > 0) {
        if (rxBuf.startsWith("STAT:")) lastStatusLine = rxBuf;
        rxBuf = "";
      }
    } else {
      rxBuf += c;
    }
  }
}

// ---------- C√¢mera (init) ----------
bool initCamera() {
  // evitar brownout
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;

  // Valores conservadores para estabilidade (pode mudar depois via /cam)
  config.xclk_freq_hz = 10000000;     // 10 MHz costuma ser mais est√°vel que 20 MHz
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_QVGA;  // 320x240 (leve)
  config.jpeg_quality = 20;              // n√∫mero MAIOR = MAIS compress√£o (arquivo menor)
  config.fb_count     = 1;               // 1 buffer reduz consumo RAM e travas

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) return false;

  sensor_t* s = esp_camera_sensor_get();
  if (s) {
    s->set_vflip  (s, false);
    s->set_hmirror(s, false);
  }
  return true;
}

// ---------- Helpers de c√¢mera (compat√≠veis) ----------

// map string -> framesize code (int). Retorna -1 se desconhecido.
int framesize_from_name(const String& name) {
  String n = name; n.toLowerCase();
  if (n == "qqvga") return FRAMESIZE_QQVGA;   // 160x120
  if (n == "qvga")  return FRAMESIZE_QVGA;    // 320x240
  if (n == "vga")   return FRAMESIZE_VGA;     // 640x480
  if (n == "svga")  return FRAMESIZE_SVGA;    // 800x600
  if (n == "xga")   return FRAMESIZE_XGA;     // 1024x768
  if (n == "sxga")  return FRAMESIZE_SXGA;    // 1280x1024
  if (n == "uxga")  return FRAMESIZE_UXGA;    // 1600x1200
  return -1;
}

// Aplica P&B/qualidade/tamanho sem reinicializar (apenas fun√ß√µes amplamente suportadas)
bool applyCameraTweaks(bool gray, int quality /*10..63*/, int fs_code /*-1 = manter*/) {
  sensor_t* s = esp_camera_sensor_get();
  if (!s) return false;

  if (s->set_special_effect) s->set_special_effect(s, gray ? 2 : 0); // 2=grayscale
  if (s->set_saturation)     s->set_saturation(s, gray ? -2 : 0);

  // travar balan√ßo de branco (evita ‚Äúpicos‚Äù em cenas muito vermelhas)
  if (s->set_awb)            s->set_awb(s, 0);
  if (s->set_wb_mode)        s->set_wb_mode(s, 0);

  if (quality >= 10 && quality <= 63 && s->set_quality) {
    s->set_quality(s, quality);       // n√∫mero MAIOR = MAIS compress√£o
  }
  if (fs_code > 0 && s->set_framesize) {
    s->set_framesize(s, (framesize_t)fs_code);
  }
  return true;
}

// ---------- HTTP Handlers ----------
void handleRoot() {
  addCORS();
  String html = "<!doctype html><html><head><meta charset='utf-8'/>"
                "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
                "<title>HydroBot ESP32-CAM</title>"
                "<style>body{font-family:system-ui;background:#0b0b0f;color:#e5e7eb;padding:16px}"
                "a,button{background:#e6403a;color:#fff;padding:8px 12px;border:none;border-radius:8px;text-decoration:none;margin-right:8px}"
                "code{background:#121218;padding:2px 6px;border-radius:6px}</style></head><body>";
  html += "<h2>HydroBot ESP32-CAM (STA)</h2>";
  html += "<p>IP: <code>" + WiFi.localIP().toString() + "</code> | RSSI: <code>" + String(WiFi.RSSI()) + " dBm</code></p>";
  html += "<p><a href='/snapshot'>/snapshot</a> <a href='/stream'>/stream</a> <a href='/status'>/status</a></p>";
  html += "<p>mDNS: <code>http://" + String(MDNS_NAME) + ".local</code></p>";
  html += "<p>√öltimo STATUS Arduino: <code>" + (lastStatusLine.length() ? lastStatusLine : "(ainda n√£o)") + "</code></p>";
  html += "</body></html>";
  server.send(200, "text/html", html);
}

void handleStatus() {
  addCORS();
  String json = "{";
  json += "\"ip\":\"" + WiFi.localIP().toString() + "\",";
  json += "\"rssi\":" + String(WiFi.RSSI()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"uptime_ms\":" + String(millis()) + ",";
  json += "\"arduino_status\":\"" + lastStatusLine + "\"";
  json += "}";
  server.send(200, "application/json", json);
}

void handleSnapshot() {
  addCORS();
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) { server.send(503, "text/plain", "Camera capture failed"); return; }
  server.sendHeader("Content-Type", "image/jpeg");
  server.sendHeader("Content-Disposition", "inline; filename=capture.jpg");
  server.send_P(200, "image/jpeg", (const char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

void handleStream() {
  WiFiClient client = server.client();
  client.println("HTTP/1.1 200 OK");
  client.println(String("Content-Type: ") + STREAM_CONTENT_TYPE);
  client.println("Access-Control-Allow-Origin: *");
  client.println();

  while (client.connected()) {
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) break;

    client.println("--" + String(STREAM_BOUNDARY));
    client.println("Content-Type: image/jpeg");
    client.println("Content-Length: " + String(fb->len));
    client.println();
    client.write(fb->buf, fb->len);
    client.println();
    esp_camera_fb_return(fb);

    delay(10);
  }
}

void handleUART() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  String cmd = server.arg("cmd");
  if (!cmd.length()) { server.send(400, "application/json", "{\"error\":\"use /uart?cmd=...\"}"); return; }
  if (!cmd.endsWith("\n")) cmd += "\n";
  Serial2.print(cmd);
  server.send(200, "application/json", "{\"ok\":true}");
}

void handleLED() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  int on = server.arg("on").toInt();
  digitalWrite(FLASH_PIN, on ? HIGH : LOW);
  server.send(200, "application/json", String("{\"on\":") + (on? "true":"false") + "}");
}

void handleRestart() {
  addCORS();
  server.send(200, "application/json", "{\"restarting\":true}");
  delay(300);
  ESP.restart();
}

// POST /cam?gray=0|1[&q=10..63][&size=...]
void handleCam() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }

  bool gray = server.hasArg("gray") ? (server.arg("gray").toInt() ? true : false) : false;
  int  q    = server.hasArg("q")    ? server.arg("q").toInt() : -1;

  int fs_code = -1;
  String sizeStr = "";
  if (server.hasArg("size")) {
    sizeStr = server.arg("size");
    fs_code = framesize_from_name(sizeStr);
  }

  bool ok = applyCameraTweaks(gray, q, fs_code);

  String resp = String("{\"ok\":") + (ok ? "true" : "false") +
                ",\"gray\":" + (gray ? "true" : "false") +
                (q >= 0 ? String(",\"q\":") + q : "") +
                (sizeStr.length() ? String(",\"size\":\"") + sizeStr + "\"" : "") +
                "}";
  server.send(ok ? 200 : 500, "application/json", resp);
}

// ---------- Wi-Fi ----------
void connectWiFi() {
#ifdef USE_STATIC_IP
  WiFi.config(local_IP, gateway, subnet, dns1, dns2);
#endif
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);

  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 15000) {
    delay(250);
  }
}

void setupServer() {
  // Rotas
  server.on("/",        HTTP_GET,  handleRoot);
  server.on("/status",  HTTP_GET,  handleStatus);
  server.on("/snapshot",HTTP_GET,  handleSnapshot);
  server.on("/stream",  HTTP_GET,  handleStream);
  server.on("/uart",    HTTP_POST, handleUART);
  server.on("/led",     HTTP_POST, handleLED);
  server.on("/restart", HTTP_POST, handleRestart);

  // Novo: ajustes de c√¢mera
  server.on("/cam",     HTTP_POST, handleCam);

  // CORS / notFound
  server.onNotFound([](){
    addCORS();
    server.send(404, "application/json", "{\"error\":\"not found\"}");
  });
  server.on("/uart",    HTTP_OPTIONS, handleOptions);
  server.on("/led",     HTTP_OPTIONS, handleOptions);
  server.on("/restart", HTTP_OPTIONS, handleOptions);
  server.on("/cam",     HTTP_OPTIONS, handleOptions);

  server.begin();
}

// ---------- setup / loop ----------
void setup() {
  Serial.begin(115200);
  delay(200);

  pinMode(FLASH_PIN, OUTPUT);
  digitalWrite(FLASH_PIN, LOW);

  initUART();

  if (!initCamera()) { delay(1000); initCamera(); }

  connectWiFi();

  if (WiFi.status() == WL_CONNECTED) {
    if (MDNS.begin(MDNS_NAME)) MDNS.addService("http", "tcp", 80);
  }

  setupServer();
}

void loop() {
  server.handleClient();

  // Reconnect Wi-Fi
  if (millis() - lastWiFiCheck > 3000) {
    lastWiFiCheck = millis();
    if (WiFi.status() != WL_CONNECTED) connectWiFi();
  }

  // Poll STATUS do Arduino
  if (millis() - lastStatusPoll > STATUS_POLL_MS) {
    lastStatusPoll = millis();
    pollArduinoStatus();
  }
}



Como usar o P&B no encoder da c√¢mera




Ligar P&B + comprimir + reduzir resolu√ß√£o:

POST http://hydrobot.local/cam?gray=1&q=22&size=qvga





Voltar ao colorido (mant√©m qualidade/resolu√ß√£o atuais):

POST http://hydrobot.local/cam?gray=0









Observa√ß√µes:




Na API da esp32-camera, quality maior = mais compress√£o (arquivo menor). Bons valores: 20‚Äì30.


size=qvga (320√ó240) √© muito mais est√°vel do que VGA em redes mais fracas.


Se ainda houver travas, teste xclk=10MHz, fb_count=1 (j√° est√£o assim) e mantenha gray=1 durante cenas cr√≠ticas.






Se quiser, te mando tamb√©m um cURL ou um snippet em JS/React Native para alternar isso direto do app (mas voc√™ j√° tem o bot√£o chamando /cam).








































Show! Aqui v√£o os c√≥digos completos j√° com o P&B controlado direto no ESP via POST /cam e o app com o bot√£o que liga/desliga isso em tempo real.



1) ESP32-CAM (firmware completo, com /cam)




Baseado no seu sketch anterior, adicionei: helpers de c√¢mera, handleCam(), e o registro das rotas. Mantive seus endpoints originais e a l√≥gica de STA, UART, snapshot/stream, etc.




/*
  HydroBot - ESP32-CAM em modo STA (roteador externo)
  - Endpoints:
      GET  /              -> p√°gina info r√°pida
      GET  /status        -> JSON (uptime, RSSI, heap, ip, √∫ltimo STATUS do Arduino)
      GET  /snapshot      -> JPEG √∫nico
      GET  /stream        -> MJPEG stream
      POST /uart?cmd=...  -> envia comando na UART para o Arduino (ex: CMD:FWD:ms=400:spd=70)
      POST /led?on=0|1    -> liga/desliga flash (GPIO 4)
      POST /restart       -> reinicia ESP
      POST /cam?gray=0|1[&q=10..63][&size=qqvga|qvga|vga|svga|xga|sxga|uxga]
                          -> ajusta c√¢mera em tempo real (P&B, qualidade, resolu√ß√£o)
  - mDNS: http://hydrobot.local
  - CORS: Access-Control-Allow-Origin: *
  - UART: Serial2 (pinos configur√°veis abaixo). ESP requisita "REQ:STATUS\n" periodicamente e armazena √∫ltima linha "STAT:...".
*/

#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include "esp_timer.h"
#include "img_converters.h"
#include "esp_camera.h"
#include "fb_gfx.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ====== CONFIG ======
const char* WIFI_SSID   = "HydroBot";
const char* WIFI_PASS   = "loud2025emibr";

// (Opcional) IP fixo ‚Äì deixe comentado se preferir DHCP
//#define USE_STATIC_IP
IPAddress local_IP(192,168,0,50);
IPAddress gateway(192,168,0,1);
IPAddress subnet(255,255,255,0);
IPAddress dns1(8,8,8,8);
IPAddress dns2(1,1,1,1);

// mDNS
const char* MDNS_NAME = "hydrobot"; // http://hydrobot.local

// UART com Arduino (ajuste conforme seu fio)
// Recomenda-se ESP32-CAM: RX=15, TX=14 (costuma estar dispon√≠vel nesse m√≥dulo)
#define UART_RX_PIN 15
#define UART_TX_PIN 14
#define UART_BAUD   115200

// Requisi√ß√£o peri√≥dica ao Arduino
#define STATUS_POLL_MS  1000

// Camera: selecione pinos do modelo AI Thinker
#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

// ====== FIM CONFIG ======

// Servidor HTTP
WebServer server(80);

// Buffer do √∫ltimo STATUS do Arduino
String lastStatusLine = "";

// Controle de LED do flash (AI Thinker usa GPIO 4 pra l√¢mpada)
static const int FLASH_PIN = 4;

// Controle de stream
static const char* STREAM_BOUNDARY = "frame";
static const char* STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" "frame";
static const int STREAM_QUALITY = 12;   // 10..20 (mais baixo = melhor qualidade, por√©m mais pesado)
static const bool STREAM_HFLIP = false; // espelhar horizontal
static const bool STREAM_VFLIP = false; // espelhar vertical

// Watchdog / reconex√£o
unsigned long lastWiFiCheck = 0;
unsigned long lastStatusPoll = 0;

// ---------- Util ----------
void addCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}
void handleOptions() {
  addCORS();
  server.send(204);
}

// ---------- UART ----------
void initUART() {
  Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN);
}
void pollArduinoStatus() {
  static String rxBuf;
  // Solicita status
  Serial2.print("REQ:STATUS\n");
  // L√™ o que chegou desde a √∫ltima chamada
  while (Serial2.available()) {
    char c = (char)Serial2.read();
    if (c == '\n' || c == '\r') {
      if (rxBuf.length() > 0) {
        // Guarda √∫ltima linha completa
        if (rxBuf.startsWith("STAT:")) {
          lastStatusLine = rxBuf;
        }
        rxBuf = "";
      }
    } else {
      rxBuf += c;
    }
  }
}

// ---------- C√¢mera ----------
bool initCamera() {
  // Evitar brownout reset
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;

  // >>> Recomenda√ß√µes p/ estabilidade (pode manter seus valores, mas estes ajudam):
  config.xclk_freq_hz = 10000000;   // 10 MHz deixa PSRAM/encoder mais est√°vel (pode usar 20 MHz se quiser)
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_VGA;   // voc√™ usava VGA; pode mudar em runtime via /cam
  config.jpeg_quality = 12;              // 10..20 (10 melhor). Tamb√©m ajust√°vel via /cam (q=10..63 na API do driver)
  config.fb_count     = 2;               // pode reduzir pra 1 se ainda houver travas

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    return false;
  }

  // Efeitos b√°sicos
  sensor_t * s = esp_camera_sensor_get();
  s->set_vflip(s, STREAM_VFLIP);
  s->set_hmirror(s, STREAM_HFLIP);

  return true;
}

// ---- Ajustes din√¢micos de c√¢mera (sem reinicializar) ----
bool applyCameraTweaks(bool gray, int quality /*10..63*/, framesize_t fs /*ou 0 p/ manter*/) {
  sensor_t* s = esp_camera_sensor_get();
  if (!s) return false;

  // P&B direto no sensor (efeito leve e eficiente)
  s->set_special_effect(s, gray ? 2 : 0);     // 2 = GRAYSCALE
  // Reduz satura√ß√£o no colorido tamb√©m (ajuda em cenas "vermelho forte")
  s->set_saturation(s, gray ? -2 : 0);

  // Estabiliza exposi√ß√£o/balan√ßo para evitar "picos" de bytes
  s->set_awb(s, 0);           // trava AWB (mais previs√≠vel)
  s->set_wb_mode(s, 0);       // modo "auto" como base
  s->set_aec2(s, 0);
  s->set_ae_level(s, -1);     // leve underexposure reduz ru√≠do/bytes

  if (quality >= 10 && quality <= 63) {
    // ATEN√á√ÉO: na API do driver, 'quality' MAIOR = MAIS compress√£o = arquivo MENOR
    s->set_quality(s, quality);
  }
  if (fs != 0) {
    s->set_framesize(s, fs);
  }
  return true;
}

// Converte string "qqvga|qvga|vga|svga|xga|sxga|uxga" em framesize_t
framesize_t parse_framesize(const String& name) {
  String n = name; n.toLowerCase();
  if (n == "qqvga") return FRAMESIZE_QQVGA;   // 160x120
  if (n == "qvga")  return FRAMESIZE_QVGA;    // 320x240
  if (n == "vga")   return FRAMESIZE_VGA;     // 640x480
  if (n == "svga")  return FRAMESIZE_SVGA;
  if (n == "xga")   return FRAMESIZE_XGA;
  if (n == "sxga")  return FRAMESIZE_SXGA;
  if (n == "uxga")  return FRAMESIZE_UXGA;
  return (framesize_t)0;
}

// ---------- Handlers HTTP ----------
void handleRoot() {
  addCORS();
  String html = "<!doctype html><html><head><meta charset='utf-8'/>"
                "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
                "<title>HydroBot ESP32-CAM</title>"
                "<style>body{font-family:system-ui;background:#0b0b0f;color:#e5e7eb;padding:16px}"
                "a,button{background:#e6403a;color:#fff;padding:8px 12px;border:none;border-radius:8px;text-decoration:none;margin-right:8px}"
                "code{background:#121218;padding:2px 6px;border-radius:6px}</style></head><body>";
  html += "<h2>HydroBot ESP32-CAM (STA)</h2>";
  html += "<p>IP: <code>" + WiFi.localIP().toString() + "</code> | RSSI: <code>" + String(WiFi.RSSI()) + " dBm</code></p>";
  html += "<p><a href='/snapshot'>/snapshot</a> <a href='/stream'>/stream</a> <a href='/status'>/status</a></p>";
  html += "<p>mDNS: <code>http://" + String(MDNS_NAME) + ".local</code></p>";
  html += "<p>√öltimo STATUS Arduino: <code>" + (lastStatusLine.length() ? lastStatusLine : "(ainda n√£o)") + "</code></p>";
  html += "</body></html>";
  server.send(200, "text/html", html);
}

void handleStatus() {
  addCORS();
  // Monta JSON simples
  String json = "{";
  json += "\"ip\":\"" + WiFi.localIP().toString() + "\",";
  json += "\"rssi\":" + String(WiFi.RSSI()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"uptime_ms\":" + String(millis()) + ",";
  // Se quiser, parse do lastStatusLine -> chave:valor
  json += "\"arduino_status\":\"" + lastStatusLine + "\"";
  json += "}";
  server.send(200, "application/json", json);
}

void handleSnapshot() {
  addCORS();
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) {
    server.send(503, "text/plain", "Camera capture failed");
    return;
  }
  server.sendHeader("Content-Type", "image/jpeg");
  server.sendHeader("Content-Disposition", "inline; filename=capture.jpg");
  server.send_P(200, "image/jpeg", (const char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

void handleStream() {
  WiFiClient client = server.client();
  // Cabe√ßalhos do stream
  client.println("HTTP/1.1 200 OK");
  client.println("Content-Type: " + String(STREAM_CONTENT_TYPE));
  client.println("Access-Control-Allow-Origin: *");
  client.println();

  while (client.connected()) {
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) break;

    client.println("--" + String(STREAM_BOUNDARY));
    client.println("Content-Type: image/jpeg");
    client.println("Content-Length: " + String(fb->len));
    client.println();
    client.write(fb->buf, fb->len);
    client.println();
    esp_camera_fb_return(fb);

    // Pequena folga
    delay(10);
  }
}

void handleUART() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  String cmd = server.arg("cmd");
  if (!cmd.length()) {
    server.send(400, "application/json", "{\"error\":\"use /uart?cmd=...\"}");
    return;
  }
  // Garante terminador de linha
  if (!cmd.endsWith("\n")) cmd += "\n";
  Serial2.print(cmd);
  server.send(200, "application/json", "{\"ok\":true}");
}

void handleLED() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  int on = server.arg("on").toInt();
  digitalWrite(FLASH_PIN, on ? HIGH : LOW);
  server.send(200, "application/json", String("{\"on\":") + (on? "true":"false") + "}");
}

void handleRestart() {
  addCORS();
  server.send(200, "application/json", "{\"restarting\":true}");
  delay(300);
  ESP.restart();
}

// Novo: POST /cam -> ajusta P&B, qualidade, e resolu√ß√£o em runtime
void handleCam() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  bool gray = server.hasArg("gray") ? (server.arg("gray").toInt() ? true:false) : false;
  int  q    = server.hasArg("q")    ? server.arg("q").toInt() : -1;
  framesize_t fs = 0;
  if (server.hasArg("size")) {
    fs = parse_framesize(server.arg("size"));
  }

  bool ok = applyCameraTweaks(gray, q, fs);
  String resp = String("{\"ok\":") + (ok ? "true" : "false") +
                ",\"gray\":" + (gray?"true":"false") +
                (q>=0 ? String(",\"q\":")+q : "") +
                (server.hasArg("size") ? String(",\"size\":\"")+server.arg("size")+"\"" : "") +
                "}";
  server.send(ok?200:500, "application/json", resp);
}

// ---------- Wi-Fi ----------
void connectWiFi() {
#ifdef USE_STATIC_IP
  WiFi.config(local_IP, gateway, subnet, dns1, dns2);
#endif
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);

  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 15000) {
    delay(250);
  }
}

void setupServer() {
  // Rotas
  server.on("/", HTTP_GET, handleRoot);
  server.on("/status", HTTP_GET, handleStatus);
  server.on("/snapshot", HTTP_GET, handleSnapshot);
  server.on("/stream", HTTP_GET, handleStream);
  server.on("/uart", HTTP_POST, handleUART);
  server.on("/led", HTTP_POST, handleLED);
  server.on("/restart", HTTP_POST, handleRestart);

  // Novo endpoint de c√¢mera
  server.on("/cam", HTTP_POST, handleCam);

  // CORS preflight
  server.onNotFound([](){
    addCORS();
    server.send(404, "application/json", "{\"error\":\"not found\"}");
  });
  server.on("/uart", HTTP_OPTIONS, handleOptions);
  server.on("/led", HTTP_OPTIONS, handleOptions);
  server.on("/restart", HTTP_OPTIONS, handleOptions);
  server.on("/cam", HTTP_OPTIONS, handleOptions);

  server.begin();
}

// ---------- setup / loop ----------
void setup() {
  // Logs seriais (opcional). Evite compartilhar TX0/RX0 com Arduino se usar USB.
  Serial.begin(115200);
  delay(200);

  pinMode(FLASH_PIN, OUTPUT);
  digitalWrite(FLASH_PIN, LOW);

  // UART secund√°ria com Arduino
  initUART();

  // C√¢mera
  if (!initCamera()) {
    // Tente outra vez
    delay(1000);
    initCamera();
  }

  // Wi-Fi
  connectWiFi();

  // mDNS
  if (WiFi.status() == WL_CONNECTED) {
    if (MDNS.begin(MDNS_NAME)) {
      MDNS.addService("http", "tcp", 80);
    }
  }

  // HTTP
  setupServer();
}

void loop() {
  server.handleClient();

  // Watch Wi-Fi & reconectar
  if (millis() - lastWiFiCheck > 3000) {
    lastWiFiCheck = millis();
    if (WiFi.status() != WL_CONNECTED) {
      connectWiFi();
    }
  }

  // Poll do STATUS no Arduino
  if (millis() - lastStatusPoll > STATUS_POLL_MS) {
    lastStatusPoll = millis();
    pollArduinoStatus();
  }
}




2) CameraScreen.tsx (com bot√£o P&B que chama /cam)




√â a sua tela com watchdog anti-congelamento, joystick por UART, LED, bomba via UART, e agora toggle P&B que aciona o endpoint do ESP. (Mantive o v√≠deo por snapshot do servidor com fallbacks.)




// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet,
  PanResponder, GestureResponderEvent, PanResponderGestureState,
  Image, Animated, LayoutChangeEvent,
} from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: { heroSubtitle:"Monitoramento e Controle", espIp:"ESP:", pumpOn:"BOMBA ON", pumpOff:"BOMBA OFF",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Aguardando servidor‚Ä¶", statusFail:"Falha ao conectar. Confira o Wi-Fi/IP.",
        noVideo:"Sem v√≠deo (snapshot). Verifique o servidor.", fireOn:(s:number)=>`üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sem fogo ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sincronizado",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF", bwOn:"P&B ON", bwOff:"P&B OFF" },
  en: { heroSubtitle:"Monitoring & Control", espIp:"ESP:", pumpOn:"PUMP ON", pumpOff:"PUMP OFF",
        server:"Server:", detecting:"Detecting‚Ä¶", waiting:"Waiting for server‚Ä¶", statusFail:"Failed to connect. Check Wi-Fi/IP.",
        noVideo:"No video (snapshot). Check server.", fireOn:(s:number)=>`üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`No fire ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sync OK",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF", bwOn:"B/W ON", bwOff:"B/W OFF" },
  es: { heroSubtitle:"Monitoreo y Control", espIp:"ESP:", pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Esperando servidor‚Ä¶", statusFail:"Error de conexi√≥n. Revisa Wi-Fi/IP.",
        noVideo:"Sin v√≠deo (snapshot). Revisa el servidor.", fireOn:(s:number)=>`üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sin fuego ‚Ä¢ score ${s.toFixed(2)}`, synced:"Sincronizado con servidor",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF", bwOn:"BN ON", bwOff:"BN OFF" },
};

const DEFAULT_IP = "hydrobot.local";
const DEFAULT_SERVER = "http://192.168.0.100:8000";
const DEFAULT_FRAME_WH = { w: 320, h: 240 };

const LOAD_TIMEOUT_MS = 900;   // watchdog por frame
const GLOBAL_STALL_MS  = 2500; // sem sucesso por esse tempo => for√ßa fallback

const appLogo = require("../../assets/logo.png");

/* ---------- UI ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown,
}: { currentUri: string; nextUri: string; onNextLoadStart: () => void; onNextShown: (ok: boolean) => void; }) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");
  const watchdogRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  const clearWatchdog = () => { if (watchdogRef.current) { clearTimeout(watchdogRef.current); watchdogRef.current = null; } };

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={() => {
              onNextLoadStart();
              clearWatchdog();
              watchdogRef.current = setTimeout(() => { onNextShown(false); clearWatchdog(); }, LOAD_TIMEOUT_MS);
            }}
            onError={() => { clearWatchdog(); onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              clearWatchdog();
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

type SrcBox = { x:number; y:number; w:number; h:number; type:"fire" };
function BoxesOverlay({ frameWH, containerWH, boxes }:{
  frameWH:{w:number;h:number}|null; containerWH:{w:number;h:number}|null; boxes:SrcBox[];
}) {
  const f = frameWH && frameWH.w>0 && frameWH.h>0 ? frameWH : DEFAULT_FRAME_WH;
  if (!containerWH || containerWH.w<=0 || containerWH.h<=0) return null;
  const scale = Math.min(containerWH.w / f.w, containerWH.h / f.h);
  const dispW = f.w * scale, dispH = f.h * scale;
  const offsetX = (containerWH.w - dispW)/2, offsetY = (containerWH.h - dispH)/2;
  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position:"absolute", left:offsetX, top:offsetY, width:dispW, height:dispH }}>
        {boxes.map((b,i)=>{
          const left=b.x*scale, top=b.y*scale, width=b.w*scale, height=b.h*scale;
          return (
            <View key={i} style={{ position:"absolute", left, top, width, height, borderWidth:3, borderColor:"#ff3b30", borderRadius:6 }}>
              <View style={{ position:"absolute", left:0, top:-18, paddingHorizontal:6, paddingVertical:2, borderRadius:4, backgroundColor:"#ff3b30" }}>
                <Text style={{ color:"#000", fontWeight:"800", fontSize:10 }}>FOGO</Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- SCREEN ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [statusText, setStatusText] = useState(T.waiting);
  const [pumpOn, setPumpOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{w:number;h:number}|null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{w:number;h:number}|null>(null);

  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  const [useDirectSnapshot, setUseDirectSnapshot] = useState(false);
  const failCountRef = useRef(0);
  const lastFrameOkTsRef = useRef<number>(Date.now());

  // Toggle P&B no ESP (controla encoder da c√¢mera)
  const [bw, setBw] = useState<boolean>(false);

  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const clean = (s:string)=>s.replace(/\/+$/,"");

  // Server endpoints
  const healthUrl     = useMemo(()=>`${clean(server)}/healthz`,[server]);
  const detectUrl     = useMemo(()=>`${clean(server)}/detect`,[server]);
  const snapshotSrv   = useMemo(()=>`${clean(server)}/snapshot`,[server]);
  const snapshotSrvAlt= useMemo(()=>`${clean(server)}/frame.jpg`,[server]);
  const configUrl     = useMemo(()=>`${clean(server)}/config`,[server]);

  // ESP endpoints
  const snapshotEsp   = useMemo(()=> `http://${ip}/snapshot`, [ip]);
  const uartPost      = useMemo(()=> (cmd:string)=>`http://${ip}/uart?cmd=${encodeURIComponent(cmd)}`, [ip]);
  const ledPost       = useMemo(()=> (on:boolean)=>`http://${ip}/led?on=${on?1:0}`, [ip]);
  const camPost       = useMemo(()=> (params:string)=>`http://${ip}/cam${params?("?"+params):""}`, [ip]);

  // Liga/desliga P&B no ESP (ajusta tamb√©m qualidade e tamanho recomendados)
  async function setCameraGray(on:boolean) {
    try {
      // Dica: q=20 (mais compress√£o) + size=qvga derrubam bastante os bytes por frame
      const params = on ? "gray=1&q=20&size=qvga" : "gray=0";
      const res = await fetch(camPost(params), { method: "POST" });
      return res.ok;
    } catch { return false; }
  }

  // Sincroniza IP da c√¢mera no server
  useEffect(()=>{
    let aborted=false;
    (async()=>{
      try{
        const r=await fetch(configUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({camera_ip:ip})});
        const j=await r.json();
        if(!aborted && j?.ok) setStatusText(`${T.synced} (${j.camera_ip})`);
      }catch{ if(!aborted) setStatusText(T.statusFail); }
    })();
    return()=>{aborted=true};
  },[ip, configUrl, T]);

  // Health do servidor
  useEffect(()=>{
    let stop=false, backoff=500;
    const poll=async()=>{
      if(stop) return;
      try{
        const r=await fetch(healthUrl); const j=await r.json();
        if(j?.ok){ setStatusText(`Server OK ‚Ä¢ fps_in:${j.fps_in} ‚Ä¢ hasFrame:${j.hasFrame}`); return; }
      }catch{}
      setStatusText(T.waiting);
      setTimeout(poll, backoff); backoff=Math.min(backoff*1.6, 5000);
    };
    poll(); return()=>{stop=true};
  },[healthUrl, T]);

  // SNAPSHOT loop com fallback (server -> alt -> direto ESP)
  useEffect(()=>{
    let stop=false, interval=160;

    const pickBase = ()=>{
      if (useDirectSnapshot) return snapshotEsp;
      return failCountRef.current >= 2 ? snapshotSrvAlt : snapshotSrv;
    };

    setCurrentFrameUri(`${pickBase()}?ts=${Date.now()}`);
    const tick=()=>{
      if(stop) return;
      try{
        if(!loadingNextRef.current){
          const base = pickBase();
          setNextFrameUri(`${base}?ts=${Date.now()}&n=${Math.random().toString(36).slice(2,7)}`);
        }
        interval=160;
      }catch{
        interval=Math.min(interval*1.7, 1200);
      }
      setTimeout(tick, interval);
    };
    tick();
    return()=>{stop=true};
  },[snapshotSrv, snapshotSrvAlt, snapshotEsp, useDirectSnapshot]);

  const onNextLoadStart = ()=>{ loadingNextRef.current=true; };
  const onNextShown = (ok:boolean)=>{
    if(ok){
      failCountRef.current = 0;
      lastFrameOkTsRef.current = Date.now();
      if(useDirectSnapshot){ /* mant√©m se necess√°rio */ }
      if(nextFrameUri) setCurrentFrameUri(nextFrameUri);
    }else{
      failCountRef.current += 1;
      if(!useDirectSnapshot && failCountRef.current >= 3){
        setUseDirectSnapshot(true);  // cai pro snapshot direto do ESP
        failCountRef.current = 0;
      }
    }
    loadingNextRef.current=false;
  };

  // Descongelador global
  useEffect(()=>{
    let stop=false;
    const guard=()=>{
      if(stop) return;
      const idle = Date.now() - lastFrameOkTsRef.current;
      if(idle > GLOBAL_STALL_MS){
        setUseDirectSnapshot(true); // √∫ltimo recurso
        failCountRef.current = 0;
        lastFrameOkTsRef.current = Date.now();
      }
      setTimeout(guard, 400);
    };
    guard();
    return()=>{stop=true};
  },[]);

  // DETECT loop (servidor)
  useEffect(()=>{
    let stop=false, interval=250;
    const loop=async()=>{
      if(stop) return;
      try{
        const r=await fetch(detectUrl); const j=await r.json();
        if(j && j.ok!==false){
          setIsFire(!!j.isFire); setFireScore(Number(j.score||0));
          const wh = Array.isArray(j.frame_wh)&&j.frame_wh.length===2
                     ? {w:Number(j.frame_wh[0])||0, h:Number(j.frame_wh[1])||0}:null;
          if(wh && wh.w>0 && wh.h>0) setFrameWH(wh);
          const boxes:SrcBox[]=[];
          if(j.isFire && Array.isArray(j.boxes)){
            for(const b of j.boxes){
              if(Array.isArray(b)&&b.length>=4){
                const [x,y,w,h]=b.map((n:any)=>Number(n)||0);
                boxes.push({x,y,w,h,type:"fire"});
              }
            }
          }
          setOverlayBoxes(boxes); interval=250;
        }
      }catch{
        setIsFire(false); setFireScore(0); setOverlayBoxes([]);
        interval=Math.min(interval*1.5,1500);
      }finally{ setTimeout(loop, interval); }
    };
    loop(); return()=>{stop=true};
  },[detectUrl]);

  // ------- COMANDOS (UART + LED) -------
  async function sendUART(cmd: string) {
    try {
      const res = await fetch(uartPost(cmd), { method: "POST" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return true;
    } catch {
      setStatusText(T.statusFail);
      return false;
    }
  }
  async function togglePump(){
    const target = !pumpOn;
    const ok = await sendUART(`CMD:PUMP:${target ? "1" : "0"}`);
    if (ok) setPumpOn(target);
  }
  async function led(on:boolean){
    try{
      const res = await fetch(ledPost(on), { method: "POST" });
      const txt = await res.text();
      setStatusText(`${on?T.ledOn:T.ledOff} ‚Ä¢ ${res.status} ${txt||""}`);
    }catch{
      setStatusText(T.statusFail);
    }
  }

  // Joystick -> pulsos discretos via UART
  const RADIUS=64;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder:()=>true,
      onMoveShouldSetPanResponder:()=>true,
      onPanResponderGrant:()=>{ setDragging(true); },
      onPanResponderMove:(_e:GestureResponderEvent,g:PanResponderGestureState)=>{
        let nx=g.dx/RADIUS, ny=g.dy/RADIUS;
        const len=Math.hypot(nx,ny); if(len>1){ nx/=len; ny/=len; }
        setJoy({x:nx, y:-ny});
      },
      onPanResponderRelease:()=>{ setJoy({x:0,y:0}); setDragging(false); },
      onPanResponderTerminate:()=>{ setJoy({x:0,y:0}); setDragging(false); },
    })
  ).current;

  const lastSendRef = useRef(0);
  const lastDirRef  = useRef<string>("STOP");
  const vecToDir=(x:number,y:number):"FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP"=>{
    const mag=Math.hypot(x,y); if(mag<0.2) return "STOP";
    const deg=(Math.atan2(y,x)*180)/Math.PI;
    if(deg>-45&&deg<=45) return "RIGHT";
    if(deg>45&&deg<=135) return "FWD";
    if(deg<=-45&&deg>-135) return "BACK";
    return "LEFT";
  };

  useEffect(()=>{
    let cancelled=false;
    const tick=async()=>{
      if(cancelled) return;
      const now=Date.now();
      if(now-lastSendRef.current<120){ setTimeout(tick,20); return; }
      lastSendRef.current=now;

      const {x,y}=joy; const mag=Math.hypot(x,y); const dir=vecToDir(x,y);
      if(dir!==lastDirRef.current){
        if(dir==="STOP"){ await sendUART("CMD:STOP"); }
        else{
          const ms=140+Math.round(260*Math.min(1,mag));
          const spd=50+Math.round(50*Math.min(1,mag));
          await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
        }
        lastDirRef.current=dir;
      }else if(dir!=="STOP"){
        const ms=120+Math.round(200*Math.min(1,mag));
        const spd=50+Math.round(50*Math.min(1,mag));
        await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
      }
      setTimeout(tick,120);
    };
    tick(); return()=>{cancelled=true};
  },[joy, ip]);

  function onVideoLayout(e:LayoutChangeEvent){
    const {width,height}=e.nativeEvent.layout; setVideoContainerWH({w:width,h:height});
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder={T.placeholderIp} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={styles.input} />
        <Text style={styles.label}>{T.server}</Text>
        <TextInput value={server} onChangeText={setServer} placeholder={T.placeholderServer} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={[styles.input,{minWidth:220}]} />

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn?styles.btnOn:styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn?T.pumpOn:T.pumpOff}</Text>
        </Pressable>
        <Pressable onPress={()=>led(true)} style={[styles.btn, {backgroundColor:"#2563eb"}]}>
          <Text style={styles.btnText}>{T.ledOn}</Text>
        </Pressable>
        <Pressable onPress={()=>led(false)} style={[styles.btn, {backgroundColor:"#374151"}]}>
          <Text style={styles.btnText}>{T.ledOff}</Text>
        </Pressable>

        {/* Bot√£o P&B: aciona /cam no ESP */}
        <Pressable
          onPress={async ()=>{
            const next = !bw;
            const ok = await setCameraGray(next);
            if (ok) setBw(next);
          }}
          style={[styles.btn, bw ? { backgroundColor:"#111827", borderWidth:1, borderColor:"#6b7280" } : { backgroundColor:"#d1d5db" }]}
        >
          <Text style={[styles.btnText, { color: bw ? "#e5e7eb" : "#111827" }]}>{bw ? T.bwOn : T.bwOff}</Text>
        </Pressable>
      </View>

      <View style={[styles.statusRow,{paddingTop:4,paddingBottom:8}]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText} {useDirectSnapshot ? "‚Ä¢ (snapshot direto)" : ""}
        </Text>
        <View style={[styles.badge,{backgroundColor: "#065f46"}]}>
          <Text style={{ color:"#fff", fontWeight:"800" }}>{isFire ? T.detecting : T.waiting}</Text>
        </View>
      </View>

      <View style={[styles.fireBanner, isFire?styles.fireOn:styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      <View style={{ flex:1 }} onLayout={onVideoLayout}>
        <CrossfadeImage currentUri={currentFrameUri} nextUri={nextFrameUri}
                        onNextLoadStart={()=> (loadingNextRef.current=true)}
                        onNextShown={onNextShown}/>
        {overlayBoxes.length>0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap,{width:64*2+24,height:64*2+24}]}
              {...(pan.panHandlers as any)}>
          <View style={[styles.joyBase,{width:64*2,height:64*2,borderRadius:64}]} />
          <View style={[styles.joyKnob,{width:22*2,height:22*2,borderRadius:22,
                        transform:[{translateX:joy.x*64},{translateY:-joy.y*64}], opacity: dragging?1:0.9}]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", flexWrap:"wrap",
           paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:120 },
  btn:{ backgroundColor:PALETTE.accent, paddingHorizontal:10, paddingVertical:10, borderRadius:10 },
  btnOn:{ backgroundColor:"#17a34a" }, btnOff:{ backgroundColor:"#374151" },
  btnText:{ color:"white", fontWeight:"600" },

  statusRow:{ flexDirection:"row", alignItems:"center", paddingHorizontal:12, paddingVertical:8, gap:8,
              backgroundColor:"#0f1322", borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  badge:{ paddingHorizontal:10, paddingVertical:6, borderRadius:8, borderWidth:1, borderColor:PALETTE.border },
  status:{ color:"#cbd5ff", flex:1, fontSize:12 },

  fireBanner:{ alignItems:"center", justifyContent:"center", paddingVertical:6 },
  fireOn:{ backgroundColor:"#8b0000" }, fireOff:{ backgroundColor:"#223" },
  fireText:{ color:"white", fontWeight:"800" },

  joyWrap:{ position:"absolute", bottom:24, left:24, alignItems:"center", justifyContent:"center" },
  joyBase:{ position:"absolute", backgroundColor:"rgba(255,255,255,0.08)", borderWidth:2, borderColor:"rgba(255,255,255,0.14)" },
  joyKnob:{ position:"absolute", backgroundColor:"rgba(230,64,58,0.9)", borderWidth:2, borderColor:"rgba(255,255,255,0.85)" },
  joyText:{ position:"absolute", bottom:-22, color:"#cbd5ff", fontSize:12 },
});




Dicas finais




Teste o bot√£o P&B: ao ligar, o app chama POST http://hydrobot.local/cam?gray=1&q=20&size=qvga.

Voc√™ pode ajustar esses valores no setCameraGray() conforme a sua rede (ex.: q=22 ainda menor).


Se ainda tiver algum ‚Äúsurto‚Äù em cenas muito vermelhas, experimente no setup inicial colocar fb_count=1 e xclk_freq_hz=10000000 (j√° deixei comentado/recomendado no firmware). Isso tende a eliminar travas persistentes em alguns m√≥dulos AI Thinker.




Se quiser, tamb√©m mando a vers√£o do server com re-encode P&B/resize (sob demanda) para quando voc√™ desligar o P&B no ESP mas quiser economizar banda no cliente.




























































Bora! Vou colocar um toggle P&B no app e, para funcionar de verdade, vou estender o server para reencodar o √∫ltimo frame em preto-e-branco (e opcionalmente reduzir largura/qualidade). Assim voc√™ liga/desliga na hora, sem mexer no firmware.


Abaixo est√£o os dois arquivos completos com as mudan√ßas:



1) server_heuristic.py (adiciona P&B/resize/quality em /snapshot e /frame.jpg)




Novos query params (opcionais):



gray=1 ‚Üí reencoda em preto-e-branco


scale=320 ‚Üí redimensiona para largura m√°x. (mant√©m propor√ß√£o)


quality=75 ‚Üí qualidade do JPEG reencodado (1‚Äì100)






Se nenhum par√¢metro √© passado, o server continua retornando o JPEG original do cache (zero custo extra).




# server_heuristic.py
# FastAPI proxy + heur√≠stica de fogo (leve) para ESP32-CAM snapshot (robusto)

import time
import threading
from typing import Optional, Dict, Any, List, Tuple

import cv2
import numpy as np
import requests
from fastapi import FastAPI, Response, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ========= CONFIG =========
CAMERA_IP = "hydrobot.local"                     # ESP32-CAM host (mDNS ou IP fixo)
SNAPSHOT_URL_FMT = "http://{}/snapshot"
CONNECT_TIMEOUT = 4.0
READ_TIMEOUT = 15.0
POLL_FPS_TARGET = 8.0                            # ~8 fps est√°vel
MAX_FRAME_AGE_MS = 15000
MAX_RESULT_AGE_MS = 800
JPEG_QUALITY = 85

# Heur√≠stica simples de fogo
HSV_LOW = (8, 80, 120)
HSV_HIGH = (40, 255, 255)
EMA_ALPHA = 0.25
HYST_HIGH = 0.18
HYST_LOW  = 0.15
MIN_BLOB_AREA = 900
KERNEL_SZ = 5

REQUEST_HEADERS = {
    "Connection": "keep-alive",
    "User-Agent": "HydroBot-Grabber/1.0",
    "Cache-Control": "no-cache",
    "Pragma": "no-cache",
}

ACCEPT_CT_PREFIX = ("image/jpeg", "image/jpg", "image/pjpeg", "application/octet-stream")

def is_jpeg_bytes(b: bytes) -> bool:
    return len(b) > 4 and b[0] == 0xFF and b[1] == 0xD8

# ========= FASTAPI =========
app = FastAPI(title="HydroBot Server (proxy + fire-heuristic)", version="2.3")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True,
                   allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
    camera_ip: str

# ========= PLACEHOLDER =========
def placeholder_jpeg(msg: str = "NO LIVE FRAME") -> bytes:
    img = np.zeros((240, 320, 3), dtype=np.uint8)
    img[:, :] = (40, 40, 200)
    cv2.putText(img, msg, (20, 130), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255,255,255), 2, cv2.LINE_AA)
    cv2.putText(img, time.strftime("%H:%M:%S"), (20, 200), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255,255,255), 2, cv2.LINE_AA)
    ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), 80])
    return buf.tobytes()

# ========= SNAPSHOT GRABBER =========
class SnapshotGrabber:
    def __init__(self):
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._ip = CAMERA_IP
        self._last_jpeg: Optional[bytes] = None
        self._last_ts_ms: int = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._session = requests.Session()
        self._last_err: Optional[str] = None

    def start(self, ip: Optional[str] = None):
        if ip:
            self._ip = ip
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)
        self._thread = None

    def _ok_ct(self, ct: str) -> bool:
        if not ct:
            return True
        ct = ct.lower()
        return any(ct.startswith(p) for p in ACCEPT_CT_PREFIX)

    def _fetch_once(self) -> Optional[bytes]:
        u = f"{SNAPSHOT_URL_FMT.format(self._ip)}?ts={int(time.time()*1000)}"
        r = self._session.get(u, timeout=(CONNECT_TIMEOUT, READ_TIMEOUT),
                              headers=REQUEST_HEADERS, stream=False)
        if r.status_code == 200:
            ct = r.headers.get("Content-Type", "")
            b = r.content or b""
            if (self._ok_ct(ct) and b) or is_jpeg_bytes(b):
                return b
        return None

    def _run(self):
        min_interval = 1.0 / POLL_FPS_TARGET
        backoff = 0.0
        while not self._stop.is_set():
            t0 = time.time()
            try:
                jpeg = self._fetch_once()
                if jpeg:
                    with self._lock:
                        self._last_jpeg = jpeg
                        self._last_ts_ms = int(time.time()*1000)
                        self._last_err = None
                    self._frames += 1
                    now = time.time()
                    if now - self._last_fps_tick >= 1.0:
                        self._fps = self._frames / (now - self._last_fps_tick)
                        self._frames = 0
                        self._last_fps_tick = now
                    backoff = 0.0
                else:
                    backoff = min(2.0, max(0.2, (backoff * 1.7) or 0.2))
            except Exception as e:
                with self._lock:
                    self._last_err = f"{type(e).__name__}: {e}"
                backoff = min(3.0, max(0.2, (backoff * 1.7) or 0.2))

            elapsed = time.time() - t0
            sleep = max(0.0, min_interval - elapsed) + backoff
            if self._stop.is_set():
                break
            time.sleep(sleep)

    def get_latest_jpeg(self, max_age_ms=MAX_FRAME_AGE_MS) -> Optional[bytes]:
        with self._lock:
            if self._last_jpeg is None:
                return None
            if int(time.time()*1000) - self._last_ts_ms > max_age_ms:
                return None
            return self._last_jpeg

    def status(self) -> Dict[str, Any]:
        with self._lock:
            age = int(time.time()*1000) - self._last_ts_ms if self._last_ts_ms else None
            return {"ip": self._ip, "hasFrame": self._last_jpeg is not None, "age_ms": age,
                    "fps_in": round(self._fps, 2), "last_err": self._last_err}

grabber = SnapshotGrabber()
grabber.start(CAMERA_IP)

# ========= HEUR√çSTICA FOGO =========
def hsv_fire_mask(frame_bgr: np.ndarray) -> np.ndarray:
    hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
    return cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))

def boxes_from_mask(mask_bin: np.ndarray, min_area: int = MIN_BLOB_AREA) -> List[List[int]]:
    k = np.ones((KERNEL_SZ, KERNEL_SZ), np.uint8)
    m = cv2.morphologyEx(mask_bin, cv2.MORPH_OPEN, k, 1)
    m = cv2.morphologyEx(m, cv2.MORPH_DILATE, k, 1)
    cnts, _ = cv2.findContours(m, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    out = []
    for c in cnts:
        x,y,w,h = cv2.boundingRect(c)
        if w*h >= min_area:
            out.append([int(x), int(y), int(w), int(h)])
    return out

class FireDetector:
    def __init__(self, src: SnapshotGrabber):
        self.src = src
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._ema = 0.0
        self._score_raw = 0.0
        self._is_fire = False
        self._boxes: List[List[int]] = []
        self._last_ts = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._frame_wh: Optional[Tuple[int,int]] = None

    def start(self):
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)
        self._thread = None

    def _run(self):
        min_interval = 1.0 / 8.0
        while not self._stop.is_set():
            t0 = time.time()
            jpeg = self.src.get_latest_jpeg()
            if jpeg is None:
                time.sleep(0.02); continue
            frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
            if frame is None:
                time.sleep(0.01); continue
            H, W = frame.shape[:2]
            self._frame_wh = (W, H)
            mask = hsv_fire_mask(frame)
            v_mean = float(np.mean(cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)[...,2])) / 255.0
            ratio = float(np.count_nonzero(mask))/float(mask.size)
            score_raw = min(1.0, ratio*4.0 + v_mean*0.1)
            ema = score_raw if self._ema==0.0 else EMA_ALPHA*score_raw + (1.0-EMA_ALPHA)*self._ema
            boxes = boxes_from_mask(mask)
            if   ema >= HYST_HIGH: is_fire = True
            elif ema <= HYST_LOW : is_fire = False
            else: is_fire = self._is_fire
            with self._lock:
                self._ema = ema
                self._score_raw = score_raw
                self._is_fire = is_fire
                self._boxes = boxes if is_fire else []
                self._last_ts = int(time.time()*1000)
                self._frames += 1
                now = time.time()
                if now - self._last_fps_tick >= 1.0:
                    self._fps = self._frames / (now - self._last_fps_tick)
                    self._frames = 0
                    self._last_fps_tick = now
            elapsed = time.time() - t0
            if elapsed < min_interval:
                time.sleep(min_interval - elapsed)

    def get(self) -> Dict[str, Any]:
        with self._lock:
            return {
                "ok": True,
                "isFire": bool(self._is_fire),
                "score": round(float(self._ema), 3),
                "score_raw": round(float(self._score_raw), 3),
                "score_ema": round(float(self._ema), 3),
                "boxes": list(self._boxes),
                "ts": int(self._last_ts),
                "fps_det": round(float(self._fps), 2),
                "frame_wh": list(self._frame_wh) if self._frame_wh else None
            }

det = FireDetector(grabber); det.start()

# ========= HELPERS DE RE-ENCODE =========
def _process_jpeg(jpeg: bytes, gray: bool, scale_w: Optional[int], quality: Optional[int]) -> bytes:
    """Aplica (opcional) GRAY + resize + qualidade e retorna JPEG."""
    if not (gray or scale_w or quality):
        return jpeg  # sem custo

    img = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
    if img is None:
        return jpeg

    if gray:
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  # 1 canal

    if scale_w and scale_w > 0:
        h, w = (img.shape[0], img.shape[1]) if gray else (img.shape[0], img.shape[1])
        if w > scale_w:
            scale = scale_w / float(w)
            new_size = (int(w * scale), int(h * scale))
            interp = cv2.INTER_AREA if scale < 1.0 else cv2.INTER_LINEAR
            img = cv2.resize(img, new_size, interpolation=interp)

    q = int(quality or 80)
    q = max(5, min(q, 95))
    ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), q])
    return buf.tobytes() if ok else jpeg

# ========= ENDPOINTS =========
@app.get("/healthz")
def healthz():
    s = grabber.status()
    return {"ok": True, "camera_ip": s.get("ip"), "fps_in": s.get("fps_in"),
            "hasFrame": s.get("hasFrame"), "age_ms": s.get("age_ms"), "last_err": s.get("last_err")}

@app.get("/status")
def status():
    s = grabber.status(); d = det.get()
    return {"ok": True, "camera_ip": s["ip"], **s, **d}

@app.post("/config")
def set_config(cfg: ConfigIn):
    global CAMERA_IP
    CAMERA_IP = cfg.camera_ip
    grabber.start(CAMERA_IP)
    return {"ok": True, "camera_ip": CAMERA_IP}

def _serve_snapshot(gray: int = 0, scale: int = 0, quality: int = 0) -> Response:
    b = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS)
    if b is None:
        b = placeholder_jpeg("NO LIVE FRAME")

    # aplica re-encoding se solicitado
    processed = _process_jpeg(
        b,
        gray=bool(gray),
        scale_w=scale if scale and scale > 0 else None,
        quality=quality if quality and quality > 0 else None
    )
    headers = {
        "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
        "Pragma": "no-cache",
        "Expires": "0",
        "Content-Type": "image/jpeg"
    }
    return Response(content=processed, headers=headers, media_type="image/jpeg")

@app.get("/snapshot")
def snapshot(gray: int = Query(0), scale: int = Query(0), quality: int = Query(0)):
    return _serve_snapshot(gray=gray, scale=scale, quality=quality)

@app.get("/frame.jpg")
def frame_jpg(gray: int = Query(0), scale: int = Query(0), quality: int = Query(0)):
    return _serve_snapshot(gray=gray, scale=scale, quality=quality)

@app.get("/detect")
def detect():
    res = det.get()
    if res.get("ts", 0) and (int(time.time()*1000) - res["ts"] <= MAX_RESULT_AGE_MS):
        return res
    jpeg = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS)
    if jpeg is None:
        return {"ok": False, "error": "no recent frame"}
    frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
    if frame is None:
        return {"ok": False, "error": "decode failed"}
    H, W = frame.shape[:2]
    mask = hsv_fire_mask(frame)
    v_mean = float(np.mean(cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)[...,2])) / 255.0
    ratio = float(np.count_nonzero(mask))/float(mask.size)
    score = min(1.0, ratio*4.0 + v_mean*0.1)
    is_fire = bool(score >= HYST_HIGH)
    return {"ok": True, "isFire": is_fire, "score": round(score,3), "score_raw": round(score,3),
            "score_ema": round(score,3), "boxes": [], "ts": int(time.time()*1000), "frame_wh": [W,H], "fallback": True}




2) HydroBotApp2/src/screens/CameraScreen.tsx (toggle P&B)




Adicionei um bot√£o ‚ÄúP&B‚Äù na topbar.


Quando ligado, o app:



sempre usa o servidor (desativa o fallback direto no ESP, pois o ESP n√£o reencoda),


acrescenta ?gray=1&scale=320&quality=80 √†s URLs de snapshot.






Quando desligado, volta ao comportamento anterior (caminhos normais + fallbacks).




// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet,
  PanResponder, GestureResponderEvent, PanResponderGestureState,
  Image, Animated, LayoutChangeEvent,
} from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: { heroSubtitle:"Monitoramento e Controle", espIp:"ESP:", pumpOn:"BOMBA ON", pumpOff:"BOMBA OFF",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Aguardando servidor‚Ä¶", statusFail:"Falha ao conectar. Confira o Wi-Fi/IP.",
        noVideo:"Sem v√≠deo (snapshot). Verifique o servidor.", fireOn:(s:number)=>`üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sem fogo ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sincronizado",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF", bwOn:"P&B ON", bwOff:"P&B OFF" },
  en: { heroSubtitle:"Monitoring & Control", espIp:"ESP:", pumpOn:"PUMP ON", pumpOff:"PUMP OFF",
        server:"Server:", detecting:"Detecting‚Ä¶", waiting:"Waiting for server‚Ä¶", statusFail:"Failed to connect. Check Wi-Fi/IP.",
        noVideo:"No video (snapshot). Check server.", fireOn:(s:number)=>`üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`No fire ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sync OK",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF", bwOn:"B/W ON", bwOff:"B/W OFF" },
  es: { heroSubtitle:"Monitoreo y Control", espIp:"ESP:", pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Esperando servidor‚Ä¶", statusFail:"Error de conexi√≥n. Revisa Wi-Fi/IP.",
        noVideo:"Sin v√≠deo (snapshot). Revisa el servidor.", fireOn:(s:number)=>`üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sin fuego ‚Ä¢ score ${s.toFixed(2)}`, synced:"Sincronizado con servidor",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF", bwOn:"BN ON", bwOff:"BN OFF" },
};

const DEFAULT_IP = "hydrobot.local";
const DEFAULT_SERVER = "http://192.168.0.100:8000";
const DEFAULT_FRAME_WH = { w: 320, h: 240 };

const LOAD_TIMEOUT_MS = 900;
const GLOBAL_STALL_MS  = 2500;

const appLogo = require("../../assets/logo.png");

/* ---------- UI AUX ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown,
}: { currentUri: string; nextUri: string; onNextLoadStart: () => void; onNextShown: (ok: boolean) => void; }) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");
  const watchdogRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  const clearWatchdog = () => { if (watchdogRef.current) { clearTimeout(watchdogRef.current); watchdogRef.current = null; } };

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={() => {
              onNextLoadStart();
              clearWatchdog();
              watchdogRef.current = setTimeout(() => { onNextShown(false); clearWatchdog(); }, LOAD_TIMEOUT_MS);
            }}
            onError={() => { clearWatchdog(); onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              clearWatchdog();
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

type SrcBox = { x:number; y:number; w:number; h:number; type:"fire" };
function BoxesOverlay({ frameWH, containerWH, boxes }:{
  frameWH:{w:number;h:number}|null; containerWH:{w:number;h:number}|null; boxes:SrcBox[];
}) {
  const f = frameWH && frameWH.w>0 && frameWH.h>0 ? frameWH : DEFAULT_FRAME_WH;
  if (!containerWH || containerWH.w<=0 || containerWH.h<=0) return null;
  const scale = Math.min(containerWH.w / f.w, containerWH.h / f.h);
  const dispW = f.w * scale, dispH = f.h * scale;
  const offsetX = (containerWH.w - dispW)/2, offsetY = (containerWH.h - dispH)/2;
  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position:"absolute", left:offsetX, top:offsetY, width:dispW, height:dispH }}>
        {boxes.map((b,i)=>{
          const left=b.x*scale, top=b.y*scale, width=b.w*scale, height=b.h*scale;
          return (
            <View key={i} style={{ position:"absolute", left, top, width, height, borderWidth:3, borderColor:"#ff3b30", borderRadius:6 }}>
              <View style={{ position:"absolute", left:0, top:-18, paddingHorizontal:6, paddingVertical:2, borderRadius:4, backgroundColor:"#ff3b30" }}>
                <Text style={{ color:"#000", fontWeight:"800", fontSize:10 }}>FOGO</Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- SCREEN ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [statusText, setStatusText] = useState(T.waiting);
  const [pumpOn, setPumpOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{w:number;h:number}|null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{w:number;h:number}|null>(null);

  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  const [useDirectSnapshot, setUseDirectSnapshot] = useState(false);
  const failCountRef = useRef(0);
  const lastFrameOkTsRef = useRef<number>(Date.now());

  // ---- NOVO: toggle P&B ----
  const [bw, setBw] = useState<boolean>(false);

  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const clean = (s:string)=>s.replace(/\/+$/,"");

  // Server endpoints
  const healthUrl     = useMemo(()=>`${clean(server)}/healthz`,[server]);
  const detectUrl     = useMemo(()=>`${clean(server)}/detect`,[server]);
  const snapshotSrv   = useMemo(()=>`${clean(server)}/snapshot`,[server]);
  const snapshotSrvAlt= useMemo(()=>`${clean(server)}/frame.jpg`,[server]);
  const configUrl     = useMemo(()=>`${clean(server)}/config`,[server]);

  // ESP endpoints
  const snapshotEsp   = useMemo(()=> `http://${ip}/snapshot`, [ip]);
  const uartPost      = useMemo(()=> (cmd:string)=>`http://${ip}/uart?cmd=${encodeURIComponent(cmd)}`, [ip]);
  const ledPost       = useMemo(()=> (on:boolean)=>`http://${ip}/led?on=${on?1:0}`, [ip]);

  // Sincroniza IP da c√¢mera no server
  useEffect(()=>{
    let aborted=false;
    (async()=>{
      try{
        const r=await fetch(configUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({camera_ip:ip})});
        const j=await r.json();
        if(!aborted && j?.ok) setStatusText(`${T.synced} (${j.camera_ip})`);
      }catch{ if(!aborted) setStatusText(T.statusFail); }
    })();
    return()=>{aborted=true};
  },[ip, configUrl, T]);

  // Health do servidor
  useEffect(()=>{
    let stop=false, backoff=500;
    const poll=async()=>{
      if(stop) return;
      try{
        const r=await fetch(healthUrl); const j=await r.json();
        if(j?.ok){ setStatusText(`Server OK ‚Ä¢ fps_in:${j.fps_in} ‚Ä¢ hasFrame:${j.hasFrame}`); return; }
      }catch{}
      setStatusText(T.waiting);
      setTimeout(poll, backoff); backoff=Math.min(backoff*1.6, 5000);
    };
    poll(); return()=>{stop=true};
  },[healthUrl, T]);

  // SNAPSHOT loop com fallback e suporte a P&B
  useEffect(()=>{
    let stop=false, interval=160;

    // quando P&B estiver ligado, obrigamos usar o servidor (ele que reencoda)
    if (bw && useDirectSnapshot) setUseDirectSnapshot(false);

    const pickBase = ()=>{
      const params = bw ? `?gray=1&scale=320&quality=80` : ``;
      if (useDirectSnapshot && !bw) return `${snapshotEsp}`;           // direto no ESP s√≥ se N√ÉO for P&B
      return (failCountRef.current >= 2 ? `${snapshotSrvAlt}${params}` : `${snapshotSrv}${params}`);
    };

    setCurrentFrameUri(`${pickBase()}&ts=${Date.now()}`);
    const tick=()=>{
      if(stop) return;
      try{
        if(!loadingNextRef.current){
          const base = pickBase();
          setNextFrameUri(`${base}&ts=${Date.now()}&n=${Math.random().toString(36).slice(2,7)}`);
        }
        interval=160;
      }catch{
        interval=Math.min(interval*1.7, 1200);
      }
      setTimeout(tick, interval);
    };
    tick();
    return()=>{stop=true};
  },[snapshotSrv, snapshotSrvAlt, snapshotEsp, useDirectSnapshot, bw]);

  const onNextLoadStart = ()=>{ loadingNextRef.current=true; };
  const onNextShown = (ok:boolean)=>{
    if(ok){
      failCountRef.current = 0;
      lastFrameOkTsRef.current = Date.now();
      if(useDirectSnapshot && !bw){ /* ok manter */ }
      if(nextFrameUri) setCurrentFrameUri(nextFrameUri);
    }else{
      failCountRef.current += 1;
      if(!useDirectSnapshot && !bw && failCountRef.current >= 3){
        setUseDirectSnapshot(true);                     // for√ßa snapshot direto do ESP (se N√ÉO estiver em P&B)
        failCountRef.current = 0;
      }
    }
    loadingNextRef.current=false;
  };

  // Descongelador global
  useEffect(()=>{
    let stop=false;
    const guard=()=>{
      if(stop) return;
      const idle = Date.now() - lastFrameOkTsRef.current;
      if(idle > GLOBAL_STALL_MS){
        if (!bw) { // s√≥ faz fallback direto se n√£o estiver em P&B
          setUseDirectSnapshot(true);
        }
        failCountRef.current = 0;
        lastFrameOkTsRef.current = Date.now();
      }
      setTimeout(guard, 400);
    };
    guard();
    return()=>{stop=true};
  },[bw]);

  // DETECT loop (inalterado)
  useEffect(()=>{
    let stop=false, interval=250;
    const loop=async()=>{
      if(stop) return;
      try{
        const r=await fetch(detectUrl); const j=await r.json();
        if(j && j.ok!==false){
          setIsFire(!!j.isFire); setFireScore(Number(j.score||0));
          const wh = Array.isArray(j.frame_wh)&&j.frame_wh.length===2
                     ? {w:Number(j.frame_wh[0])||0, h:Number(j.frame_wh[1])||0}:null;
          if(wh && wh.w>0 && wh.h>0) setFrameWH(wh);
          const boxes:SrcBox[]=[];
          if(j.isFire && Array.isArray(j.boxes)){
            for(const b of j.boxes){
              if(Array.isArray(b)&&b.length>=4){
                const [x,y,w,h]=b.map((n:any)=>Number(n)||0);
                boxes.push({x,y,w,h,type:"fire"});
              }
            }
          }
          setOverlayBoxes(boxes); interval=250;
        }
      }catch{
        setIsFire(false); setFireScore(0); setOverlayBoxes([]);
        interval=Math.min(interval*1.5,1500);
      }finally{ setTimeout(loop, interval); }
    };
    loop(); return()=>{stop=true};
  },[detectUrl]);

  // ------- COMANDOS (UART + LED) -------
  async function sendUART(cmd: string) {
    try {
      const res = await fetch(uartPost(cmd), { method: "POST" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return true;
    } catch {
      setStatusText(T.statusFail);
      return false;
    }
  }

  async function togglePump(){
    const target = !pumpOn;
    const ok = await sendUART(`CMD:PUMP:${target ? "1" : "0"}`);
    if (ok) setPumpOn(target);
  }

  async function led(on:boolean){
    try{
      const res = await fetch(ledPost(on), { method: "POST" });
      const txt = await res.text();
      setStatusText(`${on?T.ledOn:T.ledOff} ‚Ä¢ ${res.status} ${txt||""}`);
    }catch{
      setStatusText(T.statusFail);
    }
  }

  // Joystick (pulsos discretos por UART)
  const RADIUS=64;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder:()=>true,
      onMoveShouldSetPanResponder:()=>true,
      onPanResponderGrant:()=>{ setDragging(true); },
      onPanResponderMove:(_e:GestureResponderEvent,g:PanResponderGestureState)=>{
        let nx=g.dx/RADIUS, ny=g.dy/RADIUS;
        const len=Math.hypot(nx,ny); if(len>1){ nx/=len; ny/=len; }
        setJoy({x:nx, y:-ny});
      },
      onPanResponderRelease:()=>{ setJoy({x:0,y:0}); setDragging(false); },
      onPanResponderTerminate:()=>{ setJoy({x:0,y:0}); setDragging(false); },
    })
  ).current;

  const lastSendRef = useRef(0);
  const lastDirRef  = useRef<string>("STOP");
  const vecToDir=(x:number,y:number):"FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP"=>{
    const mag=Math.hypot(x,y); if(mag<0.2) return "STOP";
    const deg=(Math.atan2(y,x)*180)/Math.PI;
    if(deg>-45&&deg<=45) return "RIGHT";
    if(deg>45&&deg<=135) return "FWD";
    if(deg<=-45&&deg>-135) return "BACK";
    return "LEFT";
  };

  useEffect(()=>{
    let cancelled=false;
    const tick=async()=>{
      if(cancelled) return;
      const now=Date.now();
      if(now-lastSendRef.current<120){ setTimeout(tick,20); return; }
      lastSendRef.current=now;

      const {x,y}=joy; const mag=Math.hypot(x,y); const dir=vecToDir(x,y);
      if(dir!==lastDirRef.current){
        if(dir==="STOP"){ await sendUART("CMD:STOP"); }
        else{
          const ms=140+Math.round(260*Math.min(1,mag));
          const spd=50+Math.round(50*Math.min(1,mag));
          await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
        }
        lastDirRef.current=dir;
      }else if(dir!=="STOP"){
        const ms=120+Math.round(200*Math.min(1,mag));
        const spd=50+Math.round(50*Math.min(1,mag));
        await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
      }
      setTimeout(tick,120);
    };
    tick(); return()=>{cancelled=true};
  },[joy, ip]);

  function onVideoLayout(e:LayoutChangeEvent){
    const {width,height}=e.nativeEvent.layout; setVideoContainerWH({w:width,h:height});
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder={T.placeholderIp} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={styles.input} />
        <Text style={styles.label}>{T.server}</Text>
        <TextInput value={server} onChangeText={setServer} placeholder={T.placeholderServer} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={[styles.input,{minWidth:220}]} />

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn?styles.btnOn:styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn?T.pumpOn:T.pumpOff}</Text>
        </Pressable>
        <Pressable onPress={()=>led(true)} style={[styles.btn, {backgroundColor:"#2563eb"}]}>
          <Text style={styles.btnText}>{T.ledOn}</Text>
        </Pressable>
        <Pressable onPress={()=>led(false)} style={[styles.btn, {backgroundColor:"#374151"}]}>
          <Text style={styles.btnText}>{T.ledOff}</Text>
        </Pressable>

        {/* ---- NOVO: BOT√ÉO P&B ---- */}
        <Pressable
          onPress={()=> setBw(v=>!v)}
          style={[styles.btn, bw ? { backgroundColor:"#111827", borderWidth:1, borderColor:"#6b7280" } : { backgroundColor:"#d1d5db" }]}
        >
          <Text style={[styles.btnText, { color: bw ? "#e5e7eb" : "#111827" }]}>{bw ? T.bwOn : T.bwOff}</Text>
        </Pressable>
      </View>

      <View style={[styles.statusRow,{paddingTop:4,paddingBottom:8}]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText} {useDirectSnapshot && !bw ? "‚Ä¢ (snapshot direto)" : ""}
        </Text>
        <View style={[styles.badge,{backgroundColor: "#065f46"}]}>
          <Text style={{ color:"#fff", fontWeight:"800" }}>{isFire ? T.detecting : T.waiting}</Text>
        </View>
      </View>

      <View style={[styles.fireBanner, isFire?styles.fireOn:styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      <View style={{ flex:1 }} onLayout={onVideoLayout}>
        <CrossfadeImage currentUri={currentFrameUri} nextUri={nextFrameUri}
                        onNextLoadStart={()=> (loadingNextRef.current=true)}
                        onNextShown={onNextShown}/>
        {overlayBoxes.length>0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap,{width:64*2+24,height:64*2+24}]}
              {...(pan.panHandlers as any)}>
          <View style={[styles.joyBase,{width:64*2,height:64*2,borderRadius:64}]} />
          <View style={[styles.joyKnob,{width:22*2,height:22*2,borderRadius:22,
                        transform:[{translateX:joy.x*64},{translateY:-joy.y*64}], opacity: dragging?1:0.9}]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", flexWrap:"wrap",
           paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:120 },
  btn:{ backgroundColor:PALETTE.accent, paddingHorizontal:10, paddingVertical:10, borderRadius:10 },
  btnOn:{ backgroundColor:"#17a34a" }, btnOff:{ backgroundColor:"#374151" },
  btnText:{ color:"white", fontWeight:"600" },

  statusRow:{ flexDirection:"row", alignItems:"center", paddingHorizontal:12, paddingVertical:8, gap:8,
              backgroundColor:"#0f1322", borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  badge:{ paddingHorizontal:10, paddingVertical:6, borderRadius:8, borderWidth:1, borderColor:PALETTE.border },
  status:{ color:"#cbd5ff", flex:1, fontSize:12 },

  fireBanner:{ alignItems:"center", justifyContent:"center", paddingVertical:6 },
  fireOn:{ backgroundColor:"#8b0000" }, fireOff:{ backgroundColor:"#223" },
  fireText:{ color:"white", fontWeight:"800" },

  joyWrap:{ position:"absolute", bottom:24, left:24, alignItems:"center", justifyContent:"center" },
  joyBase:{ position:"absolute", backgroundColor:"rgba(255,255,255,0.08)", borderWidth:2, borderColor:"rgba(255,255,255,0.14)" },
  joyKnob:{ position:"absolute", backgroundColor:"rgba(230,64,58,0.9)", borderWidth:2, borderColor:"rgba(255,255,255,0.85)" },
  joyText:{ position:"absolute", bottom:-22, color:"#cbd5ff", fontSize:12 },
});



Como usar




Suba o server e o app.


Na tela, toque P&B OFF ‚Üí P&B ON.


Com P&B ligado, as URLs de snapshot passam a incluir ?gray=1&scale=320&quality=80, o servidor reencoda e o app usa sempre o servidor (sem fallback direto no ESP).


Desligando, volta ao fluxo normal.




Se quiser, posso trocar os valores padr√£o do bot√£o (ex.: scale=240, quality=70) para economizar ainda mais banda.


















































// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet,
  PanResponder, GestureResponderEvent, PanResponderGestureState,
  Image, Animated, LayoutChangeEvent,
} from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: { heroSubtitle:"Monitoramento e Controle", espIp:"ESP:", pumpOn:"BOMBA ON", pumpOff:"BOMBA OFF",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Aguardando servidor‚Ä¶", statusFail:"Falha ao conectar. Confira o Wi-Fi/IP.",
        noVideo:"Sem v√≠deo (snapshot). Verifique o servidor.", fireOn:(s:number)=>`üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sem fogo ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sincronizado",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  en: { heroSubtitle:"Monitoring & Control", espIp:"ESP:", pumpOn:"PUMP ON", pumpOff:"PUMP OFF",
        server:"Server:", detecting:"Detecting‚Ä¶", waiting:"Waiting for server‚Ä¶", statusFail:"Failed to connect. Check Wi-Fi/IP.",
        noVideo:"No video (snapshot). Check server.", fireOn:(s:number)=>`üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`No fire ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sync OK",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  es: { heroSubtitle:"Monitoreo y Control", espIp:"ESP:", pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Esperando servidor‚Ä¶", statusFail:"Error de conexi√≥n. Revisa Wi-Fi/IP.",
        noVideo:"Sin v√≠deo (snapshot). Revisa el servidor.", fireOn:(s:number)=>`üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sin fuego ‚Ä¢ score ${s.toFixed(2)}`, synced:"Sincronizado con servidor",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
};

const DEFAULT_IP = "hydrobot.local";
const DEFAULT_SERVER = "http://192.168.0.100:8000";
const DEFAULT_FRAME_WH = { w: 320, h: 240 };

// ---- NOVO: timeouts anti-congelamento ----
const LOAD_TIMEOUT_MS = 900;       // watchdog por frame
const GLOBAL_STALL_MS  = 2500;     // sem sucesso por esse tempo => for√ßa fallback

const appLogo = require("../../assets/logo.png");

/* ---------- UI AUX ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown,
}: { currentUri: string; nextUri: string; onNextLoadStart: () => void; onNextShown: (ok: boolean) => void; }) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");
  const watchdogRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  // limpa watchdog em qualquer t√©rmino
  const clearWatchdog = () => {
    if (watchdogRef.current) { clearTimeout(watchdogRef.current); watchdogRef.current = null; }
  };

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={() => {
              onNextLoadStart();
              clearWatchdog();
              // ---- NOVO: watchdog por frame ----
              watchdogRef.current = setTimeout(() => {
                // Se a imagem pendurar (nem onError nem onLoadEnd), tratamos como falha
                onNextShown(false);
                clearWatchdog();
              }, LOAD_TIMEOUT_MS);
            }}
            onError={() => { clearWatchdog(); onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              clearWatchdog();
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

type SrcBox = { x:number; y:number; w:number; h:number; type:"fire" };
function BoxesOverlay({ frameWH, containerWH, boxes }:{
  frameWH:{w:number;h:number}|null; containerWH:{w:number;h:number}|null; boxes:SrcBox[];
}) {
  const f = frameWH && frameWH.w>0 && frameWH.h>0 ? frameWH : DEFAULT_FRAME_WH;
  if (!containerWH || containerWH.w<=0 || containerWH.h<=0) return null;
  const scale = Math.min(containerWH.w / f.w, containerWH.h / f.h);
  const dispW = f.w * scale, dispH = f.h * scale;
  const offsetX = (containerWH.w - dispW)/2, offsetY = (containerWH.h - dispH)/2;
  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position:"absolute", left:offsetX, top:offsetY, width:dispW, height:dispH }}>
        {boxes.map((b,i)=>{
          const left=b.x*scale, top=b.y*scale, width=b.w*scale, height=b.h*scale;
          return (
            <View key={i} style={{ position:"absolute", left, top, width, height, borderWidth:3, borderColor:"#ff3b30", borderRadius:6 }}>
              <View style={{ position:"absolute", left:0, top:-18, paddingHorizontal:6, paddingVertical:2, borderRadius:4, backgroundColor:"#ff3b30" }}>
                <Text style={{ color:"#000", fontWeight:"800", fontSize:10 }}>FOGO</Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- SCREEN ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [statusText, setStatusText] = useState(T.waiting);
  const [pumpOn, setPumpOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{w:number;h:number}|null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{w:number;h:number}|null>(null);

  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  const [useDirectSnapshot, setUseDirectSnapshot] = useState(false);
  const failCountRef = useRef(0);
  const lastFrameOkTsRef = useRef<number>(Date.now());   // ---- NOVO: marca o √∫ltimo sucesso ----

  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const clean = (s:string)=>s.replace(/\/+$/,"");

  // Server endpoints
  const healthUrl     = useMemo(()=>`${clean(server)}/healthz`,[server]);
  const detectUrl     = useMemo(()=>`${clean(server)}/detect`,[server]);
  const snapshotSrv   = useMemo(()=>`${clean(server)}/snapshot`,[server]);
  const snapshotSrvAlt= useMemo(()=>`${clean(server)}/frame.jpg`,[server]);
  const configUrl     = useMemo(()=>`${clean(server)}/config`,[server]);

  // ESP endpoints
  const snapshotEsp   = useMemo(()=> `http://${ip}/snapshot`, [ip]);
  const uartPost      = useMemo(()=> (cmd:string)=>`http://${ip}/uart?cmd=${encodeURIComponent(cmd)}`, [ip]);
  const ledPost       = useMemo(()=> (on:boolean)=>`http://${ip}/led?on=${on?1:0}`, [ip]);

  // Sincroniza IP da c√¢mera no server (poller)
  useEffect(()=>{
    let aborted=false;
    (async()=>{
      try{
        const r=await fetch(configUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({camera_ip:ip})});
        const j=await r.json();
        if(!aborted && j?.ok) setStatusText(`${T.synced} (${j.camera_ip})`);
      }catch{ if(!aborted) setStatusText(T.statusFail); }
    })();
    return()=>{aborted=true};
  },[ip, configUrl, T]);

  // Health do servidor
  useEffect(()=>{
    let stop=false, backoff=500;
    const poll=async()=>{
      if(stop) return;
      try{
        const r=await fetch(healthUrl); const j=await r.json();
        if(j?.ok){ setStatusText(`Server OK ‚Ä¢ fps_in:${j.fps_in} ‚Ä¢ hasFrame:${j.hasFrame}`); return; }
      }catch{}
      setStatusText(T.waiting);
      setTimeout(poll, backoff); backoff=Math.min(backoff*1.6, 5000);
    };
    poll(); return()=>{stop=true};
  },[healthUrl, T]);

  // SNAPSHOT loop com fallback server->ESP
  useEffect(()=>{
    let stop=false, interval=160;
    const pickBase = ()=>{
      if (useDirectSnapshot) return snapshotEsp;
      return failCountRef.current >= 2 ? snapshotSrvAlt : snapshotSrv;
    };

    setCurrentFrameUri(`${pickBase()}?ts=${Date.now()}`);
    const tick=()=>{
      if(stop) return;
      try{
        if(!loadingNextRef.current){
          const base = pickBase();
          // ‚Äúnonce‚Äù extra evita qualquer cache agressivo
          setNextFrameUri(`${base}?ts=${Date.now()}&n=${Math.random().toString(36).slice(2,7)}`);
        }
        interval=160;
      }catch{
        interval=Math.min(interval*1.7, 1200);
      }
      setTimeout(tick, interval);
    };
    tick();
    return()=>{stop=true};
  },[snapshotSrv, snapshotSrvAlt, snapshotEsp, useDirectSnapshot]);

  const onNextLoadStart = ()=>{ loadingNextRef.current=true; };

  const onNextShown = (ok:boolean)=>{
    if(ok){
      failCountRef.current = 0;
      lastFrameOkTsRef.current = Date.now();            // ---- NOVO: registra sucesso ----
      if(useDirectSnapshot){ setUseDirectSnapshot(false); }   // volta p/ servidor quando estabiliza
      if(nextFrameUri) setCurrentFrameUri(nextFrameUri);
    }else{
      // falha (inclui timeout do watchdog)
      failCountRef.current += 1;
      if(!useDirectSnapshot && failCountRef.current >= 3){
        setUseDirectSnapshot(true);                     // for√ßa snapshot direto do ESP
        failCountRef.current = 0;
      }
    }
    loadingNextRef.current=false;
  };

  // ---- NOVO: descongelador global ----
  useEffect(()=>{
    let stop=false;
    const guard=()=>{
      if(stop) return;
      const idle = Date.now() - lastFrameOkTsRef.current;
      if(idle > GLOBAL_STALL_MS){
        // Se passou muito tempo sem ‚Äúok‚Äù, for√ßa fallback direto do ESP
        setUseDirectSnapshot(true);
        failCountRef.current = 0;
        lastFrameOkTsRef.current = Date.now(); // evita m√∫ltiplos flips seguidos
      }
      setTimeout(guard, 400);
    };
    guard();
    return()=>{stop=true};
  },[]);

  // DETECT loop (inalterado)
  useEffect(()=>{
    let stop=false, interval=250;
    const loop=async()=>{
      if(stop) return;
      try{
        const r=await fetch(detectUrl); const j=await r.json();
        if(j && j.ok!==false){
          setIsFire(!!j.isFire); setFireScore(Number(j.score||0));
          const wh = Array.isArray(j.frame_wh)&&j.frame_wh.length===2
                     ? {w:Number(j.frame_wh[0])||0, h:Number(j.frame_wh[1])||0}:null;
          if(wh && wh.w>0 && wh.h>0) setFrameWH(wh);
          const boxes:SrcBox[]=[];
          if(j.isFire && Array.isArray(j.boxes)){
            for(const b of j.boxes){
              if(Array.isArray(b)&&b.length>=4){
                const [x,y,w,h]=b.map((n:any)=>Number(n)||0);
                boxes.push({x,y,w,h,type:"fire"});
              }
            }
          }
          setOverlayBoxes(boxes); interval=250;
        }
      }catch{
        setIsFire(false); setFireScore(0); setOverlayBoxes([]);
        interval=Math.min(interval*1.5,1500);
      }finally{ setTimeout(loop, interval); }
    };
    loop(); return()=>{stop=true};
  },[detectUrl]);

  // ------- COMANDOS (UART + LED) -------
  async function sendUART(cmd: string) {
    try {
      const res = await fetch(uartPost(cmd), { method: "POST" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return true;
    } catch {
      setStatusText(T.statusFail);
      return false;
    }
  }

  async function togglePump(){
    const target = !pumpOn;
    const ok = await sendUART(`CMD:PUMP:${target ? "1" : "0"}`);
    if (ok) setPumpOn(target);
  }

  async function led(on:boolean){
    try{
      const res = await fetch(ledPost(on), { method: "POST" });
      const txt = await res.text();
      setStatusText(`${on?T.ledOn:T.ledOff} ‚Ä¢ ${res.status} ${txt||""}`);
    }catch{
      setStatusText(T.statusFail);
    }
  }

  // Joystick: envia PULSOS discretos por UART (CMD:FWD/BACK/LEFT/RIGHT/STOP)
  const RADIUS=64;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder:()=>true,
      onMoveShouldSetPanResponder:()=>true,
      onPanResponderGrant:()=>{ setDragging(true); },
      onPanResponderMove:(_e:GestureResponderEvent,g:PanResponderGestureState)=>{
        let nx=g.dx/RADIUS, ny=g.dy/RADIUS;
        const len=Math.hypot(nx,ny); if(len>1){ nx/=len; ny/=len; }
        setJoy({x:nx, y:-ny});
      },
      onPanResponderRelease:()=>{ setJoy({x:0,y:0}); setDragging(false); },
      onPanResponderTerminate:()=>{ setJoy({x:0,y:0}); setDragging(false); },
    })
  ).current;

  const lastSendRef = useRef(0);
  const lastDirRef  = useRef<string>("STOP");

  const vecToDir=(x:number,y:number):"FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP"=>{
    const mag=Math.hypot(x,y); if(mag<0.2) return "STOP";
    const deg=(Math.atan2(y,x)*180)/Math.PI;
    if(deg>-45&&deg<=45) return "RIGHT";
    if(deg>45&&deg<=135) return "FWD";
    if(deg<=-45&&deg>-135) return "BACK";
    return "LEFT";
  };

  useEffect(()=>{
    let cancelled=false;
    const tick=async()=>{
      if(cancelled) return;
      const now=Date.now();
      if(now-lastSendRef.current<120){ setTimeout(tick,20); return; }
      lastSendRef.current=now;

      const {x,y}=joy;
      const mag=Math.hypot(x,y);
      const dir=vecToDir(x,y);

      if(dir!==lastDirRef.current){
        if(dir==="STOP"){
          await sendUART("CMD:STOP");
        }else{
          const ms=140+Math.round(260*Math.min(1,mag));
          const spd=50+Math.round(50*Math.min(1,mag));
          await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
        }
        lastDirRef.current=dir;
      }else if(dir!=="STOP"){
        const ms=120+Math.round(200*Math.min(1,mag));
        const spd=50+Math.round(50*Math.min(1,mag));
        await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
      }
      setTimeout(tick,120);
    };
    tick(); return()=>{cancelled=true};
  },[joy, ip]);

  function onVideoLayout(e:LayoutChangeEvent){
    const {width,height}=e.nativeEvent.layout; setVideoContainerWH({w:width,h:height});
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder={T.placeholderIp} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={styles.input} />
        <Text style={styles.label}>{T.server}</Text>
        <TextInput value={server} onChangeText={setServer} placeholder={T.placeholderServer} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={[styles.input,{minWidth:220}]} />

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn?styles.btnOn:styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn?T.pumpOn:T.pumpOff}</Text>
        </Pressable>
        <Pressable onPress={()=>led(true)} style={[styles.btn, {backgroundColor:"#2563eb"}]}>
          <Text style={styles.btnText}>{T.ledOn}</Text>
        </Pressable>
        <Pressable onPress={()=>led(false)} style={[styles.btn, {backgroundColor:"#374151"}]}>
          <Text style={styles.btnText}>{T.ledOff}</Text>
        </Pressable>
      </View>

      <View style={[styles.statusRow,{paddingTop:4,paddingBottom:8}]}>
        <Text numberOfLines={2} style={styles.status}>{statusText} {useDirectSnapshot ? "‚Ä¢ (snapshot direto)" : ""}</Text>
        <View style={[styles.badge,{backgroundColor: "#065f46"}]}>
          <Text style={{ color:"#fff", fontWeight:"800" }}>{isFire ? T.detecting : T.waiting}</Text>
        </View>
      </View>

      <View style={[styles.fireBanner, isFire?styles.fireOn:styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      <View style={{ flex:1 }} onLayout={onVideoLayout}>
        <CrossfadeImage currentUri={currentFrameUri} nextUri={nextFrameUri}
                        onNextLoadStart={()=> (loadingNextRef.current=true)}
                        onNextShown={onNextShown}/>
        {overlayBoxes.length>0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap,{width:64*2+24,height:64*2+24}]}
              {...(pan.panHandlers as any)}>
          <View style={[styles.joyBase,{width:64*2,height:64*2,borderRadius:64}]} />
          <View style={[styles.joyKnob,{width:22*2,height:22*2,borderRadius:22,
                        transform:[{translateX:joy.x*64},{translateY:-joy.y*64}], opacity: dragging?1:0.9}]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", flexWrap:"wrap",
           paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:120 },
  btn:{ backgroundColor:PALETTE.accent, paddingHorizontal:10, paddingVertical:10, borderRadius:10 },
  btnOn:{ backgroundColor:"#17a34a" }, btnOff:{ backgroundColor:"#374151" },
  btnText:{ color:"white", fontWeight:"600" },

  statusRow:{ flexDirection:"row", alignItems:"center", paddingHorizontal:12, paddingVertical:8, gap:8,
              backgroundColor:"#0f1322", borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  badge:{ paddingHorizontal:10, paddingVertical:6, borderRadius:8, borderWidth:1, borderColor:PALETTE.border },
  status:{ color:"#cbd5ff", flex:1, fontSize:12 },

  fireBanner:{ alignItems:"center", justifyContent:"center", paddingVertical:6 },
  fireOn:{ backgroundColor:"#8b0000" }, fireOff:{ backgroundColor:"#223" },
  fireText:{ color:"white", fontWeight:"800" },

  joyWrap:{ position:"absolute", bottom:24, left:24, alignItems:"center", justifyContent:"center" },
  joyBase:{ position:"absolute", backgroundColor:"rgba(255,255,255,0.08)", borderWidth:2, borderColor:"rgba(255,255,255,0.14)" },
  joyKnob:{ position:"absolute", backgroundColor:"rgba(230,64,58,0.9)", borderWidth:2, borderColor:"rgba(255,255,255,0.85)" },
  joyText:{ position:"absolute", bottom:-22, color:"#cbd5ff", fontSize:12 },
});
















































// ====== HydroBot ‚Äì AUTO baseado no c√≥digo antigo (delta anal√≥gico) + confirma√ß√£o e recalibra√ß√£o por eventos ======
#include <Arduino.h>
#include <Servo.h>

/* ---------------- PINOS (iguais ao seu c√≥digo antigo) ---------------- */
// Motores (ponte H)
#define IN1 8
#define IN2 9
#define IN3 10
#define IN4 11

// Servo
#define SERVO_PIN     12
#define SERVO_ESQ     45
#define SERVO_CENTRO  100
#define SERVO_DIR     135
Servo servoMangueira;

// Sensores KY-026 (digitais)
#define SENSOR_FOGO_ESQ_D 2   // esquerdo - digital (LOW = fogo)
#define SENSOR_FOGO_MEIO_D 4  // meio    - digital (LOW = fogo)
#define SENSOR_FOGO_DIR_D 7   // direito - digital (LOW = fogo)

// Sensores KY-026 (anal√≥gicos)
#define SENSOR_FOGO_ESQ  A2   // esquerdo - anal√≥gico
#define SENSOR_FOGO_MEIO A1   // meio     - anal√≥gico
#define SENSOR_FOGO_DIR  A0   // direito  - anal√≥gico

// Bomba / N√≠vel de √°gua / LED (mesma pinagem antiga)
#define BOMBA_PIN     13
#define NIVEL_AGUA_PIN A3
#define LED_VERMELHO   3   // pode ser PWM

// Bot√£o (opcional, N√ÉO usar 7 pois conflita com sensor digital direito)
#define BOTAO 6

/* ---------------- PAR√ÇMETROS ---------------- */
// Detec√ß√£o (baseado no antigo): delta = base - leitura; delta grande => fogo
static const int DIFERENCA_FOGO = 150;   // ‚Äúaciona‚Äù
static const int DIFERENCA_CLEAR = 100;  // ‚Äúlimpa‚Äù (histerese)

// Confirma√ß√£o anti-falso-positivo (r√°pida e leve)
static const uint8_t CONFIRM_READS = 3;    // 3 leituras
static const uint8_t CONFIRM_MIN   = 2;    // precisa acertar 2
static const uint16_t CONFIRM_SPACING_MS = 15;

// Hold para suavidade (mant√©m ‚Äúfogo‚Äù por um instante)
static const uint16_t FIRE_HOLD_MS = 250;

// Calibra√ß√£o
static const uint16_t TEMPO_CALIBRACAO_MS = 3000; // 3 s ao entrar no AUTO
static const uint8_t  RECALIB_EVERY_CONFIRMED = 5; // recalibra a cada 5 eventos confirmados

// Velocidade e tempos de movimento
static const uint8_t  VEL_PERC = 60;   // 60% (se usar PWM por software)
static const uint16_t T_FWD_MS = 210;
static const uint16_t T_TURN_MS = 150;
static const uint16_t T_BACK_MS = 260;

/* ---------------- ESTADO ---------------- */
enum Modo : uint8_t { MODO_APP = 0, MODO_AUTO = 1 };
enum Dir  : uint8_t { DIR_STOP=0, DIR_FWD, DIR_BACK, DIR_LEFT, DIR_RIGHT };

struct State {
  // modo
  Modo modo = MODO_AUTO; // se quiser iniciar em APP, troque aqui

  // calibra√ß√£o
  int baseEsq=0, baseMeio=0, baseDir=0;
  bool calibrado=false;

  // √°gua/LED/bomba
  uint8_t nivelAguaPct=0;
  bool bombaOn=false;
  unsigned long ledBlinkAt=0;
  bool ledBlink=false;

  // fogo confirmado
  bool fogoConfirmado=false;
  unsigned long fogoHoldUntil=0;
  uint16_t eventosConfirmados=0;

  // movimento (watchdog simples)
  Dir currentDir=DIR_STOP;
  bool motionActive=false;
  unsigned long motionEndMs=0;
  unsigned long lastMoveCmdAt=0;

  // servo
  int posServo=SERVO_CENTRO;
} G;

/* ---------------- PROT√ìTIPOS ---------------- */
void motorsStop(); void motorsFwd(); void motorsBack(); void motorsLeftTurn(); void motorsRightTurn();
void setMotion(Dir d, uint16_t ms);
void pwmSoftware(void (*mov)(), int velPerc, int duracaoMs); // compat√≠vel com seu antigo

void pumpWrite(bool on);
uint8_t waterPercent();
void updateWaterLED(uint8_t pct);

void calibrarSensores();                  // m√©dia em 3s
bool detectarFogoConfirmado(int &side);   // confirma em burst (2/3)
bool isClearNow();                        // checa histerese de sa√≠da

void moverServo(int novaPos);
void ligarBomba(); void desligarBomba();

void frenteBasico(); void trasBasico(); void direitaBasico(); void esquerdaBasico(); void parar();

void handleAuto();    // l√≥gica AUTO pura (sem patrulha)
void handleManual();  // opcional

/* ---------------- IMPLEMENTA√á√ÉO ---------------- */
// Motores b√°sicos
void motorsStop(){ digitalWrite(IN1,LOW);digitalWrite(IN2,LOW);digitalWrite(IN3,LOW);digitalWrite(IN4,LOW); G.currentDir=DIR_STOP; }
void motorsFwd(){  digitalWrite(IN1,HIGH);digitalWrite(IN2,LOW);digitalWrite(IN3,HIGH);digitalWrite(IN4,LOW); G.currentDir=DIR_FWD; }
void motorsBack(){ digitalWrite(IN1,LOW);digitalWrite(IN2,HIGH);digitalWrite(IN3,LOW);digitalWrite(IN4,HIGH); G.currentDir=DIR_BACK; }
void motorsLeftTurn(){  digitalWrite(IN1,HIGH);digitalWrite(IN2,LOW);digitalWrite(IN3,LOW);digitalWrite(IN4,HIGH); G.currentDir=DIR_LEFT; }
void motorsRightTurn(){ digitalWrite(IN1,LOW);digitalWrite(IN2,HIGH);digitalWrite(IN3,HIGH);digitalWrite(IN4,LOW); G.currentDir=DIR_RIGHT; }

void setMotion(Dir d, uint16_t ms){
  if (ms==0 || d==DIR_STOP){ motorsStop(); G.motionActive=false; return; }
  switch(d){ case DIR_FWD: motorsFwd(); break; case DIR_BACK: motorsBack(); break;
             case DIR_LEFT: motorsLeftTurn(); break; case DIR_RIGHT: motorsRightTurn(); break; default: motorsStop(); }
  G.motionActive=true; G.motionEndMs=millis()+ms; G.lastMoveCmdAt=millis();
}

// PWM por software (compat√≠vel com seu antigo)
void pwmSoftware(void (*movimento)(), int vel, int duracao){
  unsigned long inicio = millis();
  const int ciclo = 10;
  const int onMs = (ciclo * vel) / 100;
  const int offMs = ciclo - onMs;
  while ((int)(millis()-inicio) < duracao){
    movimento(); delay(onMs);
    if (vel < 100 && offMs>0){ parar(); delay(offMs); }
  }
}

// √Ågua / LED / Bomba
void pumpWrite(bool on){ G.bombaOn=on; digitalWrite(BOMBA_PIN, on?HIGH:LOW); }
uint8_t waterPercent(){ int raw=analogRead(NIVEL_AGUA_PIN); int pct=map(raw,0,1023,0,100); return (uint8_t)constrain(pct,0,100); }
void updateWaterLED(uint8_t pct){
  if (pct>=60){ analogWrite(LED_VERMELHO,0); return; }
  if (pct>=40){ analogWrite(LED_VERMELHO,120); return; }
  if (pct>=20){
    if (millis()-G.ledBlinkAt>800){ G.ledBlinkAt=millis(); G.ledBlink=!G.ledBlink; }
    analogWrite(LED_VERMELHO, G.ledBlink?200:0);
    return;
  }
  if (millis()-G.ledBlinkAt>250){ G.ledBlinkAt=millis(); G.ledBlink=!G.ledBlink; }
  analogWrite(LED_VERMELHO, G.ledBlink?255:0);
}

// Calibra√ß√£o
void calibrarSensores(){
  unsigned long t0=millis();
  long sE=0,sM=0,sD=0; int n=0;
  while (millis()-t0 < TEMPO_CALIBRACAO_MS){
    sE+=analogRead(SENSOR_FOGO_ESQ);
    sM+=analogRead(SENSOR_FOGO_MEIO);
    sD+=analogRead(SENSOR_FOGO_DIR);
    n++; delay(100);
  }
  if (n==0) n=1;
  G.baseEsq = sE/n; G.baseMeio = sM/n; G.baseDir = sD/n;
  G.calibrado=true;
  Serial.print(F("CALIB bases -> E:"));Serial.print(G.baseEsq);
  Serial.print(F(" M:"));Serial.print(G.baseMeio);
  Serial.print(F(" D:"));Serial.println(G.baseDir);
}

// Leitura √∫nica e delta
static inline void leituraDelta(int &dE,int &dM,int &dD, int &side){
  int aE=analogRead(SENSOR_FOGO_ESQ);
  int aM=analogRead(SENSOR_FOGO_MEIO);
  int aD=analogRead(SENSOR_FOGO_DIR);
  dE = G.baseEsq - aE; dM = G.baseMeio - aM; dD = G.baseDir - aD;
  // lado do maior delta:
  int md=dM; side=0; if (dE>md){ md=dE; side=-1; } if (dD>md){ md=dD; side=+1; }
}

// Filtro r√°pido: 2 de 3 leituras com delta acima do limiar
bool detectarFogoConfirmado(int &sideOut){
  uint8_t hits=0;
  int bestDelta=-32768; int sideBest=0;
  for (uint8_t i=0;i<CONFIRM_READS;i++){
    int dE,dM,dD,side; leituraDelta(dE,dM,dD,side);
    bool fogo = (dE>DIFERENCA_FOGO) || (dM>DIFERENCA_FOGO) || (dD>DIFERENCA_FOGO);
    if (fogo) hits++;
    int strongest = dM; if (dE>strongest) strongest=dE; if (dD>strongest) strongest=dD;
    if (strongest>bestDelta){ bestDelta=strongest; sideBest=side; }
    delay(CONFIRM_SPACING_MS);
  }
  sideOut = sideBest;
  return (hits>=CONFIRM_MIN);
}

// Clear com histerese
bool isClearNow(){
  int dE,dM,dD,sideDummy; leituraDelta(dE,dM,dD,sideDummy);
  return (dE<DIFERENCA_CLEAR) && (dM<DIFERENCA_CLEAR) && (dD<DIFERENCA_CLEAR);
}

// Servo/Bomba helpers
void moverServo(int nova){
  if (nova==G.posServo) return;
  int passo = (nova > G.posServo) ? 2 : -2;
  while (abs(G.posServo-nova)>2){ G.posServo+=passo; servoMangueira.write(G.posServo); delay(15); }
  G.posServo=nova; servoMangueira.write(G.posServo);
}
void ligarBomba(){ if (!G.bombaOn && G.nivelAguaPct>10){ pumpWrite(true); } }
void desligarBomba(){ if (G.bombaOn){ pumpWrite(false); } }

// B√°sicos (compat√≠veis com seu antigo para pwmSoftware)
void frenteBasico(){  digitalWrite(IN1,HIGH); digitalWrite(IN2,LOW);  digitalWrite(IN3,HIGH);  digitalWrite(IN4,LOW);  }
void trasBasico(){    digitalWrite(IN1,LOW);  digitalWrite(IN2,HIGH); digitalWrite(IN3,LOW);   digitalWrite(IN4,HIGH); }
void direitaBasico(){ digitalWrite(IN1,LOW);  digitalWrite(IN2,HIGH); digitalWrite(IN3,HIGH);  digitalWrite(IN4,LOW);  }
void esquerdaBasico(){digitalWrite(IN1,HIGH); digitalWrite(IN2,LOW);  digitalWrite(IN3,LOW);   digitalWrite(IN4,HIGH); }
void parar(){         motorsStop(); }

// ===================== L√ìGICA AUTO (SEM PATRULHA) =====================
void handleAuto(){
  if (!G.calibrado){ calibrarSensores(); G.posServo=SERVO_CENTRO; servoMangueira.write(G.posServo); return; }

  // √°gua/LED
  G.nivelAguaPct = waterPercent();
  updateWaterLED(G.nivelAguaPct);
  if (G.nivelAguaPct<=10) desligarBomba();

  // confirma fogo via burst
  int side=0;
  bool fireNow = detectarFogoConfirmado(side);

  unsigned long now=millis();
  if (fireNow){
    G.fogoConfirmado = true;
    G.fogoHoldUntil = now + FIRE_HOLD_MS;

    // a√ß√£o: direciona e faz passos curtos
    if (G.nivelAguaPct>10) ligarBomba(); else desligarBomba();

    if (side<0){ // mais forte √† esquerda do rob√¥ -> gira para ESQUERDA (servo aponta para direita f√≠sica)
      moverServo(SERVO_DIR); // seu mapeamento antigo
      // giro leve e avan√ßo curto
      pwmSoftware(esquerdaBasico, VEL_PERC, T_TURN_MS);
      pwmSoftware(frenteBasico,  VEL_PERC, T_FWD_MS);
    } else if (side>0){
      moverServo(SERVO_ESQ);
      pwmSoftware(direitaBasico, VEL_PERC, T_TURN_MS);
      pwmSoftware(frenteBasico,  VEL_PERC, T_FWD_MS);
    } else {
      moverServo(SERVO_CENTRO);
      pwmSoftware(frenteBasico,  VEL_PERC, T_FWD_MS);
    }

    // contar eventos para recalibra√ß√£o peri√≥dica
    static bool lastHadFire=false;
    if (!lastHadFire && G.fogoConfirmado){
      G.eventosConfirmados++;
      if (G.eventosConfirmados % RECALIB_EVERY_CONFIRMED == 0){
        Serial.println(F("AUTO: Recalibrando por contagem de eventos..."));
        calibrarSensores();
      }
    }
    lastHadFire = true;
  } else {
    // limpar com histerese e hold
    if (G.fogoConfirmado && now > G.fogoHoldUntil){
      if (isClearNow()){ G.fogoConfirmado=false; }
    }

    // Sem fogo confirmado => N√ÉO se move, bomba OFF, servo centro
    if (!G.fogoConfirmado){
      desligarBomba();
      moverServo(SERVO_CENTRO);
      motorsStop();
    }
  }
}

// ===================== (Opcional) MODO MANUAL =====================
void handleManual(){
  // Se n√£o usa, deixe vazio. Mantido para compatibilidade com seu app.
  G.nivelAguaPct = waterPercent();
  updateWaterLED(G.nivelAguaPct);
  if (digitalRead(BOTAO)==LOW){
    // exemplo: segurar bot√£o liga bomba (se houver √°gua)
    if (G.nivelAguaPct>10) ligarBomba();
  } else {
    desligarBomba();
  }
}

/* ===================== SETUP / LOOP ===================== */
void setup(){
  Serial.begin(115200);

  pinMode(IN1,OUTPUT); pinMode(IN2,OUTPUT); pinMode(IN3,OUTPUT); pinMode(IN4,OUTPUT);
  pinMode(BOMBA_PIN,OUTPUT); pumpWrite(false);
  pinMode(LED_VERMELHO,OUTPUT); analogWrite(LED_VERMELHO,0);

  pinMode(SENSOR_FOGO_ESQ_D,INPUT);
  pinMode(SENSOR_FOGO_MEIO_D,INPUT);
  pinMode(SENSOR_FOGO_DIR_D,INPUT);
  pinMode(BOTAO,INPUT_PULLUP);

  servoMangueira.attach(SERVO_PIN);
  servoMangueira.write(SERVO_CENTRO);
  G.posServo = SERVO_CENTRO;

  motorsStop();
  Serial.println(F("HydroBot pronto (AUTO sem patrulha). Calibrando ao entrar..."));
  // Inicia em AUTO: j√° calibra no primeiro handleAuto()
  G.modo = MODO_AUTO;
}

void loop(){
  // watchdog de movimento
  if (G.motionActive && (long)(millis()-G.motionEndMs)>=0){ motorsStop(); G.motionActive=false; }
  if ((millis()-G.lastMoveCmdAt)>1000 && G.currentDir!=DIR_STOP){ motorsStop(); G.motionActive=false; }

  if (G.modo==MODO_AUTO) handleAuto();
  else handleManual();
}






































// ====== HydroBot ‚Äì Driver, Modos (APP/AUTO) com Confirma√ß√£o de Fogo e Calibra√ß√£o por Evento ======
#include <Arduino.h>

/* ========================== CONFIGURA√á√ÉO GERAL ========================== */
#define HAVE_SERVO 0

/* ---------------- PINAGEM ---------------- */
#define IN1 8
#define IN2 9
#define IN3 10
#define IN4 11
#define BOMBA_PIN 13

#if HAVE_SERVO
  #include <Servo.h>
  Servo servoMangueira;
  #define SERVO_PIN     12
  #define SERVO_ESQ     45
  #define SERVO_CENTRO 100
  #define SERVO_DIR     135
  #define LED_VERMELHO_PIN 3
#else
  #define LED_VERMELHO_PIN 12
#endif

#define BOTAO 7
#define SENSOR_FOGO_ESQ_D 4
#define SENSOR_FOGO_MEIO_D 5
#define SENSOR_FOGO_DIR_D 6

#define SENSOR_FOGO_ESQ  A2
#define SENSOR_FOGO_MEIO A1
#define SENSOR_FOGO_DIR  A0
#define NIVEL_AGUA_PIN   A3

/* ========================== TIPOS E ESTADOS ========================== */
enum Modo       : uint8_t { MODO_APP = 0, MODO_AUTO = 1 };
enum Dir        : uint8_t { DIR_STOP=0, DIR_FWD, DIR_BACK, DIR_LEFT, DIR_RIGHT };
enum AutoState  : uint8_t { AUTO_IDLE=0, AUTO_ATTACK_FWD, AUTO_ATTACK_BACK };

struct FireSample {
  bool digE, digM, digD;     // digitais (LOW = fogo)
  int  aE, aM, aD;           // anal√≥gicos
  int  dE, dM, dD;           // base - atual
  bool fogo;                 // marcou fogo nesta leitura
  int  side;                 // -1 esq, 0 meio, +1 dir
};

struct State {
  Modo modo = MODO_APP;
  bool pumpOn = false;

  // movimento
  Dir currentDir = DIR_STOP;
  bool motionActive = false;
  unsigned long motionEndMs = 0;
  unsigned long lastMoveCmdAt = 0;
  uint8_t baseSpeed = 70;

  // bot√£o
  bool ultimoEstadoBotao = HIGH;
  unsigned long lastDebounce = 0;

  // calibra√ß√£o (somente por evento ou ao entrar no AUTO)
  int baseEsq = 0, baseMeio = 0, baseDir = 0;
  bool sistemaCalibrado = false;

  // auto
  AutoState autoState = AUTO_IDLE;
  unsigned long autoStateUntil = 0;

  // √°gua
  uint8_t nivelAguaPct = 0;

  // LED √°gua
  unsigned long ledToggleAt = 0;
  bool ledBlinkState = false;

  // confirma√ß√£o de fogo
  bool fogoConfirmado = false;
  unsigned long fogoHoldUntil = 0;     // mant√©m ‚Äúfogo‚Äù por um tempo p/ estabilidade
  uint16_t eventosFogoConfirmados = 0; // conta para recalibrar
} G;

/* ========================== CONSTANTES ========================== */
// Calibra√ß√£o
static const uint16_t TEMPO_CALIBRACAO_MS   = 2500;

// Histerese
static const int      DIF_FOGO   = 160;  // limiar para ACIONAR
static const int      DIF_CLEAR  = 110;  // limiar para LIMPAR (menor que DIF_FOGO)

// Confirma√ß√£o (anti-falso-positivo)
static const uint8_t  CONFIRM_READS = 4; // M leituras
static const uint8_t  CONFIRM_MIN   = 3; // precisa de K acertos
static const uint16_t CONFIRM_SPACING_MS = 15; // espa√ßamento entre leituras no burst

// Hold (suavidade)
static const uint16_t FIRE_HOLD_MS = 250; // mant√©m fogo por este tempo ap√≥s √∫ltima confirma√ß√£o

// Recalibra√ß√£o por evento
static const uint8_t  RECALIB_EVERY_CONFIRMED = 5; // recalibra a cada N eventos confirmados

// Debounce bot√£o
static const uint16_t BTN_DEBOUNCE_MS       = 35;
static const uint16_t MANUAL_BTN_HOLD_MS    = 40;

/* ========================== PROT√ìTIPOS ========================== */
void setupHardware();
FireSample readSensorsOnce();
bool readSensorsBurstConfirm(FireSample &outBest);
void updateMotors(Dir d);
void setMotion(Dir d, uint16_t ms);
void pumpWrite(bool on);
uint8_t waterPercent();
void updateWaterLED(uint8_t pct);
void emitStatus();

void handleAutoMode();
void handleManualMode();
void autoCalibrateInitial();
void autoAimBySide(int side);

void handleModeButtonToggle();
void handleUARTLine(const String& s);

/* ========================== IMPLEMENTA√á√ÉO ========================== */
// --------- Motores ---------
void motorsStop(){ digitalWrite(IN1,LOW);digitalWrite(IN2,LOW);digitalWrite(IN3,LOW);digitalWrite(IN4,LOW); G.currentDir=DIR_STOP; }
void motorsFwd(){  digitalWrite(IN1,HIGH);digitalWrite(IN2,LOW);digitalWrite(IN3,HIGH);digitalWrite(IN4,LOW); G.currentDir=DIR_FWD; }
void motorsBack(){ digitalWrite(IN1,LOW);digitalWrite(IN2,HIGH);digitalWrite(IN3,LOW);digitalWrite(IN4,HIGH); G.currentDir=DIR_BACK; }
void motorsLeftTurn(){  digitalWrite(IN1,LOW);digitalWrite(IN2,HIGH);digitalWrite(IN3,HIGH);digitalWrite(IN4,LOW); G.currentDir=DIR_LEFT; }
void motorsRightTurn(){ digitalWrite(IN1,HIGH);digitalWrite(IN2,LOW);digitalWrite(IN3,LOW);digitalWrite(IN4,HIGH); G.currentDir=DIR_RIGHT; }

void updateMotors(Dir d){
  switch(d){
    case DIR_FWD: motorsFwd(); break;
    case DIR_BACK: motorsBack(); break;
    case DIR_LEFT: motorsLeftTurn(); break;
    case DIR_RIGHT: motorsRightTurn(); break;
    default: motorsStop(); break;
  }
}

void setMotion(Dir d, uint16_t ms){
  if (ms==0 || d==DIR_STOP){ motorsStop(); G.motionActive=false; return; }
  updateMotors(d);
  G.motionActive = true;
  G.motionEndMs = millis() + (unsigned long)ms;
  G.lastMoveCmdAt = millis();
}

// --------- Bomba e √Ågua ---------
void pumpWrite(bool on){
  G.pumpOn = on;
  digitalWrite(BOMBA_PIN, on?HIGH:LOW);
}

uint8_t waterPercent(){
  int raw = analogRead(NIVEL_AGUA_PIN);
  int pct = map(raw,0,1023,0,100);
  pct = constrain(pct,0,100);
  return (uint8_t)pct;
}

void updateWaterLED(uint8_t pct){
  if (pct > 50){ digitalWrite(LED_VERMELHO_PIN, LOW); return; }
  if (pct > 15){ digitalWrite(LED_VERMELHO_PIN, HIGH); return; }
  if (millis() - G.ledToggleAt > 300){
    G.ledToggleAt = millis();
    G.ledBlinkState = !G.ledBlinkState;
    digitalWrite(LED_VERMELHO_PIN, G.ledBlinkState ? HIGH : LOW);
  }
}

// --------- Status ---------
void emitStatus(){
  int ax=analogRead(SENSOR_FOGO_ESQ), am=analogRead(SENSOR_FOGO_MEIO), ad=analogRead(SENSOR_FOGO_DIR);
  Serial.print(F("STAT:ax="));Serial.print(ax);
  Serial.print(F(":am="));Serial.print(am);
  Serial.print(F(":ad="));Serial.print(ad);
  Serial.print(F(":water="));Serial.print(G.nivelAguaPct);
  Serial.print(F(":pump="));Serial.print(G.pumpOn?1:0);
  Serial.print(F(":mode="));Serial.print((int)G.modo);
  Serial.print(F(":auto="));Serial.print((int)G.autoState);
  Serial.print(F(":fire="));Serial.println(G.fogoConfirmado?1:0);
}

/* ========================== SENSORES / CALIBRA√á√ÉO ========================== */
void autoCalibrateInitial(){
  unsigned long t0=millis(); long sE=0,sM=0,sD=0; int n=0;
  while(millis()-t0<TEMPO_CALIBRACAO_MS){
    sE += analogRead(SENSOR_FOGO_ESQ);
    sM += analogRead(SENSOR_FOGO_MEIO);
    sD += analogRead(SENSOR_FOGO_DIR);
    n++; delay(40);
  }
  if (n==0) n=1;
  G.baseEsq  = sE/n;
  G.baseMeio = sM/n;
  G.baseDir  = sD/n;
  G.sistemaCalibrado = true;
  Serial.print(F("CALIB:E="));Serial.print(G.baseEsq);
  Serial.print(F(" M="));Serial.print(G.baseMeio);
  Serial.print(F(" D="));Serial.println(G.baseDir);
}

static inline bool isAnalogFire(int dE,int dM,int dD){
  return (dE > DIF_FOGO) || (dM > DIF_FOGO) || (dD > DIF_FOGO);
}
static inline bool isAnalogClear(int dE,int dM,int dD){
  return (dE < DIF_CLEAR) && (dM < DIF_CLEAR) && (dD < DIF_CLEAR);
}

FireSample readSensorsOnce(){
  FireSample s;
  s.digE=(digitalRead(SENSOR_FOGO_ESQ_D)==LOW);
  s.digM=(digitalRead(SENSOR_FOGO_MEIO_D)==LOW);
  s.digD=(digitalRead(SENSOR_FOGO_DIR_D)==LOW);
  s.aE=analogRead(SENSOR_FOGO_ESQ);
  s.aM=analogRead(SENSOR_FOGO_MEIO);
  s.aD=analogRead(SENSOR_FOGO_DIR);
  s.dE=G.baseEsq - s.aE; s.dM=G.baseMeio - s.aM; s.dD=G.baseDir - s.aD;

  // Crit√©rio de ‚Äúfogo‚Äù por leitura √∫nica: ANAL√ìGICO acima do limiar OU >=2 digitais LOW
  bool fogoAnal = isAnalogFire(s.dE,s.dM,s.dD);
  uint8_t digCount = (s.digE?1:0)+(s.digM?1:0)+(s.digD?1:0);
  bool fogoDig2 = (digCount >= 2);
  s.fogo = fogoAnal || fogoDig2;

  // Dire√ß√£o de maior delta anal√≥gico
  int md=s.dM; s.side=0; if(s.dE>md){md=s.dE; s.side=-1;} if(s.dD>md){md=s.dD; s.side=+1;}
  return s;
}

// Faz M leituras com pequeno intervalo e requer K confirma√ß√µes
bool readSensorsBurstConfirm(FireSample &outBest){
  uint8_t hits = 0;
  FireSample best; int bestDelta = -32768;

  for (uint8_t i=0;i<CONFIRM_READS;i++){
    FireSample s = readSensorsOnce();
    int strongest = s.dM; if (s.dE>strongest) strongest=s.dE; if (s.dD>strongest) strongest=s.dD;
    if (s.fogo) hits++;
    if (strongest > bestDelta){ bestDelta = strongest; best = s; }
    delay(CONFIRM_SPACING_MS);
  }

  outBest = best;
  return (hits >= CONFIRM_MIN);
}

/* ========================== AUTO MODE ========================== */
void autoAimBySide(int side){
#if HAVE_SERVO
  int tgt = (side<0?SERVO_DIR:(side>0?SERVO_ESQ:SERVO_CENTRO));
  servoMangueira.write(tgt);
#else
  (void)side;
#endif
}

void handleAutoMode(){
  // Calibra s√≥ ao entrar no AUTO (ou por comando) e por contagem de eventos
  if (!G.sistemaCalibrado){
    autoCalibrateInitial();
    return;
  }

  // √Ågua + LED
  G.nivelAguaPct = waterPercent();
  updateWaterLED(G.nivelAguaPct);
  if (G.nivelAguaPct < 10 && G.pumpOn) pumpWrite(false);

  // Confirma√ß√£o de fogo (burst)
  FireSample best;
  bool fireNow = readSensorsBurstConfirm(best);

  // Histerese e hold
  unsigned long now = millis();
  if (fireNow){
    G.fogoConfirmado = true;
    G.fogoHoldUntil = now + FIRE_HOLD_MS;
  } else if (G.fogoConfirmado){
    // S√≥ limpa se ficar abaixo do clear e passar o hold
    if (now > G.fogoHoldUntil){
      // Checa ‚Äúclear‚Äù com uma leitura r√°pida
      FireSample s = readSensorsOnce();
      if (isAnalogClear(s.dE,s.dM,s.dD)){
        G.fogoConfirmado = false;
      }
    }
  }

  // A√á√ÉO: somente se fogoConfirmado
  if (G.fogoConfirmado){
    if (G.nivelAguaPct > 10) pumpWrite(true); else pumpWrite(false);

    // Dire√ß√£o com base no delta mais forte (best.side)
    if (G.autoState==AUTO_IDLE || (long)(now - G.autoStateUntil) >= 0){
      static uint8_t forwardStrikes=0;
      if (G.autoState!=AUTO_ATTACK_BACK){
        G.autoState = AUTO_ATTACK_FWD; G.autoStateUntil = now + 450;
        if (best.side < 0) setMotion(DIR_LEFT,150);
        else if (best.side > 0) setMotion(DIR_RIGHT,150);
        else setMotion(DIR_FWD,210);
        forwardStrikes++;
        if (forwardStrikes>=3){
          G.autoState=AUTO_ATTACK_BACK; G.autoStateUntil=now+550; setMotion(DIR_BACK,260); forwardStrikes=0;
        }
      } else {
        G.autoState=AUTO_ATTACK_FWD; G.autoStateUntil=now+450; setMotion(DIR_FWD,210);
      }
    }

    // Quando ‚Äúnasce‚Äù um novo evento confirmado, conte para recalibrar
    static bool lastLoopHadFire=false;
    if (!lastLoopHadFire && G.fogoConfirmado){
      G.eventosFogoConfirmados++;
      if (G.eventosFogoConfirmados % RECALIB_EVERY_CONFIRMED == 0){
        Serial.println(F("AUTO:Recalibrando por contagem de eventos..."));
        autoCalibrateInitial();
      }
    }
    lastLoopHadFire = true;

  } else {
    // Sem fogo: para tudo, n√£o patrulha.
    motorsStop();
    pumpWrite(false);
#if HAVE_SERVO
    servoMangueira.write(SERVO_CENTRO);
#endif
    G.autoState = AUTO_IDLE;

    // Zera marcador de ‚Äúem fogo‚Äù para o contador de eventos
    static bool lastLoopHadFire=false;
    lastLoopHadFire = false;
  }
}

/* ========================== MANUAL MODE (sob demanda) ========================== */
void handleManualMode(){
  G.nivelAguaPct = waterPercent();
  updateWaterLED(G.nivelAguaPct);
  if (G.nivelAguaPct<10 && G.pumpOn) pumpWrite(false);

  static unsigned long btnPressStart = 0;
  bool btnPressed = (digitalRead(BOTAO) == LOW);

  if (btnPressed){
    if (btnPressStart==0) btnPressStart = millis();
    if (millis() - btnPressStart >= MANUAL_BTN_HOLD_MS){
      // Uma leitura simples basta (manual √© sob demanda)
      FireSample s = readSensorsOnce();
      bool fire = s.fogo;
      if (fire){
        if (G.nivelAguaPct>10) pumpWrite(true); else pumpWrite(false);
        Serial.println(F("MANUAL:FOGO"));
      } else {
        pumpWrite(false);
        Serial.println(F("MANUAL:SEM_FOGO"));
      }
    }
  } else {
    btnPressStart = 0;
    pumpWrite(false);
  }
}

/* ========================== ENTRADA (BOT√ÉO/MODO) ========================== */
void handleModeButtonToggle(){
  bool leitura = digitalRead(BOTAO);
  if (leitura != G.ultimoEstadoBotao){
    G.lastDebounce = millis();
    G.ultimoEstadoBotao = leitura;
  }
  if ((millis()-G.lastDebounce) > BTN_DEBOUNCE_MS){
    static bool prev = HIGH;
    if (prev==HIGH && leitura==LOW){
      G.modo = (G.modo==MODO_APP) ? MODO_AUTO : MODO_APP;

      motorsStop(); pumpWrite(false);
#if HAVE_SERVO
      servoMangueira.write(SERVO_CENTRO);
#endif
      G.autoState = AUTO_IDLE;
      G.fogoConfirmado = false;

      // Ao entrar no AUTO: calibra uma vez
      if (G.modo == MODO_AUTO){
        autoCalibrateInitial();
      }

      Serial.print(F("MODE:")); Serial.println(G.modo==MODO_APP?F("APP"):F("AUTO"));
    }
    prev = leitura;
  }
}

/* ========================== UART / PROTOCOLO ========================== */
void handleMoveCmd(const String&cmd){
  uint16_t ms=200; int pms=cmd.indexOf("ms="); if(pms>=0) ms=(uint16_t)cmd.substring(pms+3).toInt();
  ms = constrain(ms,80,700);
  if      (cmd.indexOf("FWD")>=0)   setMotion(DIR_FWD,ms);
  else if (cmd.indexOf("BACK")>=0)  setMotion(DIR_BACK,ms);
  else if (cmd.indexOf("LEFT")>=0)  setMotion(DIR_LEFT,ms);
  else if (cmd.indexOf("RIGHT")>=0) setMotion(DIR_RIGHT,ms);
  else if (cmd.indexOf("STOP")>=0)  setMotion(DIR_STOP,0);
}

void handleUARTLine(const String& s){
  if (s.startsWith("REQ:STATUS")){ emitStatus(); return; }
  if (s.startsWith("SET:SPEED:")){ int v=s.substring(10).toInt(); G.baseSpeed=(uint8_t)constrain(v,0,100); Serial.println(F("OK:SPEED")); return; }
  if (s.startsWith("SET:LED:"))  { int v=s.substring(8).toInt(); digitalWrite(LED_VERMELHO_PIN, v>0?HIGH:LOW); Serial.println(F("OK:LED")); return; }

  if (G.modo == MODO_APP){
    if (s.indexOf("CMD:PUMP:")>=0){ bool on=s.endsWith("1"); if(on && waterPercent()<=15){ pumpWrite(false); Serial.println(F("WARN:NO_WATER")); } else { pumpWrite(on); Serial.println(on?F("OK:PUMP_ON"):F("OK:PUMP_OFF")); } return; }
    if (s.startsWith("CMD:")){ handleMoveCmd(s); return; }
    if (s.startsWith("CMD:CALIB")){ Serial.println(F("IGN:CALIB_MANUAL")); return; }
  } else {
    if (s.startsWith("CMD:CALIB")){ G.sistemaCalibrado=false; Serial.println(F("OK:CALIB_REQUEST")); return; }
    if (s.indexOf("CMD:STOP")>=0){ setMotion(DIR_STOP,0); Serial.println(F("OK:STOP")); return; }
    if (s.indexOf("CMD:PUMP:0")>=0){ pumpWrite(false); Serial.println(F("OK:PUMP_OFF")); return; }
  }

  Serial.println(F("ERR:UNKNOWN"));
}

/* ========================== SETUP / LOOP ========================== */
void setupHardware(){
  Serial.begin(115200);

  pinMode(IN1,OUTPUT); pinMode(IN2,OUTPUT); pinMode(IN3,OUTPUT); pinMode(IN4,OUTPUT);
  pinMode(BOMBA_PIN,OUTPUT); pumpWrite(false);
  pinMode(LED_VERMELHO_PIN,OUTPUT); digitalWrite(LED_VERMELHO_PIN,LOW);

  pinMode(BOTAO,INPUT_PULLUP);

  pinMode(SENSOR_FOGO_ESQ_D,INPUT);
  pinMode(SENSOR_FOGO_MEIO_D,INPUT);
  pinMode(SENSOR_FOGO_DIR_D,INPUT);

#if HAVE_SERVO
  servoMangueira.attach(SERVO_PIN);
  servoMangueira.write(SERVO_CENTRO);
#endif

  motorsStop();
  Serial.println(F("ARDUINO_READY"));
}

void setup(){
  setupHardware();
  // Se desejar iniciar em AUTO por padr√£o, ative a linha abaixo.
  // G.modo = MODO_AUTO;
  if (G.modo == MODO_AUTO){
    autoCalibrateInitial();
  }
}

void loop(){
  if (G.motionActive && (long)(millis()-G.motionEndMs)>=0){ motorsStop(); G.motionActive=false; }
  if ((millis()-G.lastMoveCmdAt)>1000 && G.currentDir!=DIR_STOP){ motorsStop(); G.motionActive=false; }

  handleModeButtonToggle();

  while(Serial.available()){
    static String line;
    char c=Serial.read();
    if(c=='\n'||c=='\r'){
      if(line.length()>0){ String s=line; line=""; s.trim(); handleUARTLine(s); }
    } else {
      line += c; if(line.length()>240) line.remove(0);
    }
  }

  if (G.modo == MODO_APP){
    handleManualMode();
  } else {
    handleAutoMode();
  }
}










Entendi ‚Äî voc√™ quer manter a arquitetura por snapshot que j√° estava funcionando (server faz polling de /snapshot) e apenas alinhar os pontos que mudaram no firmware:




Controles agora s√£o via POST /uart?cmd=... (n√£o mais /uart?line=).


LED via POST /led?on=0|1.


Voc√™ tem /status, /snapshot, /stream ‚Äî mas o server continua usando /snapshot.


Podemos usar mDNS hydrobot.local como IP padr√£o.




Abaixo v√£o os dois arquivos completos, com mudan√ßas m√≠nimas e cir√∫rgicas:



server_heuristic.py (mantido snapshot-poller, s√≥ ajustei IP default e coment√°rios)


# server_heuristic.py
# FastAPI proxy + heur√≠stica de fogo (leve) para ESP32-CAM snapshot (robusto)

import time
import threading
from typing import Optional, Dict, Any, List, Tuple

import cv2
import numpy as np
import requests
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ========= CONFIG =========
# Agora usando mDNS do seu firmware como padr√£o; pode trocar via /config
CAMERA_IP = "hydrobot.local"                     # ESP32-CAM host (mDNS ou IP fixo)
SNAPSHOT_URL_FMT = "http://{}/snapshot"
CONNECT_TIMEOUT = 4.0
READ_TIMEOUT = 15.0
POLL_FPS_TARGET = 8.0                            # ~8 fps est√°vel
MAX_FRAME_AGE_MS = 15000                         # relaxado p/ redes lentas
MAX_RESULT_AGE_MS = 800
JPEG_QUALITY = 85

# Heur√≠stica simples de fogo
HSV_LOW = (8, 80, 120)
HSV_HIGH = (40, 255, 255)
EMA_ALPHA = 0.25
HYST_HIGH = 0.18
HYST_LOW  = 0.15
MIN_BLOB_AREA = 900
KERNEL_SZ = 5

REQUEST_HEADERS = {
    "Connection": "keep-alive",
    "User-Agent": "HydroBot-Grabber/1.0",
    "Cache-Control": "no-cache",
    "Pragma": "no-cache",
}

ACCEPT_CT_PREFIX = ("image/jpeg", "image/jpg", "image/pjpeg", "application/octet-stream")

def is_jpeg_bytes(b: bytes) -> bool:
    return len(b) > 4 and b[0] == 0xFF and b[1] == 0xD8

# ========= FASTAPI =========
app = FastAPI(title="HydroBot Server (proxy + fire-heuristic)", version="2.2")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True,
                   allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
    camera_ip: str

# ========= PLACEHOLDER =========
def placeholder_jpeg(msg: str = "NO LIVE FRAME") -> bytes:
    img = np.zeros((240, 320, 3), dtype=np.uint8)
    img[:, :] = (40, 40, 200)
    cv2.putText(img, msg, (20, 130), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255,255,255), 2, cv2.LINE_AA)
    cv2.putText(img, time.strftime("%H:%M:%S"), (20, 200), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255,255,255), 2, cv2.LINE_AA)
    ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), 80])
    return buf.tobytes()

# ========= SNAPSHOT GRABBER =========
class SnapshotGrabber:
    def __init__(self):
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._ip = CAMERA_IP
        self._last_jpeg: Optional[bytes] = None
        self._last_ts_ms: int = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._session = requests.Session()
        self._last_err: Optional[str] = None

    def start(self, ip: Optional[str] = None):
        if ip:
            self._ip = ip
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)
        self._thread = None

    def _ok_ct(self, ct: str) -> bool:
        if not ct:
            return True  # √†s vezes vem vazio; vamos checar magic bytes
        ct = ct.lower()
        return any(ct.startswith(p) for p in ACCEPT_CT_PREFIX)

    def _fetch_once(self) -> Optional[bytes]:
        u = f"{SNAPSHOT_URL_FMT.format(self._ip)}?ts={int(time.time()*1000)}"
        r = self._session.get(u, timeout=(CONNECT_TIMEOUT, READ_TIMEOUT),
                              headers=REQUEST_HEADERS, stream=False)
        if r.status_code == 200:
            ct = r.headers.get("Content-Type", "")
            b = r.content or b""
            if (self._ok_ct(ct) and b) or is_jpeg_bytes(b):
                return b
        return None

    def _run(self):
        min_interval = 1.0 / POLL_FPS_TARGET
        backoff = 0.0
        while not self._stop.is_set():
            t0 = time.time()
            try:
                jpeg = self._fetch_once()
                if jpeg:
                    with self._lock:
                        self._last_jpeg = jpeg
                        self._last_ts_ms = int(time.time()*1000)
                        self._last_err = None
                    self._frames += 1
                    now = time.time()
                    if now - self._last_fps_tick >= 1.0:
                        self._fps = self._frames / (now - self._last_fps_tick)
                        self._frames = 0
                        self._last_fps_tick = now
                    backoff = 0.0
                else:
                    backoff = min(2.0, max(0.2, (backoff * 1.7) or 0.2))
            except Exception as e:
                with self._lock:
                    self._last_err = f"{type(e).__name__}: {e}"
                backoff = min(3.0, max(0.2, (backoff * 1.7) or 0.2))

            elapsed = time.time() - t0
            sleep = max(0.0, min_interval - elapsed) + backoff
            if self._stop.is_set():
                break
            time.sleep(sleep)

    def get_latest_jpeg(self, max_age_ms=MAX_FRAME_AGE_MS) -> Optional[bytes]:
        with self._lock:
            if self._last_jpeg is None:
                return None
            if int(time.time()*1000) - self._last_ts_ms > max_age_ms:
                return None
            return self._last_jpeg

    def status(self) -> Dict[str, Any]:
        with self._lock:
            age = int(time.time()*1000) - self._last_ts_ms if self._last_ts_ms else None
            return {"ip": self._ip, "hasFrame": self._last_jpeg is not None, "age_ms": age,
                    "fps_in": round(self._fps, 2), "last_err": self._last_err}

grabber = SnapshotGrabber()
grabber.start(CAMERA_IP)

# ========= HEUR√çSTICA FOGO =========
def hsv_fire_mask(frame_bgr: np.ndarray) -> np.ndarray:
    hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
    return cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))

def boxes_from_mask(mask_bin: np.ndarray, min_area: int = MIN_BLOB_AREA) -> List[List[int]]:
    k = np.ones((KERNEL_SZ, KERNEL_SZ), np.uint8)
    m = cv2.morphologyEx(mask_bin, cv2.MORPH_OPEN, k, 1)
    m = cv2.morphologyEx(m, cv2.MORPH_DILATE, k, 1)
    cnts, _ = cv2.findContours(m, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    out = []
    for c in cnts:
        x,y,w,h = cv2.boundingRect(c)
        if w*h >= min_area:
            out.append([int(x), int(y), int(w), int(h)])
    return out

class FireDetector:
    def __init__(self, src: SnapshotGrabber):
        self.src = src
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._ema = 0.0
        self._score_raw = 0.0
        self._is_fire = False
        self._boxes: List[List[int]] = []
        self._last_ts = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._frame_wh: Optional[Tuple[int,int]] = None

    def start(self):
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)
        self._thread = None

    def _run(self):
        min_interval = 1.0 / 8.0
        while not self._stop.is_set():
            t0 = time.time()
            jpeg = self.src.get_latest_jpeg()
            if jpeg is None:
                time.sleep(0.02); continue
            frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
            if frame is None:
                time.sleep(0.01); continue
            H, W = frame.shape[:2]
            self._frame_wh = (W, H)
            mask = hsv_fire_mask(frame)
            v_mean = float(np.mean(cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)[...,2])) / 255.0
            ratio = float(np.count_nonzero(mask))/float(mask.size)
            score_raw = min(1.0, ratio*4.0 + v_mean*0.1)
            ema = score_raw if self._ema==0.0 else EMA_ALPHA*score_raw + (1.0-EMA_ALPHA)*self._ema
            boxes = boxes_from_mask(mask)
            if   ema >= HYST_HIGH: is_fire = True
            elif ema <= HYST_LOW : is_fire = False
            else: is_fire = self._is_fire
            with self._lock:
                self._ema = ema
                self._score_raw = score_raw
                self._is_fire = is_fire
                self._boxes = boxes if is_fire else []
                self._last_ts = int(time.time()*1000)
                self._frames += 1
                now = time.time()
                if now - self._last_fps_tick >= 1.0:
                    self._fps = self._frames / (now - self._last_fps_tick)
                    self._frames = 0
                    self._last_fps_tick = now
            elapsed = time.time() - t0
            if elapsed < min_interval:
                time.sleep(min_interval - elapsed)

    def get(self) -> Dict[str, Any]:
        with self._lock:
            return {
                "ok": True,
                "isFire": bool(self._is_fire),
                "score": round(float(self._ema), 3),
                "score_raw": round(float(self._score_raw), 3),
                "score_ema": round(float(self._ema), 3),
                "boxes": list(self._boxes),
                "ts": int(self._last_ts),
                "fps_det": round(float(self._fps), 2),
                "frame_wh": list(self._frame_wh) if self._frame_wh else None
            }

det = FireDetector(grabber); det.start()

# ========= ENDPOINTS =========
@app.get("/healthz")
def healthz():
    s = grabber.status()
    return {"ok": True, "camera_ip": s.get("ip"), "fps_in": s.get("fps_in"),
            "hasFrame": s.get("hasFrame"), "age_ms": s.get("age_ms"), "last_err": s.get("last_err")}

@app.get("/status")
def status():
    s = grabber.status(); d = det.get()
    return {"ok": True, "camera_ip": s["ip"], **s, **d}

@app.post("/config")
def set_config(cfg: ConfigIn):
    global CAMERA_IP
    CAMERA_IP = cfg.camera_ip
    grabber.start(CAMERA_IP)
    return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
    b = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS) or placeholder_jpeg("NO LIVE FRAME")
    headers = {
        "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
        "Pragma": "no-cache",
        "Expires": "0",
        "Content-Type": "image/jpeg"
    }
    return Response(content=b, headers=headers, media_type="image/jpeg")

@app.get("/frame.jpg")
def frame_jpg():
    b = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS) or placeholder_jpeg("NO LIVE FRAME")
    headers = {
        "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
        "Pragma": "no-cache",
        "Expires": "0",
        "Content-Type": "image/jpeg"
    }
    return Response(content=b, headers=headers, media_type="image/jpeg")

@app.get("/detect")
def detect():
    res = det.get()
    if res.get("ts", 0) and (int(time.time()*1000) - res["ts"] <= MAX_RESULT_AGE_MS):
        return res
    jpeg = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS)
    if jpeg is None:
        return {"ok": False, "error": "no recent frame"}
    frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
    if frame is None:
        return {"ok": False, "error": "decode failed"}
    H, W = frame.shape[:2]
    mask = hsv_fire_mask(frame)
    v_mean = float(np.mean(cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)[...,2])) / 255.0
    ratio = float(np.count_nonzero(mask))/float(mask.size)
    score = min(1.0, ratio*4.0 + v_mean*0.1)
    is_fire = bool(score >= HYST_HIGH)
    return {"ok": True, "isFire": is_fire, "score": round(score,3), "score_raw": round(score,3),
            "score_ema": round(score,3), "boxes": [], "ts": int(time.time()*1000), "frame_wh": [W,H], "fallback": True}




HydroBotApp2/src/screens/CameraScreen.tsx


Ajustes m√≠nimos para a l√≥gica nova:




UART agora √© POST http://<ESP>/uart?cmd=... (antes era line= e GET).


LED: adicionei bot√µes LED ON/OFF que fazem POST /led?on=1|0.


Bomba: reaproveitei o bot√£o ‚ÄúBOMBA ON/OFF‚Äù, mas agora ele envia CMD:PUMP:1|0 via UART (porque o firmware n√£o tem mais /pump).


Joystick: removi o ‚Äú/joystick‚Äù direto; o loop agora sempre manda pulsos discretos por UART (CMD:FWD/BACK/LEFT/RIGHT ou CMD:STOP), do jeitinho que seu Arduino espera.


Mantive todo o pipeline de snapshot apontando pro server (com fallback pra /frame.jpg e, se necess√°rio, direto no http://<ESP>/snapshot).




// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet,
  PanResponder, GestureResponderEvent, PanResponderGestureState,
  Image, Animated, LayoutChangeEvent,
} from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: { heroSubtitle:"Monitoramento e Controle", espIp:"ESP:", pumpOn:"BOMBA ON", pumpOff:"BOMBA OFF",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Aguardando servidor‚Ä¶", statusFail:"Falha ao conectar. Confira o Wi-Fi/IP.",
        noVideo:"Sem v√≠deo (snapshot). Verifique o servidor.", fireOn:(s:number)=>`üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sem fogo ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sincronizado",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  en: { heroSubtitle:"Monitoring & Control", espIp:"ESP:", pumpOn:"PUMP ON", pumpOff:"PUMP OFF",
        server:"Server:", detecting:"Detecting‚Ä¶", waiting:"Waiting for server‚Ä¶", statusFail:"Failed to connect. Check Wi-Fi/IP.",
        noVideo:"No video (snapshot). Check server.", fireOn:(s:number)=>`üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`No fire ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sync OK",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  es: { heroSubtitle:"Monitoreo y Control", espIp:"ESP:", pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Esperando servidor‚Ä¶", statusFail:"Error de conexi√≥n. Revisa Wi-Fi/IP.",
        noVideo:"Sin v√≠deo (snapshot). Revisa el servidor.", fireOn:(s:number)=>`üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sin fuego ‚Ä¢ score ${s.toFixed(2)}`, synced:"Sincronizado con servidor",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
};

const DEFAULT_IP = "hydrobot.local";
const DEFAULT_SERVER = "http://192.168.0.100:8000";
const DEFAULT_FRAME_WH = { w: 320, h: 240 };

const appLogo = require("../../assets/logo.png");

/* ---------------------- UI AUX ---------------------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown,
}: { currentUri: string; nextUri: string; onNextLoadStart: () => void; onNextShown: (ok: boolean) => void; }) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={() => { onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

type SrcBox = { x:number; y:number; w:number; h:number; type:"fire" };
function BoxesOverlay({ frameWH, containerWH, boxes }:{
  frameWH:{w:number;h:number}|null; containerWH:{w:number;h:number}|null; boxes:SrcBox[];
}) {
  const f = frameWH && frameWH.w>0 && frameWH.h>0 ? frameWH : DEFAULT_FRAME_WH;
  if (!containerWH || containerWH.w<=0 || containerWH.h<=0) return null;
  const scale = Math.min(containerWH.w / f.w, containerWH.h / f.h);
  const dispW = f.w * scale, dispH = f.h * scale;
  const offsetX = (containerWH.w - dispW)/2, offsetY = (containerWH.h - dispH)/2;
  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position:"absolute", left:offsetX, top:offsetY, width:dispW, height:dispH }}>
        {boxes.map((b,i)=>{
          const left=b.x*scale, top=b.y*scale, width=b.w*scale, height=b.h*scale;
          return (
            <View key={i} style={{ position:"absolute", left, top, width, height, borderWidth:3, borderColor:"#ff3b30", borderRadius:6 }}>
              <View style={{ position:"absolute", left:0, top:-18, paddingHorizontal:6, paddingVertical:2, borderRadius:4, backgroundColor:"#ff3b30" }}>
                <Text style={{ color:"#000", fontWeight:"800", fontSize:10 }}>FOGO</Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------------------- SCREEN ---------------------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [statusText, setStatusText] = useState(T.waiting);
  const [pumpOn, setPumpOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{w:number;h:number}|null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{w:number;h:number}|null>(null);

  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  const [useDirectSnapshot, setUseDirectSnapshot] = useState(false);
  const failCountRef = useRef(0);

  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const clean = (s:string)=>s.replace(/\/+$/,"");

  // Server endpoints
  const healthUrl     = useMemo(()=>`${clean(server)}/healthz`,[server]);
  const detectUrl     = useMemo(()=>`${clean(server)}/detect`,[server]);
  const snapshotSrv   = useMemo(()=>`${clean(server)}/snapshot`,[server]);
  const snapshotSrvAlt= useMemo(()=>`${clean(server)}/frame.jpg`,[server]);
  const configUrl     = useMemo(()=>`${clean(server)}/config`,[server]);

  // ESP endpoints (agora TUDO via UART + LED; snapshot direto s√≥ como fallback)
  const snapshotEsp   = useMemo(()=> `http://${ip}/snapshot`, [ip]);
  const uartPost      = useMemo(()=> (cmd:string)=>`http://${ip}/uart?cmd=${encodeURIComponent(cmd)}`, [ip]);
  const ledPost       = useMemo(()=> (on:boolean)=>`http://${ip}/led?on=${on?1:0}`, [ip]);

  // Sincroniza IP da c√¢mera no server (para o poller)
  useEffect(()=>{
    let aborted=false;
    (async()=>{
      try{
        const r=await fetch(configUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({camera_ip:ip})});
        const j=await r.json();
        if(!aborted && j?.ok) setStatusText(`${T.synced} (${j.camera_ip})`);
      }catch{ if(!aborted) setStatusText(T.statusFail); }
    })();
    return()=>{aborted=true};
  },[ip, configUrl, T]);

  // Health do servidor
  useEffect(()=>{
    let stop=false, backoff=500;
    const poll=async()=>{
      if(stop) return;
      try{
        const r=await fetch(healthUrl); const j=await r.json();
        if(j?.ok){ setStatusText(`Server OK ‚Ä¢ fps_in:${j.fps_in} ‚Ä¢ hasFrame:${j.hasFrame}`); return; }
      }catch{}
      setStatusText(T.waiting);
      setTimeout(poll, backoff); backoff=Math.min(backoff*1.6, 5000);
    };
    poll(); return()=>{stop=true};
  },[healthUrl, T]);

  // SNAPSHOT loop com fallback server->ESP
  useEffect(()=>{
    let stop=false, interval=160;
    const pickBase = ()=>{
      if (useDirectSnapshot) return snapshotEsp;
      return failCountRef.current >= 2 ? snapshotSrvAlt : snapshotSrv;
    };

    setCurrentFrameUri(`${pickBase()}?ts=${Date.now()}`);
    const tick=()=>{
      if(stop) return;
      try{
        if(!loadingNextRef.current){
          const base = pickBase();
          setNextFrameUri(`${base}?ts=${Date.now()}`);
        }
        interval=160;
      }catch{
        interval=Math.min(interval*1.7, 1200);
      }
      setTimeout(tick, interval);
    };
    tick();
    return()=>{stop=true};
  },[snapshotSrv, snapshotSrvAlt, snapshotEsp, useDirectSnapshot]);

  const onNextLoadStart = ()=>{ loadingNextRef.current=true; };
  const onNextShown = (ok:boolean)=>{
    if(ok){
      failCountRef.current = 0;
      if(useDirectSnapshot){ setUseDirectSnapshot(false); }   // volta p/ server quando estabiliza
      if(nextFrameUri) setCurrentFrameUri(nextFrameUri);
    }else{
      failCountRef.current += 1;
      if(!useDirectSnapshot && failCountRef.current >= 3){
        setUseDirectSnapshot(true);
        failCountRef.current = 0;
      }
    }
    loadingNextRef.current=false;
  };

  // DETECT loop (inalterado)
  useEffect(()=>{
    let stop=false, interval=250;
    const loop=async()=>{
      if(stop) return;
      try{
        const r=await fetch(detectUrl); const j=await r.json();
        if(j && j.ok!==false){
          setIsFire(!!j.isFire); setFireScore(Number(j.score||0));
          const wh = Array.isArray(j.frame_wh)&&j.frame_wh.length===2
                     ? {w:Number(j.frame_wh[0])||0, h:Number(j.frame_wh[1])||0}:null;
          if(wh && wh.w>0 && wh.h>0) setFrameWH(wh);
          const boxes:SrcBox[]=[];
          if(j.isFire && Array.isArray(j.boxes)){
            for(const b of j.boxes){
              if(Array.isArray(b)&&b.length>=4){
                const [x,y,w,h]=b.map((n:any)=>Number(n)||0);
                boxes.push({x,y,w,h,type:"fire"});
              }
            }
          }
          setOverlayBoxes(boxes); interval=250;
        }
      }catch{
        setIsFire(false); setFireScore(0); setOverlayBoxes([]);
        interval=Math.min(interval*1.5,1500);
      }finally{ setTimeout(loop, interval); }
    };
    loop(); return()=>{stop=true};
  },[detectUrl]);

  // ------- COMANDOS (UART + LED) -------
  // Manda um comando via UART (POST /uart?cmd=...)
  async function sendUART(cmd: string) {
    try {
      const res = await fetch(uartPost(cmd), { method: "POST" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return true;
    } catch {
      setStatusText(T.statusFail);
      return false;
    }
  }

  async function togglePump(){
    const target = !pumpOn;
    const ok = await sendUART(`CMD:PUMP:${target ? "1" : "0"}`);
    if (ok) setPumpOn(target);
  }

  async function led(on:boolean){
    try{
      const res = await fetch(ledPost(on), { method: "POST" });
      const txt = await res.text();
      setStatusText(`${on?T.ledOn:T.ledOff} ‚Ä¢ ${res.status} ${txt||""}`);
    }catch{
      setStatusText(T.statusFail);
    }
  }

  // Joystick: envia PULSOS discretos por UART (CMD:FWD/BACK/LEFT/RIGHT/STOP)
  const RADIUS=64;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder:()=>true,
      onMoveShouldSetPanResponder:()=>true,
      onPanResponderGrant:()=>{ setDragging(true); },
      onPanResponderMove:(_e:GestureResponderEvent,g:PanResponderGestureState)=>{
        let nx=g.dx/RADIUS, ny=g.dy/RADIUS;
        const len=Math.hypot(nx,ny); if(len>1){ nx/=len; ny/=len; }
        setJoy({x:nx, y:-ny});
      },
      onPanResponderRelease:()=>{ setJoy({x:0,y:0}); setDragging(false); },
      onPanResponderTerminate:()=>{ setJoy({x:0,y:0}); setDragging(false); },
    })
  ).current;

  const lastSendRef = useRef(0);
  const lastDirRef  = useRef<string>("STOP");

  const vecToDir=(x:number,y:number):"FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP"=>{
    const mag=Math.hypot(x,y); if(mag<0.2) return "STOP";
    const deg=(Math.atan2(y,x)*180)/Math.PI;
    if(deg>-45&&deg<=45) return "RIGHT";
    if(deg>45&&deg<=135) return "FWD";
    if(deg<=-45&&deg>-135) return "BACK";
    return "LEFT";
  };

  useEffect(()=>{
    let cancelled=false;
    const tick=async()=>{
      if(cancelled) return;
      const now=Date.now();
      if(now-lastSendRef.current<120){ setTimeout(tick,20); return; }
      lastSendRef.current=now;

      const {x,y}=joy;
      const mag=Math.hypot(x,y);
      const dir=vecToDir(x,y);

      // Evita flood: s√≥ manda quando muda ou mant√©m em passos curtos
      if(dir!==lastDirRef.current){
        if(dir==="STOP"){
          await sendUART("CMD:STOP");
        }else{
          const ms=140+Math.round(260*Math.min(1,mag));
          const spd=50+Math.round(50*Math.min(1,mag));
          await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
        }
        lastDirRef.current=dir;
      }else if(dir!=="STOP"){
        // Refor√ßa o movimento com pequenos pulsos
        const ms=120+Math.round(200*Math.min(1,mag));
        const spd=50+Math.round(50*Math.min(1,mag));
        await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
      }

      setTimeout(tick,120);
    };
    tick(); return()=>{cancelled=true};
  },[joy, ip]);

  function onVideoLayout(e:LayoutChangeEvent){
    const {width,height}=e.nativeEvent.layout; setVideoContainerWH({w:width,h:height});
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder={T.placeholderIp} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={styles.input} />
        <Text style={styles.label}>{T.server}</Text>
        <TextInput value={server} onChangeText={setServer} placeholder={T.placeholderServer} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={[styles.input,{minWidth:220}]} />

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn?styles.btnOn:styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn?T.pumpOn:T.pumpOff}</Text>
        </Pressable>
        <Pressable onPress={()=>led(true)} style={[styles.btn, {backgroundColor:"#2563eb"}]}>
          <Text style={styles.btnText}>{T.ledOn}</Text>
        </Pressable>
        <Pressable onPress={()=>led(false)} style={[styles.btn, {backgroundColor:"#374151"}]}>
          <Text style={styles.btnText}>{T.ledOff}</Text>
        </Pressable>
      </View>

      <View style={[styles.statusRow,{paddingTop:4,paddingBottom:8}]}>
        <Text numberOfLines={2} style={styles.status}>{statusText} {useDirectSnapshot ? "‚Ä¢ (snapshot direto)" : ""}</Text>
        <View style={[styles.badge,{backgroundColor: "#065f46"}]}>
          <Text style={{ color:"#fff", fontWeight:"800" }}>{isFire ? T.detecting : T.waiting}</Text>
        </View>
      </View>

      <View style={[styles.fireBanner, isFire?styles.fireOn:styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      <View style={{ flex:1 }} onLayout={onVideoLayout}>
        <CrossfadeImage currentUri={currentFrameUri} nextUri={nextFrameUri}
                        onNextLoadStart={()=> (loadingNextRef.current=true)}
                        onNextShown={onNextShown}/>
        {overlayBoxes.length>0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap,{width:64*2+24,height:64*2+24}]}
              {...(pan.panHandlers as any)}>
          <View style={[styles.joyBase,{width:64*2,height:64*2,borderRadius:64}]} />
          <View style={[styles.joyKnob,{width:22*2,height:22*2,borderRadius:22,
                        transform:[{translateX:joy.x*64},{translateY:-joy.y*64}], opacity: dragging?1:0.9}]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", flexWrap:"wrap",
           paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:120 },
  btn:{ backgroundColor:PALETTE.accent, paddingHorizontal:10, paddingVertical:10, borderRadius:10 },
  btnOn:{ backgroundColor:"#17a34a" }, btnOff:{ backgroundColor:"#374151" },
  btnText:{ color:"white", fontWeight:"600" },

  statusRow:{ flexDirection:"row", alignItems:"center", paddingHorizontal:12, paddingVertical:8, gap:8,
              backgroundColor:"#0f1322", borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  badge:{ paddingHorizontal:10, paddingVertical:6, borderRadius:8, borderWidth:1, borderColor:PALETTE.border },
  status:{ color:"#cbd5ff", flex:1, fontSize:12 },

  fireBanner:{ alignados:"center", justifyContent:"center", paddingVertical:6 },
  fireOn:{ backgroundColor:"#8b0000" }, fireOff:{ backgroundColor:"#223" },
  fireText:{ color:"white", fontWeight:"800" },

  joyWrap:{ position:"absolute", bottom:24, left:24, alignItems:"center", justifyContent:"center" },
  joyBase:{ position:"absolute", backgroundColor:"rgba(255,255,255,0.08)", borderWidth:2, borderColor:"rgba(255,255,255,0.14)" },
  joyKnob:{ position:"absolute", backgroundColor:"rgba(230,64,58,0.9)", borderWidth:2, borderColor:"rgba(255,255,255,0.85)" },
  joyText:{ position:"absolute", bottom:-22, color:"#cbd5ff", fontSize:12 },
});




O que foi adaptado (sem mudar sua base):




Server (FastAPI): permanece id√™ntico no fluxo (cache do snapshot + heur√≠stica), apenas mudei CAMERA_IP default para hydrobot.local. Nada mais.


App (CameraScreen):



UART: agora POST /uart?cmd=....


LED: bot√µes fazem POST /led?on=1|0.


Bomba: reusa o bot√£o para enviar CMD:PUMP:1|0 via UART.


Joystick: remove o antigo /joystick; envia pulsos CMD:FWD/BACK/LEFT/RIGHT/STOP por UART, como seu Arduino espera.


V√≠deo: mant√©m o snapshot do servidor com fallback para /frame.jpg e, se necess√°rio, snapshot direto do ESP.








Se quiser, posso incluir um bot√£o ‚ÄúReiniciar ESP‚Äù (POST /restart) no app em dois cliques.







































# server_heuristic.py
# FastAPI proxy + heur√≠stica de fogo (leve) para ESP32-CAM snapshot (robusto)
import time
import threading
from typing import Optional, Dict, Any, List, Tuple

import cv2
import numpy as np
import requests
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ========= CONFIG =========
CAMERA_IP = "192.168.3.3"                          # ESP32-CAM IP (roteador)
SNAPSHOT_URL_FMT = "http://{}/snapshot"
CONNECT_TIMEOUT = 4.0
READ_TIMEOUT = 15.0
POLL_FPS_TARGET = 8.0                              # ~8 fps est√°vel
MAX_FRAME_AGE_MS = 15000                           # relaxado p/ redes lentas
MAX_RESULT_AGE_MS = 800
JPEG_QUALITY = 85

# Heur√≠stica simples de fogo
HSV_LOW = (8, 80, 120)
HSV_HIGH = (40, 255, 255)
EMA_ALPHA = 0.25
HYST_HIGH = 0.18
HYST_LOW  = 0.15
MIN_BLOB_AREA = 900
KERNEL_SZ = 5

REQUEST_HEADERS = {
    "Connection": "keep-alive",
    "User-Agent": "HydroBot-Grabber/1.0",
    "Cache-Control": "no-cache",
    "Pragma": "no-cache",
}

ACCEPT_CT_PREFIX = ("image/jpeg", "image/jpg", "image/pjpeg", "application/octet-stream")

def is_jpeg_bytes(b: bytes) -> bool:
    return len(b) > 4 and b[0] == 0xFF and b[1] == 0xD8

# ========= FASTAPI =========
app = FastAPI(title="HydroBot Server (proxy + fire-heuristic)", version="2.2")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True,
                   allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
    camera_ip: str

# ========= PLACEHOLDER =========
def placeholder_jpeg(msg: str = "NO LIVE FRAME") -> bytes:
    img = np.zeros((240, 320, 3), dtype=np.uint8)
    img[:, :] = (40, 40, 200)
    cv2.putText(img, msg, (20, 130), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255,255,255), 2, cv2.LINE_AA)
    cv2.putText(img, time.strftime("%H:%M:%S"), (20, 200), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255,255,255), 2, cv2.LINE_AA)
    ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), 80])
    return buf.tobytes()

# ========= SNAPSHOT GRABBER =========
class SnapshotGrabber:
    def __init__(self):
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._ip = CAMERA_IP
        self._last_jpeg: Optional[bytes] = None
        self._last_ts_ms: int = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._session = requests.Session()
        self._last_err: Optional[str] = None

    def start(self, ip: Optional[str] = None):
        if ip:
            self._ip = ip
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)
        self._thread = None

    def _ok_ct(self, ct: str) -> bool:
        if not ct:
            return True  # √†s vezes vem vazio; vamos checar magic bytes
        ct = ct.lower()
        return any(ct.startswith(p) for p in ACCEPT_CT_PREFIX)

    def _fetch_once(self) -> Optional[bytes]:
        u = f"{SNAPSHOT_URL_FMT.format(self._ip)}?ts={int(time.time()*1000)}"
        r = self._session.get(u, timeout=(CONNECT_TIMEOUT, READ_TIMEOUT),
                              headers=REQUEST_HEADERS, stream=False)
        if r.status_code == 200:
            ct = r.headers.get("Content-Type", "")
            b = r.content or b""
            if (self._ok_ct(ct) and b) or is_jpeg_bytes(b):
                return b
        return None

    def _run(self):
        min_interval = 1.0 / POLL_FPS_TARGET
        backoff = 0.0
        while not self._stop.is_set():
            t0 = time.time()
            try:
                jpeg = self._fetch_once()
                if jpeg:
                    with self._lock:
                        self._last_jpeg = jpeg
                        self._last_ts_ms = int(time.time()*1000)
                        self._last_err = None
                    self._frames += 1
                    now = time.time()
                    if now - self._last_fps_tick >= 1.0:
                        self._fps = self._frames / (now - self._last_fps_tick)
                        self._frames = 0
                        self._last_fps_tick = now
                    backoff = 0.0
                else:
                    backoff = min(2.0, max(0.2, (backoff * 1.7) or 0.2))
            except Exception as e:
                with self._lock:
                    self._last_err = f"{type(e).__name__}: {e}"
                backoff = min(3.0, max(0.2, (backoff * 1.7) or 0.2))

            elapsed = time.time() - t0
            sleep = max(0.0, min_interval - elapsed) + backoff
            if self._stop.is_set():
                break
            time.sleep(sleep)

    def get_latest_jpeg(self, max_age_ms=MAX_FRAME_AGE_MS) -> Optional[bytes]:
        with self._lock:
            if self._last_jpeg is None:
                return None
            if int(time.time()*1000) - self._last_ts_ms > max_age_ms:
                return None
            return self._last_jpeg

    def status(self) -> Dict[str, Any]:
        with self._lock:
            age = int(time.time()*1000) - self._last_ts_ms if self._last_ts_ms else None
            return {"ip": self._ip, "hasFrame": self._last_jpeg is not None, "age_ms": age,
                    "fps_in": round(self._fps, 2), "last_err": self._last_err}

grabber = SnapshotGrabber()
grabber.start(CAMERA_IP)

# ========= HEUR√çSTICA FOGO (igual) =========
def hsv_fire_mask(frame_bgr: np.ndarray) -> np.ndarray:
    hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
    return cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))

def boxes_from_mask(mask_bin: np.ndarray, min_area: int = MIN_BLOB_AREA) -> List[List[int]]:
    k = np.ones((KERNEL_SZ, KERNEL_SZ), np.uint8)
    m = cv2.morphologyEx(mask_bin, cv2.MORPH_OPEN, k, 1)
    m = cv2.morphologyEx(m, cv2.MORPH_DILATE, k, 1)
    cnts, _ = cv2.findContours(m, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    out = []
    for c in cnts:
        x,y,w,h = cv2.boundingRect(c)
        if w*h >= min_area:
            out.append([int(x), int(y), int(w), int(h)])
    return out

class FireDetector:
    def __init__(self, src: SnapshotGrabber):
        self.src = src
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._ema = 0.0
        self._score_raw = 0.0
        self._is_fire = False
        self._boxes: List[List[int]] = []
        self._last_ts = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._frame_wh: Optional[Tuple[int,int]] = None

    def start(self):
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)
        self._thread = None

    def _run(self):
        min_interval = 1.0 / 8.0
        while not self._stop.is_set():
            t0 = time.time()
            jpeg = self.src.get_latest_jpeg()
            if jpeg is None:
                time.sleep(0.02); continue
            frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
            if frame is None:
                time.sleep(0.01); continue
            H, W = frame.shape[:2]
            self._frame_wh = (W, H)
            mask = hsv_fire_mask(frame)
            v_mean = float(np.mean(cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)[...,2])) / 255.0
            ratio = float(np.count_nonzero(mask))/float(mask.size)
            score_raw = min(1.0, ratio*4.0 + v_mean*0.1)
            ema = score_raw if self._ema==0.0 else EMA_ALPHA*score_raw + (1.0-EMA_ALPHA)*self._ema
            boxes = boxes_from_mask(mask)
            if   ema >= HYST_HIGH: is_fire = True
            elif ema <= HYST_LOW : is_fire = False
            else: is_fire = self._is_fire
            with self._lock:
                self._ema = ema
                self._score_raw = score_raw
                self._is_fire = is_fire
                self._boxes = boxes if is_fire else []
                self._last_ts = int(time.time()*1000)
                self._frames += 1
                now = time.time()
                if now - self._last_fps_tick >= 1.0:
                    self._fps = self._frames / (now - self._last_fps_tick)
                    self._frames = 0
                    self._last_fps_tick = now
            elapsed = time.time() - t0
            if elapsed < min_interval:
                time.sleep(min_interval - elapsed)

    def get(self) -> Dict[str, Any]:
        with self._lock:
            return {
                "ok": True,
                "isFire": bool(self._is_fire),
                "score": round(float(self._ema), 3),
                "score_raw": round(float(self._score_raw), 3),
                "score_ema": round(float(self._ema), 3),
                "boxes": list(self._boxes),
                "ts": int(self._last_ts),
                "fps_det": round(float(self._fps), 2),
                "frame_wh": list(self._frame_wh) if self._frame_wh else None
            }

det = FireDetector(grabber); det.start()

# ========= ENDPOINTS =========
@app.get("/healthz")
def healthz():
    s = grabber.status()
    return {"ok": True, "camera_ip": s.get("ip"), "fps_in": s.get("fps_in"),
            "hasFrame": s.get("hasFrame"), "age_ms": s.get("age_ms"), "last_err": s.get("last_err")}

@app.get("/status")
def status():
    s = grabber.status(); d = det.get()
    return {"ok": True, "camera_ip": s["ip"], **s, **d}

@app.post("/config")
def set_config(cfg: ConfigIn):
    global CAMERA_IP
    CAMERA_IP = cfg.camera_ip
    grabber.start(CAMERA_IP)
    return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
    # üîß M√çNIMO: n√£o chama o ESP aqui; s√≥ devolve o √∫ltimo frame do cache (grabber)
    b = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS) or placeholder_jpeg("NO LIVE FRAME")
    headers = {
        "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
        "Pragma": "no-cache",
        "Expires": "0",
        "Content-Type": "image/jpeg"
    }
    return Response(content=b, headers=headers, media_type="image/jpeg")

# üîß Alias simples com extens√£o (alguns devices/WebViews preferem):
@app.get("/frame.jpg")
def frame_jpg():
    b = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS) or placeholder_jpeg("NO LIVE FRAME")
    headers = {
        "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
        "Pragma": "no-cache",
        "Expires": "0",
        "Content-Type": "image/jpeg"
    }
    return Response(content=b, headers=headers, media_type="image/jpeg")

@app.get("/detect")
def detect():
    res = det.get()
    if res.get("ts", 0) and (int(time.time()*1000) - res["ts"] <= MAX_RESULT_AGE_MS):
        return res
    jpeg = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS)
    if jpeg is None:
        return {"ok": False, "error": "no recent frame"}
    frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
    if frame is None:
        return {"ok": False, "error": "decode failed"}
    H, W = frame.shape[:2]
    mask = hsv_fire_mask(frame)
    v_mean = float(np.mean(cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)[...,2])) / 255.0
    ratio = float(np.count_nonzero(mask))/float(mask.size)
    score = min(1.0, ratio*4.0 + v_mean*0.1)
    is_fire = bool(score >= HYST_HIGH)
    return {"ok": True, "isFire": is_fire, "score": round(score,3), "score_raw": round(score,3),
            "score_ema": round(score,3), "boxes": [], "ts": int(time.time()*1000), "frame_wh": [W,H], "fallback": True}








import { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet,
  PanResponder, GestureResponderEvent, PanResponderGestureState,
  Image, Animated, LayoutChangeEvent,
} from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: { heroSubtitle:"Monitoramento e Controle", espIp:"ESP IP:", pumpOn:"BOMBA ON", pumpOff:"BOMBA OFF",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Aguardando servidor‚Ä¶", statusFail:"Falha ao conectar. Confira o Wi-Fi/IP.",
        noVideo:"Sem v√≠deo (snapshot). Verifique o servidor.", fireOn:(s:number)=>`üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sem fogo ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sincronizado",
        placeholderIp:"192.168.3.3", placeholderServer:"http://192.168.3.4:8000" },
  en: { heroSubtitle:"Monitoring & Control", espIp:"ESP IP:", pumpOn:"PUMP ON", pumpOff:"PUMP OFF",
        server:"Server:", detecting:"Detecting‚Ä¶", waiting:"Waiting for server‚Ä¶", statusFail:"Failed to connect. Check Wi-Fi/IP.",
        noVideo:"No video (snapshot). Check the server.", fireOn:(s:number)=>`üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`No fire ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sync OK",
        placeholderIp:"192.168.3.3", placeholderServer:"http://192.168.3.4:8000" },
  es: { heroSubtitle:"Monitoreo y Control", espIp:"ESP IP:", pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Esperando servidor‚Ä¶", statusFail:"Error de conexi√≥n. Revisa Wi-Fi/IP.",
        noVideo:"Sin v√≠deo (snapshot). Revisa el servidor.", fireOn:(s:number)=>`üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sin fuego ‚Ä¢ score ${s.toFixed(2)}`, synced:"Sincronizado con servidor",
        placeholderIp:"192.168.3.3", placeholderServer:"http://192.168.3.4:8000" },
};

const DEFAULT_IP = "192.168.3.3";
const DEFAULT_SERVER = "http://192.168.3.4:8000";
const DEFAULT_FRAME_WH = { w: 320, h: 240 };

const appLogo = require("../../assets/logo.png");

function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown,
}: { currentUri: string; nextUri: string; onNextLoadStart: () => void; onNextShown: (ok: boolean) => void; }) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={() => { onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

type SrcBox = { x:number; y:number; w:number; h:number; type:"fire" };
function BoxesOverlay({ frameWH, containerWH, boxes }:{
  frameWH:{w:number;h:number}|null; containerWH:{w:number;h:number}|null; boxes:SrcBox[];
}) {
  const f = frameWH && frameWH.w>0 && frameWH.h>0 ? frameWH : DEFAULT_FRAME_WH;
  if (!containerWH || containerWH.w<=0 || containerWH.h<=0) return null;
  const scale = Math.min(containerWH.w / f.w, containerWH.h / f.h);
  const dispW = f.w * scale, dispH = f.h * scale;
  const offsetX = (containerWH.w - dispW)/2, offsetY = (containerWH.h - dispH)/2;
  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position:"absolute", left:offsetX, top:offsetY, width:dispW, height:dispH }}>
        {boxes.map((b,i)=>{
          const left=b.x*scale, top=b.y*scale, width=b.w*scale, height=b.h*scale;
          return (
            <View key={i} style={{ position:"absolute", left, top, width, height, borderWidth:3, borderColor:"#ff3b30", borderRadius:6 }}>
              <View style={{ position:"absolute", left:0, top:-18, paddingHorizontal:6, paddingVertical:2, borderRadius:4, backgroundColor:"#ff3b30" }}>
                <Text style={{ color:"#000", fontWeight:"800", fontSize:10 }}>FOGO</Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [statusText, setStatusText] = useState(T.waiting);
  const [pumpOn, setPumpOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{w:number;h:number}|null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{w:number;h:number}|null>(null);

  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  const [useDirectSnapshot, setUseDirectSnapshot] = useState(false);
  const failCountRef = useRef(0);

  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const clean = (s:string)=>s.replace(/\/+$/,"");

  // Server endpoints
  const healthUrl     = useMemo(()=>`${clean(server)}/healthz`,[server]);
  const detectUrl     = useMemo(()=>`${clean(server)}/detect`,[server]);
  const snapshotSrv   = useMemo(()=>`${clean(server)}/snapshot`,[server]);
  const snapshotSrvAlt= useMemo(()=>`${clean(server)}/frame.jpg`,[server]);
  const configUrl     = useMemo(()=>`${clean(server)}/config`,[server]);

  // ESP endpoints (controle e snapshot direto - fallback)
  const pumpUrl       = useMemo(()=> (on:boolean)=>`http://${ip}/pump?on=${on?"1":"0"}`,[ip]);
  const joystickUrl   = useMemo(()=> (x:number,y:number)=>`http://${ip}/joystick?x=${x.toFixed(2)}&y=${y.toFixed(2)}`,[ip]);
  const uartUrl       = useMemo(()=> (line:string)=>`http://${ip}/uart?line=${encodeURIComponent(line)}`,[ip]);
  const snapshotEsp   = useMemo(()=> `http://${ip}/snapshot`, [ip]);

  // Sincroniza IP da c√¢mera no server
  useEffect(()=>{
    let aborted=false;
    (async()=>{
      try{
        const r=await fetch(configUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({camera_ip:ip})});
        const j=await r.json();
        if(!aborted && j?.ok) setStatusText(`${T.synced} (${j.camera_ip})`);
      }catch{ if(!aborted) setStatusText(T.statusFail); }
    })();
    return()=>{aborted=true};
  },[ip, configUrl, T]);

  // Health do servidor
  useEffect(()=>{
    let stop=false, backoff=500;
    const poll=async()=>{
      if(stop) return;
      try{
        const r=await fetch(healthUrl); const j=await r.json();
        if(j?.ok){ setStatusText(`Server OK ‚Ä¢ fps_in:${j.fps_in} ‚Ä¢ hasFrame:${j.hasFrame}`); return; }
      }catch{}
      setStatusText(T.waiting);
      setTimeout(poll, backoff); backoff=Math.min(backoff*1.6, 5000);
    };
    poll(); return()=>{stop=true};
  },[healthUrl, T]);

  // SNAPSHOT loop com fallback server->ESP (m√≠nimo)
  useEffect(()=>{
    let stop=false, interval=160;
    const pickBase = ()=>{
      if (useDirectSnapshot) return snapshotEsp;
      // üîß m√≠nimo: se falhar 2x no /snapshot, tenta /frame.jpg
      return failCountRef.current >= 2 ? snapshotSrvAlt : snapshotSrv;
    };

    setCurrentFrameUri(`${pickBase()}?ts=${Date.now()}`);
    const tick=()=>{
      if(stop) return;
      try{
        if(!loadingNextRef.current){
          const base = pickBase();
          setNextFrameUri(`${base}?ts=${Date.now()}`);
        }
        interval=160;
      }catch{
        interval=Math.min(interval*1.7, 1200);
      }
      setTimeout(tick, interval);
    };
    tick();
    return()=>{stop=true};
  },[snapshotSrv, snapshotSrvAlt, snapshotEsp, useDirectSnapshot]);

  const onNextLoadStart = ()=>{ loadingNextRef.current=true; };
  const onNextShown = (ok:boolean)=>{
    if(ok){
      failCountRef.current = 0;
      if(useDirectSnapshot){ setUseDirectSnapshot(false); }   // volta p/ servidor quando estabiliza
      if(nextFrameUri) setCurrentFrameUri(nextFrameUri);
    }else{
      failCountRef.current += 1;
      // 2 falhas: tenta rota alternativa; 3 falhas: cai p/ ESP direto
      if(!useDirectSnapshot && failCountRef.current >= 3){
        setUseDirectSnapshot(true);
        failCountRef.current = 0;
      }
    }
    loadingNextRef.current=false;
  };

  // DETECT loop (inalterado)
  useEffect(()=>{
    let stop=false, interval=250;
    const loop=async()=>{
      if(stop) return;
      try{
        const r=await fetch(detectUrl); const j=await r.json();
        if(j && j.ok!==false){
          setIsFire(!!j.isFire); setFireScore(Number(j.score||0));
          const wh = Array.isArray(j.frame_wh)&&j.frame_wh.length===2
                     ? {w:Number(j.frame_wh[0])||0, h:Number(j.frame_wh[1])||0}:null;
          if(wh && wh.w>0 && wh.h>0) setFrameWH(wh);
          const boxes:SrcBox[]=[];
          if(j.isFire && Array.isArray(j.boxes)){
            for(const b of j.boxes){
              if(Array.isArray(b)&&b.length>=4){
                const [x,y,w,h]=b.map((n:any)=>Number(n)||0);
                boxes.push({x,y,w,h,type:"fire"});
              }
            }
          }
          setOverlayBoxes(boxes); interval=250;
        }
      }catch{
        setIsFire(false); setFireScore(0); setOverlayBoxes([]);
        interval=Math.min(interval*1.5,1500);
      }finally{ setTimeout(loop, interval); }
    };
    loop(); return()=>{stop=true};
  },[detectUrl]);

  // Joystick (inalterado)
  const RADIUS=64;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder:()=>true,
      onMoveShouldSetPanResponder:()=>true,
      onPanResponderGrant:()=>{ setDragging(true); },
      onPanResponderMove:(_e:GestureResponderEvent,g:PanResponderGestureState)=>{
        let nx=g.dx/RADIUS, ny=g.dy/RADIUS;
        const len=Math.hypot(nx,ny); if(len>1){ nx/=len; ny/=len; }
        setJoy({x:nx, y:-ny});
      },
      onPanResponderRelease:()=>{ setJoy({x:0,y:0}); setDragging(false); },
      onPanResponderTerminate:()=>{ setJoy({x:0,y:0}); setDragging(false); },
    })
  ).current;

  const lastSendRef = useRef(0);
  const lastDirRef  = useRef<string>("STOP");
  const trySendJoystick = async (x:number,y:number)=>{ try{ await fetch(joystickUrl(x,y)); return true; }catch{ return false; } };
  const sendDiscreteCmd  = async (line:string)=>{ try{ await fetch(uartUrl(line)); return true; }catch{ return false; } };
  const vecToDir=(x:number,y:number):"FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP"=>{
    const mag=Math.hypot(x,y); if(mag<0.2) return "STOP";
    const deg=(Math.atan2(y,x)*180)/Math.PI;
    if(deg>-45&&deg<=45) return "RIGHT";
    if(deg>45&&deg<=135) return "FWD";
    if(deg<=-45&&deg>-135) return "BACK";
    return "LEFT";
  };

  useEffect(()=>{
    let cancelled=false;
    const tick=async()=>{
      if(cancelled) return;
      const now=Date.now();
      if(now-lastSendRef.current<120){ setTimeout(tick,20); return; }
      lastSendRef.current=now;

      const {x,y}=joy; const mag=Math.hypot(x,y);
      const ok = await trySendJoystick(x,y);
      if(ok){
        if(mag<0.2 && lastDirRef.current!=="STOP"){ await sendDiscreteCmd("CMD:STOP"); lastDirRef.current="STOP"; }
        setTimeout(tick,120); return;
      }
      const dir=vecToDir(x,y);
      if(dir!==lastDirRef.current){
        const ms=140+Math.round(260*Math.min(1,mag));
        const spd=50+Math.round(50*Math.min(1,mag));
        await sendDiscreteCmd( dir==="STOP" ? "CMD:STOP" : `CMD:${dir}:ms=${ms}:spd=${spd}` );
        lastDirRef.current=dir;
      }else if(dir!=="STOP"){
        const ms=120+Math.round(200*Math.min(1,mag));
        const spd=50+Math.round(50*Math.min(1,mag));
        await sendDiscreteCmd(`CMD:${dir}:ms=${ms}:spd=${spd}`);
      }
      setTimeout(tick,120);
    };
    tick(); return()=>{cancelled=true};
  },[joy, ip]);

  // Bomba (inalterado)
  async function togglePump(){
    try{
      const t=!pumpOn; await fetch(pumpUrl(t)); setPumpOn(t);
    }catch{ setStatusText(T.statusFail); }
  }

  function onVideoLayout(e:LayoutChangeEvent){
    const {width,height}=e.nativeEvent.layout; setVideoContainerWH({w:width,h:height});
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />
      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder={T.placeholderIp} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={styles.input} keyboardType="numeric" />
        <Text style={styles.label}>{T.server}</Text>
        <TextInput value={server} onChangeText={(s)=>{ setServer(s); }}
                   placeholder={T.placeholderServer} placeholderTextColor="#8a93a5" autoCapitalize="none" autoCorrect={false}
                   style={[styles.input,{minWidth:220}]} />
        <Pressable onPress={togglePump} style={[styles.btn, pumpOn?styles.btnOn:styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn?T.pumpOn:T.pumpOff}</Text>
        </Pressable>
      </View>

      <View style={[styles.statusRow,{paddingTop:4,paddingBottom:8}]}>
        <Text numberOfLines={2} style={styles.status}>{statusText} {useDirectSnapshot ? "‚Ä¢ (snapshot direto)" : ""}</Text>
        <View style={[styles.badge,{backgroundColor: "#065f46"}]}>
          <Text style={{ color:"#fff", fontWeight:"800" }}>{isFire ? T.detecting : T.waiting}</Text>
        </View>
      </View>

      <View style={[styles.fireBanner, isFire?styles.fireOn:styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      <View style={{ flex:1 }} onLayout={onVideoLayout}>
        <CrossfadeImage currentUri={currentFrameUri} nextUri={nextFrameUri}
                        onNextLoadStart={()=> (loadingNextRef.current=true)}
                        onNextShown={onNextShown}/>
        {overlayBoxes.length>0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Joystick (inalterado) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap,{width:64*2+24,height:64*2+24}]}
              {...pan.panHandlers}>
          <View style={[styles.joyBase,{width:64*2,height:64*2,borderRadius:64}]} />
          <View style={[styles.joyKnob,{width:22*2,height:22*2,borderRadius:22,
                        transform:[{translateX:joy.x*64},{translateY:-joy.y*64}], opacity: dragging?1:0.9}]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:120 },
  btn:{ backgroundColor:PALETTE.accent, paddingHorizontal:10, paddingVertical:10, borderRadius:10 },
  btnOn:{ backgroundColor:"#17a34a" }, btnOff:{ backgroundColor:"#374151" },
  btnText:{ color:"white", fontWeight:"600" },

  statusRow:{ flexDirection:"row", alignItems:"center", paddingHorizontal:12, paddingVertical:8, gap:8,
              backgroundColor:"#0f1322", borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  badge:{ paddingHorizontal:10, paddingVertical:6, borderRadius:8, borderWidth:1, borderColor:PALETTE.border },
  status:{ color:"#cbd5ff", flex:1, fontSize:12 },

  fireBanner:{ alignItems:"center", justifyContent:"center", paddingVertical:6 },
  fireOn:{ backgroundColor:"#8b0000" }, fireOff:{ backgroundColor:"#223" },
  fireText:{ color:"white", fontWeight:"800" },

  joyWrap:{ position:"absolute", bottom:24, left:24, alignItems:"center", justifyContent:"center" },
  joyBase:{ position:"absolute", backgroundColor:"rgba(255,255,255,0.08)", borderWidth:2, borderColor:"rgba(255,255,255,0.14)" },
  joyKnob:{ position:"absolute", backgroundColor:"rgba(230,64,58,0.9)", borderWidth:2, borderColor:"rgba(255,255,255,0.85)" },
  joyText:{ position:"absolute", bottom:-22, color:"#cbd5ff", fontSize:12 },
});
