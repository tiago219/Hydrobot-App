#include <Servo.h>

// ===== DEFINIÇÕES DE PINOS =====
// Motores do carrinho (ponte H)
#define IN1 8
#define IN2 9
#define IN3 10
#define IN4 11

// Servo motor para direcionamento da mangueira
#define SERVO_PIN 12
Servo servoMangueira;

// Sensores de fogo KY-026 (analógicos)
#define SENSOR_FOGO_ESQ A2 // Sensor esquerdo
#define SENSOR_FOGO_MEIO A1  // Sensor meio  
#define SENSOR_FOGO_DIR A0   // Sensor direito

// Bomba de água
#define BOMBA_PIN 13

// Sensor de nível de água FD-10
#define NIVEL_AGUA_PIN A3

// LED RGB (3 pinos - PWM para controle de intensidade)
#define LED_R 3  // Pino Red (PWM)
#define LED_G 5  // Pino Green (PWM) - não usado mas mantido  
#define LED_B 6  // Pino Blue (PWM)
// GND vai para o GND do Arduino

// ===== VARIÁVEIS GLOBAIS =====
int velocidade = 60; // 60% da velocidade máxima
int posicaoServo = 100; // Posição central do servo (0-180°)
bool bombaLigada = false;
int nivelAgua = 0; // Porcentagem de água (0-100%)

// Limiares para detecção de fogo (CORRIGIDO: valores menores indicam fogo)
#define LIMIAR_FOGO 300  // Valores ABAIXO deste indicam fogo
#define SEM_FOGO 800     // Valores ACIMA deste indicam ausência de fogo

// Posições do servo para cada direção
#define SERVO_ESQUERDA 45   // 45° para esquerda
#define SERVO_CENTRO 100    // 100° para centro
#define SERVO_DIREITA 135   // 135° para direita

void setup() {
  Serial.begin(9600);
  Serial.println("=== CARRINHO DE BOMBEIRO INICIANDO ===");
  
  // ===== CONFIGURAÇÃO DOS PINOS =====
  // Motores do carrinho
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  parar();
  
  // Bomba de água
  pinMode(BOMBA_PIN, OUTPUT);
  digitalWrite(BOMBA_PIN, LOW);
  
  // LED RGB (todos os pinos, mas verde sempre em 0)
  pinMode(LED_R, OUTPUT);
  pinMode(LED_G, OUTPUT);
  pinMode(LED_B, OUTPUT);
  
  // Servo motor - RESET PARA CENTRO
  servoMangueira.attach(SERVO_PIN);
  Serial.println("Resetando servo para posição central...");
  servoMangueira.write(SERVO_CENTRO);
  posicaoServo = SERVO_CENTRO;
  delay(2000); // Aguarda 2 segundos para posicionamento
  Serial.println("Servo posicionado! Pronto para encaixar a mangueira.");
  
  Serial.println("Sistema pronto!");
  delay(1000);
}

void loop() {
  // ===== LEITURA DOS SENSORES =====
  lerNivelAgua();
  atualizarLEDAgua();
  
  // ===== DETECÇÃO E COMBATE AO FOGO =====
  detectarECombaterFogo();
  
  delay(100); // Pequeno delay para estabilidade
}

// ===== FUNÇÕES DO LED RGB PARA NÍVEL DE ÁGUA =====
void lerNivelAgua() {
  int leituraAnalogica = analogRead(NIVEL_AGUA_PIN);
  // Converte para porcentagem (0-1023 -> 0-100%)
  nivelAgua = map(leituraAnalogica, 0, 1023, 0, 100);
  nivelAgua = constrain(nivelAgua, 0, 100);
}

void atualizarLEDAgua() {
  if (nivelAgua >= 80) {
    // Água alta - LED AZUL brilhante
    setLedCor(0, 0, 255);
  }
  else if (nivelAgua >= 60) {
    // Água média-alta - LED AZUL médio
    setLedCor(0, 0, 180);
  }
  else if (nivelAgua >= 40) {
    // Água média - LED ROXO (vermelho + azul)
    setLedCor(150, 0, 150);
  }
  else if (nivelAgua >= 20) {
    // Água baixa - LED VERMELHO médio piscando
    static unsigned long ultimoPisca = 0;
    static bool estadoPisca = false;
    
    if (millis() - ultimoPisca > 500) {
      estadoPisca = !estadoPisca;
      if (estadoPisca) {
        setLedCor(180, 0, 0); // Vermelho médio
      } else {
        setLedCor(0, 0, 0); // Apagado
      }
      ultimoPisca = millis();
    }
  }
  else {
    // Água muito baixa - LED VERMELHO intenso piscando rápido
    static unsigned long ultimoPiscaRapido = 0;
    static bool estadoPiscaRapido = false;
    
    if (millis() - ultimoPiscaRapido > 200) {
      estadoPiscaRapido = !estadoPiscaRapido;
      if (estadoPiscaRapido) {
        setLedCor(255, 0, 0); // Vermelho intenso
      } else {
        setLedCor(0, 0, 0); // Apagado
      }
      ultimoPiscaRapido = millis();
    }
  }
}

// Função para controlar LED RGB com PWM (verde sempre em 0)
void setLedCor(int r, int g, int b) {
  analogWrite(LED_R, r);
  analogWrite(LED_G, g);  // Verde sempre recebe 0
  analogWrite(LED_B, b);
}

// ===== FUNÇÕES DE DETECÇÃO E COMBATE AO FOGO =====
void detectarECombaterFogo() {
  int sensorEsq = analogRead(SENSOR_FOGO_ESQ);
  int sensorMeio = analogRead(SENSOR_FOGO_MEIO);
  int sensorDir = analogRead(SENSOR_FOGO_DIR);
  
  Serial.print("Sensores - Esq: ");
  Serial.print(sensorEsq);
  Serial.print(", Meio: ");
  Serial.print(sensorMeio);
  Serial.print(", Dir: ");
  Serial.print(sensorDir);
  Serial.print(", Água: ");
  Serial.print(nivelAgua);
  Serial.println("%");
  
  bool fogoDetectado = false;
  int novaPos = posicaoServo;
  
  // Verifica se há água suficiente
  if (nivelAgua < 10) {
    Serial.println("AVISO: Nível de água muito baixo!");
    desligarBomba();
    return;
  }
  
  // ===== LÓGICA DE DETECÇÃO CORRIGIDA =====
  // MENOR valor = MAIS fogo detectado
  // Verifica se algum sensor detectou fogo (valor baixo)
  if (sensorEsq < LIMIAR_FOGO || sensorMeio < LIMIAR_FOGO || sensorDir < LIMIAR_FOGO) {
    fogoDetectado = true;
    
    // Encontra o sensor com MENOR valor (mais fogo)
    int menorValor = min(min(sensorEsq, sensorMeio), sensorDir);
    
    if (sensorMeio == menorValor) {
      // Fogo no MEIO (sensor do meio tem menor valor)
      Serial.println("FOGO DETECTADO NO MEIO!");
      novaPos = SERVO_CENTRO;
    }
    else if (sensorEsq == menorValor) {
      // Fogo na ESQUERDA (sensor esquerdo tem menor valor)
      Serial.println("FOGO DETECTADO NA ESQUERDA!");
      novaPos = SERVO_DIREITA;  // CORRIGIDO: servo vai para DIREITA quando sensor ESQ detecta
    }
    else if (sensorDir == menorValor) {
      // Fogo na DIREITA (sensor direito tem menor valor)  
      Serial.println("FOGO DETECTADO NA DIREITA!");
      novaPos = SERVO_ESQUERDA; // CORRIGIDO: servo vai para ESQUERDA quando sensor DIR detecta
    }
    
    // Move servo para posição e liga bomba
    moverServo(novaPos);
    ligarBomba();
    
    // Combate o fogo por área (varredura)
    combaterFogoPorArea(novaPos);
  }
  else {
    // Nenhum fogo detectado (todos os sensores com valores altos)
    if (bombaLigada) {
      Serial.println("Fogo controlado! Desligando bomba...");
      desligarBomba();
      // Retorna servo para centro
      moverServo(SERVO_CENTRO);
    }
  }
}

void combaterFogoPorArea(int posicaoAlvo) {
  Serial.println("Iniciando combate ao fogo com varredura...");
  
  int inicio, fim;
  
  // Define área de varredura baseada na posição alvo
  switch (posicaoAlvo) {
    case SERVO_ESQUERDA:
      inicio = 30;  // 30° a 60°
      fim = 60;
      break;
    case SERVO_DIREITA:
      inicio = 120; // 120° a 150°  
      fim = 150;
      break;
    case SERVO_CENTRO:
    default:
      inicio = 75;  // 75° a 120°
      fim = 120;
      break;
  }
  
  // Varredura na área do fogo
  for (int i = 0; i < 3; i++) { // 3 passadas
    // Ida
    for (int pos = inicio; pos <= fim; pos += 5) {
      servoMangueira.write(pos);
      delay(200);
      
      // Verifica se ainda há fogo durante a varredura
      if (!verificarFogoNaPosicao(posicaoAlvo)) {
        Serial.println("Fogo extinto durante varredura!");
        return;
      }
    }
    
    // Volta
    for (int pos = fim; pos >= inicio; pos -= 5) {
      servoMangueira.write(pos);
      delay(200);
      
      if (!verificarFogoNaPosicao(posicaoAlvo)) {
        Serial.println("Fogo extinto durante varredura!");
        return;
      }
    }
  }
}

bool verificarFogoNaPosicao(int posicaoAlvo) {
  int sensor;
  
  switch (posicaoAlvo) {
    case SERVO_ESQUERDA:
      sensor = analogRead(SENSOR_FOGO_DIR);  // CORRIGIDO: posição ESQ lê sensor DIR
      break;
    case SERVO_DIREITA:
      sensor = analogRead(SENSOR_FOGO_ESQ);  // CORRIGIDO: posição DIR lê sensor ESQ
      break;
    case SERVO_CENTRO:
    default:
      sensor = analogRead(SENSOR_FOGO_MEIO);
      break;
  }
  
  // CORRIGIDO: retorna true se ainda há fogo (valor baixo)
  return (sensor < LIMIAR_FOGO);
}

// ===== FUNÇÕES DO SERVO E BOMBA =====
void moverServo(int novaPosicao) {
  if (novaPosicao != posicaoServo) {
    Serial.print("Movendo servo de ");
    Serial.print(posicaoServo);
    Serial.print("° para ");
    Serial.print(novaPosicao);
    Serial.println("°");
    
    // Move gradualmente para posição suave
    int passo = (novaPosicao > posicaoServo) ? 2 : -2;
    
    while (abs(posicaoServo - novaPosicao) > 2) {
      posicaoServo += passo;
      servoMangueira.write(posicaoServo);
      delay(15);
    }
    
    posicaoServo = novaPosicao;
    servoMangueira.write(posicaoServo);
  }
}

void ligarBomba() {
  if (!bombaLigada && nivelAgua > 10) {
    Serial.println("LIGANDO BOMBA DE ÁGUA!");
    digitalWrite(BOMBA_PIN, HIGH);
    bombaLigada = true;
  }
}

void desligarBomba() {
  if (bombaLigada) {
    Serial.println("Desligando bomba de água.");
    digitalWrite(BOMBA_PIN, LOW);
    bombaLigada = false;
  }
}

// ===== FUNÇÕES DE MOVIMENTO DO CARRINHO =====
void pwmSoftware(void (*movimento)(), int vel, int duracao) {
  unsigned long inicio = millis();
  int ciclo = 10;
  int tempoLigado = (ciclo * vel) / 100;
  int tempoDesligado = ciclo - tempoLigado;
  
  while (millis() - inicio < duracao) {
    movimento();
    delay(tempoLigado);
    
    if (vel < 100 && tempoDesligado > 0) {
      parar();
      delay(tempoDesligado);
    }
  }
}

void frenteBasico() {
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
}

void trasBasico() {
  digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);
}

void direitaBasico() {
  digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);   // Motor esquerdo para trás
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);   // Motor direito para frente
}

void esquerdaBasico() {
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);   // Motor esquerdo para frente
  digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);   // Motor direito para trás
}

void parar() {
  digitalWrite(IN1, LOW); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW); digitalWrite(IN4, LOW);
}

void frente(int duracao) {
  pwmSoftware(frenteBasico, velocidade, duracao);
}

void tras(int duracao) {
  pwmSoftware(trasBasico, velocidade, duracao);
}

void direita(int duracao) {
  pwmSoftware(direitaBasico, velocidade, duracao);
}

void esquerda(int duracao) {
  pwmSoftware(esquerdaBasico, velocidade, duracao);
}
