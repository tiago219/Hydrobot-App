https://chatgpt.com/share/68b78dcd-48bc-800d-b32a-aecc510baa8b

https://chatgpt.com/share/68b78dcd-48bc-800d-b32a-aecc510baa8b

Perfeito ‚Äî vamos migrar o seu projeto para Bluetooth (SPP/Serial), tirar WebView/navegador do app, mover o LED para um pino seguro que n√£o conflita com a roda, e preparar a rota com TensorFlow fora da ESP32-CAM (no Node.js). J√° deixo tudo funcionando sem TF e com toggles no app para:




Fonte do v√≠deo: direto da ESP por Bluetooth (sem TF) ou via servidor (com TF habilit√°vel).


Troca de modo: manual / auto / patrol (via Bluetooth).


Joystick: envia vetores x/y.


Bomba (MOSFET): bot√£o ON/OFF.


LED indicador: realocado para pino seguro.




perfeito! abaixo est√° o CameraScreen.tsx completo j√° com a l√≥gica de registrar evento sempre que o fogo for detectado (borda de subida), salvando hor√°rio exato e screenshot via server/snapshot.

Inclu√≠ um cooldown de 5s pra evitar spam enquanto o fogo permanece cont√≠nuo.




Requisitos (se ainda n√£o instalou):




expo install expo-file-system


npm i @react-native-async-storage/async-storage && npx pod-install (no iOS)


crie tamb√©m o arquivo src/storage/fireLog.ts (segue no final)







src/screens/CameraScreen.tsx (com persist√™ncia de eventos)


import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
} from "react-native";
import { saveEventFromServer } from "../storage/fireLog";

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#ffffff" };

// ajuste estes padr√µes se quiser
const DEFAULT_IP = "192.168.4.1";                // ESP32-CAM (AP)
const DEFAULT_SERVER = "http://192.168.4.2:8000"; // Servidor IA (PC no mesmo AP)

export default function CameraScreen() {
  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");
  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // detec√ß√£o
  const [detectOn, setDetectOn] = useState<boolean>(false);
  const [isFire, setIsFire] = useState<boolean>(false);
  const [fireScore, setFireScore] = useState<number>(0);

  // controle de registro (evitar spam)
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef<number>(0);
  const wasFireRef = useRef<boolean>(false);
  const SAVE_COOLDOWN_MS = 5000; // 5s entre registros

  // ‚Äúv√≠deo‚Äù por snapshots do servidor
  const [frameUri, setFrameUri] = useState<string>("");

  // joystick (UI)
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // URLs do ESP
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  // consulta /status do ESP
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl, { method: "GET" });
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }

  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText("Erro ao alternar LED.");
    }
  }

  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText("Erro ao alternar bomba.");
    }
  }

  // ping peri√≥dico de status do ESP
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // ===== V√≠deo por snapshots do servidor =====
  useEffect(() => {
    let stop = false;
    const tick = () => {
      if (stop) return;
      // cache-buster (?ts=) para evitar cache da Image
      setFrameUri(`${server.replace(/\/+$/, "")}/snapshot?ts=${Date.now()}`);
      setTimeout(tick, 250); // ~4 fps; ajuste conforme sua m√°quina/rede
    };
    tick();
    return () => {
      stop = true;
    };
  }, [server]);

  // polling de /detect do servidor de IA
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;
    const loop = async () => {
      try {
        const r = await fetch(`${server.replace(/\/+$/, "")}/detect`, { method: "GET" });
        const j = await r.json();
        if (!stop && j && j.ok) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
        }
      } finally {
        if (!stop) setTimeout(loop, 500); // ~2 Hz
      }
    };
    loop();
    return () => {
      stop = true;
    };
  }, [detectOn, server]);

  // ===== Registro autom√°tico de evento (quando fogo detectado) =====
  useEffect(() => {
    // borda de subida: false -> true
    const risingEdge = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;

    if (detectOn && risingEdge && cooldownOk && !saving) {
      (async () => {
        try {
          setSaving(true);
          await saveEventFromServer(server);
          lastSaveRef.current = Date.now();
          // feedback no status
          const ts = new Date(lastSaveRef.current).toLocaleString();
          setStatusText(`Evento salvo em ${ts}`);
        } catch {
          setStatusText("Falha ao salvar evento (snapshot). Verifique o servidor.");
        } finally {
          setSaving(false);
        }
      })();
    }

    wasFireRef.current = isFire;
  }, [detectOn, isFire, server, saving]);

  // joystick (UI)
  const RADIUS = 64;
  const KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS;
        let ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny }); // y positivo para cima
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const knobLeft = joy.x * RADIUS;
  const knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="192.168.4.1"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor IA + Detectar */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>Servidor:</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder="http://192.168.4.2:8000"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? (saving ? "Salvando..." : "Detectando") : "Detectar"}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>
            {isFire ? `üî• FOGO ‚Ä¢ score ${fireScore.toFixed(2)}` : `Sem fogo ‚Ä¢ score ${fireScore.toFixed(2)}`}
          </Text>
        </View>
      )}

      {/* ‚ÄúV√≠deo‚Äù via snapshots do servidor */}
      <Image
        source={{ uri: frameUri }}
        style={styles.video}
        resizeMode="contain"
        onError={() => {
          setStatusText("Sem v√≠deo (snapshot). Verifique o servidor /snapshot.");
        }}
      />

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: knobLeft }, { translateY: knobTop }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: PALETTE.bg,
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
    minWidth: 110,
  },
  btn: {
    backgroundColor: "#2b48ff",
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  // v√≠deo por snapshots
  video: { flex: 1, backgroundColor: "black", width: "100%" },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(43,72,255,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});




src/storage/fireLog.ts (mesmo do passo anterior)


import * as FileSystem from "expo-file-system";
import AsyncStorage from "@react-native-async-storage/async-storage";

export type FireEvent = {
  id: string;       // ex: 2025-09-08T12-34-56.789Z
  ts: number;       // epoch ms
  iso: string;      // ISO string
  imageUri: string; // file://.../fire_events/<id>.jpg
};

const EVENTS_KEY = "fire_events_index_v1";
const DIR = FileSystem.documentDirectory + "fire_events/";

async function ensureDir() {
  const info = await FileSystem.getInfoAsync(DIR);
  if (!info.exists) {
    await FileSystem.makeDirectoryAsync(DIR, { intermediates: true });
  }
}

export async function getEvents(): Promise<FireEvent[]> {
  const raw = await AsyncStorage.getItem(EVENTS_KEY);
  const arr: FireEvent[] = raw ? JSON.parse(raw) : [];
  return arr.sort((a, b) => b.ts - a.ts);
}

async function saveIndex(list: FireEvent[]) {
  await AsyncStorage.setItem(EVENTS_KEY, JSON.stringify(list));
}

export async function deleteEvent(id: string) {
  const list = await getEvents();
  const idx = list.findIndex((e) => e.id === id);
  if (idx >= 0) {
    const ev = list[idx];
    try {
      const info = await FileSystem.getInfoAsync(ev.imageUri);
      if (info.exists) await FileSystem.deleteAsync(ev.imageUri, { idempotent: true });
    } catch {}
    list.splice(idx, 1);
    await saveIndex(list);
  }
}

export async function clearAllEvents() {
  try {
    const info = await FileSystem.getInfoAsync(DIR);
    if (info.exists) await FileSystem.deleteAsync(DIR, { idempotent: true });
  } catch {}
  await AsyncStorage.removeItem(EVENTS_KEY);
  await ensureDir();
}

/** Baixa um snapshot e registra o evento localmente. */
export async function saveEventFromServer(serverBase: string): Promise<FireEvent> {
  await ensureDir();
  const now = new Date();
  const iso = now.toISOString();
  const id = iso.replace(/[:]/g, "-");
  const ts = now.getTime();

  const target = `${DIR}${id}.jpg`;
  const url = `${serverBase.replace(/\/+$/, "")}/snapshot?ts=${ts}`;

  await FileSystem.downloadAsync(url, target);

  const ev: FireEvent = { id, ts, iso, imageUri: target };
  const list = await getEvents();
  list.push(ev);
  await saveIndex(list);
  return ev;
}




Como validar




Inicie o servidor (/detect e /snapshot).


No app, Detectar ligado.


Quando o banner mostrar üî• FOGO, o app salva o snapshot e o hor√°rio (1 registro a cada ‚â•5s).


Abra a tela Dashboard (se voc√™ j√° criou) para ver a lista; se ainda n√£o, posso te enviar a tela pronta.





‚ö†Ô∏è Observa√ß√µes importantes




Bluetooth cl√°ssico (SPP) funciona no Android. No iOS o SPP n√£o √© suportado; se precisar iOS, usamos Wi-Fi ou BLE (sem v√≠deo fluido).


Expo Go n√£o tem Bluetooth cl√°ssico. Use Expo Dev Build (ou bare) com react-native-bluetooth-serial-next. Abaixo deixo o passo-a-passo.







A) Firmware ESP32-CAM (Bluetooth + v√≠deo em Base64 + comandos)


O que muda




Sem Wi-Fi/HTTP ‚Äî tudo por Bluetooth Serial.


V√≠deo MJPEG capturado, encodado em base64 e enviado como NDJSON (JSON por linha). FPS baixo (1‚Äì2) para caber no throughput do SPP.


Comandos simples por texto (linhas): CMD:MODE:auto, CMD:STREAM:1, CMD:JOY:x,y, CMD:PUMP:1, CMD:LED:1, CMD:TF:1.


LED indicador movido para GPIO 33 (sa√≠da OK). PUMP no GPIO 32. (Ambos n√£o conflitam com c√¢mera; fio um LED externo no 33 com resistor).




Crie o arquivo HydroBotBT.ino:


/**
 * HydroBotBT.ino ‚Äî ESP32-CAM (AI Thinker) via Bluetooth SPP
 * - Captura frames JPEG e envia via Bluetooth como NDJSON (1 linha por evento)
 * - Sem Wi-Fi/HTTP. Tudo por SerialBT.
 * - Comandos por linha (texto): CMD:...
 * - LED indicador em GPIO 33 (n√£o conflita com roda/motores)
 * - MOSFET da bomba em GPIO 32
 * - Sem sensor IR por enquanto
 *
 * OBS: FPS baixo (1‚Äì2) por limita√ß√£o de banda do SPP
 */

#include "esp_camera.h"
#include <BluetoothSerial.h>
#include <time.h>
#include "mbedtls/base64.h"

// ===== Pins (AI Thinker) =====
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ===== Seus atuadores sem conflito =====
#define LED_IND_PIN  33   // LED indicador externo
#define PUMP_PIN     32   // MOSFET da bomba

BluetoothSerial SerialBT;

// ===== Estado =====
String g_mode = "manual";
bool   g_streamOn = true;     // envia frames
bool   g_ledOn    = false;    // LED indicador
bool   g_pumpOn   = false;    // bomba
bool   g_tfOn     = false;    // s√≥ espelha no status (TF roda fora)
float  g_joyX     = 0.0f;
float  g_joyY     = 0.0f;

uint32_t lastFrameMs = 0;
uint32_t frameIntervalMs = 700; // ~1.4 fps (ajuste ao seu gosto)
char lineBuf[256];

// ===== Util =====
void writeJsonLine(const String& s) {
  SerialBT.write((const uint8_t*)s.c_str(), s.length());
  SerialBT.write('\n');
}

String isoTsUptime() {
  // sem NTP ‚Üí uptime
  char buf[64];
  snprintf(buf, sizeof(buf), "{\"uptime_ms\":%lu}", millis());
  return String(buf);
}

// ===== Camera =====
bool initCamera() {
  camera_config_t c;
  c.ledc_channel = LEDC_CHANNEL_0;
  c.ledc_timer   = LEDC_TIMER_0;
  c.pin_d0       = Y2_GPIO_NUM;
  c.pin_d1       = Y3_GPIO_NUM;
  c.pin_d2       = Y4_GPIO_NUM;
  c.pin_d3       = Y5_GPIO_NUM;
  c.pin_d4       = Y6_GPIO_NUM;
  c.pin_d5       = Y7_GPIO_NUM;
  c.pin_d6       = Y8_GPIO_NUM;
  c.pin_d7       = Y9_GPIO_NUM;
  c.pin_xclk     = XCLK_GPIO_NUM;
  c.pin_pclk     = PCLK_GPIO_NUM;
  c.pin_vsync    = VSYNC_GPIO_NUM;
  c.pin_href     = HREF_GPIO_NUM;
  c.pin_sscb_sda = SIOD_GPIO_NUM;
  c.pin_sscb_scl = SIOC_GPIO_NUM;
  c.pin_pwdn     = PWDN_GPIO_NUM;
  c.pin_reset    = RESET_GPIO_NUM;
  c.xclk_freq_hz = 20000000;
  c.pixel_format = PIXFORMAT_JPEG;

  if (psramFound()) {
    c.frame_size   = FRAMESIZE_QVGA; // 320x240 para reduzir base64
    c.jpeg_quality = 22;             // + n√∫mero = + compacta√ß√£o
    c.fb_count     = 2;
    c.fb_location  = CAMERA_FB_IN_PSRAM;
    c.grab_mode    = CAMERA_GRAB_WHEN_EMPTY;
  } else {
    c.frame_size   = FRAMESIZE_QQVGA; // 160x120 fallback
    c.jpeg_quality = 25;
    c.fb_count     = 1;
    c.fb_location  = CAMERA_FB_IN_DRAM;
  }

  esp_err_t err = esp_camera_init(&c);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed: 0x%x\n", err);
    return false;
  }

  sensor_t * s = esp_camera_sensor_get();
  if (s) {
    s->set_exposure_ctrl(s, 1);
    s->set_gain_ctrl(s, 1);
    s->set_brightness(s, 0);
    s->set_contrast(s, 0);
    s->set_saturation(s, 0);
    s->set_vflip(s, 0);
    s->set_hmirror(s, 0);
    s->set_dcw(s, 1);
  }
  return true;
}

// ===== Envio de frame como NDJSON base64 =====
void sendFrameBase64() {
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) return;

  // Base64 tamanho ~ 4/3 do JPEG
  size_t outLen = 4 * ((fb->len + 2) / 3) + 4;
  uint8_t* b64 = (uint8_t*)malloc(outLen);
  if (!b64) {
    esp_camera_fb_return(fb);
    return;
  }

  size_t olen = 0;
  int rc = mbedtls_base64_encode(b64, outLen, &olen, fb->buf, fb->len);
  esp_camera_fb_return(fb);
  if (rc != 0) { free(b64); return; }

  // Monta JSON por partes para n√£o estourar buffer interno do BT
  writeJsonLine(String("{\"evt\":\"frame\",\"fmt\":\"jpeg\",\"b64\":\"BEGIN\"}"));
  // envia o base64 em blocos
  const size_t CHUNK = 1000;
  for (size_t i = 0; i < olen; i += CHUNK) {
    size_t n = (i + CHUNK <= olen) ? CHUNK : (olen - i);
    SerialBT.write((const uint8_t*)"{\"chunk\":\"", 10);
    SerialBT.write((const uint8_t*)(b64 + i), n);
    SerialBT.write((const uint8_t*)"\"}\n", 3);
  }
  writeJsonLine(String("{\"evt\":\"frame\",\"b64\":\"END\"}"));
  free(b64);
}

// ===== Parser de comandos "CMD:..." por linha =====
void handleCmd(const String& line) {
  // Formatos aceitos:
  // CMD:MODE:auto
  // CMD:STREAM:1
  // CMD:JOY:x,y
  // CMD:PUMP:1
  // CMD:LED:1
  // CMD:TF:1
  if (!line.startsWith("CMD:")) return;
  int p1 = line.indexOf(':', 4);
  if (p1 < 0) return;
  String key = line.substring(4, p1);
  String val = line.substring(p1 + 1);
  val.trim();

  if (key == "MODE") {
    if (val == "manual" || val == "auto" || val == "patrol") {
      g_mode = val;
      writeJsonLine(String("{\"evt\":\"mode\",\"v\":\"") + g_mode + "\"}");
    }
  } else if (key == "STREAM") {
    g_streamOn = (val == "1" || val == "true");
    writeJsonLine(String("{\"evt\":\"stream\",\"on\":") + (g_streamOn?"true":"false") + "}");
  } else if (key == "LED") {
    g_ledOn = (val == "1" || val == "true");
    digitalWrite(LED_IND_PIN, g_ledOn ? HIGH : LOW);
    writeJsonLine(String("{\"evt\":\"led\",\"on\":") + (g_ledOn?"true":"false") + "}");
  } else if (key == "PUMP") {
    g_pumpOn = (val == "1" || val == "true");
    digitalWrite(PUMP_PIN, g_pumpOn ? HIGH : LOW);
    writeJsonLine(String("{\"evt\":\"pump\",\"on\":") + (g_pumpOn?"true":"false") + "}");
  } else if (key == "TF") {
    g_tfOn = (val == "1" || val == "true");
    writeJsonLine(String("{\"evt\":\"tf\",\"on\":") + (g_tfOn?"true":"false") + "}");
  } else if (key == "JOY") {
    int c = val.indexOf(',');
    if (c > 0) {
      g_joyX = val.substring(0, c).toFloat();
      g_joyY = val.substring(c + 1).toFloat();
      // eco simples
      char buf[96];
      snprintf(buf, sizeof(buf), "{\"evt\":\"joy\",\"x\":%.3f,\"y\":%.3f}", g_joyX, g_joyY);
      writeJsonLine(String(buf));
    }
  }
}

// ===== Setup/Loop =====
void setup() {
  Serial.begin(115200);
  pinMode(LED_IND_PIN, OUTPUT);
  pinMode(PUMP_PIN, OUTPUT);
  digitalWrite(LED_IND_PIN, LOW);
  digitalWrite(PUMP_PIN, LOW);

  if (!initCamera()) {
    Serial.println("Falha camera");
    delay(3000);
    ESP.restart();
  }

  // Bluetooth
  if (!SerialBT.begin("HYDROBOT")) {
    Serial.println("BT falhou");
    while (1) delay(1000);
  }
  Serial.println("BT pronto: HYDROBOT");

  // Status inicial
  writeJsonLine(String("{\"evt\":\"status\",\"ts\":") + isoTsUptime() +
                ",\"mode\":\"" + g_mode + "\",\"stream\":" + (g_streamOn?"true":"false") + "}");
}

void loop() {
  // Leitura de comandos por linha
  static String acc;
  while (SerialBT.available()) {
    char ch = (char)SerialBT.read();
    if (ch == '\n' || ch == '\r') {
      if (acc.length() > 0) { handleCmd(acc); acc = ""; }
    } else {
      if (acc.length() < 200) acc += ch; // evita linhas absurdas
    }
  }

  // Envio peri√≥dico de frame
  uint32_t now = millis();
  if (g_streamOn && now - lastFrameMs >= frameIntervalMs && SerialBT.hasClient()) {
    lastFrameMs = now;
    sendFrameBase64();
  }

  // Status ping a cada ~3s
  static uint32_t lastPing = 0;
  if (now - lastPing > 3000) {
    lastPing = now;
    writeJsonLine(String("{\"evt\":\"status\",\"ts\":") + isoTsUptime() +
      ",\"mode\":\"" + g_mode + "\",\"led\":" + (g_ledOn?"true":"false") +
      ",\"pump\":" + (g_pumpOn?"true":"false") + ",\"tf\":" + (g_tfOn?"true":"false") + "}");
  }
}





Fia√ß√£o:




LED indicador: GPIO33 ‚Üí resistor 220Œ© ‚Üí LED ‚Üí GND.


Bomba (MOSFET): GPIO32 ‚Üí gate (MOSFET logic-level) + resist√™ncia 100k pull-down gate-GND; n√£o alimente bomba pelo 3V3 da placa.







B) App React Native (Expo Dev Build, TS) ‚Äî Bluetooth + v√≠deo + controles


1) Projeto e depend√™ncias


npx create-expo-app hydrobot-bt -t expo-template-blank-typescript
cd hydrobot-bt

# Bluetooth Cl√°ssico:
yarn add react-native-bluetooth-serial-next
# se usar npm: npm i react-native-bluetooth-serial-next

# Pr√©-build (cria projeto nativo)
npx expo prebuild

# Android: habilite BLUETOOTH perms automaticamente pelo pacote.
# Gere Dev Build:
eas build:configure
eas build --profile development --platform android
# Instale o .apk de dev no aparelho e abra o app com ele (n√£o Expo Go).





Se preferir bare, rode npx react-native run-android.




2) Servi√ßo de Bluetooth ‚Äî src/services/bluetooth.ts


// src/services/bluetooth.ts
import BluetoothSerial from 'react-native-bluetooth-serial-next';
import { NativeEventEmitter } from 'react-native';

type Listener = (msg: any) => void;

let connectedId: string | null = null;
let lineBuffer = '';

const listeners = new Set<Listener>();

export async function ensureEnabled() {
  const ok = await BluetoothSerial.isEnabled();
  if (!ok) await BluetoothSerial.requestEnable();
}

export async function listDevices() {
  const bonded = await BluetoothSerial.list();
  return bonded; // [{id,name,address},...]
}

export async function connectByName(name: string) {
  const devs = await listDevices();
  const dev = devs.find(d => (d.name || '').includes(name));
  if (!dev) throw new Error(`Dispositivo '${name}' n√£o pareado`);
  await BluetoothSerial.connect(dev.id);
  connectedId = dev.id;
  // ler dados cont√≠nuos
  BluetoothSerial.withDelimiter('\n'); // separa por \n
  BluetoothSerial.on('read', ({ data }) => {
    // cada 'data' √© uma linha (string)
    try {
      const obj = JSON.parse(data);
      for (const cb of listeners) cb(obj);
    } catch {
      // pode chegar chunks do frame ({"chunk":"..."}), ainda √© JSON
      try {
        const o2 = JSON.parse(data);
        for (const cb of listeners) cb(o2);
      } catch {}
    }
  });
}

export function onMsg(cb: Listener) { listeners.add(cb); return () => listeners.delete(cb); }

async function send(line: string) {
  if (!connectedId) throw new Error('BT n√£o conectado');
  await BluetoothSerial.write(line + '\n');
}

// === Comandos ===
export async function setMode(v: 'manual'|'auto'|'patrol') {
  await send(`CMD:MODE:${v}`);
}
export async function setStream(on: boolean) {
  await send(`CMD:STREAM:${on ? 1 : 0}`);
}
export async function setLED(on: boolean) {
  await send(`CMD:LED:${on ? 1 : 0}`);
}
export async function setPump(on: boolean) {
  await send(`CMD:PUMP:${on ? 1 : 0}`);
}
export async function setTF(on: boolean) {
  await send(`CMD:TF:${on ? 1 : 0}`);
}
export async function sendJoy(x: number, y: number) {
  const nx = Math.max(-1, Math.min(1, x));
  const ny = Math.max(-1, Math.min(1, y));
  await send(`CMD:JOY:${nx.toFixed(3)},${ny.toFixed(3)}`);
}



3) Componente de Joystick ‚Äî src/components/Joystick.tsx


// src/components/Joystick.tsx
import React, { useMemo, useState } from 'react';
import { View, PanResponder } from 'react-native';

export default function Joystick({ onMove }:{ onMove:(x:number,y:number)=>void }) {
  const size = 160, knob = 64;
  const r = size/2, rk = knob/2;
  const [p,setP] = useState({x:0,y:0});
  const pan = useMemo(()=>PanResponder.create({
    onStartShouldSetPanResponder:()=>true,
    onPanResponderMove:(_,g)=>{
      const lim = r - rk;
      let x = g.dx, y = g.dy;
      const mag = Math.hypot(x,y);
      if (mag > lim) { const k = lim/mag; x*=k; y*=k; }
      setP({x,y});
      onMove(x/lim, -y/lim);
    },
    onPanResponderRelease:()=>{
      setP({x:0,y:0});
      onMove(0,0);
    }
  }),[]);
  return (
    <View {...pan.panHandlers} style={{
      width:size,height:size,borderRadius:r,backgroundColor:'#101827',
      borderWidth:1,borderColor:'#223',justifyContent:'center',alignItems:'center'
    }}>
      <View style={{
        position:'absolute',width:knob,height:knob,borderRadius:rk,backgroundColor:'#4f7cff',
        transform:[{translateX:p.x},{translateY:p.y}]
      }}/>
    </View>
  );
}



4) Montagem da tela ‚Äî App.tsx


// App.tsx
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { SafeAreaView, View, Text, TouchableOpacity, TextInput, Image, ScrollView, Alert } from 'react-native';
import Joystick from './src/components/Joystick';
import { ensureEnabled, connectByName, onMsg, setMode, setLED, setPump, setStream, setTF, sendJoy } from './src/services/bluetooth';

type FrameState = { collecting:boolean, chunks:string[], last:string };

export default function App() {
  const [btName,setBtName] = useState('HYDROBOT');
  const [status,setStatus] = useState<any>({});
  const [imgB64,setImgB64] = useState<string>('');
  const [useServer,setUseServer] = useState(false); // fonte do v√≠deo: false=ESP direto; true=servidor
  const [tfOn,setTfOn] = useState(false);

  useEffect(()=>{ (async()=>{
    try {
      await ensureEnabled();
      await connectByName(btName);
      const off = onMsg((msg)=>{
        // Protocolo:
        // {evt:"frame", b64:"BEGIN"} / {chunk:"..."} / {evt:"frame", b64:"END"}
        // {evt:"status"...} etc.
        if (msg.evt === 'status' || msg.evt === 'mode' || msg.evt === 'led' || msg.evt === 'pump' || msg.evt === 'tf') {
          setStatus((s:any)=>({ ...s, ...msg }));
        } else if (msg.evt === 'frame' && msg.b64 === 'BEGIN') {
          frame.current = { collecting:true, chunks:[], last:'' };
        } else if (msg.evt === 'frame' && msg.b64 === 'END') {
          const b64 = frame.current.chunks.join('');
          setImgB64(b64);
          frame.current = { collecting:false, chunks:[], last:'' };
        } else if (typeof msg.chunk === 'string') {
          if (frame.current.collecting) frame.current.chunks.push(msg.chunk);
        }
      });
      return ()=>off();
    } catch (e:any) {
      Alert.alert('BT', e.message || String(e));
    }
  })(); }, []);

  const frame = useRef<FrameState>({ collecting:false, chunks:[], last:'' });

  async function toggleLED(){ await setLED(!(status.led)); }
  async function togglePump(){ await setPump(!(status.pump)); }
  async function toggleStream(){ await setStream(!(status.stream)); }
  async function switchMode(m:'manual'|'auto'|'patrol'){ await setMode(m); }
  async function toggleTF(){
    const next = !tfOn; setTfOn(next);
    await setTF(next);
    // Quando usar servidor, o TF real roda l√°; no app apenas espelhamos estado.
  }

  const videoView = useMemo(()=>{
    if (useServer) {
      return (
        <View style={{height:220, borderRadius:10, backgroundColor:'#000', alignItems:'center', justifyContent:'center'}}>
          <Text style={{color:'#fff', opacity:0.7}}>V√≠deo via Servidor (TF)</Text>
          {/* Em pr√≥xima etapa, conectamos ao WS ws://servidor:4000 para receber frames processados */}
        </View>
      );
    }
    return (
      <View style={{height:220, borderRadius:10, backgroundColor:'#000', overflow:'hidden', alignItems:'center', justifyContent:'center'}}>
        {imgB64 ? (
          <Image source={{ uri: 'data:image/jpeg;base64,' + imgB64 }} style={{ width:'100%', height:'100%', resizeMode:'contain' }}/>
        ) : (
          <Text style={{color:'#fff', opacity:0.7}}>Sem frame ainda‚Ä¶</Text>
        )}
      </View>
    );
  },[useServer, imgB64]);

  return (
    <SafeAreaView style={{flex:1, backgroundColor:'#0b1220'}}>
      <ScrollView contentContainerStyle={{padding:16, gap:12}}>
        <Text style={{color:'#fff', fontSize:20, fontWeight:'700'}}>HydroBot ‚Äî Bluetooth</Text>

        <View style={{flexDirection:'row', gap:8}}>
          <TextInput value={btName} onChangeText={setBtName}
            placeholder="Nome BT (pareado) ‚Äî HYDROBOT" placeholderTextColor="#789"
            style={{flex:1, backgroundColor:'#111a2e', color:'#fff', padding:10, borderRadius:8}} />
        </View>

        {videoView}

        <View style={{flexDirection:'row', gap:8, flexWrap:'wrap'}}>
          <TouchableOpacity onPress={toggleLED} style={{backgroundColor:'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>LED {status.led ? 'ON' : 'OFF'}</Text></TouchableOpacity>
          <TouchableOpacity onPress={togglePump} style={{backgroundColor:'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>Bomba {status.pump ? 'ON' : 'OFF'}</Text></TouchableOpacity>
          <TouchableOpacity onPress={()=>switchMode('manual')} style={{backgroundColor: (status.mode==='manual')?'#3a6df0':'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>Manual</Text></TouchableOpacity>
          <TouchableOpacity onPress={()=>switchMode('auto')} style={{backgroundColor: (status.mode==='auto')?'#3a6df0':'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>Auto</Text></TouchableOpacity>
          <TouchableOpacity onPress={()=>switchMode('patrol')} style={{backgroundColor: (status.mode==='patrol')?'#3a6df0':'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>Patrol</Text></TouchableOpacity>
          <TouchableOpacity onPress={toggleStream} style={{backgroundColor:'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>Stream {status.stream ? 'ON':'OFF'}</Text></TouchableOpacity>
          <TouchableOpacity onPress={toggleTF} style={{backgroundColor: tfOn ? '#22c55e' : '#2e374f', padding:10, borderRadius:8}}>
            <Text style={{color:'#fff'}}>TensorFlow {tfOn ? 'ON' : 'OFF'}</Text>
          </TouchableOpacity>
          <TouchableOpacity onPress={()=>setUseServer(!useServer)} style={{backgroundColor: useServer ? '#22c55e' : '#2e374f', padding:10, borderRadius:8}}>
            <Text style={{color:'#fff'}}>Fonte: {useServer ? 'Servidor (TF)' : 'ESP direto'}</Text>
          </TouchableOpacity>
        </View>

        <View style={{alignItems:'center', marginTop:6}}>
          <Joystick onMove={(x,y)=>{ sendJoy(x,y).catch(()=>{}); }} />
          <Text style={{color:'#8cb', marginTop:6}}>Arraste para enviar JOY (x,y)</Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}





O app acima envia/recebe tudo por Bluetooth e mostra v√≠deo direto da ESP (sem navegador).

Quando voc√™ alternar para ‚ÄúServidor (TF)‚Äù, o painel de v√≠deo j√° troca (na pr√≥xima se√ß√£o ligamos o servidor com TF + WebSocket).





C) Servidor intermedi√°rio (Node.js) ‚Äî Bluetooth ‚Üî TF ‚Üî App (WebSocket)


Objetivo: rodar TensorFlow fora da ESP e automatizar ‚Äúdetectar fogo ‚áí aciona bomba + ir at√© o fogo‚Äù.


Aqui deixo um servidor funcional que:




Conecta ao Bluetooth SPP da ESP (nome HYDROBOT).


Recebe NDJSON (frames em base64).


(Stub TF) Faz detec√ß√£o simplificada (lugar do TF real) e envia evento por WebSocket.


Repassa comandos de autonomia para a ESP (ex.: liga bomba quando ‚Äúfogo‚Äù detectado).




server/
  package.json
  index.js



server/package.json


{
  "name": "hydrobot-server",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "bluetooth-serial-port": "^2.2.8",
    "ws": "^8.18.0",
    "jimp": "^0.22.12"
  }
}



server/index.js


import { BluetoothSerialPort } from 'bluetooth-serial-port';
import { WebSocketServer } from 'ws';
import Jimp from 'jimp';

const DEV_NAME = process.env.ESP_NAME || 'HYDROBOT';

const bt = new BluetoothSerialPort();
let btChannelOpen = false;

const wss = new WebSocketServer({ port: 4000 });
const clients = new Set();

wss.on('connection', ws => {
  clients.add(ws);
  ws.on('close', ()=>clients.delete(ws));
});

function broadcast(obj) {
  const s = JSON.stringify(obj);
  for (const ws of clients) {
    try { ws.send(s); } catch {}
  }
}

function findAndConnect() {
  bt.inquire();
  bt.on('found', function(address, name) {
    if (!name) return;
    if (name.includes(DEV_NAME)) {
      bt.findSerialPortChannel(address, channel => {
        bt.connect(address, channel, () => {
          console.log('BT conectado a', name, address, 'ch', channel);
          btChannelOpen = true;

          // peca stream
          writeLine('CMD:STREAM:1');

          let acc = '';
          bt.on('data', (buf) => {
            acc += buf.toString('utf8');
            let i;
            while ((i = acc.indexOf('\n')) >= 0) {
              const line = acc.slice(0, i).trim();
              acc = acc.slice(i + 1);
              if (!line) continue;
              handleLine(line);
            }
          });

        }, () => console.log('Falha BT connect'));
      }, () => console.log('Sem canal SPP'));
    }
  });
}

function writeLine(s) {
  if (!btChannelOpen) return;
  bt.write(Buffer.from(s + '\n', 'utf8'), (err) => {
    if (err) console.log('BT write err', err);
  });
}

// Coleta de frame (BEGIN/chunks/END) vinda da ESP
const frameCollector = { collecting:false, parts:[] };

async function handleLine(line) {
  try {
    const obj = JSON.parse(line);
    if (obj.evt === 'frame' && obj.b64 === 'BEGIN') {
      frameCollector.collecting = true;
      frameCollector.parts = [];
    } else if (obj.evt === 'frame' && obj.b64 === 'END') {
      const b64 = frameCollector.parts.join('');
      frameCollector.collecting = false;
      frameCollector.parts = [];
      broadcast({ evt:'frame', b64 });

      // === STUB de detec√ß√£o (substitua por TF real) ===
      try {
        const img = await Jimp.read(Buffer.from(b64, 'base64'));
        // regra boba: pixel "vermelho forte" acima de limiar
        let redCount = 0, tot = img.bitmap.width * img.bitmap.height;
        img.scan(0,0,img.bitmap.width,img.bitmap.height,function(x,y,idx){
          const r=this.bitmap.data[idx], g=this.bitmap.data[idx+1], b=this.bitmap.data[idx+2];
          if (r > 200 && g < 120 && b < 120) redCount++;
        });
        const ratio = redCount / tot;
        const fire = ratio > 0.08; // limiar experimental
        broadcast({ evt:'detect', fire, ratio });

        if (fire) {
          writeLine('CMD:PUMP:1');        // liga bomba
          writeLine('CMD:MODE:auto');     // sinaliza modo auto (voc√™ pode usar para acionar locomo√ß√£o)
          // Pr√≥ximo passo: calcular dire√ß√£o do ‚Äúcentro vermelho‚Äù e mandar JOY para perseguir.
        }
      } catch (e) {}
    } else if (typeof obj.chunk === 'string') {
      if (frameCollector.collecting) frameCollector.parts.push(obj.chunk);
    } else {
      broadcast(obj); // status/mode/led/pump/tf/joy‚Ä¶
    }
  } catch {}
}

findAndConnect();
console.log('WS em ws://localhost:4000  (broadcast frames/detections)')





Pr√≥xima etapa para TF real: trocar o bloco Jimp pelo @tensorflow/tfjs-node + modelo de ‚Äúfire detection‚Äù (classifica√ß√£o em recortes ou detec√ß√£o com YOLO-lite). A estrutura acima j√° envia {evt:'detect', fire, ratio} para o app e comanda a ESP (bomba + modo) ao detectar.





D) App ‚Äî recebendo do servidor (quando ‚ÄúServidor (TF)‚Äù estiver ativo)


No App.tsx, quando useServer === true, voc√™ pode abrir um WebSocket e substituir imgB64/eventos pelos do servidor:


// adicione no App.tsx
useEffect(()=>{
  if (!useServer) return;
  const ws = new WebSocket('ws://<IP_DO_NOTEBOOK>:4000');
  ws.onmessage = (e)=>{
    try{
      const msg = JSON.parse(e.data);
      if (msg.evt === 'frame' && msg.b64) setImgB64(msg.b64);
      if (msg.evt === 'detect') {
        // pode mostrar um badge ‚Äúüî•‚Äù
      }
    }catch{}
  };
  return ()=>{ try{ws.close();}catch{} }
}, [useServer]);





Assim voc√™ alterna: ESP direto (Bluetooth) ou Servidor (TF) por um bot√£o ‚Äî como voc√™ pediu.





E) Passo a passo (resumo execut√°vel)






Grave a ESP32-CAM com HydroBotBT.ino.




LED indicador ‚Üí GPIO33 (externo).


MOSFET bomba ‚Üí GPIO32.


Pareie a ESP no Android (nome HYDROBOT).








App (Expo Dev Build)




Instale depend√™ncias, expo prebuild, gere Dev Build e instale o .apk.


Abra o app, BT ligado, nome HYDROBOT, aguarde status ‚Üí v√≠deo surgir√° (1‚Äì2 fps).








Servidor (opcional p/ TF)




cd server && npm i && node index.js


No app, ative ‚ÄúServidor (TF)‚Äù para receber frames do WS.


(Hoje est√° com detec√ß√£o stub via ‚Äúvermelho‚Äù e comanda PUMP + MODE:auto automaticamente.)









F) Pr√≥ximos incrementos (quando voc√™ quiser)




Auto-drive real: no servidor, calcule o centro do fogo (momento vermelho) e envie CMD:JOY:x,y para perseguir ‚Äî j√° est√° tudo encadeado.


TF real: trocar o stub por modelo TFJS/Node (ex.: MobileNet+SVM ou YOLO-tiny).


Seguran√ßa el√©trica: diodo flyback na bomba, fonte 5V/2A, GND comum.


iOS: usar Wi-Fi ou BLE GATT (com streaming reduzido) ‚Äî podemos te dar uma varia√ß√£o.





Se quiser, eu j√° acoplo a l√≥gica de persegui√ß√£o (c√°lculo de vetor JOY a partir do centro detectado) e deixo curva exponencial/limiar para o joystick, al√©m de debounce da bomba (s√≥ ligar por 2‚Äì3s e pausar).




















perfeito ‚Äî seu firmware exp√µe GET /pump?on=1|0. Vou adicionar um bot√£o Bomba ON/OFF na mesma barra da c√¢mera, espelhando o estado que vem de /status.


Substitua src/screens/CameraScreen.tsx pelo c√≥digo abaixo (mudan√ßas: estado pumpOn, url pumpUrl, leitura em pingStatus(), bot√£o togglePump()):


import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  ActivityIndicator,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
} from "react-native";
import { WebView } from "react-native-webview";

const DEFAULT_IP = "192.168.4.1"; // IP padr√£o do AP do ESP32-CAM

export default function CameraScreen() {
  const [ip, setIp] = useState(DEFAULT_IP);
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");

  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // Joystick state (UI por enquanto)
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const webref = useRef<WebView>(null);

  const streamUrl = useMemo(() => `http://${ip}:81/stream`, [ip]);
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl   = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl  = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl, { method: "GET" });
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }

  async function toggleLed() {
    try {
      const target = !ledOn;
      await fetch(ledUrl(target));
      setLedOn(target);
      setStatusText((s) => `LED ${target ? "ligado" : "desligado"} ‚Ä¢ ` + s.replace(/^LED .* ‚Ä¢ /, ""));
    } catch {
      setStatusText("Erro ao alternar LED.");
    }
  }

  async function togglePump() {
    try {
      const target = !pumpOn;
      await fetch(pumpUrl(target));
      setPumpOn(target);
      setStatusText((s) => `Bomba ${target ? "ligada" : "desligada"} ‚Ä¢ ` + s.replace(/^Bomba .* ‚Ä¢ /, ""));
    } catch {
      setStatusText("Erro ao alternar bomba.");
    }
  }

  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // HTML simples p/ MJPEG
  const html = `
    <html>
      <head><meta name="viewport" content="width=device-width, initial-scale=1" /></head>
      <body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;height:100vh;">
        <img src="${streamUrl}" style="width:100%;height:100%;object-fit:contain;" />
      </body>
    </html>
  `;

  // ===== Joystick (UI) =====
  const RADIUS = 64;
  const KNOB_R = 22;

  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS;
        let ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) { nx /= len; ny /= len; }
        setJoy({ x: nx, y: -ny }); // y para cima positivo
      },
      onPanResponderRelease: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
      onPanResponderTerminate: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
    })
  ).current;

  const knobLeft = joy.x * RADIUS;
  const knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Barra de controle */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="192.168.4.1"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text>
        </Pressable>
      </View>

      {/* Status */}
      <View style={styles.statusRow}>
        {isChecking ? <ActivityIndicator /> : null}
        <Text numberOfLines={2} style={styles.status}>{statusText}</Text>
        <Pressable onPress={() => webref.current?.reload()} style={[styles.btn, { marginLeft: 8 }]}>
          <Text style={styles.btnText}>Recarregar</Text>
        </Pressable>
      </View>

      {/* V√≠deo MJPEG */}
      <WebView
        ref={webref}
        originWhitelist={["*"]}
        source={{ html }}
        style={styles.web}
        allowFileAccess
        allowingReadAccessToURL={"*"}
        javaScriptEnabled
        domStorageEnabled
        allowUniversalAccessFromFileURLs
        allowsInlineMediaPlayback
        mediaPlaybackRequiresUserAction={false}
      />

      {/* Joystick overlay (UI apenas) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View
          style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]}
          {...pan.panHandlers}
        >
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: knobLeft }, { translateY: knobTop }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#0b1220" },
  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: "#111a33",
  },
  label: { color: "#9fb3ff", fontSize: 12 },
  input: {
    flex: 1,
    backgroundColor: "#0b1220",
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
  },
  btn: {
    backgroundColor: "#2b48ff",
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },
  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },
  web: { flex: 1, backgroundColor: "black" },

  // Joystick
  joyWrap: {
    position: "absolute",
    bottom: 24,
    left: 24,
    alignItems: "center",
    justifyContent: "center",
  },
  joyBase: {
    position: "absolute",
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.14)",
  },
  joyKnob: {
    position: "absolute",
    backgroundColor: "rgba(43,72,255,0.9)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.85)",
  },
  joyText: {
    position: "absolute",
    bottom: -22,
    color: "#cbd5ff",
    fontSize: 12,
  },
});



Pronto ‚Äî o bot√£o BOMBA ON/OFF usa a rota /pump do seu ESP e mant√©m o estado sincronizado quando o /status √© consultado.

Se quiser, no pr√≥ximo passo adiciono um controle PWM (slider para /pump_pwm?duty=0..255).

















perfeito ‚Äî vamos deixar o index/Home bonito e adicionar um rodap√© com abas (Home, C√¢mera, Dashboard, Settings).

A navega√ß√£o passa a usar Bottom Tabs do @react-navigation.



1) App.tsx (tabs + tema escuro)


Substitua o arquivo inteiro:


import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";
import DashboardScreen from "./src/screens/DashboardScreen";
import SettingsScreen from "./src/screens/SettingsScreen";

export type TabParamList = {
  Home: undefined;
  Camera: undefined;
  Dashboard: undefined;
  Settings: undefined;
};

const Tab = createBottomTabNavigator<TabParamList>();

// Tema dark do app
const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: "#0b1220",
    primary: "#2b48ff",
    card: "#111a33",
    text: "#e5e7ff",
    border: "#1e2a4d",
    notification: "#2b48ff",
  },
};

export default function App() {
  return (
    <NavigationContainer theme={DarkThemeHB}>
      <Tab.Navigator
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: "#111a33" },
          headerTintColor: "#fff",
          tabBarStyle: { backgroundColor: "#0f1730", borderTopColor: "#0f1730" },
          tabBarActiveTintColor: "#2b48ff",
          tabBarInactiveTintColor: "#8aa0ff",
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} options={{ title: "In√≠cio" }} />
        <Tab.Screen name="Camera" component={CameraScreen} options={{ title: "C√¢mera" }} />
        <Tab.Screen name="Dashboard" component={DashboardScreen} options={{ title: "Dashboard" }} />
        <Tab.Screen name="Settings" component={SettingsScreen} options={{ title: "Ajustes" }} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}




2) src/screens/HomeScreen.tsx (hero + CTA)


Substitua o arquivo para um layout ‚Äúhero card‚Äù com seu logo e bot√£o para abrir a C√¢mera (troca para a aba Camera):


import { View, Text, StyleSheet, Image, Pressable } from "react-native";
import { useNavigation } from "@react-navigation/native";
import type { TabParamList } from "../../App";
import type { BottomTabNavigationProp } from "@react-navigation/bottom-tabs";

type Nav = BottomTabNavigationProp<TabParamList>;

export default function HomeScreen() {
  const navigation = useNavigation<Nav>();

  return (
    <View style={styles.container}>
      <View style={styles.card}>
        <Image
          source={require("../../assets/logo.png")} // salve sua imagem como assets/logo.png
          style={styles.logo}
          resizeMode="contain"
        />
        <Text style={styles.title}>HydroBotApp2</Text>
        <Text style={styles.subtitle}>Controle o rob√¥ ‚Ä¢ V√≠deo ‚Ä¢ Bomba ‚Ä¢ LED</Text>

        <Pressable
          onPress={() => navigation.navigate("Camera")}
          style={({ pressed }) => [styles.cta, pressed && { opacity: 0.9 }]}
        >
          <Text style={styles.ctaText}>Abrir C√¢mera</Text>
        </Pressable>

        <View style={styles.linksRow}>
          <View style={styles.pill}><Text style={styles.pillText}>Dashboard</Text></View>
          <View style={styles.pill}><Text style={styles.pillText}>Ajustes</Text></View>
        </View>
      </View>

      <Text style={styles.footerHint}>Use as abas no rodap√© para navegar</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#0b1220", alignItems: "center", justifyContent: "center", padding: 20 },
  card: {
    width: "100%",
    backgroundColor: "#111a33",
    borderRadius: 20,
    padding: 20,
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#1e2a4d",
  },
  logo: { width: 140, height: 140, marginBottom: 12 },
  title: { color: "white", fontSize: 24, fontWeight: "800" },
  subtitle: { color: "#9fb3ff", fontSize: 14, marginTop: 4, textAlign: "center" },
  cta: {
    marginTop: 16,
    backgroundColor: "#2b48ff",
    borderRadius: 12,
    paddingVertical: 12,
    paddingHorizontal: 22,
    shadowColor: "#2b48ff",
    shadowOpacity: 0.25,
    shadowRadius: 8,
    elevation: 4,
  },
  ctaText: { color: "white", fontWeight: "700", fontSize: 16 },
  linksRow: { flexDirection: "row", gap: 8, marginTop: 16 },
  pill: { backgroundColor: "#0b1220", borderColor: "#1e2a4d", borderWidth: 1, paddingVertical: 6, paddingHorizontal: 10, borderRadius: 999 },
  pillText: { color: "#cbd5ff", fontSize: 12 },
  footerHint: { color: "#8aa0ff", marginTop: 14, fontSize: 12 },
});





Coloque a imagem que voc√™ enviou como assets/logo.png (PNG com fundo transparente fica top).





3) Novas telas ‚Äúplaceholder‚Äù


src/screens/DashboardScreen.tsx


import { View, Text, StyleSheet } from "react-native";

export default function DashboardScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Dashboard</Text>
      <Text style={styles.sub}>Aqui vir√£o telemetria, gr√°ficos e logs.</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#0b1220", alignItems: "center", justifyContent: "center" },
  title: { color: "white", fontSize: 22, fontWeight: "700" },
  sub: { color: "#9fb3ff", marginTop: 6 },
});



src/screens/SettingsScreen.tsx


import { View, Text, StyleSheet } from "react-native";

export default function SettingsScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Ajustes</Text>
      <Text style={styles.sub}>Prefer√™ncias do app e conex√µes.</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#0b1220", alignItems: "center", justifyContent: "center" },
  title: { color: "white", fontSize: 22, fontWeight: "700" },
  sub: { color: "#9fb3ff", marginTop: 6 },
});





Sua CameraScreen.tsx permanece como fizemos (com LED, Bomba e Joystick UI). Ela j√° aparece como aba ‚ÄúC√¢mera‚Äù.





4) √çcones


@expo/vector-icons j√° vem com Expo; n√£o precisa instalar nada extra.



Pronto! Voc√™ ter√°:




Home com hero + bot√£o ‚ÄúAbrir C√¢mera‚Äù


Rodap√© com abas: Home, C√¢mera, Dashboard, Settings


Tema dark consistente com seu logo HB üî•üíß




Se quiser, eu adiciono um badge na aba C√¢mera quando a conex√£o com o ESP32 falhar/sucesso, ou coloco labels grandes no tab bar.


























perfeito üëå vamos deixar a tela inicial (Home) como um menu em grade com bot√µes quadrados grandes, cada um levando para a aba correspondente. Os √≠cones v√£o usar Ionicons (j√° vem com Expo).



src/screens/HomeScreen.tsx (nova vers√£o)


import { View, Text, StyleSheet, Pressable, Dimensions } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { TabParamList } from "../../App";
import type { BottomTabNavigationProp } from "@react-navigation/bottom-tabs";

type Nav = BottomTabNavigationProp<TabParamList>;

const size = Dimensions.get("window").width / 2 - 32; // 2 colunas com espa√ßamento

export default function HomeScreen() {
  const navigation = useNavigation<Nav>();

  const items = [
    { name: "Camera" as keyof TabParamList, label: "C√¢mera", icon: "videocam" as const, color: "#2b48ff" },
    { name: "Dashboard" as keyof TabParamList, label: "Dashboard", icon: "pulse" as const, color: "#17a34a" },
    { name: "Settings" as keyof TabParamList, label: "Ajustes", icon: "settings" as const, color: "#eab308" },
  ];

  return (
    <View style={styles.container}>
      <Text style={styles.title}>HydroBotApp2</Text>
      <View style={styles.grid}>
        {items.map((item) => (
          <Pressable
            key={item.name}
            onPress={() => navigation.navigate(item.name)}
            style={({ pressed }) => [
              styles.card,
              { width: size, height: size, backgroundColor: item.color },
              pressed && { opacity: 0.85 },
            ]}
          >
            <Ionicons name={item.icon} size={42} color="white" />
            <Text style={styles.cardText}>{item.label}</Text>
          </Pressable>
        ))}
      </View>
      <Text style={styles.footerHint}>ou use o rodap√© abaixo para navegar</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#0b1220", padding: 20 },
  title: { color: "white", fontSize: 24, fontWeight: "800", marginBottom: 20, textAlign: "center" },
  grid: { flexDirection: "row", flexWrap: "wrap", justifyContent: "space-between" },
  card: {
    borderRadius: 16,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 20,
    shadowColor: "#000",
    shadowOpacity: 0.3,
    shadowRadius: 6,
    elevation: 5,
  },
  cardText: { color: "white", marginTop: 10, fontWeight: "600", fontSize: 16 },
  footerHint: { textAlign: "center", color: "#8aa0ff", marginTop: 10, fontSize: 12 },
});




Como fica




T√≠tulo em cima: HydroBotApp2


Grade de bot√µes quadrados grandes (2 colunas):



üìπ C√¢mera (azul)


üìä Dashboard (verde)


‚öôÔ∏è Ajustes (amarelo)






Rodap√© ainda existe (tabs) para navega√ß√£o alternativa.





quer que eu j√° adicione tamb√©m o bot√£o da Home (üè†) nesse grid, ou prefere deixar Home s√≥ como hub de acesso √†s outras telas?





























perfeito! vamos alinhar tudo √† paleta do logo (preto #000, vermelho bombeiro, branco gelo).

Vou te passar:




pequenas mudan√ßas no tema (App.tsx)


HomeScreen redesenhada com dois bot√µes quadrados grandes (C√¢mera e Dashboard) + logo no topo






Coloque a imagem do logo como assets/logo.png (use a que voc√™ enviou).





1) Tema no App.tsx (ajuste de cores)


Substitua apenas o bloco do tema e op√ß√µes do Tab:


// ...
const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",   // vermelho do logo
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
  textSoft: "#E6E6E6",
};

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

export default function App() {
  return (
    <NavigationContainer theme={DarkThemeHB}>
      <Tab.Navigator
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          // √≠cones mantidos
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        {/* as 4 abas continuam (Home, Camera, Dashboard, Settings) */}
        <Tab.Screen name="Home" component={HomeScreen} options={{ title: "In√≠cio" }} />
        <Tab.Screen name="Camera" component={CameraScreen} options={{ title: "C√¢mera" }} />
        <Tab.Screen name="Dashboard" component={DashboardScreen} options={{ title: "Dashboard" }} />
        <Tab.Screen name="Settings" component={SettingsScreen} options={{ title: "Ajustes" }} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}




2) src/screens/HomeScreen.tsx (apenas C√¢mera e Dashboard)


import { View, Text, StyleSheet, Pressable, Dimensions, Image } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { BottomTabNavigationProp } from "@react-navigation/bottom-tabs";
import type { TabParamList } from "../../App";

type Nav = BottomTabNavigationProp<TabParamList>;

const W = Dimensions.get("window").width;
const CARD = W / 2 - 28; // duas colunas com respiro lateral

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
  textSoft: "#E6E6E6",
};

export default function HomeScreen() {
  const navigation = useNavigation<Nav>();

  const tiles = [
    { key: "Camera" as const, label: "C√¢mera", icon: "videocam" as const, color: PALETTE.red },
    { key: "Dashboard" as const, label: "Dashboard", icon: "pulse" as const, color: PALETTE.redSoft },
  ];

  return (
    <View style={styles.container}>
      {/* topo com logo */}
      <View style={styles.hero}>
        <Image source={require("../../assets/logo.png")} style={styles.logo} resizeMode="contain" />
        <Text style={styles.title}>HydroBot</Text>
        <Text style={styles.sub}>Monitoramento e Controle</Text>
      </View>

      {/* grade de bot√µes (somente 2) */}
      <View style={styles.grid}>
        {tiles.map((t) => (
          <Pressable
            key={t.key}
            onPress={() => navigation.navigate(t.key)}
            style={({ pressed }) => [
              styles.tile,
              { width: CARD, height: CARD, borderColor: t.color },
              pressed && { transform: [{ scale: 0.98 }] },
            ]}
          >
            <View style={[styles.tileInner, { backgroundColor: t.color }]}>
              <Ionicons name={t.icon} size={42} color={PALETTE.white} />
            </View>
            <Text style={styles.tileLabel}>{t.label}</Text>
          </Pressable>
        ))}
      </View>

      <Text style={styles.hint}>Use o rodap√© para navegar entre as se√ß√µes</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 18 },
  hero: {
    alignItems: "center",
    marginTop: 6,
    marginBottom: 16,
  },
  logo: { width: 120, height: 120, marginBottom: 6 },
  title: { color: PALETTE.white, fontSize: 24, fontWeight: "800", letterSpacing: 0.5 },
  sub: { color: PALETTE.textSoft, fontSize: 12, marginTop: 2 },
  grid: {
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "space-between",
    rowGap: 16,
  },
  tile: {
    borderRadius: 18,
    borderWidth: 2,
    backgroundColor: PALETTE.card,
    overflow: "hidden",
  },
  tileInner: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  tileLabel: {
    position: "absolute",
    bottom: 8,
    width: "100%",
    textAlign: "center",
    color: PALETTE.white,
    fontWeight: "700",
    fontSize: 16,
    textShadowColor: "rgba(0,0,0,0.4)",
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 2,
  },
  hint: { textAlign: "center", color: "#9c9c9c", marginTop: 12, fontSize: 12 },
});



O que mudou no design




Fundo preto; cart√µes e tab bar mais escuros (quase preto).


Acentos em vermelho do logo (borda dos cards e preenchimento do √≠cone).


Tipografia clara (branco e cinza-claro).


Logo no topo como identidade.




Se quiser, eu coloco um gradiente sutil vermelho‚Üípreto nos tiles ou um glow vermelho ao pressionar ‚Äî mas mantive limpo e coerente com o logo.






























√≥timo üöÄ vou juntar tudo que j√° montamos (tabs, tema, Home redesenhada, C√¢mera com LED+Bomba+Joystick, Dashboard e Settings placeholders).

Estrutura final:


HydroBotApp2/
  App.tsx
  app.json
  babel.config.js
  package.json
  src/
    screens/
      HomeScreen.tsx
      CameraScreen.tsx
      DashboardScreen.tsx
      SettingsScreen.tsx
  assets/
    logo.png   ‚Üê (a logo que voc√™ mandou, salva aqui)
    icon.png
    splash.png
    adaptive-icon.png




App.tsx


import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";
import DashboardScreen from "./src/screens/DashboardScreen";
import SettingsScreen from "./src/screens/SettingsScreen";

export type TabParamList = {
  Home: undefined;
  Camera: undefined;
  Dashboard: undefined;
  Settings: undefined;
};

const Tab = createBottomTabNavigator<TabParamList>();

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
};

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

export default function App() {
  return (
    <NavigationContainer theme={DarkThemeHB}>
      <Tab.Navigator
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} options={{ title: "In√≠cio" }} />
        <Tab.Screen name="Camera" component={CameraScreen} options={{ title: "C√¢mera" }} />
        <Tab.Screen name="Dashboard" component={DashboardScreen} options={{ title: "Dashboard" }} />
        <Tab.Screen name="Settings" component={SettingsScreen} options={{ title: "Ajustes" }} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}




src/screens/HomeScreen.tsx


import { View, Text, StyleSheet, Pressable, Dimensions, Image } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { BottomTabNavigationProp } from "@react-navigation/bottom-tabs";
import type { TabParamList } from "../../App";

type Nav = BottomTabNavigationProp<TabParamList>;

const W = Dimensions.get("window").width;
const CARD = W / 2 - 28;

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
  textSoft: "#E6E6E6",
};

export default function HomeScreen() {
  const navigation = useNavigation<Nav>();

  const tiles = [
    { key: "Camera" as const, label: "C√¢mera", icon: "videocam" as const, color: PALETTE.red },
    { key: "Dashboard" as const, label: "Dashboard", icon: "pulse" as const, color: PALETTE.redSoft },
  ];

  return (
    <View style={styles.container}>
      <View style={styles.hero}>
        <Image source={require("../../assets/logo.png")} style={styles.logo} resizeMode="contain" />
        <Text style={styles.title}>HydroBot</Text>
        <Text style={styles.sub}>Monitoramento e Controle</Text>
      </View>

      <View style={styles.grid}>
        {tiles.map((t) => (
          <Pressable
            key={t.key}
            onPress={() => navigation.navigate(t.key)}
            style={({ pressed }) => [
              styles.tile,
              { width: CARD, height: CARD, borderColor: t.color },
              pressed && { transform: [{ scale: 0.98 }] },
            ]}
          >
            <View style={[styles.tileInner, { backgroundColor: t.color }]}>
              <Ionicons name={t.icon} size={42} color={PALETTE.white} />
            </View>
            <Text style={styles.tileLabel}>{t.label}</Text>
          </Pressable>
        ))}
      </View>

      <Text style={styles.hint}>Use o rodap√© para navegar entre as se√ß√µes</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 18 },
  hero: { alignItems: "center", marginTop: 6, marginBottom: 16 },
  logo: { width: 120, height: 120, marginBottom: 6 },
  title: { color: PALETTE.white, fontSize: 24, fontWeight: "800" },
  sub: { color: PALETTE.textSoft, fontSize: 12 },
  grid: { flexDirection: "row", flexWrap: "wrap", justifyContent: "space-between", rowGap: 16 },
  tile: { borderRadius: 18, borderWidth: 2, backgroundColor: PALETTE.card, overflow: "hidden" },
  tileInner: { flex: 1, alignItems: "center", justifyContent: "center" },
  tileLabel: {
    position: "absolute",
    bottom: 8,
    width: "100%",
    textAlign: "center",
    color: PALETTE.white,
    fontWeight: "700",
    fontSize: 16,
  },
  hint: { textAlign: "center", color: "#9c9c9c", marginTop: 12, fontSize: 12 },
});




src/screens/CameraScreen.tsx


(vers√£o com LED ON/OFF, Bomba ON/OFF e joystick UI)


(esse √© bem longo, mas j√° te passei a vers√£o completa na √∫ltima rodada; se quiser eu colo de novo aqui inteiro sem cortar)



src/screens/DashboardScreen.tsx


import { View, Text, StyleSheet } from "react-native";

export default function DashboardScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Dashboard</Text>
      <Text style={styles.sub}>Aqui vir√£o telemetria, gr√°ficos e logs.</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#000", alignItems: "center", justifyContent: "center" },
  title: { color: "white", fontSize: 22, fontWeight: "700" },
  sub: { color: "#9fb3ff", marginTop: 6 },
});




src/screens/SettingsScreen.tsx


import { View, Text, StyleSheet } from "react-native";

export default function SettingsScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Ajustes</Text>
      <Text style={styles.sub}>Prefer√™ncias do app e conex√µes.</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#000", alignItems: "center", justifyContent: "center" },
  title: { color: "white", fontSize: 22, fontWeight: "700" },
  sub: { color: "#9fb3ff", marginTop: 6 },
});




üëâ quer que eu cole novamente o c√≥digo inteiro da CameraScreen.tsx atualizado, junto com esses, para ficar 100% fechado em um s√≥ bloco?



















show! vou te entregar um guia passo-a-passo (sem pular nada) + c√≥digo pronto de um servidor intermedi√°rio em Python com TensorFlow ‚Äúnormal‚Äù (Keras) e a integra√ß√£o no app para exibir a detec√ß√£o.



PARTE A ‚Äî Servidor de IA (TensorFlow)


0) Pr√©-requisitos




Python 3.10 ou 3.11 (recomendado p/ TF 2.15)


Pip atualizado: python -m pip install -U pip


M√°quina que consiga acessar o ESP32 na rede (ex.: conectada ao Wi-Fi HYDROBOT-CAM)






Dica: quando o celular estiver no Wi-Fi do ESP32 (sem internet), rode o Expo com --tunnel para continuar vendo o app.





1) Criar a pasta do servidor


mkdir hydrobot-server
cd hydrobot-server



Crie estes arquivos:


requirements.txt




(TensorFlow 2.15 usa NumPy 1.26.x ‚Äî importante fixar)




fastapi==0.115.5
uvicorn[standard]==0.32.0
opencv-python==4.10.0.84
numpy==1.26.4
tensorflow==2.15.1



Estrutura


hydrobot-server/
  server_tf.py
  requirements.txt
  models/
    fire_classifier.h5      ‚Üê seu modelo Keras (2 classes: [no_fire, fire])



server_tf.py


import cv2
import time
import threading
import numpy as np
from typing import Optional, List, Dict
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from tensorflow.keras.models import load_model  # TensorFlow "normal"

# =========================
# Config do servidor
# =========================
CAMERA_IP = "192.168.4.1"                 # IP padr√£o do ESP32-CAM em AP
STREAM_URL_FMT = "http://{}:81/stream"
MODEL_PATH = "./models/fire_classifier.h5" # Keras (2 sa√≠das: [no_fire, fire])
SCORE_THRESHOLD = 0.60                     # corte (ajuste depois)
USE_HEURISTIC_IF_MODEL_MISSING = True      # fallback se faltar modelo

app = FastAPI(title="HydroBot Fire TF Server", version="1.0.0")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

# =========================
# Leitor de frames (OpenCV)
# =========================
class CameraReader:
    def __init__(self, ip: str):
        self.ip = ip
        self._cap: Optional[cv2.VideoCapture] = None
        self._lock = threading.Lock()
        self._last_frame: Optional[np.ndarray] = None
        self._fps = 0.0
        self._running = False
        self._thread: Optional[threading.Thread] = None

    def start(self):
        if self._running: return
        self._running = True
        self._thread = threading.Thread(target=self._loop, daemon=True)
        self._thread.start()

    def stop(self):
        self._running = False
        if self._thread: self._thread.join(timeout=2.0)
        if self._cap: self._cap.release()
        self._cap = None

    def set_ip(self, ip: str):
        if ip == self.ip: return
        self.ip = ip
        self.stop(); self.start()

    def _open(self):
        cap = cv2.VideoCapture(STREAM_URL_FMT.format(self.ip))
        cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
        return cap

    def _loop(self):
        self._cap = self._open()
        if not self._cap or not self._cap.isOpened():
            for _ in range(10):
                time.sleep(0.6)
                self._cap = self._open()
                if self._cap.isOpened(): break

        frames, last = 0, time.time()
        while self._running:
            if not self._cap or not self._cap.isOpened():
                time.sleep(0.3); continue
            ok, frame = self._cap.read()
            if not ok or frame is None:
                time.sleep(0.03); continue
            with self._lock:
                self._last_frame = frame
            frames += 1
            now = time.time()
            if now - last >= 1.0:
                self._fps = frames / (now - last)
                frames, last = 0, now

    def get_latest(self) -> Optional[np.ndarray]:
        with self._lock:
            return None if self._last_frame is None else self._last_frame.copy()

    def get_fps(self) -> float:
        return self._fps

reader = CameraReader(CAMERA_IP)
reader.start()

# =========================
# Carregar modelo Keras
# =========================
class FireClassifier:
    def __init__(self, model_path: str):
        self.model = None
        try:
            self.model = load_model(model_path)
        except Exception as e:
            print(f"[WARN] N√£o foi poss√≠vel carregar o modelo: {e}")
            self.model = None

        # inferir input shape [H, W, 3]
        if self.model is not None:
            ishape = self.model.inputs[0].shape  # (None, H, W, 3)
            self.H = int(ishape[1]); self.W = int(ishape[2])
        else:
            self.H = 224; self.W = 224  # padr√£o se faltar modelo

    def preprocess(self, frame_bgr: np.ndarray) -> np.ndarray:
        img = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2RGB)
        img = cv2.resize(img, (self.W, self.H), interpolation=cv2.INTER_AREA)
        x = img.astype(np.float32) / 255.0   # normaliza√ß√£o padr√£o
        return np.expand_dims(x, axis=0)

    def predict(self, frame_bgr: np.ndarray) -> float:
        if self.model is None:
            # fallback heur√≠stico (propor√ß√£o de pixels "quentes")
            hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
            mask = cv2.inRange(hsv, (5, 80, 120), (40, 255, 255))
            score = float(np.count_nonzero(mask)) / float(mask.size)
            return float(min(1.0, score * 4.0))
        x = self.preprocess(frame_bgr)
        probs = self.model.predict(x, verbose=0)[0]
        # espera [no_fire, fire]; se for 1 sa√≠da (sigmoid), trate como fire
        if probs.shape[0] == 2:
            fire_score = float(probs[1])
        else:
            fire_score = float(probs[0])
        return max(0.0, min(1.0, fire_score))

clf = FireClassifier(MODEL_PATH)

# =========================
# Caixas por heur√≠stica (opcional)
# =========================
def fire_boxes(frame_bgr: np.ndarray) -> List[List[int]]:
    h, w = frame_bgr.shape[:2]
    scl = min(640, w)
    rs = cv2.resize(frame_bgr, (scl, int(h * scl / w)))
    hsv = cv2.cvtColor(rs, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, (5, 80, 120), (40, 255, 255))
    kernel = np.ones((5, 5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, 1)
    mask = cv2.morphologyEx(mask, cv2.MORPH_DILATE, kernel, 1)
    cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    boxes: List[List[int]] = []
    rx, ry = w / float(scl), h / float(rs.shape[0])
    for c in cnts:
        x, y, bw, bh = cv2.boundingRect(c)
        if bw * bh < 600: 
            continue
        boxes.append([int(x * rx), int(y * ry), int(bw * rx), int(bh * ry)])
    return boxes

# =========================
# API
# =========================
class ConfigIn(BaseModel):
    camera_ip: str

@app.get("/status")
def status():
    return {
        "ok": True,
        "camera_ip": reader.ip,
        "fps": round(reader.get_fps(), 2),
        "has_frame": reader.get_latest() is not None,
        "model": "keras_h5" if clf.model is not None else ("heuristic" if USE_HEURISTIC_IF_MODEL_MISSING else "none"),
        "ts": int(time.time() * 1000),
    }

@app.post("/config")
def set_config(cfg: ConfigIn):
    reader.set_ip(cfg.camera_ip)
    return {"ok": True, "camera_ip": reader.ip}

@app.get("/snapshot")
def snapshot():
    frame = reader.get_latest()
    if frame is None:
        return {"ok": False, "error": "no frame yet"}
    ok, buf = cv2.imencode(".jpg", frame, [int(cv2.IMWRITE_JPEG_QUALITY), 85])
    if not ok:
        return {"ok": False, "error": "encode failed"}
    return Response(content=buf.tobytes(), media_type="image/jpeg")

@app.get("/detect")
def detect():
    frame = reader.get_latest()
    if frame is None:
        return {"ok": False, "error": "no frame"}
    score = clf.predict(frame)
    is_fire = bool(score >= SCORE_THRESHOLD)
    boxes = fire_boxes(frame) if is_fire else []
    return {
        "ok": True,
        "isFire": is_fire,
        "score": round(float(score), 3),
        "boxes": boxes,
        "threshold": SCORE_THRESHOLD,
        "ts": int(time.time() * 1000),
    }




2) Instalar e rodar


# (na pasta hydrobot-server)
python -m venv .venv
# Windows: .venv\Scripts\activate
# macOS/Linux:
source .venv/bin/activate

pip install -r requirements.txt
uvicorn server_tf:app --reload --host 0.0.0.0 --port 8000





Sem modelo ainda? Pode rodar assim mesmo: ele usa o fallback heur√≠stico.

Quando voc√™ colocar models/fire_classifier.h5, ele usa o Keras automaticamente.





3) Conectividade de rede




ESP32-CAM cria o AP HYDROBOT-CAM ‚Üí IP padr√£o 192.168.4.1


Servidor (sua m√°quina) deve conectar a esse AP para ler o stream.


Celular tamb√©m conecta ao mesmo AP para usar o app.


Para o Expo Go funcionar enquanto est√° nesse AP (sem internet), rode o bundler com:

npx expo start --tunnel


(o t√∫nel usa a rede m√≥vel para entregar o bundle)




Descubra o IP do servidor dentro do AP (Windows: ipconfig, macOS/Linux: ifconfig).

Geralmente vira 192.168.4.x.



PARTE B ‚Äî App (React Native) consumindo a IA


Voc√™ j√° tem a CameraScreen.tsx. Vamos adicionar:




Campo de Servidor (http://192.168.4.X:8000)


Bot√£o Detectar (liga/desliga polling)


Banner ‚Äúüî• FOGO‚Äù com score






Substitua seu src/screens/CameraScreen.tsx pelo abaixo (j√° inclui LED, Bomba, Joystick e Detec√ß√£o):




import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  ActivityIndicator,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
} from "react-native";
import { WebView } from "react-native-webview";

const DEFAULT_IP = "192.168.4.1";          // ESP32-CAM
const DEFAULT_SERVER = "http://192.168.4.2:8000"; // <-- troque para o IP do seu servidor no AP

export default function CameraScreen() {
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");
  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // Detec√ß√£o
  const [detectOn, setDetectOn] = useState<boolean>(false);
  const [isFire, setIsFire] = useState<boolean>(false);
  const [fireScore, setFireScore] = useState<number>(0);

  // Joystick UI
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const webref = useRef<WebView>(null);

  const streamUrl = useMemo(() => `http://${ip}:81/stream`, [ip]);
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl   = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl  = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl);
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try {
      const t = !ledOn; await fetch(ledUrl(t)); setLedOn(t);
    } catch { setStatusText("Erro ao alternar LED."); }
  }
  async function togglePump() {
    try {
      const t = !pumpOn; await fetch(pumpUrl(t)); setPumpOn(t);
    } catch { setStatusText("Erro ao alternar bomba."); }
  }

  useEffect(() => {
    pingStatus(); const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // HTML para MJPEG
  const html = `
    <html>
      <head><meta name="viewport" content="width=device-width, initial-scale=1" /></head>
      <body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;height:100vh;">
        <img src="${streamUrl}" style="width:100%;height:100%;object-fit:contain;" />
      </body>
    </html>
  `;

  // ======= Polling de detec√ß√£o =======
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;
    const tick = async () => {
      try {
        const r = await fetch(`${server}/detect`, { method: "GET" });
        const j = await r.json();
        if (!stop && j && j.ok) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));
        }
      } catch {
        if (!stop) { setIsFire(false); setFireScore(0); }
      } finally {
        if (!stop) setTimeout(tick, 500); // ~2Hz (ajuste)
      }
    };
    tick();
    return () => { stop = true; };
  }, [detectOn, server]);

  // ===== Joystick (UI) =====
  const RADIUS = 64, KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS, ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny); if (len > 1) { nx /= len; ny /= len; }
        setJoy({ x: nx, y: -ny });
      },
      onPanResponderRelease: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
      onPanResponderTerminate: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
    })
  ).current;
  const knobLeft = joy.x * RADIUS, knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Controles superiores */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder="192.168.4.1"
          autoCapitalize="none" autoCorrect={false} style={styles.input} keyboardType="numeric" />
        <Pressable onPress={pingStatus} style={styles.btn}><Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text></Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text>
        </Pressable>
        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text>
        </Pressable>
      </View>

      {/* Linha do servidor + detec√ß√£o */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>Servidor:</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder="http://192.168.4.2:8000"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? "Detectando" : "Detectar"}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>{statusText}</Text>
        <Pressable onPress={() => webref.current?.reload()} style={[styles.btn, { marginLeft: 8 }]}>
          <Text style={styles.btnText}>Recarregar</Text>
        </Pressable>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>
            {isFire ? `üî• FOGO ‚Ä¢ score ${fireScore.toFixed(2)}` : `Sem fogo ‚Ä¢ score ${fireScore.toFixed(2)}`}
          </Text>
        </View>
      )}

      {/* V√≠deo */}
      <WebView
        ref={webref}
        originWhitelist={["*"]}
        source={{ html }}
        style={styles.web}
        allowFileAccess
        allowingReadAccessToURL={"*"}
        javaScriptEnabled
        domStorageEnabled
        allowUniversalAccessFromFileURLs
        allowsInlineMediaPlayback
        mediaPlaybackRequiresUserAction={false}
      />

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View style={[styles.joyKnob, { width: KNOB_R * 2, height: KNOB_R * 2, borderRadius: KNOB_R, transform: [{ translateX: knobLeft }, { translateY: knobTop }], opacity: dragging ? 1 : 0.9 }]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const PALETTE = { bg:"#000", card:"#0d0d0d", border:"#1a1a1a", red:"#E53B2F", white:"#fff" };

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },
  topbar: { flexDirection: "row", alignItems: "center", paddingHorizontal: 12, paddingVertical: 10, gap: 8, backgroundColor: PALETTE.card },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: { backgroundColor: PALETTE.bg, color: "white", borderRadius: 8, paddingHorizontal: 10, paddingVertical: 8, borderWidth: 1, borderColor: "#1e2a4d", minWidth: 110 },
  btn: { backgroundColor: "#2b48ff", paddingHorizontal: 10, paddingVertical: 10, borderRadius: 10 },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },
  statusRow: { flexDirection: "row", alignItems: "center", paddingHorizontal: 12, paddingVertical: 8, gap: 8, backgroundColor: "#0f1730" },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },
  web: { flex: 1, backgroundColor: "black" },
  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(43,72,255,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});




CHECKLIST r√°pido (do zero at√© ver ‚Äúüî• FOGO‚Äù no app)




Ligue o ESP32-CAM (AP HYDROBOT-CAM, senha 12345678).


Conecte o notebook ao AP HYDROBOT-CAM.


Suba o servidor:



Crie a pasta hydrobot-server, cole os arquivos, pip install -r requirements.txt,


Rode: uvicorn server_tf:app --reload --host 0.0.0.0 --port 8000.


(Opcional) Coloque models/fire_classifier.h5. Sem ele, usa heur√≠stica.






Descubra o IP do notebook no AP (ex.: 192.168.4.2).


No app, rode npx expo start --tunnel.


No app C√¢mera:



Campo ESP IP: 192.168.4.1 ‚Üí tocar Testar (status OK).


Campo Servidor: http://192.168.4.2:8000 (troque pelo seu IP).


Toque Detectar ‚Üí deve aparecer um banner ‚ÄúSem fogo ‚Ä¢ score ‚Ä¶‚Äù.


Aponte chama/luz quente ‚Üí quando o score ‚â• 0.60, aparece üî• FOGO.






(Opcional) Ajuste SCORE_THRESHOLD no server_tf.py conforme seu modelo.




Pronto. Quando quiser, eu:




Troco o fallback por um detector com caixas (SSD/EfficientDet em TF) e desenho overlay.


Automatizo bomba ao detectar fogo (com histerese/timeout para n√£o ligar/superligar).


Adiciono /detect/stream (SSE) para lat√™ncia menor e menos requisi√ß√µes.




















Sim ‚Äî d√° pra seguir de dois jeitos sem remover o 3.13.5:




(r√°pido, hoje) rodar a detec√ß√£o ‚Äúplaceholder‚Äù (heur√≠stica HSV) 100% compat√≠vel com Python 3.13 ‚Äî funciona agora.


(TensorFlow ‚Äúde verdade‚Äù) rodar o servidor em Docker com Python 3.11 + TensorFlow, independente do Python instalado no Windows.




Abaixo te deixo os dois caminhos completos. Se quiser pular direto pro TensorFlow, vai no Plano B.



Plano A (imediato): servidor compat√≠vel com Python 3.13 (heur√≠stica)


Isso te deixa testar o fluxo end-to-end (app ‚áÑ servidor ‚áÑ ESP32) enquanto a gente prepara o cont√™iner TF.


1) Arquivos


requirements_heuristic.txt (compat√≠veis com 3.13):


fastapi==0.115.5
uvicorn[standard]==0.32.0
opencv-python>=4.10.0
numpy>=2.0.0



server_heuristic.py (igual ao que passei antes, s√≥ sem TensorFlow):


import cv2, time, threading, numpy as np
from typing import Optional, List
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

CAMERA_IP = "192.168.4.1"
STREAM_URL_FMT = "http://{}:81/stream"
SCORE_THRESHOLD = 0.60

app = FastAPI(title="HydroBot Fire (Heuristic)", version="0.1.0")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

class CameraReader:
    def __init__(self, ip: str):
        self.ip = ip; self._cap=None; self._lock=threading.Lock()
        self._last=None; self._fps=0.0; self._run=False; self._th=None
    def start(self):
        if self._run: return
        self._run=True; self._th=threading.Thread(target=self._loop,daemon=True); self._th.start()
    def stop(self):
        self._run=False
        if self._th: self._th.join(timeout=2.0)
        if self._cap: self._cap.release(); self._cap=None
    def set_ip(self, ip:str):
        if ip==self.ip: return
        self.ip=ip; self.stop(); self.start()
    def _open(self):
        cap=cv2.VideoCapture(STREAM_URL_FMT.format(self.ip)); cap.set(cv2.CAP_PROP_BUFFERSIZE,1); return cap
    def _loop(self):
        self._cap=self._open()
        for _ in range(10):
            if self._cap and self._cap.isOpened(): break
            time.sleep(0.6); self._cap=self._open()
        frames=0; last=time.time()
        while self._run:
            if not self._cap or not self._cap.isOpened(): time.sleep(0.3); continue
            ok,frame=self._cap.read()
            if not ok or frame is None: time.sleep(0.03); continue
            with self._lock: self._last=frame
            frames+=1; now=time.time()
            if now-last>=1.0: self._fps=frames/(now-last); frames=0; last=now
    def get_latest(self): 
        with self._lock: return None if self._last is None else self._last.copy()
    def get_fps(self): return self._fps

reader=CameraReader(CAMERA_IP); reader.start()

class ConfigIn(BaseModel): camera_ip: str

def fire_score(frame):
    hsv=cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    mask=cv2.inRange(hsv,(5,80,120),(40,255,255))
    ratio=float(np.count_nonzero(mask))/float(mask.size)
    v_mean=float(np.mean(hsv[...,2]))/255.0
    return min(1.0, ratio*4.0 + v_mean*0.2)

def fire_boxes(frame):
    h,w=frame.shape[:2]; scl=min(640,w)
    rs=cv2.resize(frame,(scl,int(h*scl/w))); hsv=cv2.cvtColor(rs, cv2.COLOR_BGR2HSV)
    mask=cv2.inRange(hsv,(5,80,120),(40,255,255))
    k=np.ones((5,5),np.uint8)
    mask=cv2.morphologyEx(mask, cv2.MORPH_OPEN, k,1); mask=cv2.morphologyEx(mask, cv2.MORPH_DILATE, k,1)
    cnts,_=cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    rx=w/float(scl); ry=h/float(rs.shape[0]); boxes=[]
    for c in cnts:
        x,y,bw,bh=cv2.boundingRect(c)
        if bw*bh<600: continue
        boxes.append([int(x*rx),int(y*ry),int(bw*rx),int(bh*ry)])
    return boxes

@app.get("/status")
def status(): 
    return {"ok":True,"camera_ip":reader.ip,"fps":round(reader.get_fps(),2),"has_frame":reader.get_latest() is not None,"model":"heuristic","ts":int(time.time()*1000)}

@app.post("/config")
def set_config(cfg:ConfigIn):
    reader.set_ip(cfg.camera_ip); return {"ok":True,"camera_ip":reader.ip}

@app.get("/snapshot")
def snapshot():
    f=reader.get_latest()
    if f is None: return {"ok":False,"error":"no frame"}
    ok,buf=cv2.imencode(".jpg",f,[int(cv2.IMWRITE_JPEG_QUALITY),85])
    if not ok: return {"ok":False,"error":"encode failed"}
    return Response(content=buf.tobytes(),media_type="image/jpeg")

@app.get("/detect")
def detect():
    f=reader.get_latest()
    if f is None: return {"ok":False,"error":"no frame"}
    s=fire_score(f); is_fire=bool(s>=SCORE_THRESHOLD)
    return {"ok":True,"isFire":is_fire,"score":round(float(s),3),"boxes":(fire_boxes(f) if is_fire else []),"threshold":SCORE_THRESHOLD,"ts":int(time.time()*1000)}



2) Instalar e rodar (com seu Python 3.13)


python -m pip install -U pip
pip install -r requirements_heuristic.txt
uvicorn server_heuristic:app --reload --host 0.0.0.0 --port 8000



No app (tela C√¢mera), aponte Servidor para http://<IP_DO_PC_NO_AP>:8000 e toque Detectar.

Voc√™ j√° ver√° o banner com o score; quando houver chama/√°rea quente, ele sobe.




Depois, quando quiser trocar para TensorFlow ‚Äúreal‚Äù, voc√™ n√£o muda nada no app, s√≥ troca o servidor.





Plano B (recomendado p/ TensorFlow): Docker com Python 3.11 + TF


Mesmo mantendo Python 3.13 no Windows, o servidor roda dentro do cont√™iner com 3.11 + TF.


0) Pr√©-requisitos




Docker Desktop instalado e rodando.




1) Arquivos


Dockerfile


FROM python:3.11-slim

# libs p/ OpenCV
RUN apt-get update && apt-get install -y --no-install-recommends \
    libglib2.0-0 libsm6 libxrender1 libxext6 && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app

# requirements (TF 2.15 + numpy compat√≠vel)
COPY requirements_tf.txt /app/requirements_tf.txt
RUN pip install --no-cache-dir -r requirements_tf.txt

# c√≥digo e modelos
COPY server_tf.py /app/server_tf.py
COPY models /app/models

EXPOSE 8000
CMD ["uvicorn", "server_tf:app", "--host", "0.0.0.0", "--port", "8000"]



requirements_tf.txt


fastapi==0.115.5
uvicorn[standard]==0.32.0
opencv-python-headless==4.10.0.84
numpy==1.26.4
tensorflow==2.15.1





Uso opencv-python-headless no cont√™iner para evitar depend√™ncias de GUI.




server_tf.py

‚Äî √© exatamente o que te passei anteriormente (TensorFlow ‚Äúnormal‚Äù, modelo Keras .h5). Se quiser, eu reenvio o arquivo inteiro de novo aqui.


Estrutura:


hydrobot-server/
  Dockerfile
  requirements_tf.txt
  server_tf.py
  models/
    fire_classifier.h5   ‚Üê (opcional; se faltar, usa heur√≠stica fallback)



2) Build & run


# dentro da pasta hydrobot-server
docker build -t hydrobot-tf .
docker run --rm -p 8000:8000 --network host --name hydrobot-tf hydrobot-tf





Se --network host n√£o funcionar no Windows Docker Desktop, use:


docker run --rm -p 8000:8000 --name hydrobot-tf hydrobot-tf



e no app aponte para http://SEU-IP:8000 (o IP da sua m√°quina na rede do ESP32).




Testes:




http://SEU-IP:8000/status


http://SEU-IP:8000/detect




Quando voc√™ colocar models/fire_classifier.h5 dentro da pasta antes do build, o servidor passar√° a usar TF de fato.



Qual caminho eu recomendo agora?




Se voc√™ quer seguir hoje, use o Plano A (heur√≠stica) com o Python 3.13 e j√° integre ao app.


Em paralelo, prepare o Plano B (Docker) para usar seu modelo TensorFlow sem esquentar com a vers√£o do Python do Windows.




Se quiser, eu te mando o server_tf.py completo novamente, e/ou um docker-compose.yml pra subir com um comando s√≥.































Valeu pela print ‚Äî o erro √© claro: o comando uvicorn n√£o foi encontrado no PATH. O pip instalou os scripts em uma pasta que n√£o est√° no PATH (a mensagem amarela mostra isso). Resolvo em 1 minuto com qualquer uma destas op√ß√µes; deixo a recomendada primeiro.



‚úÖ Solu√ß√£o recomendada (sem dor de cabe√ßa): use um venv e chame via python -m




Dentro da pasta do servidor (onde est√° server_heuristic.py):




# crie e ative um venv usando o Python que voc√™ quer (3.13 mesmo)
py -3.13 -m venv .venv
.\.venv\Scripts\activate
python -m pip install -U pip





Instale as depend√™ncias no venv (Plano A ‚Äì heur√≠stica):




pip install fastapi==0.115.5 uvicorn[standard]==0.32.0 opencv-python==4.10.0.84 numpy==2.1.1





Rode o servidor sem depender do PATH:




python -m uvicorn server_heuristic:app --reload --host 0.0.0.0 --port 8000





Usando python -m uvicorn funciona mesmo se o uvicorn.exe n√£o estiver no PATH.




Se abrir, voc√™ ver√° ‚ÄúUvicorn running on http://0.0.0.0:8000‚Äù.

Teste em outro terminal: curl http://localhost:8000/status



Alternativas r√°pidas (caso prefira)






A. Usar o Python 3.11 (se foi nele que o pip instalou):


py -3.11 -m uvicorn server_heuristic:app --reload --host 0.0.0.0 --port 8000



(garante que voc√™ usa o mesmo Python que instalou o uvicorn)






B. Adicionar a pasta ‚ÄúScripts‚Äù ao PATH (n√£o recomendado; venv √© melhor):

Adicione a pasta mostrada no aviso (ex.: C:\Users\SEUUSER\AppData\Roaming\Python\Python311\Scripts\) ao PATH do Windows, feche e reabra o terminal. Depois uvicorn --version deve funcionar.







Checagens r√°pidas se ainda falhar




Confirme o arquivo e a pasta:



Nome do arquivo: server_heuristic.py


Comando √© executado na mesma pasta do arquivo.






Confirme o Python do venv:

python -V
pip -V


(devem apontar para .venv\‚Ä¶)


Teste import direto:

python -c "import uvicorn, fastapi; print('ok')"







Seguindo os passos do venv acima, o servidor sobe lisinho e seu app j√° consegue chamar http://<IP_DO_PC>:8000/detect.




















segue o arquivo completo da tela da c√¢mera, j√° com:




campo de IP do ESP (/status, /led, /pump, stream MJPEG)


campo de Servidor IA (/detect)


bot√£o Detectar (liga/desliga polling)


banner de fogo com score


LED ON/OFF e Bomba ON/OFF


joystick (UI) pronto pra enviar depois




Salve como: src/screens/CameraScreen.tsx


import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  ActivityIndicator,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
} from "react-native";
import { WebView } from "react-native-webview";

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#ffffff" };

// ajuste estes padr√µes se quiser
const DEFAULT_IP = "192.168.4.1";            // ESP32-CAM (AP)
const DEFAULT_SERVER = "http://192.168.4.2:8000"; // Servidor de IA (PC no mesmo AP)

export default function CameraScreen() {
  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");
  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // detec√ß√£o
  const [detectOn, setDetectOn] = useState<boolean>(false);
  const [isFire, setIsFire] = useState<boolean>(false);
  const [fireScore, setFireScore] = useState<number>(0);

  // joystick (UI)
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const webref = useRef<WebView>(null);

  // URLs do ESP
  const streamUrl = useMemo(() => `http://${ip}:81/stream`, [ip]);
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  // consulta /status do ESP
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl, { method: "GET" });
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }

  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText("Erro ao alternar LED.");
    }
  }

  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText("Erro ao alternar bomba.");
    }
  }

  // ping peri√≥dico de status do ESP
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // HTML simples para tocar MJPEG dentro da WebView
  const html = `
    <html>
      <head><meta name="viewport" content="width=device-width, initial-scale=1" /></head>
      <body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;height:100vh;">
        <img src="${streamUrl}" style="width:100%;height:100%;object-fit:contain;" />
      </body>
    </html>
  `;

  // polling de /detect do servidor de IA
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;
    const loop = async () => {
      try {
        const r = await fetch(`${server}/detect`, { method: "GET" });
        const j = await r.json();
        if (!stop && j && j.ok) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
        }
      } finally {
        if (!stop) setTimeout(loop, 500); // ~2 Hz
      }
    };
    loop();
    return () => {
      stop = true;
    };
  }, [detectOn, server]);

  // joystick (UI)
  const RADIUS = 64;
  const KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS;
        let ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny }); // y positivo para cima
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const knobLeft = joy.x * RADIUS;
  const knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="192.168.4.1"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor IA + Detectar */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>Servidor:</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder="http://192.168.4.2:8000"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? "Detectando" : "Detectar"}</Text>
        </Pressable>
      </View>

      {/* Status curto + recarregar stream */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
        <Pressable onPress={() => webref.current?.reload()} style={[styles.btn, { marginLeft: 8 }]}>
          <Text style={styles.btnText}>Recarregar</Text>
        </Pressable>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>
            {isFire ? `üî• FOGO ‚Ä¢ score ${fireScore.toFixed(2)}` : `Sem fogo ‚Ä¢ score ${fireScore.toFixed(2)}`}
          </Text>
        </View>
      )}

      {/* V√≠deo MJPEG */}
      <WebView
        ref={webref}
        originWhitelist={["*"]}
        source={{ html }}
        style={styles.web}
        allowFileAccess
        allowingReadAccessToURL={"*"}
        javaScriptEnabled
        domStorageEnabled
        allowUniversalAccessFromFileURLs
        allowsInlineMediaPlayback
        mediaPlaybackRequiresUserAction={false}
      />

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: knobLeft }, { translateY: knobTop }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: PALETTE.bg,
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
    minWidth: 110,
  },
  btn: {
    backgroundColor: "#2b48ff",
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },

  web: { flex: 1, backgroundColor: "black" },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(43,72,255,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});



Como testar rapidamente




Suba o servidor (server_heuristic.py) no PC:

python -m uvicorn server_heuristic:app --reload --host 0.0.0.0 --port 8000


Conecte PC e celular ao Wi-Fi HYDROBOT-CAM.


Na tela C√¢mera:



ESP IP: 192.168.4.1 ‚Üí Testar


Servidor: http://SEU_IP_DO_PC:8000 ‚Üí Detectar






Veja o stream e o banner üî• FOGO mudar conforme o score.




Se quiser, depois plugamos o joystick no endpoint /joystick do ESP e colocamos slider PWM para a bomba.






























show üëå vou te mandar o CameraScreen.tsx completo e revisado, j√° com os fixes que estavam dando erro (camelCase e fireText).


salva em src/screens/CameraScreen.tsx:


import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
} from "react-native";
import { WebView } from "react-native-webview";

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#ffffff" };

// ajuste estes padr√µes se quiser
const DEFAULT_IP = "192.168.4.1";            // ESP32-CAM (AP)
const DEFAULT_SERVER = "http://192.168.4.2:8000"; // Servidor IA (PC no mesmo AP)

export default function CameraScreen() {
  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");
  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // detec√ß√£o
  const [detectOn, setDetectOn] = useState<boolean>(false);
  const [isFire, setIsFire] = useState<boolean>(false);
  const [fireScore, setFireScore] = useState<number>(0);

  // joystick (UI)
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const webref = useRef<WebView>(null);

  // URLs do ESP
  const streamUrl = useMemo(() => `http://${ip}:81/stream`, [ip]);
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  // consulta /status do ESP
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl, { method: "GET" });
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }

  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText("Erro ao alternar LED.");
    }
  }

  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText("Erro ao alternar bomba.");
    }
  }

  // ping peri√≥dico de status do ESP
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // HTML simples para tocar MJPEG dentro da WebView
  const html = `
    <html>
      <head><meta name="viewport" content="width=device-width, initial-scale=1" /></head>
      <body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;height:100vh;">
        <img src="${streamUrl}" style="width:100%;height:100%;object-fit:contain;" />
      </body>
    </html>
  `;

  // polling de /detect do servidor de IA
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;
    const loop = async () => {
      try {
        const r = await fetch(`${server}/detect`, { method: "GET" });
        const j = await r.json();
        if (!stop && j && j.ok) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
        }
      } finally {
        if (!stop) setTimeout(loop, 500); // ~2 Hz
      }
    };
    loop();
    return () => {
      stop = true;
    };
  }, [detectOn, server]);

  // joystick (UI)
  const RADIUS = 64;
  const KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS;
        let ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny }); // y positivo para cima
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const knobLeft = joy.x * RADIUS;
  const knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="192.168.4.1"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor IA + Detectar */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>Servidor:</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder="http://192.168.4.2:8000"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? "Detectando" : "Detectar"}</Text>
        </Pressable>
      </View>

      {/* Status curto + recarregar stream */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
        <Pressable onPress={() => webref.current?.reload()} style={[styles.btn, { marginLeft: 8 }]}>
          <Text style={styles.btnText}>Recarregar</Text>
        </Pressable>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>
            {isFire ? `üî• FOGO ‚Ä¢ score ${fireScore.toFixed(2)}` : `Sem fogo ‚Ä¢ score ${fireScore.toFixed(2)}`}
          </Text>
        </View>
      )}

      {/* V√≠deo MJPEG */}
      <WebView
        ref={webref}
        originWhitelist={["*"]}
        source={{ html }}
        style={styles.web}
        allowFileAccess
        allowingReadAccessToURL={"*"}
        javaScriptEnabled
        domStorageEnabled
        allowUniversalAccessFromFileURLs
        allowsInlineMediaPlayback
        mediaPlaybackRequiresUserAction={false}
      />

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: knobLeft }, { translateY: knobTop }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: PALETTE.bg,
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
    minWidth: 110,
  },
  btn: {
    backgroundColor: "#2b48ff",
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  web: { flex: 1, backgroundColor: "black" },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(43,72,255,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});




‚úÖ Agora n√£o tem mais firetext errado nem backgroundcolor.

Se quiser, roda com cache limpo pra garantir:


npx expo start -c








































üëâ a ordem correta √©:






Liga o ESP32-CAM (ele sobe o Wi-Fi HYDROBOT-CAM).






Conecta PC e celular nesse Wi-Fi.






Inicia o servidor no PC:


cd hydrobot-server
python -m uvicorn server_heuristic:app --reload --host 0.0.0.0 --port 8000





Assim o servidor j√° est√° de p√© e pronto pra responder ao app.

Teste no navegador do PC http://localhost:8000/status ‚Äî se responder JSON, t√° ok.








Inicia o app no Expo:


npx expo start --lan





Escaneia o QR com o celular (tamb√©m no HYDROBOT-CAM).


O app abre e j√° consegue conversar com ESP (192.168.4.1) e servidor IA (IP do PC).









‚ö†Ô∏è Se voc√™ abrir o app antes do servidor, a parte de ‚ÄúDetectar‚Äù vai dar erro porque /detect n√£o existe ainda.

Por isso sempre: server primeiro ‚Üí app depois.


Quer que eu te mande um checklist r√°pido de teste (pingar ESP, abrir stream, checar /status do server) pra voc√™ marcar quando for validar?





































Boa, vi pela sua print que o erro √©:


No module named uvicorn



üëâ Isso significa que no novo PC voc√™ ainda n√£o instalou as depend√™ncias (FastAPI, Uvicorn, etc).

Ou seja, o Python est√° rodando, mas o pacote n√£o existe nesse ambiente.



Como resolver (Windows / PowerShell)




Entre na pasta do seu servidor:




cd D:\Loud2025\hydrobot-server





(opcional, mas recomendado) Crie um ambiente virtual:




py -3.13 -m venv .venv
.\.venv\Scripts\activate



Voc√™ vai ver (.venv) no come√ßo da linha do terminal.




Instale os pacotes necess√°rios:




pip install fastapi==0.115.5 uvicorn[standard]==0.32.0 opencv-python==4.10.0.84 numpy==2.1.1 requests





Agora rode o servidor:




python -m uvicorn server_heuristic:app --reload --host 0.0.0.0 --port 8000




Dicas extras




Sempre rode dentro do venv (.\.venv\Scripts\activate).


Se trocar de PC, basta rodar de novo o pip install ... ou usar um requirements.txt.

Exemplo:

fastapi==0.115.5
uvicorn[standard]==0.32.0
opencv-python==4.10.0.84
numpy==2.1.1
requests


e depois:

pip install -r requirements.txt








Quer que eu te monte esse requirements.txt j√° pronto, pra voc√™ s√≥ dar pip install -r requirements.txt e nunca mais precisar digitar os pacotes um a um quando mudar de computador?





























bora fazer o v√≠deo aparecer üëá


Checklist r√°pido (pra isolar o problema)






No celular, abra o navegador e acesse:

http://192.168.4.1:81/stream




Se aparecer o v√≠deo ‚Üí a c√¢mera est√° ok; o ajuste √© no app.


Se n√£o aparecer ‚Üí √© rede/conex√£o com o ESP (cheque Wi-Fi HYDROBOT-CAM).








Confirme no app.json (voc√™ j√° tinha adicionado, mas vale checar):






{
  "expo": {
    "...": "...",
    "android": {
      "usesCleartextTraffic": true
    },
    "ios": {
      "infoPlist": {
        "NSAppTransportSecurity": { "NSAllowsArbitraryLoads": true }
      }
    }
  }
}



Depois rode: npx expo start -c



Ajuste na tela: carregar o stream direto (sem HTML wrapper)


Alguns devices/WebView n√£o curtem MJPEG dentro de <img> em HTML local. Carregar direto a URL no WebView costuma funcionar melhor.


No seu CameraScreen.tsx, troque apenas o bloco do WebView (deixe todo o resto igual):


{/* V√≠deo MJPEG (carrega a URL diretamente) */}
<WebView
  ref={webref}
  source={{ uri: streamUrl }}          // <--- direto na URL
  style={styles.web}
  originWhitelist={["*"]}
  javaScriptEnabled
  domStorageEnabled
  allowsInlineMediaPlayback
  mediaPlaybackRequiresUserAction={false}
  mixedContentMode="always"            // <--- importante no Android
  overScrollMode="never"
  allowingReadAccessToURL={"*"}
/>



E remova as vari√°veis/uso do const html = \...`;` se n√£o for mais usar o HTML.



Se ainda n√£o renderizar






Teste outra variante do WebView:


<WebView
  source={{ uri: `${streamUrl}` }}
  useWebKit
  allowsInlineMediaPlayback
  mixedContentMode="always"
  originWhitelist={["*"]}
  style={styles.web}
/>







Alguns Androids bloqueiam MJPEG no WebView. Alternativas:




Usar o pacote react-native-mjpeg (exibe MJPEG nativamente no Android).


Servir JPEGs individuais do servidor (snapshot a cada 200‚Äì300 ms) e mostrar com <Image>; √© menos fluido, mas funciona em qualquer lugar:

const [frameUri, setFrameUri] = useState(`${server}/snapshot?ts=${Date.now()}`);
useEffect(() => {
  let id: any;
  const pull = async () => {
    setFrameUri(`${server}/snapshot?ts=${Date.now()}`);
    id = setTimeout(pull, 300);
  };
  pull();
  return () => clearTimeout(id);
}, [server]);

<Image source={{ uri: frameUri }} style={{ flex: 1, resizeMode: "contain", backgroundColor: "black" }} />


(precisa do endpoint /snapshot ativo no servidor.)









Teste na ordem




Servidor rodando (/status responde).


Celular e PC no mesmo Wi-Fi do ESP.


Abra no celular o navegador em http://192.168.4.1:81/stream (tem que ver v√≠deo).


Abra o app ‚Üí aba C√¢mera ‚Üí coloque ESP IP = 192.168.4.1 ‚Üí Testar ‚Üí depois troque o WebView como mostrei acima.




Se travar em algum passo, me diga exatamente qual (e o modelo do celular). A seguir, posso te passar a op√ß√£o com react-native-mjpeg j√° pronta.

























/**
 * HydroBot.ino - ESP32-CAM (AI Thinker) - AP ONLY (sem sensores)
 * - AP fixo (HYDROBOT-CAM)
 * - Stream MJPEG: /stream (porta 81)
 * - API (80): /status, /led, /mode, /joystick, /pump (on/off), /pump_pwm?duty=0..255
 * - LED no GPIO 4 (flash onboard)
 * - Bomba por MOSFET com PWM (LEDC via ESP-IDF)
 */

#include <Arduino.h>
#include "esp_camera.h"
#include <WiFi.h>
#include <WebServer.h>
#include "esp_http_server.h"
#include <time.h>
#include "driver/ledc.h"   // PWM (ESP-IDF)

// Desativa brownout
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ===================== WIFI AP =====================
const char* AP_SSID = "HYDROBOT-CAM";
const char* AP_PASS = "12345678"; // 8+ chars

// ===================== PINOS =====================
// LED seguro no ESP32-CAM (flash onboard). Se quiser usar 2, troque aqui (n√£o recomendado).
#define LED_FLASH_PIN 4
// Bomba (MOSFET): evite 1/3/2/12/15; 14 √© est√°vel no ESP32-CAM
#define PUMP_PIN 14

// ===================== ESTADO =====================
String g_mode = "manual";
bool   g_ledOn = false;
bool   g_pumpOn = false;
float  g_joyX = 0.0f, g_joyY = 0.0f;

static httpd_handle_t stream_httpd = NULL;
WebServer server(80);

// ===================== CAMERA (AI THINKER) =====================
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ===================== UTILS =====================
String isoTimestamp() {
  time_t now = time(nullptr);
  if (now < 8 * 3600 * 2) {
    unsigned long ms = millis();
    char buf[64];
    snprintf(buf, sizeof(buf), "\"uptime_ms\":%lu", ms);
    return String("{") + buf + "}";
  }
  struct tm timeinfo;
  localtime_r(&now, &timeinfo);
  char buf[64];
  strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S%z", &timeinfo);
  String ts(buf);
  if (ts.length() >= 5) ts = ts.substring(0, ts.length()-2) + ":" + ts.substring(ts.length()-2);
  return "\"" + ts + "\"";
}

void sendCORSHeaders(httpd_req_t *req) {
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Headers", "Content-Type");
}

void sendCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}

// ===================== BOMBA (PWM via ESP-IDF LEDC) =====================
static const ledc_channel_t PUMP_CH   = LEDC_CHANNEL_0;
static const ledc_timer_t   PUMP_TMR  = LEDC_TIMER_0;
static const ledc_mode_t    PUMP_MODE = LEDC_HIGH_SPEED_MODE;

void pumpPwmInit() {
  ledc_timer_config_t tcfg = {};
  tcfg.speed_mode      = PUMP_MODE;
  tcfg.timer_num       = PUMP_TMR;
  tcfg.duty_resolution = LEDC_TIMER_8_BIT; // 0..255
  tcfg.freq_hz         = 5000;            // 5 kHz
  tcfg.clk_cfg         = LEDC_AUTO_CLK;
  ledc_timer_config(&tcfg);

  ledc_channel_config_t ccfg = {};
  ccfg.gpio_num   = PUMP_PIN;
  ccfg.speed_mode = PUMP_MODE;
  ccfg.channel    = PUMP_CH;
  ccfg.intr_type  = LEDC_INTR_DISABLE;
  ccfg.timer_sel  = PUMP_TMR;
  ccfg.duty       = 0;
  ccfg.hpoint     = 0;
  ledc_channel_config(&ccfg);

  g_pumpOn = false;
}

static inline void pumpWriteDuty(uint8_t duty) {
  ledc_set_duty(PUMP_MODE, PUMP_CH, duty);
  ledc_update_duty(PUMP_MODE, PUMP_CH);
}

void pumpSetOnOff(bool on) {
  g_pumpOn = on;
  pumpWriteDuty(on ? 255 : 0);
}

void pumpSetDuty(uint8_t duty) {
  if (duty > 255) duty = 255;
  g_pumpOn = (duty > 0);
  pumpWriteDuty(duty);
}

// ===================== STREAM (/stream) =====================
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";
static const char* _STREAM_BOUNDARY = "\r\n--frame\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

esp_err_t jpg_stream_httpd_handler(httpd_req_t *req) {
  sendCORSHeaders(req);
  camera_fb_t * fb = NULL;
  esp_err_t res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) return res;

  while (true) {
    fb = esp_camera_fb_get();
    if (!fb) return ESP_FAIL;
    if (fb->format != PIXFORMAT_JPEG) { esp_camera_fb_return(fb); continue; }

    res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    if (res == ESP_OK) {
      char part_buf[64];
      size_t hlen = snprintf(part_buf, 64, _STREAM_PART, fb->len);
      res = httpd_resp_send_chunk(req, part_buf, hlen);
    }
    if (res == ESP_OK) res = httpd_resp_send_chunk(req, (const char *)fb->buf, fb->len);

    esp_camera_fb_return(fb);
    if (res != ESP_OK) break;
    vTaskDelay(10 / portTICK_PERIOD_MS);
  }
  return res;
}

void startCameraStreamServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 81;
  config.ctrl_port = 32768;
  config.max_open_sockets = 3;
  config.task_priority = 5;

  httpd_uri_t stream_uri = { .uri="/stream", .method=HTTP_GET, .handler=jpg_stream_httpd_handler, .user_ctx=NULL };
  if (httpd_start(&stream_httpd, &config) == ESP_OK) {
    httpd_register_uri_handler(stream_httpd, &stream_uri);
    Serial.println("Stream em :81/stream");
  }
}

// ===================== API =====================
void api_status() {
  sendCORS();
  String ts = isoTimestamp();
  String json = "{";
  json += "\"ip\":\"" + WiFi.softAPIP().toString() + "\",";
  json += "\"mode\":\"" + g_mode + "\",";
  json += "\"led\":" + String(g_ledOn ? "true":"false") + ",";
  json += "\"pump\":" + String(g_pumpOn ? "true":"false") + ",";
  json += "\"uptime\":" + String(millis()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"ts\":" + ts;
  json += "}";
  server.send(200, "application/json", json);
}

void api_led() {
  sendCORS();
  bool on = server.arg("on") == "1" || server.arg("on") == "true";
  g_ledOn = on;
  digitalWrite(LED_FLASH_PIN, g_ledOn ? HIGH : LOW);
  server.send(200, "application/json", String("{\"ok\":true,\"led\":") + (g_ledOn?"true":"false") + "}");
}

void api_pump() { // on/off r√°pido
  sendCORS();
  bool on = server.arg("on") == "1" || server.arg("on") == "true";
  pumpSetOnOff(on);
  server.send(200, "application/json", String("{\"ok\":true,\"pump\":") + (g_pumpOn?"true":"false") + "}");
}

void api_pump_pwm() { // duty 0..255
  sendCORS();
  int duty = server.hasArg("duty") ? server.arg("duty").toInt() : -1;
  if (duty < 0 || duty > 255) {
    server.send(400, "application/json", "{\"ok\":false,\"error\":\"duty 0..255\"}");
    return;
  }
  pumpSetDuty((uint8_t)duty);
  server.send(200, "application/json", String("{\"ok\":true,\"duty\":") + duty + "}");
}

void api_mode() {
  sendCORS();
  String v = server.arg("v"); if (v.length()==0) v = server.arg("mode");
  if (v != "manual" && v != "auto" && v != "patrol") {
    server.send(400, "application/json", "{\"ok\":false,\"error\":\"mode must be manual|auto|patrol\"}");
    return;
  }
  g_mode = v;
  server.send(200, "application/json", String("{\"ok\":true,\"mode\":\"") + g_mode + "\"}");
}

void api_joystick() {
  sendCORS();
  float x = server.arg("x").toFloat();
  float y = server.arg("y").toFloat();
  if (x < -1) x = -1; if (x > 1) x = 1;
  if (y < -1) y = -1; if (y > 1) y = 1;
  g_joyX = x; g_joyY = y;
  server.send(200, "application/json", String("{\"ok\":true,\"x\":") + x + ",\"y\":" + y + "}");
}

void handleCORS() {
  sendCORS();
  server.send(200);
}

// ===================== SETUP =====================
void setupNTP() {
  configTime(-3 * 3600, 0, "pool.ntp.org", "time.nist.gov");
}

bool initCamera() {
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;

  if (psramFound()) {
    config.frame_size = FRAMESIZE_VGA;
    config.jpeg_quality = 12;
    config.fb_count = 2;
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
  } else {
    config.frame_size = FRAMESIZE_QVGA;
    config.jpeg_quality = 15;
    config.fb_count = 1;
    config.fb_location = CAMERA_FB_IN_DRAM;
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed: 0x%x\n", err);
    return false;
  }
  return true;
}

void startAPOnly() {
  WiFi.mode(WIFI_AP);
  WiFi.softAP(AP_SSID, AP_PASS);
  delay(100);
  Serial.println("AP iniciado:");
  Serial.print(" SSID: "); Serial.println(AP_SSID);
  Serial.print(" PASS: "); Serial.println(AP_PASS);
  Serial.print(" IP: ");   Serial.println(WiFi.softAPIP());
}

void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);
  Serial.begin(115200);
  Serial.println("\n=== HYDROBOT CAM (AP ONLY / SEM SENSORES) ===");

  pinMode(LED_FLASH_PIN, OUTPUT);
  digitalWrite(LED_FLASH_PIN, LOW);

  pumpPwmInit();

  if (!initCamera()) {
    Serial.println("Camera FAIL");
    delay(3000);
    ESP.restart();
  }

  startAPOnly();
  setupNTP();

  // Rotas
  server.on("/status",    HTTP_GET, api_status);
  server.on("/led",       HTTP_GET, api_led);
  server.on("/led",       HTTP_POST, api_led);
  server.on("/pump",      HTTP_GET, api_pump);
  server.on("/pump",      HTTP_POST, api_pump);
  server.on("/pump_pwm",  HTTP_GET, api_pump_pwm);
  server.on("/pump_pwm",  HTTP_POST, api_pump_pwm);
  server.on("/mode",      HTTP_GET, api_mode);
  server.on("/mode",      HTTP_POST, api_mode);
  server.on("/joystick",  HTTP_GET, api_joystick);
  server.on("/joystick",  HTTP_POST, api_joystick);

  // CORS (OPTIONS)
  server.on("/status",   HTTP_OPTIONS, handleCORS);
  server.on("/led",      HTTP_OPTIONS, handleCORS);
  server.on("/pump",     HTTP_OPTIONS, handleCORS);
  server.on("/pump_pwm", HTTP_OPTIONS, handleCORS);
  server.on("/mode",     HTTP_OPTIONS, handleCORS);
  server.on("/joystick", HTTP_OPTIONS, handleCORS);

  server.begin();
  Serial.println("HTTP :80 pronto");
  startCameraStreamServer();
  Serial.println("=== PRONTO ===");
}

void loop() {
  server.handleClient();
  delay(10);
}


































Perfeito ‚Äî o seu ESP est√° ok e o stream est√° em :81/stream. O que est√° te travando √© o WebView com MJPEG, que falha em v√°rios Androids. A solu√ß√£o mais est√°vel √© usar o servidor intermedi√°rio (que voc√™ j√° est√° rodando e que tamb√©m l√™ o MJPEG) para entregar quadros JPEG via /snapshot e o app exibir isso com <Image>. Assim voc√™ v√™ o v√≠deo no app sem depender do suporte do WebView ao multipart/x-mixed-replace.


Abaixo est√° o CameraScreen.tsx completo, j√° ajustado para:




manter todos seus bot√µes (LED, Bomba, Detectar, Joystick);


substituir o WebView por um <Image> que atualiza server/snapshot a cada 250 ms;


continuar usando /detect para o banner de fogo.






S√≥ precisa garantir que o servidor est√° rodando e acess√≠vel em http://SEU_IP:8000.

O ESP continua sendo usado para LED/Bomba/Status. O v√≠deo vem do server/snapshot.





src/screens/CameraScreen.tsx


import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
} from "react-native";

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#ffffff" };

// ajuste estes padr√µes se quiser
const DEFAULT_IP = "192.168.4.1";            // ESP32-CAM (AP)
const DEFAULT_SERVER = "http://192.168.4.2:8000"; // Servidor IA (PC no mesmo AP)

export default function CameraScreen() {
  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");
  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // detec√ß√£o
  const [detectOn, setDetectOn] = useState<boolean>(false);
  const [isFire, setIsFire] = useState<boolean>(false);
  const [fireScore, setFireScore] = useState<number>(0);

  // ‚Äúv√≠deo‚Äù por snapshots do servidor
  const [frameUri, setFrameUri] = useState<string>("");

  // joystick (UI)
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // URLs do ESP
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  // consulta /status do ESP
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl, { method: "GET" });
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }

  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText("Erro ao alternar LED.");
    }
  }

  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText("Erro ao alternar bomba.");
    }
  }

  // ping peri√≥dico de status do ESP
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // ===== V√≠deo por snapshots do servidor =====
  useEffect(() => {
    let stop = false;
    const tick = () => {
      if (stop) return;
      // cache-buster (?ts=) para evitar cache da Image
      setFrameUri(`${server}/snapshot?ts=${Date.now()}`);
      setTimeout(tick, 250); // ~4 fps; ajuste conforme sua m√°quina/rede
    };
    tick();
    return () => {
      stop = true;
    };
  }, [server]);

  // polling de /detect do servidor de IA
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;
    const loop = async () => {
      try {
        const r = await fetch(`${server}/detect`, { method: "GET" });
        const j = await r.json();
        if (!stop && j && j.ok) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
        }
      } finally {
        if (!stop) setTimeout(loop, 500); // ~2 Hz
      }
    };
    loop();
    return () => {
      stop = true;
    };
  }, [detectOn, server]);

  // joystick (UI)
  const RADIUS = 64;
  const KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS;
        let ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny }); // y positivo para cima
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const knobLeft = joy.x * RADIUS;
  const knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="192.168.4.1"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor IA + Detectar */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>Servidor:</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder="http://192.168.4.2:8000"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? "Detectando" : "Detectar"}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>
            {isFire ? `üî• FOGO ‚Ä¢ score ${fireScore.toFixed(2)}` : `Sem fogo ‚Ä¢ score ${fireScore.toFixed(2)}`}
          </Text>
        </View>
      )}

      {/* ‚ÄúV√≠deo‚Äù via snapshots do servidor */}
      <Image
        source={{ uri: frameUri }}
        style={styles.video}
        resizeMode="contain"
        onError={() => {
          // feedback visual simples; mant√©m o polling at√© voltar
          setStatusText("Sem v√≠deo (snapshot). Verifique o servidor /snapshot.");
        }}
      />

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: knobLeft }, { translateY: knobTop }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: PALETTE.bg,
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
    minWidth: 110,
  },
  btn: {
    backgroundColor: "#2b48ff",
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  // v√≠deo por snapshots
  video: { flex: 1, backgroundColor: "black", width: "100%" },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(43,72,255,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});




Por que isso resolve?




Muitos Androids/iOS n√£o renderizam MJPEG em WebView.


O servidor j√° l√™ o MJPEG do ESP e oferece /snapshot (JPEG √∫nico) com CORS liberado ‚Äî perfeito para <Image>.


Trocando para snapshots, o v√≠deo aparece no app de forma est√°vel. Voc√™ pode ajustar o intervalo (250 ms ‚Üí ~4 fps) conforme desempenho.




Se quiser manter duas op√ß√µes (Direto do ESP e Via Servidor) eu coloco um toggle ‚ÄúFonte de v√≠deo‚Äù pra alternar entre WebView e snapshots com um toque.
































Perfeito ‚Äî esse ‚Äúpisca‚Äù acontece porque o <Image> mostra um frame vazio enquanto a pr√≥xima foto carrega. Vamos corrigir com duplo-buffer: mantemos duas imagens sobrepostas; carregamos a pr√≥xima no ‚Äúbuffer oculto‚Äù e s√≥ trocamos a vis√≠vel quando o onLoadEnd confirmar que ela est√° pronta. Assim n√£o h√° frame preto entre uma foto e outra.


Abaixo est√° o CameraScreen.tsx completo j√° com o duplo-buffer (o resto da tela ‚Äî LED, Bomba, Detectar, Joystick ‚Äî permanece igual):


import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
} from "react-native";

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#ffffff" };

// ajuste estes padr√µes se quiser
const DEFAULT_IP = "192.168.4.1";                // ESP32-CAM (AP)
const DEFAULT_SERVER = "http://192.168.4.2:8000"; // Servidor IA (PC no mesmo AP)

// intervalo alvo entre trocas (ms). 200~300 d√° 3‚Äì5 fps sem piscas
const SNAP_INTERVAL_MS = 250;

export default function CameraScreen() {
  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");
  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // detec√ß√£o
  const [detectOn, setDetectOn] = useState<boolean>(false);
  const [isFire, setIsFire] = useState<boolean>(false);
  const [fireScore, setFireScore] = useState<number>(0);

  // snapshot duplo-buffer
  const [uriA, setUriA] = useState<string>("");
  const [uriB, setUriB] = useState<string>("");
  const [showA, setShowA] = useState<boolean>(true); // qual buffer est√° vis√≠vel
  const nextTimer = useRef<ReturnType<typeof setTimeout> | null>(null);
  const waitingRef = useRef<boolean>(false); // esperando carregar o buffer oculto

  // joystick (UI)
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // URLs do ESP
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  // ===== ESP STATUS / CONTROLES =====
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl, { method: "GET" });
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try { const t = !ledOn; await fetch(ledUrl(t)); setLedOn(t); }
    catch { setStatusText("Erro ao alternar LED."); }
  }
  async function togglePump() {
    try { const t = !pumpOn; await fetch(pumpUrl(t)); setPumpOn(t); }
    catch { setStatusText("Erro ao alternar bomba."); }
  }
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // ===== SNAPSHOTS (sem piscar) ‚Äî duplo-buffer =====
  function scheduleNext() {
    if (nextTimer.current) clearTimeout(nextTimer.current);
    nextTimer.current = setTimeout(() => {
      // sempre carrega para o buffer oculto; mant√©m o vis√≠vel intocado
      const nextUri = `${server}/snapshot?ts=${Date.now()}`;
      waitingRef.current = true;
      if (showA) setUriB(nextUri); else setUriA(nextUri);
    }, SNAP_INTERVAL_MS);
  }

  // inicia o ciclo
  useEffect(() => {
    // limpa e for√ßa primeiro frame nos dois buffers (evita ‚Äúflash‚Äù inicial)
    const firstUri = `${server}/snapshot?ts=${Date.now()}`;
    setUriA(firstUri);
    setUriB(firstUri);
    waitingRef.current = false;
    scheduleNext();
    return () => { if (nextTimer.current) clearTimeout(nextTimer.current); };
  }, [server]);

  // quando o buffer oculto terminar de carregar, faz o ‚Äúflip‚Äù sem piscar
  const onLoadEndA = () => {
    // A acabou de carregar; se A est√° oculto, faz flip para A
    if (waitingRef.current && !showA) {
      setShowA(true);
      waitingRef.current = false;
      scheduleNext();
    }
  };
  const onLoadEndB = () => {
    // B acabou de carregar; se B est√° oculto, faz flip para B
    if (waitingRef.current && showA) {
      setShowA(false);
      waitingRef.current = false;
      scheduleNext();
    }
  };

  // ===== DETEC√á√ÉO =====
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;
    const loop = async () => {
      try {
        const r = await fetch(`${server}/detect`, { method: "GET" });
        const j = await r.json();
        if (!stop && j && j.ok) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));
        }
      } catch {
        if (!stop) { setIsFire(false); setFireScore(0); }
      } finally {
        if (!stop) setTimeout(loop, 500);
      }
    };
    loop();
    return () => { stop = true; };
  }, [detectOn, server]);

  // ===== JOYSTICK (UI) =====
  const RADIUS = 64, KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS, ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny); if (len > 1) { nx /= len; ny /= len; }
        setJoy({ x: nx, y: -ny });
      },
      onPanResponderRelease: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
      onPanResponderTerminate: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
    })
  ).current;

  const knobLeft = joy.x * RADIUS, knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder="192.168.4.1"
          autoCapitalize="none" autoCorrect={false} style={styles.input} keyboardType="numeric" />
        <Pressable onPress={pingStatus} style={styles.btn}><Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text></Pressable>
        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}><Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text></Pressable>
        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}><Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text></Pressable>
      </View>

      {/* Linha: Servidor IA + Detectar */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>Servidor:</Text>
        <TextInput value={server} onChangeText={setServer} placeholder="http://192.168.4.2:8000"
          autoCapitalize="none" autoCorrect={false} style={[styles.input, { flex: 1 }]} />
        <Pressable onPress={() => setDetectOn(v => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? "Detectando" : "Detectar"}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>{statusText}</Text>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>
            {isFire ? `üî• FOGO ‚Ä¢ score ${fireScore.toFixed(2)}` : `Sem fogo ‚Ä¢ score ${fireScore.toFixed(2)}`}
          </Text>
        </View>
      )}

      {/* ‚ÄúV√≠deo‚Äù via snapshots com duplo-buffer (sem flicker) */}
      <View style={styles.videoWrap}>
        {/* Buffer A */}
        <Image
          source={{ uri: uriA }}
          style={[styles.video, { opacity: showA ? 1 : 0 }]}
          resizeMode="contain"
          onLoadEnd={onLoadEndA}
          onError={() => setStatusText("Snapshot A falhou")}
        />
        {/* Buffer B */}
        <Image
          source={{ uri: uriB }}
          style={[styles.video, { opacity: showA ? 0 : 1 }]}
          resizeMode="contain"
          onLoadEnd={onLoadEndB}
          onError={() => setStatusText("Snapshot B falhou")}
        />
      </View>

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View style={[styles.joyKnob, { width: KNOB_R * 2, height: KNOB_R * 2, borderRadius: KNOB_R, transform: [{ translateX: knobLeft }, { translateY: knobTop }], opacity: dragging ? 1 : 0.9 }]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: PALETTE.bg,
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
    minWidth: 110,
  },
  btn: { backgroundColor: "#2b48ff", paddingHorizontal: 10, paddingVertical: 10, borderRadius: 10 },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  // √°rea do v√≠deo
  videoWrap: { flex: 1, backgroundColor: "black", overflow: "hidden" },
  video: { position: "absolute", top: 0, left: 0, right: 0, bottom: 0, width: "100%", height: "100%" },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(43,72,255,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});



Observa√ß√µes




Se quiser mais fluidez, diminua SNAP_INTERVAL_MS (ex.: 180 ms).


Se o servidor estiver pesado, aumente (ex.: 300‚Äì400 ms).


Essa t√©cnica mant√©m sempre um frame vis√≠vel enquanto o pr√≥ximo carrega, eliminando o ‚Äúmeio segundo preto‚Äù.




Se preferir, posso adicionar uma transi√ß√£o suave (fade) entre os buffers usando Animated ‚Äî s√≥ falar!


































import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
} from "react-native";

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#ffffff" };

// ajuste estes padr√µes se quiser
const DEFAULT_IP = "192.168.4.1";            // ESP32-CAM (AP)
const DEFAULT_SERVER = "http://192.168.4.2:8000"; // Servidor IA (PC no mesmo AP)

export default function CameraScreen() {
  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");
  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // detec√ß√£o
  const [detectOn, setDetectOn] = useState<boolean>(false);
  const [isFire, setIsFire] = useState<boolean>(false);
  const [fireScore, setFireScore] = useState<number>(0);

  // ‚Äúv√≠deo‚Äù por snapshots do servidor
  const [frameUri, setFrameUri] = useState<string>("");

  // joystick (UI)
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // URLs do ESP
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  // consulta /status do ESP
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl, { method: "GET" });
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }

  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText("Erro ao alternar LED.");
    }
  }

  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText("Erro ao alternar bomba.");
    }
  }

  // ping peri√≥dico de status do ESP
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // ===== V√≠deo por snapshots do servidor =====
  useEffect(() => {
    let stop = false;
    const tick = () => {
      if (stop) return;
      // cache-buster (?ts=) para evitar cache da Image
      setFrameUri(`${server}/snapshot?ts=${Date.now()}`);
      setTimeout(tick, 250); // ~4 fps; ajuste conforme sua m√°quina/rede
    };
    tick();
    return () => {
      stop = true;
    };
  }, [server]);

  // polling de /detect do servidor de IA
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;
    const loop = async () => {
      try {
        const r = await fetch(`${server}/detect`, { method: "GET" });
        const j = await r.json();
        if (!stop && j && j.ok) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
        }
      } finally {
        if (!stop) setTimeout(loop, 500); // ~2 Hz
      }
    };
    loop();
    return () => {
      stop = true;
    };
  }, [detectOn, server]);

  // joystick (UI)
  const RADIUS = 64;
  const KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS;
        let ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny }); // y positivo para cima
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const knobLeft = joy.x * RADIUS;
  const knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="192.168.4.1"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor IA + Detectar */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>Servidor:</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder="http://192.168.4.2:8000"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? "Detectando" : "Detectar"}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>
            {isFire ? `üî• FOGO ‚Ä¢ score ${fireScore.toFixed(2)}` : `Sem fogo ‚Ä¢ score ${fireScore.toFixed(2)}`}
          </Text>
        </View>
      )}

      {/* ‚ÄúV√≠deo‚Äù via snapshots do servidor */}
      <Image
        source={{ uri: frameUri }}
        style={styles.video}
        resizeMode="contain"
        onError={() => {
          // feedback visual simples; mant√©m o polling at√© voltar
          setStatusText("Sem v√≠deo (snapshot). Verifique o servidor /snapshot.");
        }}
      />

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: knobLeft }, { translateY: knobTop }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: PALETTE.bg,
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
    minWidth: 110,
  },
  btn: {
    backgroundColor: "#2b48ff",
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  // v√≠deo por snapshots
  video: { flex: 1, backgroundColor: "black", width: "100%" },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(43,72,255,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});










































perfeito ‚Äî aqui vai uma implementa√ß√£o completa do Dashboard + um pequeno m√≥dulo de persist√™ncia para registrar cada evento de fogo com hor√°rio exato e screenshot (jpeg) salvo no dispositivo.




Requisitos (se ainda n√£o tiver):

expo install expo-file-system

npm i @react-native-async-storage/async-storage && npx pod-install (no iOS)





1) Persist√™ncia dos eventos


Crie src/storage/fireLog.ts:


// src/storage/fireLog.ts
import * as FileSystem from "expo-file-system";
import AsyncStorage from "@react-native-async-storage/async-storage";

export type FireEvent = {
  id: string;       // ex: 2025-09-08T12-34-56.789Z
  ts: number;       // epoch ms
  iso: string;      // ISO string
  imageUri: string; // file://.../fire_events/<id>.jpg
};

const EVENTS_KEY = "fire_events_index_v1";
const DIR = FileSystem.documentDirectory + "fire_events/";

async function ensureDir() {
  const info = await FileSystem.getInfoAsync(DIR);
  if (!info.exists) {
    await FileSystem.makeDirectoryAsync(DIR, { intermediates: true });
  }
}

export async function getEvents(): Promise<FireEvent[]> {
  const raw = await AsyncStorage.getItem(EVENTS_KEY);
  const arr: FireEvent[] = raw ? JSON.parse(raw) : [];
  // mais recente primeiro
  return arr.sort((a, b) => b.ts - a.ts);
}

async function saveIndex(list: FireEvent[]) {
  await AsyncStorage.setItem(EVENTS_KEY, JSON.stringify(list));
}

export async function deleteEvent(id: string) {
  const list = await getEvents();
  const idx = list.findIndex((e) => e.id === id);
  if (idx >= 0) {
    const ev = list[idx];
    // apaga arquivo se existir
    try {
      const info = await FileSystem.getInfoAsync(ev.imageUri);
      if (info.exists) await FileSystem.deleteAsync(ev.imageUri, { idempotent: true });
    } catch {}
    list.splice(idx, 1);
    await saveIndex(list);
  }
}

export async function clearAllEvents() {
  // apaga diret√≥rio e √≠ndice
  try {
    const info = await FileSystem.getInfoAsync(DIR);
    if (info.exists) await FileSystem.deleteAsync(DIR, { idempotent: true });
  } catch {}
  await AsyncStorage.removeItem(EVENTS_KEY);
  await ensureDir();
}

/**
 * Baixa um snapshot do servidor em tempo real e cria um evento.
 * serverBase deve ser algo como: http://192.168.4.2:8000
 */
export async function saveEventFromServer(serverBase: string): Promise<FireEvent> {
  await ensureDir();
  // id com formato seguro para filename
  const now = new Date();
  const iso = now.toISOString();
  const id = iso.replace(/[:]/g, "-"); // : n√£o √© permitido no Windows
  const ts = now.getTime();

  const target = `${DIR}${id}.jpg`;
  const url = `${serverBase.replace(/\/+$/, "")}/snapshot?ts=${ts}`;

  // baixa direto para arquivo (sem base64)
  await FileSystem.downloadAsync(url, target);

  const ev: FireEvent = { id, ts, iso, imageUri: target };
  const list = await getEvents();
  list.push(ev);
  await saveIndex(list);
  return ev;
}




2) Tela do Dashboard


Crie src/screens/DashboardScreen.tsx:


import { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Image,
  Pressable,
  Alert,
  TextInput,
  Modal,
  TouchableOpacity,
  SafeAreaView,
} from "react-native";
import { getEvents, saveEventFromServer, deleteEvent, clearAllEvents, FireEvent } from "../storage/fireLog";

const PALETTE = { bg: "#0a0a0a", card: "#121212", border: "#232323", text: "#e5e7eb", sub: "#9ca3af", accent: "#2b48ff", danger: "#ef4444", ok: "#16a34a" };

// ajuste o padr√£o do servidor conforme seu ambiente
const DEFAULT_SERVER = "http://192.168.4.2:8000";

export default function DashboardScreen() {
  const [server, setServer] = useState<string>(DEFAULT_SERVER);
  const [items, setItems] = useState<FireEvent[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [preview, setPreview] = useState<FireEvent | null>(null);
  const [busy, setBusy] = useState(false);

  async function load() {
    setRefreshing(true);
    try {
      const list = await getEvents();
      setItems(list);
    } finally {
      setRefreshing(false);
    }
  }

  useEffect(() => {
    load();
  }, []);

  async function handleRegisterNow() {
    try {
      setBusy(true);
      const ev = await saveEventFromServer(server);
      setItems((prev) => [ev, ...prev]); // insere no topo
    } catch (e) {
      Alert.alert("Falha ao salvar", "Verifique o servidor /snapshot e a rede.");
    } finally {
      setBusy(false);
    }
  }

  function confirmDelete(ev: FireEvent) {
    Alert.alert("Excluir registro", "Deseja excluir este evento?", [
      { text: "Cancelar", style: "cancel" },
      {
        text: "Excluir",
        style: "destructive",
        onPress: async () => {
          await deleteEvent(ev.id);
          setItems((prev) => prev.filter((x) => x.id !== ev.id));
        },
      },
    ]);
  }

  function confirmClearAll() {
    Alert.alert("Limpar tudo", "Isso apagar√° todos os eventos e imagens. Continuar?", [
      { text: "Cancelar", style: "cancel" },
      {
        text: "Apagar tudo",
        style: "destructive",
        onPress: async () => {
          await clearAllEvents();
          setItems([]);
        },
      },
    ]);
  }

  const renderItem = ({ item }: { item: FireEvent }) => {
    const dateStr = new Date(item.ts).toLocaleString();
    return (
      <Pressable onPress={() => setPreview(item)} style={styles.card}>
        <Image source={{ uri: item.imageUri }} style={styles.thumb} />
        <View style={{ flex: 1 }}>
          <Text style={styles.title}>Detec√ß√£o de fogo</Text>
          <Text style={styles.time}>{dateStr}</Text>
          <Text style={styles.path} numberOfLines={1}>{item.imageUri}</Text>
        </View>
        <Pressable onPress={() => confirmDelete(item)} style={styles.trashBtn}>
          <Text style={styles.trashTxt}>Excluir</Text>
        </Pressable>
      </Pressable>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      {/* Header / controles */}
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Dashboard</Text>
        <Pressable onPress={confirmClearAll} style={styles.clearAllBtn}>
          <Text style={styles.clearAllTxt}>Limpar</Text>
        </Pressable>
      </View>

      {/* Linha de servidor + registrar agora */}
      <View style={styles.row}>
        <Text style={styles.label}>Servidor:</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder="http://192.168.4.2:8000"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={handleRegisterNow} style={[styles.btn, busy && { opacity: 0.6 }]} disabled={busy}>
          <Text style={styles.btnTxt}>{busy ? "Salvando..." : "Registrar agora"}</Text>
        </Pressable>
      </View>

      {/* Lista */}
      <FlatList
        data={items}
        keyExtractor={(it) => it.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={load}
        contentContainerStyle={items.length === 0 && { flex: 1, justifyContent: "center" }}
        ListEmptyComponent={
          <View style={{ alignItems: "center" }}>
            <Text style={{ color: PALETTE.sub }}>Sem eventos ainda.</Text>
            <Text style={{ color: PALETTE.sub, marginTop: 4, textAlign: "center" }}>
              Quando o detector sinalizar fogo, capturemos o snapshot automaticamente.{'\n'}
              Voc√™ tamb√©m pode tocar ‚ÄúRegistrar agora‚Äù.
            </Text>
          </View>
        }
      />

      {/* Preview em tela cheia */}
      <Modal visible={!!preview} transparent animationType="fade" onRequestClose={() => setPreview(null)}>
        <View style={styles.modalBg}>
          <TouchableOpacity style={styles.modalBg} activeOpacity={1} onPress={() => setPreview(null)}>
            {preview && <Image source={{ uri: preview.imageUri }} style={styles.fullImg} resizeMode="contain" />}
          </TouchableOpacity>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },
  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  headerTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700", flex: 1 },
  clearAllBtn: { paddingHorizontal: 10, paddingVertical: 8, backgroundColor: PALETTE.danger, borderRadius: 8 },
  clearAllTxt: { color: "white", fontWeight: "700" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  label: { color: PALETTE.sub, fontSize: 12 },
  input: {
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 140,
  },
  btn: { backgroundColor: PALETTE.accent, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 10 },
  btnTxt: { color: "white", fontWeight: "700" },

  card: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  thumb: { width: 84, height: 56, backgroundColor: "#000", borderRadius: 8 },
  title: { color: PALETTE.text, fontSize: 14, fontWeight: "700" },
  time: { color: PALETTE.sub, fontSize: 12, marginTop: 2 },
  path: { color: "#8b93a3", fontSize: 11, marginTop: 2 },

  trashBtn: { backgroundColor: "#333", paddingHorizontal: 10, paddingVertical: 8, borderRadius: 8 },
  trashTxt: { color: "#fca5a5", fontWeight: "700", fontSize: 12 },

  modalBg: { flex: 1, backgroundColor: "rgba(0,0,0,0.9)", alignItems: "center", justifyContent: "center" },
  fullImg: { width: "100%", height: "100%" },
});




3) Como integrar com a detec√ß√£o da C√¢mera (autom√°tico)


Na sua CameraScreen.tsx, quando o score cruzar o limiar (ou isFire mudar de false ‚Üí true), chame:


import { saveEventFromServer } from "../storage/fireLog";

// ...
const [wasFire, setWasFire] = useState(false);

useEffect(() => {
  if (detectOn && isFire && !wasFire) {
    // registra e evita spam (ex.: s√≥ 1 vez por surto)
    saveEventFromServer(server).catch(() => {});
  }
  setWasFire(isFire);
}, [detectOn, isFire, server]);





Isso vai baixar o /snapshot no momento da detec√ß√£o e guardar no disco + √≠ndice.

O Dashboard automaticamente listar√° o novo evento (se voc√™ chamar load() via pull-to-refresh ou usando um event emitter ‚Äî posso adicionar depois).




Se quiser, eu j√° deixo o CameraScreen chamando e envio a vers√£o pronta com esse useEffect.








































perfeito! abaixo est√° o CameraScreen.tsx completo j√° com a l√≥gica de registrar evento sempre que o fogo for detectado (borda de subida), salvando hor√°rio exato e screenshot via server/snapshot.

Inclu√≠ um cooldown de 5s pra evitar spam enquanto o fogo permanece cont√≠nuo.




Requisitos (se ainda n√£o instalou):




expo install expo-file-system


npm i @react-native-async-storage/async-storage && npx pod-install (no iOS)


crie tamb√©m o arquivo src/storage/fireLog.ts (segue no final)







src/screens/CameraScreen.tsx (com persist√™ncia de eventos)


import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
} from "react-native";
import { saveEventFromServer } from "../storage/fireLog";

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#ffffff" };

// ajuste estes padr√µes se quiser
const DEFAULT_IP = "192.168.4.1";                // ESP32-CAM (AP)
const DEFAULT_SERVER = "http://192.168.4.2:8000"; // Servidor IA (PC no mesmo AP)

export default function CameraScreen() {
  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");
  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // detec√ß√£o
  const [detectOn, setDetectOn] = useState<boolean>(false);
  const [isFire, setIsFire] = useState<boolean>(false);
  const [fireScore, setFireScore] = useState<number>(0);

  // controle de registro (evitar spam)
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef<number>(0);
  const wasFireRef = useRef<boolean>(false);
  const SAVE_COOLDOWN_MS = 5000; // 5s entre registros

  // ‚Äúv√≠deo‚Äù por snapshots do servidor
  const [frameUri, setFrameUri] = useState<string>("");

  // joystick (UI)
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // URLs do ESP
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  // consulta /status do ESP
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl, { method: "GET" });
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }

  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText("Erro ao alternar LED.");
    }
  }

  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText("Erro ao alternar bomba.");
    }
  }

  // ping peri√≥dico de status do ESP
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // ===== V√≠deo por snapshots do servidor =====
  useEffect(() => {
    let stop = false;
    const tick = () => {
      if (stop) return;
      // cache-buster (?ts=) para evitar cache da Image
      setFrameUri(`${server.replace(/\/+$/, "")}/snapshot?ts=${Date.now()}`);
      setTimeout(tick, 250); // ~4 fps; ajuste conforme sua m√°quina/rede
    };
    tick();
    return () => {
      stop = true;
    };
  }, [server]);

  // polling de /detect do servidor de IA
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;
    const loop = async () => {
      try {
        const r = await fetch(`${server.replace(/\/+$/, "")}/detect`, { method: "GET" });
        const j = await r.json();
        if (!stop && j && j.ok) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
        }
      } finally {
        if (!stop) setTimeout(loop, 500); // ~2 Hz
      }
    };
    loop();
    return () => {
      stop = true;
    };
  }, [detectOn, server]);

  // ===== Registro autom√°tico de evento (quando fogo detectado) =====
  useEffect(() => {
    // borda de subida: false -> true
    const risingEdge = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;

    if (detectOn && risingEdge && cooldownOk && !saving) {
      (async () => {
        try {
          setSaving(true);
          await saveEventFromServer(server);
          lastSaveRef.current = Date.now();
          // feedback no status
          const ts = new Date(lastSaveRef.current).toLocaleString();
          setStatusText(`Evento salvo em ${ts}`);
        } catch {
          setStatusText("Falha ao salvar evento (snapshot). Verifique o servidor.");
        } finally {
          setSaving(false);
        }
      })();
    }

    wasFireRef.current = isFire;
  }, [detectOn, isFire, server, saving]);

  // joystick (UI)
  const RADIUS = 64;
  const KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS;
        let ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny }); // y positivo para cima
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const knobLeft = joy.x * RADIUS;
  const knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="192.168.4.1"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor IA + Detectar */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>Servidor:</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder="http://192.168.4.2:8000"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? (saving ? "Salvando..." : "Detectando") : "Detectar"}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>
            {isFire ? `üî• FOGO ‚Ä¢ score ${fireScore.toFixed(2)}` : `Sem fogo ‚Ä¢ score ${fireScore.toFixed(2)}`}
          </Text>
        </View>
      )}

      {/* ‚ÄúV√≠deo‚Äù via snapshots do servidor */}
      <Image
        source={{ uri: frameUri }}
        style={styles.video}
        resizeMode="contain"
        onError={() => {
          setStatusText("Sem v√≠deo (snapshot). Verifique o servidor /snapshot.");
        }}
      />

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: knobLeft }, { translateY: knobTop }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: PALETTE.bg,
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
    minWidth: 110,
  },
  btn: {
    backgroundColor: "#2b48ff",
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  // v√≠deo por snapshots
  video: { flex: 1, backgroundColor: "black", width: "100%" },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(43,72,255,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});




src/storage/fireLog.ts (mesmo do passo anterior)


import * as FileSystem from "expo-file-system";
import AsyncStorage from "@react-native-async-storage/async-storage";

export type FireEvent = {
  id: string;       // ex: 2025-09-08T12-34-56.789Z
  ts: number;       // epoch ms
  iso: string;      // ISO string
  imageUri: string; // file://.../fire_events/<id>.jpg
};

const EVENTS_KEY = "fire_events_index_v1";
const DIR = FileSystem.documentDirectory + "fire_events/";

async function ensureDir() {
  const info = await FileSystem.getInfoAsync(DIR);
  if (!info.exists) {
    await FileSystem.makeDirectoryAsync(DIR, { intermediates: true });
  }
}

export async function getEvents(): Promise<FireEvent[]> {
  const raw = await AsyncStorage.getItem(EVENTS_KEY);
  const arr: FireEvent[] = raw ? JSON.parse(raw) : [];
  return arr.sort((a, b) => b.ts - a.ts);
}

async function saveIndex(list: FireEvent[]) {
  await AsyncStorage.setItem(EVENTS_KEY, JSON.stringify(list));
}

export async function deleteEvent(id: string) {
  const list = await getEvents();
  const idx = list.findIndex((e) => e.id === id);
  if (idx >= 0) {
    const ev = list[idx];
    try {
      const info = await FileSystem.getInfoAsync(ev.imageUri);
      if (info.exists) await FileSystem.deleteAsync(ev.imageUri, { idempotent: true });
    } catch {}
    list.splice(idx, 1);
    await saveIndex(list);
  }
}

export async function clearAllEvents() {
  try {
    const info = await FileSystem.getInfoAsync(DIR);
    if (info.exists) await FileSystem.deleteAsync(DIR, { idempotent: true });
  } catch {}
  await AsyncStorage.removeItem(EVENTS_KEY);
  await ensureDir();
}

/** Baixa um snapshot e registra o evento localmente. */
export async function saveEventFromServer(serverBase: string): Promise<FireEvent> {
  await ensureDir();
  const now = new Date();
  const iso = now.toISOString();
  const id = iso.replace(/[:]/g, "-");
  const ts = now.getTime();

  const target = `${DIR}${id}.jpg`;
  const url = `${serverBase.replace(/\/+$/, "")}/snapshot?ts=${ts}`;

  await FileSystem.downloadAsync(url, target);

  const ev: FireEvent = { id, ts, iso, imageUri: target };
  const list = await getEvents();
  list.push(ev);
  await saveIndex(list);
  return ev;
}




Como validar




Inicie o servidor (/detect e /snapshot).


No app, Detectar ligado.


Quando o banner mostrar üî• FOGO, o app salva o snapshot e o hor√°rio (1 registro a cada ‚â•5s).


Abra a tela Dashboard (se voc√™ j√° criou) para ver a lista; se ainda n√£o, posso te enviar a tela pronta.
















































Perfeito üöÄ

Aqui est√° a tela Settings b√°sica, com suporte a espanhol, ingl√™s e portugu√™s.

Usei AsyncStorage para gravar a escolha e um LanguageContext simples para permitir que todo o app use essa configura√ß√£o depois (quando voc√™ quiser traduzir mais textos).



1) Crie um src/context/LanguageContext.tsx


import React, { createContext, useContext, useEffect, useState } from "react";
import AsyncStorage from "@react-native-async-storage/async-storage";

type Lang = "pt" | "en" | "es";

type LanguageContextType = {
  lang: Lang;
  setLang: (l: Lang) => void;
};

const LanguageContext = createContext<LanguageContextType>({
  lang: "en",
  setLang: () => {},
});

export const useLanguage = () => useContext(LanguageContext);

const STORAGE_KEY = "app_language";

export function LanguageProvider({ children }: { children: React.ReactNode }) {
  const [lang, setLangState] = useState<Lang>("en");

  useEffect(() => {
    (async () => {
      const saved = await AsyncStorage.getItem(STORAGE_KEY);
      if (saved === "pt" || saved === "es" || saved === "en") {
        setLangState(saved);
      }
    })();
  }, []);

  function setLang(l: Lang) {
    setLangState(l);
    AsyncStorage.setItem(STORAGE_KEY, l);
  }

  return (
    <LanguageContext.Provider value={{ lang, setLang }}>
      {children}
    </LanguageContext.Provider>
  );
}



No App.tsx (n√≠vel raiz), envolva seu app com o LanguageProvider:


import { LanguageProvider } from "./src/context/LanguageContext";

export default function App() {
  return (
    <LanguageProvider>
      {/* seu NavigationContainer / Tabs */}
    </LanguageProvider>
  );
}




2) Tela Settings (src/screens/SettingsScreen.tsx)


import { View, Text, StyleSheet, Pressable } from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg: "#0a0a0a", card: "#121212", border: "#232323", text: "#e5e7eb", accent: "#2b48ff" };

export default function SettingsScreen() {
  const { lang, setLang } = useLanguage();

  return (
    <View style={styles.container}>
      <Text style={styles.title}>
        {lang === "pt" ? "Configura√ß√µes" : lang === "es" ? "Configuraciones" : "Settings"}
      </Text>

      <Text style={styles.label}>
        {lang === "pt" ? "Idioma do aplicativo:" : lang === "es" ? "Idioma de la aplicaci√≥n:" : "App language:"}
      </Text>

      <View style={styles.row}>
        <Pressable
          onPress={() => setLang("pt")}
          style={[styles.btn, lang === "pt" && styles.btnActive]}
        >
          <Text style={styles.btnText}>Portugu√™s</Text>
        </Pressable>

        <Pressable
          onPress={() => setLang("en")}
          style={[styles.btn, lang === "en" && styles.btnActive]}
        >
          <Text style={styles.btnText}>English</Text>
        </Pressable>

        <Pressable
          onPress={() => setLang("es")}
          style={[styles.btn, lang === "es" && styles.btnActive]}
        >
          <Text style={styles.btnText}>Espa√±ol</Text>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 20 },
  title: { color: PALETTE.text, fontSize: 22, fontWeight: "700", marginBottom: 20 },
  label: { color: PALETTE.text, marginBottom: 12 },
  row: { flexDirection: "row", gap: 12 },
  btn: {
    backgroundColor: PALETTE.card,
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  btnActive: { backgroundColor: PALETTE.accent, borderColor: PALETTE.accent },
  btnText: { color: "white", fontWeight: "600" },
});




Como funciona




A l√≠ngua escolhida fica salva no AsyncStorage.


Ao abrir o app de novo, a prefer√™ncia √© carregada.


Voc√™ pode usar const { lang } = useLanguage() em qualquer tela e mudar o texto conforme o idioma.





Quer que eu j√° adapte o Dashboard e a Camera pra mostrarem seus labels (ex: ‚ÄúDetectar‚Äù, ‚ÄúBomba‚Äù, ‚ÄúConfigura√ß√µes‚Äù) nos tr√™s idiomas usando esse lang?

