
Segue o server_heuristic.py completo com ajustes para melhorar a estabilidade da ESP32-CAM e reduzir quedas periódicas:




Timeouts mais folgados (CONNECT_TIMEOUT=4s, READ_TIMEOUT=10s) e cabeçalhos keep-alive.


Backoff exponencial nas reconexões do MJPEGGrabber (0.5s → até 5s).


User-Agent fixo para identificação.


Mantém apenas um consumidor do stream (o próprio servidor).


Incluí frame_wh no /detect (ajuda o overlay do app).


O resto do pipeline (fogo + objetos + endpoints) permanece igual.






Dica: mantenha apenas o servidor conectado ao :81/stream. O app deve consumir /snapshot e /detect do servidor, não o stream da ESP diretamente.




# server_heuristic.py
# FOGO (heurístico) + OBJETOS (MobileNet-SSD -> fallback YOLOv4-tiny) com votação/hold anti-pisca
import os, time, threading
from collections import deque
from typing import Optional, List, Tuple, Dict, Any

import numpy as np
import cv2
import requests
from fastapi import FastAPI, Response, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ===================== STREAM =====================
CAMERA_IP = "192.168.4.1"
STREAM_URL_FMT = "http://{}:81/stream"
BOUNDARY = b"--frame"

# Ajustes de robustez
CONNECT_TIMEOUT = 4.0
READ_TIMEOUT = 10.0
JPEG_QUALITY = 85
REQUEST_HEADERS = {
    "Connection": "keep-alive",
    "User-Agent": "HydroBot-Grabber/1.0"
}
MAX_BYTES = 4_000_000

# ===================== FOGO (heurístico) =====================
HSV_LOW = (8, 80, 120)
HSV_HIGH = (40, 255, 255)
RED_DELTA = 15

DETECTOR_MAX_FPS = 14.0
HYST_HIGH = 0.18
HYST_LOW  = 0.15
VOTE_WINDOW = 7
VOTE_NEED   = 4
EMA_ALPHA   = 0.25
MIN_BLOB_AREA = 1200
KERNEL_SZ = 5

MOTION_THRESH = 22
MOTION_DILATE_ITERS = 1

PERSIST_CONSEC = 2
IOU_MIN = 0.15

MAX_FRAME_AGE_MS = 3000
MAX_RESULT_AGE_MS = 800

# ===================== OBJETOS =====================
OBJECTS_MAX_FPS = 12.0
OBJ_CONF_THRESH = 0.25
OBJ_NMS_THRESH  = 0.45

# anti-pisca (votação/hold)
VOTE_WIN_OBJ   = 10
VOTE_NEED_OBJ  = 3
HOLD_MS_OBJ    = 900

COCO_ANIMAL_NAMES = {"person","cat","dog","bird","horse","sheep","cow"}

# MobileNet-SSD (VOC)
MNET_CLASSES = [
    "background","aeroplane","bicycle","bird","boat","bottle","bus","car","cat","chair",
    "cow","diningtable","dog","horse","motorbike","person","pottedplant","sheep","sofa","train","tvmonitor"
]
MNET_ANIMALS = {"person","cat","dog","bird","horse","sheep","cow"}
MNET_IN_SIZE = (300,300); MNET_SCALE = 0.007843; MNET_MEAN = 127.5
MNET_PROTOTXT_CANDS = [
    "./models/MobileNetSSD_deploy.prototxt",
    "./models/MobileNetSSD_deploy.prototxt.txt",
    "./models/deploy.prototxt",
    "./models/voc/MobileNetSSD_test.prototxt",
]
MNET_WEIGHTS_CANDS = [
    "./models/MobileNetSSD_deploy.caffemodel",
    "./models/mobilenet_iter_73000.caffemodel",
]

# YOLOv4-tiny (COCO)
YOLO_CFG  = "./models/yolov4-tiny.cfg"
YOLO_WTS  = "./models/yolov4-tiny.weights"
COCO_NAMES= "./models/coco.names"
YOLO_IN_SZ = (416,416)

# ===================== FASTAPI =====================
app = FastAPI(title="HydroBot Fire + Objects (Stable)", version="1.7.0")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
    camera_ip: str

# ===================== PLACEHOLDER =====================
def placeholder_jpeg(msg: str = "NO FRAME") -> bytes:
    img = np.zeros((270, 480, 3), dtype=np.uint8)
    img[:, :] = (40, 40, 200)
    cv2.putText(img, msg, (20, 150), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255,255,255), 2, cv2.LINE_AA)
    cv2.putText(img, time.strftime("%H:%M:%S"), (20, 200), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255,255,255), 2, cv2.LINE_AA)
    ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), 80])
    return buf.tobytes()

# ===================== GRABBER =====================
class MJPEGGrabber:
    """
    Consumidor único do :81/stream com reconexão gentil (backoff) e keep-alive.
    """
    def __init__(self):
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._ip = CAMERA_IP
        self._last_jpeg: Optional[bytes] = None
        self._last_ts_ms: int = 0
        self._frames = 0
        self._fps = 0.0
        self._last_fps_tick = time.time()
        self._session = requests.Session()

    def start(self, ip: Optional[str] = None):
        if ip: self._ip = ip
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)
        self._thread = None

    def _run(self):
        backoff = 0.5  # s (exponencial até 5s)
        while not self._stop.is_set():
            url = STREAM_URL_FMT.format(self._ip)
            try:
                with self._session.get(
                    url,
                    stream=True,
                    timeout=(CONNECT_TIMEOUT, READ_TIMEOUT),
                    headers=REQUEST_HEADERS,
                ) as r:
                    if r.status_code != 200:
                        time.sleep(backoff)
                        backoff = min(backoff*2, 5.0)
                        continue
                    # conectou — reset backoff
                    backoff = 0.2
                    buf = b""
                    self._frames = 0
                    self._last_fps_tick = time.time()

                    for chunk in r.iter_content(chunk_size=4096):
                        if self._stop.is_set():
                            break
                        if not chunk:
                            continue
                        buf += chunk
                        if len(buf) > MAX_BYTES:
                            # proteção contra lixo acumulado
                            buf = b""

                        i = buf.find(BOUNDARY)
                        if i == -1:
                            continue

                        hdr_start = i + len(BOUNDARY)
                        # pula CRLF extras
                        while hdr_start + 2 <= len(buf) and buf[hdr_start:hdr_start+2] == b"\r\n":
                            hdr_start += 2

                        headers_end = buf.find(b"\r\n\r\n", hdr_start)
                        if headers_end == -1:
                            continue

                        headers_bytes = buf[hdr_start:headers_end]
                        content_length = None
                        for line in headers_bytes.split(b"\r\n"):
                            if line.lower().startswith(b"content-length:"):
                                try:
                                    content_length = int(line.split(b":", 1)[1].strip())
                                except:
                                    content_length = None
                                break

                        img_start = headers_end + 4
                        jpeg_bytes = None
                        if content_length is not None:
                            if len(buf) < img_start + content_length:
                                continue
                            jpeg_bytes = buf[img_start:img_start + content_length]
                            buf = buf[img_start + content_length:]
                        else:
                            j = buf.find(BOUNDARY, img_start)
                            if j != -1:
                                jpeg_bytes = buf[img_start:j]
                                buf = buf[j:]
                            else:
                                continue

                        if jpeg_bytes:
                            ts_ms = int(time.time() * 1000)
                            with self._lock:
                                self._last_jpeg = jpeg_bytes
                                self._last_ts_ms = ts_ms
                            self._frames += 1
                            now = time.time()
                            if now - self._last_fps_tick >= 1.0:
                                self._fps = self._frames / (now - self._last_fps_tick)
                                self._frames = 0
                                self._last_fps_tick = now

            except Exception:
                # espera com backoff antes de tentar de novo
                time.sleep(backoff)
                backoff = min(backoff*2, 5.0)

    def get_latest_jpeg(self, max_age_ms: int = MAX_FRAME_AGE_MS) -> Optional[bytes]:
        with self._lock:
            if self._last_jpeg is None:
                return None
            if int(time.time() * 1000) - self._last_ts_ms > max_age_ms:
                return None
            return self._last_jpeg

    def status(self):
        with self._lock:
            age_ms = (int(time.time() * 1000) - self._last_ts_ms) if self._last_ts_ms else None
            return {"ip": self._ip, "hasFrame": self._last_jpeg is not None, "age_ms": age_ms,
                    "fps_in": round(self._fps, 2), "ts_ms": self._last_ts_ms}

grabber = MJPEGGrabber()
grabber.start(CAMERA_IP)

# ===================== VISÃO (fogo) =====================
def rgb_red_dominance_mask(frame_bgr: np.ndarray, delta: int = RED_DELTA) -> np.ndarray:
    b, g, r = cv2.split(frame_bgr)
    return ((r.astype(np.int16) > (g.astype(np.int16) + delta)) &
            (r.astype(np.int16) > (b.astype(np.int16) + delta))).astype(np.uint8) * 255

def hsv_fire_mask(frame_bgr: np.ndarray) -> np.ndarray:
    hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
    return cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))

def skin_mask_ycrcb(frame_bgr: np.ndarray) -> np.ndarray:
    ycrcb = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2YCrCb)
    y, cr, cb = cv2.split(ycrcb)
    skin = cv2.inRange(ycrcb, (0,133,77), (255,173,127))
    dark = cv2.threshold(y, 60, 255, cv2.THRESH_BINARY)[1]
    return cv2.bitwise_and(skin, dark)

def iou(a: Tuple[int,int,int,int], b: Tuple[int,int,int,int]) -> float:
    ax, ay, aw, ah = a; bx, by, bw, bh = b
    ax2, ay2 = ax+aw, ay+ah; bx2, by2 = bx+bw, by+bh
    ix1, iy1 = max(ax,bx), max(ay,by); ix2, iy2 = min(ax2,bx2), min(ay2,by2)
    iw, ih = max(0, ix2-ix1), max(0, iy2-iy1)
    inter = iw*ih; union = aw*ah + bw*bh - inter
    return float(inter)/float(union) if union>0 else 0.0

def boxes_from_mask(mask_bin: np.ndarray, min_area: int = MIN_BLOB_AREA) -> List[List[int]]:
    k = np.ones((KERNEL_SZ,KERNEL_SZ), np.uint8)
    m = cv2.morphologyEx(mask_bin, cv2.MORPH_OPEN, k, 1)
    m = cv2.morphologyEx(m, cv2.MORPH_DILATE, k, 1)
    cnts, _ = cv2.findContours(m, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    boxes = []
    for c in cnts:
        x,y,w,h = cv2.boundingRect(c)
        if w*h >= min_area: boxes.append([x,y,w,h])
    return boxes

class Detector:
    def __init__(self, src: MJPEGGrabber):
        self.src = src
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._prev_gray: Optional[np.ndarray] = None
        self._score_raw = 0.0; self._score_ema = 0.0
        self._is_fire = False; self._boxes: List[List[int]] = []
        self._votes = deque(maxlen=VOTE_WINDOW); self._persist_hits = 0
        self._last_main_box: Optional[Tuple[int,int,int,int]] = None
        self._det_fps = 0.0; self._det_frames = 0; self._last_fps_tick = time.time()
        self._last_result_ts = 0
        self._last_frame_wh: Tuple[int,int] = (0,0)

    def start(self):
        self.stop(); self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True); self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive(): self._thread.join(timeout=1.0)
        self._thread = None

    def _run(self):
        min_interval = 1.0/DETECTOR_MAX_FPS
        while not self._stop.is_set():
            t0 = time.time()
            jpeg = self.src.get_latest_jpeg()
            if jpeg is None: time.sleep(0.01); continue
            frame = cv2.imdecode(np.frombuffer(jpeg,np.uint8), cv2.IMREAD_COLOR)
            if frame is None: time.sleep(0.005); continue
            H,W = frame.shape[:2]
            self._last_frame_wh = (W,H)

            mask_hsv = hsv_fire_mask(frame)
            mask_skin = skin_mask_ycrcb(frame)
            mask_red  = rgb_red_dominance_mask(frame)

            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            gray = cv2.GaussianBlur(gray,(3,3),0)
            motion_mask = np.zeros_like(gray,np.uint8)
            if self._prev_gray is not None:
                diff = cv2.absdiff(gray,self._prev_gray)
                _, motion_mask = cv2.threshold(diff, MOTION_THRESH, 255, cv2.THRESH_BINARY)
                if MOTION_DILATE_ITERS>0:
                    k = np.ones((3,3),np.uint8)
                    motion_mask = cv2.morphologyEx(motion_mask, cv2.MORPH_DILATE, k, MOTION_DILATE_ITERS)
            self._prev_gray = gray

            stable = cv2.bitwise_and(mask_hsv, cv2.bitwise_not(mask_skin))
            stable = cv2.bitwise_and(stable, cv2.bitwise_not(motion_mask))

            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
            V = hsv[...,2]
            bright = cv2.threshold(V,200,255,cv2.THRESH_BINARY)[1]
            red_boost = cv2.bitwise_and(mask_red,bright)
            combined = cv2.bitwise_or(stable, red_boost)

            ratio_hsv = float(np.count_nonzero(mask_hsv))/float(mask_hsv.size)
            v_mean = float(np.mean(V))/255.0
            score_raw = min(1.0, ratio_hsv*4.0 + v_mean*0.2)
            ratio_combined = float(np.count_nonzero(combined))/float(combined.size)
            score_combined = min(1.0, ratio_combined*5.0 + v_mean*0.1)
            ema = score_combined if self._score_ema==0.0 else (EMA_ALPHA*score_combined + (1.0-EMA_ALPHA)*self._score_ema)

            boxes = boxes_from_mask(combined, MIN_BLOB_AREA)
            main_box = None
            if boxes:
                areas = [w*h for(_,_,w,h) in boxes]; main_box = boxes[int(np.argmax(areas))]
                if self._last_main_box is not None:
                    self._persist_hits = self._persist_hits+1 if iou(tuple(main_box),tuple(self._last_main_box))>=IOU_MIN else 1
                else: self._persist_hits = 1
            else: self._persist_hits = 0
            self._last_main_box = tuple(main_box) if main_box is not None else None

            if ema>=HYST_HIGH and self._persist_hits>=PERSIST_CONSEC: guess=1
            elif ema<=HYST_LOW: guess=0
            else: guess=(1 if (len(self._votes)>0 and self._votes[-1]==1 and self._persist_hits>=PERSIST_CONSEC) else 0)

            self._votes.append(guess)
            final_fire = 1 if sum(self._votes)>=VOTE_NEED else 0

            with self._lock:
                self._score_raw=float(score_raw); self._score_ema=float(ema)
                self._is_fire=bool(final_fire==1); self._boxes=boxes if self._is_fire else []
                self._last_result_ts=int(time.time()*1000)
                self._det_frames+=1
                now=time.time()
            if now-self._last_fps_tick>=1.0:
                self._det_fps=self._det_frames/(now-self._last_fps_tick)
                self._det_frames=0; self._last_fps_tick=now

            elapsed = time.time()-t0
            if elapsed<min_interval: time.sleep(min_interval-elapsed)

    def get_result(self)->Dict[str,Any]:
        with self._lock:
            return {
                "ok": True,
                "isFire": self._is_fire,
                "score": round(self._score_ema,3),
                "score_raw": round(self._score_raw,3),
                "score_ema": round(self._score_ema,3),
                "boxes": self._boxes,
                "ts": self._last_result_ts,
                "fps_det": round(self._det_fps,2),
                "vote": {"win":VOTE_WINDOW,"need":VOTE_NEED,"sum":int(sum(self._votes))},
                "persist": {"hits":self._persist_hits,"need":PERSIST_CONSEC,"iou_min":IOU_MIN},
                "hyst": {"hi":HYST_HIGH,"lo":HYST_LOW},
                "frame_wh": list(self._last_frame_wh) if self._last_frame_wh else None,
            }

detector = Detector(grabber); detector.start()

# ===================== OBJETOS (AutoBackend + votos/hold) =====================
class ObjectsDetector:
    def __init__(self, src: MJPEGGrabber):
        self.src = src
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None

        self.backend = "mobilenet-ssd"   # ou "yolov4-tiny"
        self.net = None; self.ok = False
        self.proto = None; self.weights = None; self.cfg = None; self.names = None
        self.labels = []
        self.swap_rb = False
        self._nohit = 0
        self._last_conf_max = 0.0

        self.votes_person = deque(maxlen=VOTE_WIN_OBJ)
        self.votes_animal = deque(maxlen=VOTE_WIN_OBJ)
        self.hold_person_until = 0
        self.hold_animal_until = 0

        self._frames = 0; self._fps = 0.0; self._last_fps_tick = time.time()
        self._last: Dict[str, Any] = {"ok": False, "backend": self.backend, "fps_obj": 0.0, "objects": [], "ts": 0}

        self._try_load_mnet()
        if not self.ok:
            self._try_load_yolo()

    def _try_load_mnet(self):
        self.backend = "mobilenet-ssd"
        self.labels = MNET_CLASSES
        self.proto = next((p for p in MNET_PROTOTXT_CANDS if os.path.exists(p)), None)
        self.weights = next((w for w in MNET_WEIGHTS_CANDS if os.path.exists(w)), None)
        if not self.proto or not self.weights:
            self.ok = False; self.net=None; return
        try:
            net = cv2.dnn.readNetFromCaffe(self.proto, self.weights)
            net.setPreferableBackend(cv2.dnn.DNN_BACKEND_OPENCV)
            net.setPreferableTarget(cv2.dnn.DNN_TARGET_CPU)
            self.net = net; self.ok = True; self.swap_rb=False
        except Exception:
            self.ok = False; self.net=None

    def _try_load_yolo(self):
        self.backend = "yolov4-tiny"
        if not (os.path.exists(YOLO_CFG) and os.path.exists(YOLO_WTS) and os.path.exists(COCO_NAMES)):
            self.ok=False; self.net=None; return
        try:
            net = cv2.dnn.readNetFromDarknet(YOLO_CFG, YOLO_WTS)
            net.setPreferableBackend(cv2.dnn.DNN_BACKEND_OPENCV)
            net.setPreferableTarget(cv2.dnn.DNN_TARGET_CPU)
            with open(COCO_NAMES, "r", encoding="utf-8") as f:
                self.labels = [ln.strip() for ln in f if ln.strip()]
            self.net = net; self.ok = True
        except Exception:
            self.ok=False; self.net=None

    def start(self):
        self.stop(); self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True); self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive(): self._thread.join(timeout=1.0)
        self._thread=None

    def _infer_mnet(self, frame, conf_th):
        (h,w)=frame.shape[:2]
        blob = cv2.dnn.blobFromImage(cv2.resize(frame,MNET_IN_SIZE),
                                     MNET_SCALE, MNET_IN_SIZE, MNET_MEAN, swapRB=self.swap_rb, crop=False)
        self.net.setInput(blob); det=self.net.forward()
        boxes=[]; confs=[]; labels=[]
        conf_max=0.0
        for i in range(det.shape[2]):
            conf=float(det[0,0,i,2]); conf_max=max(conf_max, conf)
            if conf<conf_th: continue
            idx=int(det[0,0,i,1])
            if 0<=idx<len(self.labels):
                label=self.labels[idx]
                if label not in MNET_ANIMALS: continue
                x1,y1,x2,y2=(det[0,0,i,3:7]*np.array([w,h,w,h])).astype(int)
                x,y=max(0,x1),max(0,y1); rw,rh=max(0,x2-x),max(0,y2-y)
                if rw*rh<=0: continue
                boxes.append([x,y,rw,rh]); confs.append(conf); labels.append(label)
        idxs=cv2.dnn.NMSBoxes(boxes,confs,conf_th,OBJ_NMS_THRESH)
        keep = [int(i) for i in (idxs.flatten().tolist() if isinstance(idxs,np.ndarray) else (idxs or []))]
        out=[{"label":labels[i],"conf":float(confs[i]),"box":boxes[i]} for i in keep]
        out.sort(key=lambda o:o["conf"], reverse=True)
        return out[:15], conf_max

    def _infer_yolo(self, frame, conf_th):
        (H,W)=frame.shape[:2]
        ln = self.net.getUnconnectedOutLayersNames()
        blob = cv2.dnn.blobFromImage(frame, 1/255.0, YOLO_IN_SZ, swapRB=True, crop=False)
        self.net.setInput(blob); layerOutputs = self.net.forward(ln)
        boxes=[]; confs=[]; labels=[]
        conf_max = 0.0
        for output in layerOutputs:
            for det in output:
                scores = det[5:]
                classID = int(np.argmax(scores))
                conf = float(scores[classID])
                conf_max = max(conf_max, conf)
                if conf < conf_th: continue
                label = self.labels[classID] if 0<=classID<len(self.labels) else str(classID)
                if label not in COCO_ANIMAL_NAMES: continue
                bx = det[0:4]
                (cx,cy,w,h) = (bx[0]*W, bx[1]*H, bx[2]*W, bx[3]*H)
                x = int(cx - w/2); y = int(cy - h/2)
                boxes.append([max(0,x), max(0,y), int(w), int(h)])
                confs.append(conf); labels.append(label)
        idxs=cv2.dnn.NMSBoxes(boxes,confs,conf_th,OBJ_NMS_THRESH)
        keep = [int(i) for i in (idxs.flatten().tolist() if isinstance(idxs,np.ndarray) else (idxs or []))]
        out=[{"label":labels[i],"conf":float(confs[i]),"box":[int(v) for v in boxes[i]]} for i in keep]
        out.sort(key=lambda o:o["conf"], reverse=True)
        return out[:15], conf_max

    def _run(self):
        min_interval = 1.0/OBJECTS_MAX_FPS
        while not self._stop.is_set():
            t0 = time.time()
            jpeg = self.src.get_latest_jpeg()
            if jpeg is None: time.sleep(0.01); continue
            frame = cv2.imdecode(np.frombuffer(jpeg,np.uint8), cv2.IMREAD_COLOR)
            if frame is None: time.sleep(0.005); continue

            out=[]; cmax=0.0; backend=self.backend
            if self.ok and self.net is not None:
                try:
                    if self.backend=="mobilenet-ssd":
                        out,cmax = self._infer_mnet(frame, OBJ_CONF_THRESH)
                        self._nohit = self._nohit+1 if cmax<0.05 else 0
                        if self._nohit>=10:
                            self.swap_rb = not self.swap_rb
                            self._nohit = 0
                    else:
                        out,cmax = self._infer_yolo(frame, OBJ_CONF_THRESH)
                except Exception as e:
                    self.ok=False
                    with self._lock:
                        self._last={"ok":False,"backend":backend,"fps_obj":round(self._fps,2),
                                    "objects":[], "ts":int(time.time()*1000), "error":f"forward failed: {e}"}
                    time.sleep(0.05); continue

            # fallback para YOLO se MNet estiver “mudo”
            if (backend=="mobilenet-ssd" and cmax<0.05 and
                os.path.exists(YOLO_CFG) and os.path.exists(YOLO_WTS) and os.path.exists(COCO_NAMES)):
                self._try_load_yolo()
                backend=self.backend
                if self.ok and self.backend=="yolov4-tiny":
                    out,cmax = self._infer_yolo(frame, max(0.2, OBJ_CONF_THRESH))

            n_person  = sum(1 for o in out if o["label"]=="person")
            n_animals = sum(1 for o in out if o["label"]!="person")
            hit_person  = 1 if n_person  > 0 else 0
            hit_animal  = 1 if n_animals > 0 else 0
            self.votes_person.append(hit_person)
            self.votes_animal.append(hit_animal)
            now_ms = int(time.time()*1000)
            if hit_person: self.hold_person_until = now_ms + HOLD_MS_OBJ
            if hit_animal: self.hold_animal_until = now_ms + HOLD_MS_OBJ
            stable_person = (sum(self.votes_person) >= VOTE_NEED_OBJ) or (now_ms < self.hold_person_until)
            stable_animal = (sum(self.votes_animal) >= VOTE_NEED_OBJ) or (now_ms < self.hold_animal_until)

            with self._lock:
                self._last_conf_max=cmax
                self._last={"ok":bool(self.ok),"backend":backend,"fps_obj":round(self._fps,2),
                            "objects":out,"ts":int(time.time()*1000),
                            "proto":self.proto,"weights":self.weights,"cfg":YOLO_CFG if backend=="yolov4-tiny" else None,
                            "names":COCO_NAMES if backend=="yolov4-tiny" else None,
                            "conf_max":round(cmax,3),"swap_rb":self.swap_rb,
                            "n_person":n_person,"n_animals":n_animals,
                            "n_person_stable":1 if stable_person else 0,
                            "n_animals_stable":1 if stable_animal else 0}

            self._frames+=1; now=time.time()
            if now-self._last_fps_tick>=1.0:
                self._fps=self._frames/(now-self._last_fps_tick); self._frames=0; self._last_fps_tick=now

            dt = time.time()-t0
            if dt<min_interval: time.sleep(min_interval-dt)

    def get(self)->Dict[str,Any]:
        with self._lock:
            return dict(self._last)

objects_det = ObjectsDetector(grabber); objects_det.start()

# ===================== ENDPOINTS =====================
@app.get("/status")
def status():
    s1 = grabber.status(); s2 = detector.get_result()
    return {"ok": True, "camera_ip": s1["ip"], "model": "balanced_detector",
            "fps_in": s1["fps_in"], "hasFrame": s1["hasFrame"], "age_ms": s1["age_ms"], **s2}

@app.post("/config")
def set_config(cfg: ConfigIn):
    global CAMERA_IP
    CAMERA_IP = cfg.camera_ip
    grabber.start(CAMERA_IP)
    return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
    jpeg = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS)
    if jpeg is None: jpeg = placeholder_jpeg("NO LIVE FRAME")
    return Response(content=jpeg, media_type="image/jpeg")

@app.get("/detect")
def detect():
    res = detector.get_result()
    res["objects"] = objects_det.get()
    if res.get("ts", 0) and (int(time.time()*1000)-res["ts"] <= MAX_RESULT_AGE_MS):
        return res
    # fallback rápido (fogo somente)
    jpeg = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS)
    if jpeg is None: return {"ok": False, "error": "no recent frame"}
    frame = cv2.imdecode(np.frombuffer(jpeg,np.uint8), cv2.IMREAD_COLOR)
    if frame is None: return {"ok": False, "error": "decode failed"}
    H,W = frame.shape[:2]
    mask_hsv = hsv_fire_mask(frame)
    ratio_hsv = float(np.count_nonzero(mask_hsv))/float(mask_hsv.size)
    v_mean = float(np.mean(cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)[...,2]))/255.0
    score_raw = min(1.0, ratio_hsv*4.0 + v_mean*0.2)
    is_fire = bool(score_raw >= HYST_HIGH)
    return {"ok":True,"isFire":is_fire,"score":round(score_raw,3),"score_raw":round(score_raw,3),
            "score_ema":round(score_raw,3),"boxes":[],"ts":int(time.time()*1000),"fallback":True,
            "frame_wh":[W,H],
            "objects": objects_det.get()}

@app.get("/objects")
def objects(conf: float = Query(None)):
    global OBJ_CONF_THRESH
    if conf is not None:
        OBJ_CONF_THRESH = max(0.05, min(0.95, float(conf)))
    return objects_det.get()

@app.get("/objects_frame")
def objects_frame(conf: float = Query(0.25)):
    jpeg = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS)
    if jpeg is None: return Response(content=placeholder_jpeg("NO LIVE FRAME"), media_type="image/jpeg")
    frame = cv2.imdecode(np.frombuffer(jpeg,np.uint8), cv2.IMREAD_COLOR)
    if frame is None: return Response(content=placeholder_jpeg("DECODE ERR"), media_type="image/jpeg")

    o = objects_det.get(); backend = o.get("backend"); det = objects_det
    try:
        if backend=="yolov4-tiny":
            objs, _ = det._infer_yolo(frame, max(0.05, min(0.95, conf)))
        else:
            objs, _ = det._infer_mnet(frame, max(0.05, min(0.95, conf)))
    except Exception:
        return Response(content=placeholder_jpeg("FORWARD ERR"), media_type="image/jpeg")

    for obj in objs:
        x,y,w,h = obj["box"]
        cv2.rectangle(frame,(x,y),(x+w,y+h),(0,255,0),2)
        cv2.putText(frame, f'{obj["label"]} {obj["conf"]:.2f}', (x, max(15,y-6)),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,255,0), 1, cv2.LINE_AA)
    ok, buf = cv2.imencode(".jpg", frame, [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY])
    return Response(content=buf.tobytes(), media_type="image/jpeg")

@app.get("/debug_models")
def debug_models():
    o = objects_det.get(); s = grabber.status()
    return {"ok":True, "backend":o.get("backend"), "objects_ok":o.get("ok"),
            "proto":o.get("proto"), "weights":o.get("weights"),
            "cfg":o.get("cfg"), "names":o.get("names"),
            "swap_rb":o.get("swap_rb"), "conf_max":o.get("conf_max"),
            "conf_thresh":OBJ_CONF_THRESH, "fps_obj":o.get("fps_obj"),
            "stream_hasFrame":s.get("hasFrame"), "stream_fps_in":s.get("fps_in"),
            "n_person":o.get("n_person"), "n_animals":o.get("n_animals"),
            "n_person_stable":o.get("n_person_stable"), "n_animals_stable":o.get("n_animals_stable"),
            "num_objects":len(o.get("objects",[])), "error":o.get("error")}



O que mudou (em resumo)




requests.Session() + keep-alive → menos custo por conexão.


Reconexão com backoff exponencial → evita “martelar” a ESP quando o link oscila.


Timeouts mais tolerantes → menos quedas por leitura lenta.


frame_wh nos resultados → o app posiciona as caixas com precisão.




Se ainda observar quedas: confirme fonte 5V parruda, Wi-Fi STA (em vez de AP) e um único cliente no :81/stream.









































Aqui está o CameraScreen.tsx completo já com:




Detecção sempre ativa (sem botão).


Snapshot em ~30 fps (FPS_INTERVAL = 33).


Crossfade rápido (duration = 16).


Sem seletor de stream e sem botão de boxes (mas o overlay de caixas segue funcionando).


Logo com caminho correto ../../assets/logo.png.


Visual no mesmo tema “vermelhinho”.




Cole em HydroBotApp2/src/screens/CameraScreen.tsx:


// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
  Animated,
  LayoutChangeEvent,
} from "react-native";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ---------- TEMA ---------- */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#151318",
  border: "#2b2230",
  accent: "#E6403A",
  text: "#f1f5f9",
};

/* ---------- TEXTOS ---------- */
const textsByLang = {
  pt: {
    heroSubtitle: "Monitoramento e Controle",
    espIp: "ESP IP:",
    test: "Testar",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "BOMBA ON",
    pumpOff: "BOMBA OFF",
    server: "Servidor:",
    detecting: "Detectando…",
    saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi/IP.",
    noVideo: "Sem vídeo (snapshot). Verifique o servidor.",
    fireOn: (s: number) => `🔥 FOGO • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sem fogo • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento salvo em ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    persons: "Pessoas",
    animals: "Animais",
    backend: "Modelo",
  },
  en: {
    heroSubtitle: "Monitoring & Control",
    espIp: "ESP IP:",
    test: "Test",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "PUMP ON",
    pumpOff: "PUMP OFF",
    server: "Server:",
    detecting: "Detecting…",
    saving: "Saving...",
    statusFail: "Failed to connect. Check Wi-Fi/IP.",
    noVideo: "No video (snapshot). Check the server.",
    fireOn: (s: number) => `🔥 FIRE • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `No fire • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Event saved at ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    persons: "People",
    animals: "Animals",
    backend: "Model",
  },
  es: {
    heroSubtitle: "Monitoreo y Control",
    espIp: "ESP IP:",
    test: "Probar",
    ledOn: "LED ENC.",
    ledOff: "LED APAG.",
    pumpOn: "BOMBA ENC.",
    pumpOff: "BOMBA APAG.",
    server: "Servidor:",
    detecting: "Detectando…",
    saving: "Guardando...",
    statusFail: "Error de conexión. Revisa Wi-Fi/IP.",
    noVideo: "Sin vídeo (snapshot). Revisa el servidor.",
    fireOn: (s: number) => `🔥 FUEGO • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sin fuego • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento guardado a las ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    persons: "Personas",
    animals: "Animales",
    backend: "Modelo",
  },
};

const DEFAULT_IP = "192.168.4.1";
const DEFAULT_SERVER = "http://192.168.4.2:8000";

/* ---------- Logo (caminho correto a partir de src/screens) ---------- */
const appLogo = require("../../assets/logo.png");

/* ---------- HERO ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ---------- SNAPSHOT com crossfade (rápido) ---------- */
function CrossfadeImage({
  currentUri,
  nextUri,
  onNextLoadStart,
  onNextShown,
}: {
  currentUri: string;
  nextUri: string;
  onNextLoadStart: () => void;
  onNextShown: () => void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}

      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={onNextShown}
            onLoadEnd={() => {
              // crossfade curtinho para não derrubar FPS
              Animated.timing(fade, { toValue: 1, duration: 16, useNativeDriver: true }).start(() => {
                onNextShown();
                fade.setValue(0);
                setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- OVERLAY DE CAIXAS ---------- */
type BoxType = "fire" | "person" | "animal";
type SrcBox = { x: number; y: number; w: number; h: number; type: BoxType; conf?: number };

function BoxesOverlay({
  frameWH,
  containerWH,
  boxes,
}: {
  frameWH: { w: number; h: number } | null;
  containerWH: { w: number; h: number } | null;
  boxes: SrcBox[];
}) {
  if (!frameWH || !containerWH || frameWH.w <= 0 || frameWH.h <= 0 || containerWH.w <= 0 || containerWH.h <= 0) {
    return null;
  }
  // simula object-fit: contain
  const scale = Math.min(containerWH.w / frameWH.w, containerWH.h / frameWH.h);
  const dispW = frameWH.w * scale;
  const dispH = frameWH.h * scale;
  const offsetX = (containerWH.w - dispW) / 2;
  const offsetY = (containerWH.h - dispH) / 2;

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position: "absolute", left: offsetX, top: offsetY, width: dispW, height: dispH }}>
        {boxes.map((b, i) => {
          const left = b.x * scale;
          const top = b.y * scale;
          const width = b.w * scale;
          const height = b.h * scale;

          let borderColor = "#ff3b30"; // fire
          if (b.type === "person") borderColor = "#00e5ff";
          else if (b.type === "animal") borderColor = "#7CFC00";

          return (
            <View
              key={`${i}-${b.type}`}
              style={{ position: "absolute", left, top, width, height, borderWidth: 3, borderColor, borderRadius: 6 }}
            >
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  top: -18,
                  paddingHorizontal: 6,
                  paddingVertical: 2,
                  borderRadius: 4,
                  backgroundColor: borderColor,
                }}
              >
                <Text style={{ color: "#000", fontWeight: "800", fontSize: 10 }}>
                  {b.type.toUpperCase()}
                  {typeof b.conf === "number" ? ` ${b.conf.toFixed(2)}` : ""}
                </Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- TELA PRINCIPAL ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  // conexões
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados do ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState("—");
  const [ledOn, setLedOn] = useState(false);
  const [pumpOn, setPumpOn] = useState(false);

  // detecção (sempre ativa)
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  // pessoas/animais
  const [people, setPeople] = useState(0);
  const [animals, setAnimals] = useState(0);
  const [backend, setBackend] = useState<string>("—");
  const [confMax, setConfMax] = useState<number>(0);

  // caixas + dimensões para overlay
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{ w: number; h: number } | null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{ w: number; h: number } | null>(null);

  // registro automático
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef(0);
  const wasFireRef = useRef(false);
  const SAVE_COOLDOWN_MS = 5000;

  // visão: sempre SNAPSHOT fallback (30 fps)
  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  // joystick (UI)
  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // helpers URL
  const cleanServer = (s: string) => s.replace(/\/+$/, "");
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  /* ===== ESP STATUS ===== */
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl);
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(`OK • ip:${j.ip} • mode:${j.mode} • led:${j.led ? "on" : "off"} • pump:${j.pump ? "on" : "off"}`);
    } catch {
      setStatusText(T.statusFail);
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  /* ===== SNAPSHOT fallback (30 fps alvo) ===== */
  useEffect(() => {
    let stop = false;
    const FPS_INTERVAL = 33; // ~30 fps

    setCurrentFrameUri(`${cleanServer(server)}/snapshot?ts=${Date.now()}`);

    const tick = () => {
      if (stop) return;
      if (!loadingNextRef.current) {
        const url = `${cleanServer(server)}/snapshot?ts=${Date.now()}`;
        setNextFrameUri(url);
      }
      setTimeout(tick, FPS_INTERVAL);
    };
    tick();

    return () => {
      stop = true;
    };
  }, [server]);

  function onNextLoadStart() {
    loadingNextRef.current = true;
  }
  function onNextShown() {
    if (nextFrameUri) setCurrentFrameUri(nextFrameUri);
    loadingNextRef.current = false;
  }

  /* ===== LOOP DE DETECÇÃO + CAIXAS ===== */
  useEffect(() => {
    let stop = false;

    const loop = async () => {
      try {
        const r = await fetch(`${cleanServer(server)}/detect`);
        const j = await r.json();

        if (!stop && j && j.ok !== false) {
          // fogo
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));

          // frame size (se não vier do servidor, assumir 640x480)
          const wh =
            Array.isArray(j.frame_wh) && j.frame_wh.length === 2
              ? { w: Number(j.frame_wh[0]) || 0, h: Number(j.frame_wh[1]) || 0 }
              : { w: 640, h: 480 };
          if (wh.w > 0 && wh.h > 0) setFrameWH(wh);

          // objetos + campos estáveis
          const o = j.objects || {};
          const objs = o.objects || [];
          const peopleStable =
            typeof o.n_person_stable === "number"
              ? o.n_person_stable
              : typeof o.n_person === "number"
              ? o.n_person
              : objs.some((x: any) => String(x.label).toLowerCase() === "person")
              ? 1
              : 0;
          const animalsStable =
            typeof o.n_animals_stable === "number"
              ? o.n_animals_stable
              : typeof o.n_animals === "number"
              ? o.n_animals
              : objs.some((x: any) => String(x.label).toLowerCase() !== "person")
              ? 1
              : 0;

          setPeople(peopleStable);
          setAnimals(animalsStable);
          setBackend(o.backend || "—");
          setConfMax(Number(o.conf_max || 0));

          // montar caixas
          const boxes: SrcBox[] = [];

          if (j.isFire && Array.isArray(j.boxes)) {
            for (const b of j.boxes) {
              if (!Array.isArray(b) || b.length < 4) continue;
              const [x, y, w, h] = b.map((n: any) => Number(n) || 0);
              boxes.push({ x, y, w, h, type: "fire" });
            }
          }
          for (const it of objs) {
            if (!it || !Array.isArray(it.box) || it.box.length < 4) continue;
            const [x, y, w, h] = it.box.map((n: any) => Number(n) || 0);
            const label = String(it.label || "").toLowerCase();
            const conf = typeof it.conf === "number" ? it.conf : undefined;
            if (label === "person") boxes.push({ x, y, w, h, type: "person", conf });
            else boxes.push({ x, y, w, h, type: "animal", conf });
          }
          setOverlayBoxes(boxes);
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
          setPeople(0);
          setAnimals(0);
          setOverlayBoxes([]);
        }
      } finally {
        if (!stop) setTimeout(loop, 180); // ~5–6 Hz (leve para CPU)
      }
    };
    loop();

    return () => {
      stop = true;
    };
  }, [server]);

  /* ===== Registro automático ===== */
  useEffect(() => {
    const rising = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;

    if (rising && cooldownOk && !saving) {
      (async () => {
        try {
          setSaving(true);
          await saveEventFromServer(server);
          lastSaveRef.current = Date.now();
          setStatusText(T.eventSavedAt(new Date(lastSaveRef.current).toLocaleString()));
        } catch {
          setStatusText(T.noVideo);
        } finally {
          setSaving(false);
        }
      })();
    }
    wasFireRef.current = isFire;
  }, [isFire, server, saving, T]);

  /* ===== Joystick ===== */
  const RADIUS = 64;
  const KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS,
          ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny });
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  /* ===== medidas do container do vídeo (para overlay) ===== */
  function onVideoLayout(e: LayoutChangeEvent) {
    const { width, height } = e.nativeEvent.layout;
    setVideoContainerWH({ w: width, h: height });
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder={T.placeholderIp}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : T.test}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? T.ledOn : T.ledOff}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? T.pumpOn : T.pumpOff}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor + indicador (sem botões de detectar/stream/boxes) */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholderServer}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <View style={styles.badge}>
          <Text style={{ color: "#fff", fontWeight: "800" }}>{T.detecting}</Text>
        </View>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Banner de fogo */}
      <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      {/* Banner de pessoas/animais + backend */}
      <View style={[styles.statusRow, { justifyContent: "space-between" }]}>
        <Text style={styles.statChip}>
          {T.persons}: <Text style={styles.statNumber}>{people}</Text>
        </Text>
        <Text style={styles.statChip}>
          {T.animals}: <Text style={styles.statNumber}>{animals}</Text>
        </Text>
        <Text style={styles.modelChip}>
          {T.backend}: {backend} • conf_max {confMax.toFixed(2)}
        </Text>
      </View>

      {/* Vídeo (sempre snapshot) + Overlay */}
      <View style={{ flex: 1 }} onLayout={onVideoLayout}>
        <CrossfadeImage
          currentUri={currentFrameUri}
          nextUri={nextFrameUri}
          onNextLoadStart={() => (loadingNextRef.current = true)}
          onNextShown={() => {
            if (nextFrameUri) setCurrentFrameUri(nextFrameUri);
            loadingNextRef.current = false;
          }}
        />

        {overlayBoxes.length > 0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: joy.x * RADIUS }, { translateY: -joy.y * RADIUS }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

/* ---------- ESTILOS ---------- */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  // HERO
  hero: { alignItems: "center", paddingTop: 18, paddingBottom: 8 },
  heroLogo: { width: 84, height: 84, resizeMode: "contain", marginBottom: 6 },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#e2e8f0", marginTop: 2 },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  label: { color: "#f3b7b1", fontSize: 12, fontWeight: "700" },
  input: {
    backgroundColor: "#0b0d14",
    color: "white",
    borderRadius: 10,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 110,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "700" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#1a1418",
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  badge: {
    backgroundColor: "#3a2a2d",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#5a3a3f",
  },
  status: { color: "#ffd4cf", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  statChip: { color: "#ffd4cf", fontSize: 14, fontWeight: "700" },
  statNumber: { color: "#fff" },
  modelChip: { marginLeft: "auto", color: "#ffb3ad", fontSize: 12 },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: {
    position: "absolute",
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.14)",
  },
  joyKnob: {
    position: "absolute",
    backgroundColor: "rgba(230,64,58,0.9)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.85)",
  },
  joyText: { position: "absolute", bottom: -22, color: "#ffd4cf", fontSize: 12 },
});



Se quiser, posso também ajustar o servidor FastAPI para enviar frame_wh (largura/altura do frame) no /detect — isso deixa o overlay 100% calibrado com qualquer resolução que você usar.


























































Aqui está o DashboardScreen.tsx completo, com o visual “vermelhinho” para combinar com as outras telas e com a logo no topo (usando o caminho correto ../../assets/logo.png). Mantive todas as funções (expandir card, baixar, compartilhar, limpar, excluir).


// HydroBotApp2/src/screens/DashboardScreen.tsx
import { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Image,
  Pressable,
  Alert,
  TextInput,
  Modal,
  TouchableOpacity,
  SafeAreaView,
  Share,
} from "react-native";
import * as FileSystem from "expo-file-system";
import * as MediaLibrary from "expo-media-library";
import {
  getEvents,
  saveEventFromServer,
  deleteEvent,
  clearAllEvents,
  FireEvent,
} from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ============ TEMA “vermelhinho” para combinar com as outras telas ============ */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#151318",
  card2: "#111015",
  border: "#2b2230",
  text: "#f1f5f9",
  sub: "#cbd5e1",
  accent: "#E6403A", // vermelho HB
  danger: "#ef4444",
  row: "#1a1418",
  chip: "#20171b",
  chipText: "#ffb3ad",
};

/* ================== TEXTOS ================== */
const texts = {
  pt: {
    title: "Dashboard",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar agora",
    saving: "Salvando...",
    empty1: "Sem eventos ainda.",
    empty2:
      "Quando o detector sinalizar fogo, capturaremos o snapshot automaticamente.\nVocê também pode tocar “Registrar agora”.",
    fire: "Detecção de fogo",
    clear: "Limpar",
    confirmClearTitle: "Limpar tudo",
    confirmClearBody: "Isso apagará todos os eventos e imagens. Continuar?",
    cancel: "Cancelar",
    delete: "Excluir",
    confirmDeleteTitle: "Excluir registro",
    confirmDeleteBody: "Deseja excluir este evento?",
    fail: "Falha ao salvar",
    failBody: "Verifique o servidor /snapshot e a rede.",
    details: "Detalhes",
    share: "Compartilhar",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Baixar",
    downloadedTo: (p: string) => `Imagem salva em:\n${p}`,
    savedToGallery: "Imagem salva na galeria 📸",
    heroSubtitle: "Monitoramento e Controle",
  },
  en: {
    title: "Dashboard",
    server: "Server:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Save now",
    saving: "Saving...",
    empty1: "No events yet.",
    empty2:
      "When fire is detected, a snapshot is captured automatically.\nYou can also tap “Save now”.",
    fire: "Fire detection",
    clear: "Clear",
    confirmClearTitle: "Clear all",
    confirmClearBody: "This will delete all events and images. Continue?",
    cancel: "Cancel",
    delete: "Delete",
    confirmDeleteTitle: "Delete entry",
    confirmDeleteBody: "Do you want to delete this event?",
    fail: "Failed to save",
    failBody: "Check the /snapshot endpoint and network.",
    details: "Details",
    share: "Share",
    show: "Show",
    hide: "Hide",
    download: "Download",
    downloadedTo: (p: string) => `Image saved to:\n${p}`,
    savedToGallery: "Image saved to gallery 📸",
    heroSubtitle: "Monitoring & Control",
  },
  es: {
    title: "Panel",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar ahora",
    saving: "Guardando...",
    empty1: "Sin eventos aún.",
    empty2:
      "Cuando se detecte fuego, se capturará una imagen automáticamente.\nTambién puedes tocar “Registrar ahora”.",
    fire: "Detección de fuego",
    clear: "Limpiar",
    confirmClearTitle: "Limpiar todo",
    confirmClearBody: "Esto borrará todos los eventos e imágenes. ¿Continuar?",
    cancel: "Cancelar",
    delete: "Eliminar",
    confirmDeleteTitle: "Eliminar registro",
    confirmDeleteBody: "¿Deseas eliminar este evento?",
    fail: "Error al guardar",
    failBody: "Revisa /snapshot y la red.",
    details: "Detalles",
    share: "Compartir",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Descargar",
    downloadedTo: (p: string) => `Imagen guardada en:\n${p}`,
    savedToGallery: "Imagen guardada en la galería 📸",
    heroSubtitle: "Monitoreo y Control",
  },
};

const DEFAULT_SERVER = "http://192.168.4.2:8000";

/* ===== Logo (caminho correto partindo de src/screens) ===== */
const appLogo = require("../../assets/logo.png");

/* ===== Hero com logo ===== */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ===== Tipos ===== */
type EventWithMeta = FireEvent & { meta?: any };

/* =============================================================================
   COMPONENTE
============================================================================= */
export default function DashboardScreen() {
  const { lang } = useLanguage();
  const T = texts[lang];

  const [server, setServer] = useState<string>(DEFAULT_SERVER);
  const [items, setItems] = useState<EventWithMeta[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [preview, setPreview] = useState<EventWithMeta | null>(null);
  const [busy, setBusy] = useState(false);
  const [expanded, setExpanded] = useState<Set<string>>(new Set());

  async function load() {
    setRefreshing(true);
    try {
      const list = (await getEvents()) as EventWithMeta[];
      setItems(list);
    } finally {
      setRefreshing(false);
    }
  }
  useEffect(() => {
    load();
  }, []);

  async function handleRegisterNow() {
    try {
      setBusy(true);
      const ev = (await saveEventFromServer(server)) as EventWithMeta;
      setItems((prev) => [ev, ...prev]);
    } catch {
      Alert.alert(T.fail, T.failBody);
    } finally {
      setBusy(false);
    }
  }

  function confirmDelete(ev: EventWithMeta) {
    Alert.alert(T.confirmDeleteTitle, T.confirmDeleteBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.delete,
        style: "destructive",
        onPress: async () => {
          await deleteEvent(ev.id);
          setItems((prev) => prev.filter((x) => x.id !== ev.id));
          setExpanded((s) => {
            const n = new Set(s);
            n.delete(ev.id);
            return n;
          });
        },
      },
    ]);
  }

  function confirmClearAll() {
    Alert.alert(T.confirmClearTitle, T.confirmClearBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.clear,
        style: "destructive",
        onPress: async () => {
          await clearAllEvents();
          setItems([]);
          setExpanded(new Set());
        },
      },
    ]);
  }

  function toggleExpand(item: EventWithMeta) {
    setExpanded((prev) => {
      const n = new Set(prev);
      if (n.has(item.id)) n.delete(item.id);
      else n.add(item.id);
      return n;
    });
  }

  async function downloadImage(uri: string, id: string) {
    try {
      const filename = `${id}.jpg`;
      const dest = FileSystem.documentDirectory + filename;

      let localPath = dest;

      if (uri.startsWith("file://")) {
        await FileSystem.copyAsync({ from: uri, to: dest });
      } else {
        const res = await FileSystem.downloadAsync(uri, dest);
        localPath = res.uri;
      }

      try {
        const perm = await MediaLibrary.requestPermissionsAsync();
        if (perm.granted) {
          const asset = await MediaLibrary.createAssetAsync(localPath);
          const albumName = "HydroBot";
          let album = await MediaLibrary.getAlbumAsync(albumName);
          if (!album) {
            album = await MediaLibrary.createAlbumAsync(albumName, asset, false);
          } else {
            await MediaLibrary.addAssetsToAlbumAsync([asset], album, false);
          }
          Alert.alert("OK", T.savedToGallery);
          return;
        }
      } catch {}

      Alert.alert("OK", T.downloadedTo(localPath));
    } catch {
      Alert.alert("Erro", "Falha ao baixar imagem");
    }
  }

  const renderItem = ({ item }: { item: EventWithMeta }) => {
    const dateStr = new Date(item.ts).toLocaleString();
    const isOpen = expanded.has(item.id);

    return (
      <View style={styles.cardWrap}>
        {/* Cabeçalho */}
        <Pressable onPress={() => toggleExpand(item)} style={styles.cardHeader}>
          <Image source={{ uri: item.imageUri }} style={styles.thumb} />
          <View style={{ flex: 1 }}>
            <Text style={styles.title}>{T.fire}</Text>
            <Text style={styles.time}>{dateStr}</Text>
          </View>

          <View style={{ alignItems: "flex-end", gap: 8 }}>
            <Pressable
              onPress={() => toggleExpand(item)}
              style={[styles.expandBtn, isOpen && styles.expandBtnOn]}
            >
              <Text style={styles.expandTxt}>
                {isOpen ? "▾ " + T.hide : "▸ " + T.show}
              </Text>
            </Pressable>
            <Pressable onPress={() => confirmDelete(item)} style={styles.trashBtn}>
              <Text style={styles.trashTxt}>{T.delete}</Text>
            </Pressable>
          </View>
        </Pressable>

        {/* Painel expandido */}
        {isOpen && (
          <View style={styles.expandPanel}>
            <Pressable onPress={() => setPreview(item)} style={styles.bigImageWrap}>
              <Image source={{ uri: item.imageUri }} style={styles.bigImage} resizeMode="contain" />
            </Pressable>

            <View style={styles.detailsBox}>
              <Text style={styles.detailsTitle}>{T.details}</Text>
              <Text style={styles.timeBig}>{dateStr}</Text>
            </View>

            <View style={styles.actionsRow}>
              <Pressable
                style={[styles.actionBtn, { backgroundColor: PALETTE.accent }]}
                onPress={() => downloadImage(item.imageUri, item.id)}
              >
                <Text style={[styles.actionTxt, { color: "white" }]}>⬇ {T.download}</Text>
              </Pressable>

              <Pressable
                style={[styles.actionBtn, { backgroundColor: "#3a2e33" }]}
                onPress={() =>
                  Share.share({
                    url: item.imageUri,
                    message: `${T.fire} • ${dateStr}`,
                  })
                }
              >
                <Text style={[styles.actionTxt, { color: "#fff" }]}>{T.share}</Text>
              </Pressable>
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      {/* HERO com logo */}
      <AppHero subtitle={T.heroSubtitle} />

      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.headerTitle}>{T.title}</Text>
        <Pressable onPress={confirmClearAll} style={styles.clearAllBtn}>
          <Text style={styles.clearAllTxt}>{T.clear}</Text>
        </Pressable>
      </View>

      {/* Linha do servidor + Registrar */}
      <View style={styles.row}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholder}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable
          onPress={handleRegisterNow}
          style={[styles.btn, busy && { opacity: 0.6 }]}
          disabled={busy}
        >
          <Text style={styles.btnTxt}>{busy ? T.saving : T.btnSave}</Text>
        </Pressable>
      </View>

      {/* Lista */}
      <FlatList
        data={items}
        keyExtractor={(it) => it.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={load}
        contentContainerStyle={items.length === 0 && { flex: 1, justifyContent: "center" }}
        ListEmptyComponent={
          <View style={{ alignItems: "center", paddingHorizontal: 16 }}>
            <Text style={{ color: PALETTE.sub, textAlign: "center" }}>{T.empty1}</Text>
            <Text style={{ color: PALETTE.sub, marginTop: 4, textAlign: "center" }}>{T.empty2}</Text>
          </View>
        }
      />

      {/* Modal zoom */}
      <Modal visible={!!preview} transparent animationType="fade" onRequestClose={() => setPreview(null)}>
        <View style={styles.modalBg}>
          <TouchableOpacity style={styles.modalBg} activeOpacity={1} onPress={() => setPreview(null)}>
            {preview && <Image source={{ uri: preview.imageUri }} style={styles.fullImg} resizeMode="contain" />}
          </TouchableOpacity>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

/* =========================
   ESTILOS
========================= */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  /* HERO */
  hero: {
    alignItems: "center",
    paddingTop: 18,
    paddingBottom: 8,
  },
  heroLogo: { width: 84, height: 84, resizeMode: "contain", marginBottom: 6 },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#e2e8f0", marginTop: 2 },

  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: "#1b1416",
  },
  headerTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700", flex: 1 },
  clearAllBtn: {
    paddingHorizontal: 10,
    paddingVertical: 8,
    backgroundColor: "#3a2a2d",
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#5a3a3f",
  },
  clearAllTxt: { color: "#ffd4cf", fontWeight: "800" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: "#161015",
  },
  label: { color: "#f3b7b1", fontSize: 12, fontWeight: "700" },
  input: {
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderRadius: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: "#3b2930",
    minWidth: 140,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 12,
  },
  btnTxt: { color: "white", fontWeight: "800" },

  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 12,
    marginTop: 12,
    borderRadius: 14,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#35252b",
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: {
    width: 86,
    height: 56,
    backgroundColor: "#000",
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#2b1f23",
  },
  title: { color: "#ffe2df", fontSize: 14, fontWeight: "800" },
  time: { color: "#eab7b1", fontSize: 12, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2b1f23",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#3b262b",
  },
  expandBtnOn: { backgroundColor: "#3b262b" },
  expandTxt: { color: "#ffd4cf", fontWeight: "800", fontSize: 12 },

  trashBtn: {
    backgroundColor: "#2a1e22",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#4b2f35",
  },
  trashTxt: { color: "#ffb4ad", fontWeight: "800", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#3b2930",
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 230 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#3b2930",
    backgroundColor: "#1b1416",
  },
  detailsTitle: { color: "#ffb3ad", fontWeight: "900", marginBottom: 6 },
  timeBig: { color: "#ffe2df", fontSize: 14, fontWeight: "700" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "900" },

  modalBg: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.92)",
    alignItems: "center",
    justifyContent: "center",
  },
  fullImg: { width: "100%", height: "100%" },
});



Se quiser, deixo o Settings e a Câmera com exatamente o mesmo “hero” e tons para tudo ficar 100% consistente.












































Aqui está o DashboardScreen.tsx completo, com o visual “vermelhinho” para combinar com as outras telas e com a logo no topo (usando o caminho correto ../../assets/logo.png). Mantive todas as funções (expandir card, baixar, compartilhar, limpar, excluir).


// HydroBotApp2/src/screens/DashboardScreen.tsx
import { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Image,
  Pressable,
  Alert,
  TextInput,
  Modal,
  TouchableOpacity,
  SafeAreaView,
  Share,
} from "react-native";
import * as FileSystem from "expo-file-system";
import * as MediaLibrary from "expo-media-library";
import {
  getEvents,
  saveEventFromServer,
  deleteEvent,
  clearAllEvents,
  FireEvent,
} from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ============ TEMA “vermelhinho” para combinar com as outras telas ============ */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#151318",
  card2: "#111015",
  border: "#2b2230",
  text: "#f1f5f9",
  sub: "#cbd5e1",
  accent: "#E6403A", // vermelho HB
  danger: "#ef4444",
  row: "#1a1418",
  chip: "#20171b",
  chipText: "#ffb3ad",
};

/* ================== TEXTOS ================== */
const texts = {
  pt: {
    title: "Dashboard",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar agora",
    saving: "Salvando...",
    empty1: "Sem eventos ainda.",
    empty2:
      "Quando o detector sinalizar fogo, capturaremos o snapshot automaticamente.\nVocê também pode tocar “Registrar agora”.",
    fire: "Detecção de fogo",
    clear: "Limpar",
    confirmClearTitle: "Limpar tudo",
    confirmClearBody: "Isso apagará todos os eventos e imagens. Continuar?",
    cancel: "Cancelar",
    delete: "Excluir",
    confirmDeleteTitle: "Excluir registro",
    confirmDeleteBody: "Deseja excluir este evento?",
    fail: "Falha ao salvar",
    failBody: "Verifique o servidor /snapshot e a rede.",
    details: "Detalhes",
    share: "Compartilhar",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Baixar",
    downloadedTo: (p: string) => `Imagem salva em:\n${p}`,
    savedToGallery: "Imagem salva na galeria 📸",
    heroSubtitle: "Monitoramento e Controle",
  },
  en: {
    title: "Dashboard",
    server: "Server:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Save now",
    saving: "Saving...",
    empty1: "No events yet.",
    empty2:
      "When fire is detected, a snapshot is captured automatically.\nYou can also tap “Save now”.",
    fire: "Fire detection",
    clear: "Clear",
    confirmClearTitle: "Clear all",
    confirmClearBody: "This will delete all events and images. Continue?",
    cancel: "Cancel",
    delete: "Delete",
    confirmDeleteTitle: "Delete entry",
    confirmDeleteBody: "Do you want to delete this event?",
    fail: "Failed to save",
    failBody: "Check the /snapshot endpoint and network.",
    details: "Details",
    share: "Share",
    show: "Show",
    hide: "Hide",
    download: "Download",
    downloadedTo: (p: string) => `Image saved to:\n${p}`,
    savedToGallery: "Image saved to gallery 📸",
    heroSubtitle: "Monitoring & Control",
  },
  es: {
    title: "Panel",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar ahora",
    saving: "Guardando...",
    empty1: "Sin eventos aún.",
    empty2:
      "Cuando se detecte fuego, se capturará una imagen automáticamente.\nTambién puedes tocar “Registrar ahora”.",
    fire: "Detección de fuego",
    clear: "Limpiar",
    confirmClearTitle: "Limpiar todo",
    confirmClearBody: "Esto borrará todos los eventos e imágenes. ¿Continuar?",
    cancel: "Cancelar",
    delete: "Eliminar",
    confirmDeleteTitle: "Eliminar registro",
    confirmDeleteBody: "¿Deseas eliminar este evento?",
    fail: "Error al guardar",
    failBody: "Revisa /snapshot y la red.",
    details: "Detalles",
    share: "Compartir",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Descargar",
    downloadedTo: (p: string) => `Imagen guardada en:\n${p}`,
    savedToGallery: "Imagen guardada en la galería 📸",
    heroSubtitle: "Monitoreo y Control",
  },
};

const DEFAULT_SERVER = "http://192.168.4.2:8000";

/* ===== Logo (caminho correto partindo de src/screens) ===== */
const appLogo = require("../../assets/logo.png");

/* ===== Hero com logo ===== */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ===== Tipos ===== */
type EventWithMeta = FireEvent & { meta?: any };

/* =============================================================================
   COMPONENTE
============================================================================= */
export default function DashboardScreen() {
  const { lang } = useLanguage();
  const T = texts[lang];

  const [server, setServer] = useState<string>(DEFAULT_SERVER);
  const [items, setItems] = useState<EventWithMeta[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [preview, setPreview] = useState<EventWithMeta | null>(null);
  const [busy, setBusy] = useState(false);
  const [expanded, setExpanded] = useState<Set<string>>(new Set());

  async function load() {
    setRefreshing(true);
    try {
      const list = (await getEvents()) as EventWithMeta[];
      setItems(list);
    } finally {
      setRefreshing(false);
    }
  }
  useEffect(() => {
    load();
  }, []);

  async function handleRegisterNow() {
    try {
      setBusy(true);
      const ev = (await saveEventFromServer(server)) as EventWithMeta;
      setItems((prev) => [ev, ...prev]);
    } catch {
      Alert.alert(T.fail, T.failBody);
    } finally {
      setBusy(false);
    }
  }

  function confirmDelete(ev: EventWithMeta) {
    Alert.alert(T.confirmDeleteTitle, T.confirmDeleteBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.delete,
        style: "destructive",
        onPress: async () => {
          await deleteEvent(ev.id);
          setItems((prev) => prev.filter((x) => x.id !== ev.id));
          setExpanded((s) => {
            const n = new Set(s);
            n.delete(ev.id);
            return n;
          });
        },
      },
    ]);
  }

  function confirmClearAll() {
    Alert.alert(T.confirmClearTitle, T.confirmClearBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.clear,
        style: "destructive",
        onPress: async () => {
          await clearAllEvents();
          setItems([]);
          setExpanded(new Set());
        },
      },
    ]);
  }

  function toggleExpand(item: EventWithMeta) {
    setExpanded((prev) => {
      const n = new Set(prev);
      if (n.has(item.id)) n.delete(item.id);
      else n.add(item.id);
      return n;
    });
  }

  async function downloadImage(uri: string, id: string) {
    try {
      const filename = `${id}.jpg`;
      const dest = FileSystem.documentDirectory + filename;

      let localPath = dest;

      if (uri.startsWith("file://")) {
        await FileSystem.copyAsync({ from: uri, to: dest });
      } else {
        const res = await FileSystem.downloadAsync(uri, dest);
        localPath = res.uri;
      }

      try {
        const perm = await MediaLibrary.requestPermissionsAsync();
        if (perm.granted) {
          const asset = await MediaLibrary.createAssetAsync(localPath);
          const albumName = "HydroBot";
          let album = await MediaLibrary.getAlbumAsync(albumName);
          if (!album) {
            album = await MediaLibrary.createAlbumAsync(albumName, asset, false);
          } else {
            await MediaLibrary.addAssetsToAlbumAsync([asset], album, false);
          }
          Alert.alert("OK", T.savedToGallery);
          return;
        }
      } catch {}

      Alert.alert("OK", T.downloadedTo(localPath));
    } catch {
      Alert.alert("Erro", "Falha ao baixar imagem");
    }
  }

  const renderItem = ({ item }: { item: EventWithMeta }) => {
    const dateStr = new Date(item.ts).toLocaleString();
    const isOpen = expanded.has(item.id);

    return (
      <View style={styles.cardWrap}>
        {/* Cabeçalho */}
        <Pressable onPress={() => toggleExpand(item)} style={styles.cardHeader}>
          <Image source={{ uri: item.imageUri }} style={styles.thumb} />
          <View style={{ flex: 1 }}>
            <Text style={styles.title}>{T.fire}</Text>
            <Text style={styles.time}>{dateStr}</Text>
          </View>

          <View style={{ alignItems: "flex-end", gap: 8 }}>
            <Pressable
              onPress={() => toggleExpand(item)}
              style={[styles.expandBtn, isOpen && styles.expandBtnOn]}
            >
              <Text style={styles.expandTxt}>
                {isOpen ? "▾ " + T.hide : "▸ " + T.show}
              </Text>
            </Pressable>
            <Pressable onPress={() => confirmDelete(item)} style={styles.trashBtn}>
              <Text style={styles.trashTxt}>{T.delete}</Text>
            </Pressable>
          </View>
        </Pressable>

        {/* Painel expandido */}
        {isOpen && (
          <View style={styles.expandPanel}>
            <Pressable onPress={() => setPreview(item)} style={styles.bigImageWrap}>
              <Image source={{ uri: item.imageUri }} style={styles.bigImage} resizeMode="contain" />
            </Pressable>

            <View style={styles.detailsBox}>
              <Text style={styles.detailsTitle}>{T.details}</Text>
              <Text style={styles.timeBig}>{dateStr}</Text>
            </View>

            <View style={styles.actionsRow}>
              <Pressable
                style={[styles.actionBtn, { backgroundColor: PALETTE.accent }]}
                onPress={() => downloadImage(item.imageUri, item.id)}
              >
                <Text style={[styles.actionTxt, { color: "white" }]}>⬇ {T.download}</Text>
              </Pressable>

              <Pressable
                style={[styles.actionBtn, { backgroundColor: "#3a2e33" }]}
                onPress={() =>
                  Share.share({
                    url: item.imageUri,
                    message: `${T.fire} • ${dateStr}`,
                  })
                }
              >
                <Text style={[styles.actionTxt, { color: "#fff" }]}>{T.share}</Text>
              </Pressable>
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      {/* HERO com logo */}
      <AppHero subtitle={T.heroSubtitle} />

      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.headerTitle}>{T.title}</Text>
        <Pressable onPress={confirmClearAll} style={styles.clearAllBtn}>
          <Text style={styles.clearAllTxt}>{T.clear}</Text>
        </Pressable>
      </View>

      {/* Linha do servidor + Registrar */}
      <View style={styles.row}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholder}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable
          onPress={handleRegisterNow}
          style={[styles.btn, busy && { opacity: 0.6 }]}
          disabled={busy}
        >
          <Text style={styles.btnTxt}>{busy ? T.saving : T.btnSave}</Text>
        </Pressable>
      </View>

      {/* Lista */}
      <FlatList
        data={items}
        keyExtractor={(it) => it.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={load}
        contentContainerStyle={items.length === 0 && { flex: 1, justifyContent: "center" }}
        ListEmptyComponent={
          <View style={{ alignItems: "center", paddingHorizontal: 16 }}>
            <Text style={{ color: PALETTE.sub, textAlign: "center" }}>{T.empty1}</Text>
            <Text style={{ color: PALETTE.sub, marginTop: 4, textAlign: "center" }}>{T.empty2}</Text>
          </View>
        }
      />

      {/* Modal zoom */}
      <Modal visible={!!preview} transparent animationType="fade" onRequestClose={() => setPreview(null)}>
        <View style={styles.modalBg}>
          <TouchableOpacity style={styles.modalBg} activeOpacity={1} onPress={() => setPreview(null)}>
            {preview && <Image source={{ uri: preview.imageUri }} style={styles.fullImg} resizeMode="contain" />}
          </TouchableOpacity>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

/* =========================
   ESTILOS
========================= */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  /* HERO */
  hero: {
    alignItems: "center",
    paddingTop: 18,
    paddingBottom: 8,
  },
  heroLogo: { width: 84, height: 84, resizeMode: "contain", marginBottom: 6 },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#e2e8f0", marginTop: 2 },

  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: "#1b1416",
  },
  headerTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700", flex: 1 },
  clearAllBtn: {
    paddingHorizontal: 10,
    paddingVertical: 8,
    backgroundColor: "#3a2a2d",
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#5a3a3f",
  },
  clearAllTxt: { color: "#ffd4cf", fontWeight: "800" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: "#161015",
  },
  label: { color: "#f3b7b1", fontSize: 12, fontWeight: "700" },
  input: {
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderRadius: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: "#3b2930",
    minWidth: 140,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 12,
  },
  btnTxt: { color: "white", fontWeight: "800" },

  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 12,
    marginTop: 12,
    borderRadius: 14,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#35252b",
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: {
    width: 86,
    height: 56,
    backgroundColor: "#000",
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#2b1f23",
  },
  title: { color: "#ffe2df", fontSize: 14, fontWeight: "800" },
  time: { color: "#eab7b1", fontSize: 12, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2b1f23",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#3b262b",
  },
  expandBtnOn: { backgroundColor: "#3b262b" },
  expandTxt: { color: "#ffd4cf", fontWeight: "800", fontSize: 12 },

  trashBtn: {
    backgroundColor: "#2a1e22",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#4b2f35",
  },
  trashTxt: { color: "#ffb4ad", fontWeight: "800", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#3b2930",
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 230 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#3b2930",
    backgroundColor: "#1b1416",
  },
  detailsTitle: { color: "#ffb3ad", fontWeight: "900", marginBottom: 6 },
  timeBig: { color: "#ffe2df", fontSize: 14, fontWeight: "700" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "900" },

  modalBg: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.92)",
    alignItems: "center",
    justifyContent: "center",
  },
  fullImg: { width: "100%", height: "100%" },
});



Se quiser, deixo o Settings e a Câmera com exatamente o mesmo “hero” e tons para tudo ficar 100% consistente.




































































































perfeito — deixei a Câmera no modo que você pediu:




Detecção sempre ativa (sem botão).


Snapshot (fallback) como visão padrão (sem opção de trocar para stream).


Removi o botão “Boxes” (o mini-preview do servidor). O overlay de caixas na própria imagem continua funcionando.


Barra do servidor simplificada (mostra “Detectando…” quando ativo).




Cole isso em HydroBotApp2/src/screens/CameraScreen.tsx:


// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
  Animated,
  LayoutChangeEvent,
} from "react-native";
import { WebView } from "react-native-webview";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ---------- PALETA ---------- */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#121218",
  border: "#25273a",
  accent: "#e6403a",
  text: "#e5e7eb",
};

/* ---------- TEXTOS ---------- */
const textsByLang = {
  pt: {
    heroSubtitle: "Monitoramento e Controle",
    espIp: "ESP IP:",
    test: "Testar",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "BOMBA ON",
    pumpOff: "BOMBA OFF",
    server: "Servidor:",
    detecting: "Detectando…",
    saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi/IP.",
    noVideo: "Sem vídeo (snapshot). Verifique o servidor.",
    fireOn: (s: number) => `🔥 FOGO • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sem fogo • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento salvo em ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    persons: "Pessoas",
    animals: "Animais",
    backend: "Modelo",
  },
  en: {
    heroSubtitle: "Monitoring & Control",
    espIp: "ESP IP:",
    test: "Test",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "PUMP ON",
    pumpOff: "PUMP OFF",
    server: "Server:",
    detecting: "Detecting…",
    saving: "Saving...",
    statusFail: "Failed to connect. Check Wi-Fi/IP.",
    noVideo: "No video (snapshot). Check the server.",
    fireOn: (s: number) => `🔥 FIRE • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `No fire • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Event saved at ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    persons: "People",
    animals: "Animals",
    backend: "Model",
  },
  es: {
    heroSubtitle: "Monitoreo y Control",
    espIp: "ESP IP:",
    test: "Probar",
    ledOn: "LED ENC.",
    ledOff: "LED APAG.",
    pumpOn: "BOMBA ENC.",
    pumpOff: "BOMBA APAG.",
    server: "Servidor:",
    detecting: "Detectando…",
    saving: "Guardando...",
    statusFail: "Error de conexión. Revisa Wi-Fi/IP.",
    noVideo: "Sin vídeo (snapshot). Revisa el servidor.",
    fireOn: (s: number) => `🔥 FUEGO • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sin fuego • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento guardado a las ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    persons: "Personas",
    animals: "Animales",
    backend: "Modelo",
  },
};

const DEFAULT_IP = "192.168.4.1";
const DEFAULT_SERVER = "http://192.168.4.2:8000";

// caminho correto da logo a partir de src/screens
const appLogo = require("../../assets/logo.png");

/* ---------- HERO ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ---------- STREAM (mantido para possível uso futuro) ---------- */
function LiveMJPEG({ ip }: { ip: string }) {
  const html = `
    <html><head><meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;}
        .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;}
        img{max-width:100%;max-height:100%;object-fit:contain;background:#000;}
      </style>
    </head>
    <body><div class="wrap"><img src="http://${ip}:81/stream"/></div></body></html>
  `.trim();

  return (
    <WebView
      originWhitelist={["*"]}
      source={{ html }}
      javaScriptEnabled
      allowsInlineMediaPlayback
      mediaPlaybackRequiresUserAction={false}
      automaticallyAdjustContentInsets={false}
      style={{ flex: 1, backgroundColor: "black" }}
    />
  );
}

/* ---------- SNAPSHOT com crossfade ---------- */
function CrossfadeImage({
  currentUri,
  nextUri,
  onNextLoadStart,
  onNextShown,
}: {
  currentUri: string;
  nextUri: string;
  onNextLoadStart: () => void;
  onNextShown: () => void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}

      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={onNextShown}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown();
                fade.setValue(0);
                setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- OVERLAY DE CAIXAS ---------- */
type BoxType = "fire" | "person" | "animal";
type SrcBox = { x: number; y: number; w: number; h: number; type: BoxType; conf?: number };

function BoxesOverlay({
  frameWH,
  containerWH,
  boxes,
}: {
  frameWH: { w: number; h: number } | null;
  containerWH: { w: number; h: number } | null;
  boxes: SrcBox[];
}) {
  if (!frameWH || !containerWH || frameWH.w <= 0 || frameWH.h <= 0 || containerWH.w <= 0 || containerWH.h <= 0) {
    return null;
  }
  const scale = Math.min(containerWH.w / frameWH.w, containerWH.h / frameWH.h);
  const dispW = frameWH.w * scale;
  const dispH = frameWH.h * scale;
  const offsetX = (containerWH.w - dispW) / 2;
  const offsetY = (containerWH.h - dispH) / 2;

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position: "absolute", left: offsetX, top: offsetY, width: dispW, height: dispH }}>
        {boxes.map((b, i) => {
          const left = b.x * scale;
          const top = b.y * scale;
          const width = b.w * scale;
          const height = b.h * scale;

          let borderColor = "#ff3b30"; // fire
          if (b.type === "person") borderColor = "#00e5ff";
          else if (b.type === "animal") borderColor = "#7CFC00";

          return (
            <View
              key={`${i}-${b.type}`}
              style={{ position: "absolute", left, top, width, height, borderWidth: 3, borderColor, borderRadius: 6 }}
            >
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  top: -18,
                  paddingHorizontal: 6,
                  paddingVertical: 2,
                  borderRadius: 4,
                  backgroundColor: borderColor,
                }}
              >
                <Text style={{ color: "#000", fontWeight: "800", fontSize: 10 }}>
                  {b.type.toUpperCase()}
                  {typeof b.conf === "number" ? ` ${b.conf.toFixed(2)}` : ""}
                </Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- TELA PRINCIPAL ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  // conexões
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados do ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState("—");
  const [ledOn, setLedOn] = useState(false);
  const [pumpOn, setPumpOn] = useState(false);

  // detecção (sempre ativa)
  const [detectOn] = useState(true);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  // pessoas/animais
  const [people, setPeople] = useState(0);
  const [animals, setAnimals] = useState(0);
  const [backend, setBackend] = useState<string>("—");
  const [confMax, setConfMax] = useState<number>(0);

  // caixas + dimensões para overlay
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{ w: number; h: number } | null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{ w: number; h: number } | null>(null);

  // registro automático
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef(0);
  const wasFireRef = useRef(false);
  const SAVE_COOLDOWN_MS = 5000;

  // visão: sempre SNAPSHOT fallback (sem botão para trocar)
  const [useStream] = useState(false);
  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  // joystick (UI)
  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // helpers URL
  const cleanServer = (s: string) => s.replace(/\/+$/, "");
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  /* ===== ESP STATUS ===== */
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl);
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(`OK • ip:${j.ip} • mode:${j.mode} • led:${j.led ? "on" : "off"} • pump:${j.pump ? "on" : "off"}`);
    } catch {
      setStatusText(T.statusFail);
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  /* ===== SNAPSHOT fallback (25 fps alvo) ===== */
  useEffect(() => {
    let stop = false;
    const FPS_INTERVAL = 40; // ~25 fps

    setCurrentFrameUri(`${cleanServer(server)}/snapshot?ts=${Date.now()}`);

    const tick = () => {
      if (stop) return;
      if (!loadingNextRef.current) {
        const url = `${cleanServer(server)}/snapshot?ts=${Date.now()}`;
        setNextFrameUri(url);
      }
      setTimeout(tick, FPS_INTERVAL);
    };
    tick();

    return () => {
      stop = true;
    };
  }, [server]);

  function onNextLoadStart() {
    loadingNextRef.current = true;
  }
  function onNextShown() {
    if (nextFrameUri) setCurrentFrameUri(nextFrameUri);
    loadingNextRef.current = false;
  }

  /* ===== LOOP DE DETECÇÃO + CAIXAS ===== */
  useEffect(() => {
    let stop = false;

    const loop = async () => {
      try {
        const r = await fetch(`${cleanServer(server)}/detect`);
        const j = await r.json();

        if (!stop && j && j.ok !== false) {
          // fogo
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));

          // frame size (se servidor expor; opcional)
          const wh =
            Array.isArray(j.frame_wh) && j.frame_wh.length === 2
              ? { w: Number(j.frame_wh[0]) || 0, h: Number(j.frame_wh[1]) || 0 }
              : null;
          if (wh && wh.w > 0 && wh.h > 0) setFrameWH(wh);

          // objetos e estáveis
          const o = j.objects || {};
          const objs = o.objects || [];
          const peopleStable =
            typeof o.n_person_stable === "number"
              ? o.n_person_stable
              : typeof o.n_person === "number"
              ? o.n_person
              : objs.some((x: any) => String(x.label).toLowerCase() === "person")
              ? 1
              : 0;
          const animalsStable =
            typeof o.n_animals_stable === "number"
              ? o.n_animals_stable
              : typeof o.n_animals === "number"
              ? o.n_animals
              : objs.some((x: any) => String(x.label).toLowerCase() !== "person")
              ? 1
              : 0;

          setPeople(peopleStable);
          setAnimals(animalsStable);
          setBackend(o.backend || "—");
          setConfMax(Number(o.conf_max || 0));

          // montar caixas
          const boxes: SrcBox[] = [];

          if (j.isFire && Array.isArray(j.boxes)) {
            for (const b of j.boxes) {
              if (!Array.isArray(b) || b.length < 4) continue;
              const [x, y, w, h] = b.map((n: any) => Number(n) || 0);
              boxes.push({ x, y, w, h, type: "fire" });
            }
          }
          for (const it of objs) {
            if (!it || !Array.isArray(it.box) || it.box.length < 4) continue;
            const [x, y, w, h] = it.box.map((n: any) => Number(n) || 0);
            const label = String(it.label || "").toLowerCase();
            const conf = typeof it.conf === "number" ? it.conf : undefined;
            if (label === "person") boxes.push({ x, y, w, h, type: "person", conf });
            else boxes.push({ x, y, w, h, type: "animal", conf });
          }
          setOverlayBoxes(boxes);
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
          setPeople(0);
          setAnimals(0);
          setOverlayBoxes([]);
        }
      } finally {
        if (!stop) setTimeout(loop, 180); // ~5-6Hz
      }
    };
    loop();

    return () => {
      stop = true;
    };
  }, [server]);

  /* ===== Registro automático ===== */
  useEffect(() => {
    const rising = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;

    if (rising && cooldownOk && !saving) {
      (async () => {
        try {
          setSaving(true);
          await saveEventFromServer(server);
          lastSaveRef.current = Date.now();
          setStatusText(T.eventSavedAt(new Date(lastSaveRef.current).toLocaleString()));
        } catch {
          setStatusText(T.noVideo);
        } finally {
          setSaving(false);
        }
      })();
    }
    wasFireRef.current = isFire;
  }, [isFire, server, saving, T]);

  /* ===== Joystick ===== */
  const RADIUS = 64,
    KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS,
          ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny });
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  /* ===== Medidas do container do vídeo ===== */
  function onVideoLayout(e: LayoutChangeEvent) {
    const { width, height } = e.nativeEvent.layout;
    setVideoContainerWH({ w: width, h: height });
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder={T.placeholderIp}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : T.test}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? T.ledOn : T.ledOff}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? T.pumpOn : T.pumpOff}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor + indicador (sem botões de detectar/stream/boxes) */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholderServer}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <View style={[styles.badge]}>
          <Text style={{ color: "#fff", fontWeight: "800" }}>{T.detecting}</Text>
        </View>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Banner de fogo */}
      <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      {/* Banner de pessoas/animais + backend */}
      <View style={[styles.statusRow, { justifyContent: "space-between" }]}>
        <Text style={styles.statChip}>
          {T.persons}: <Text style={styles.statNumber}>{people}</Text>
        </Text>
        <Text style={styles.statChip}>
          {T.animals}: <Text style={styles.statNumber}>{animals}</Text>
        </Text>
        <Text style={styles.modelChip}>
          {T.backend}: {backend} • conf_max {confMax.toFixed(2)}
        </Text>
      </View>

      {/* Vídeo (sempre snapshot) + Overlay */}
      <View style={{ flex: 1 }} onLayout={onVideoLayout}>
        <CrossfadeImage
          currentUri={currentFrameUri}
          nextUri={nextFrameUri}
          onNextLoadStart={onNextLoadStart}
          onNextShown={onNextShown}
        />

        {overlayBoxes.length > 0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: 64 * 2 + 24, height: 64 * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: 64 * 2, height: 64 * 2, borderRadius: 64 }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: 22 * 2,
                height: 22 * 2,
                borderRadius: 22,
                transform: [{ translateX: joy.x * 64 }, { translateY: -joy.y * 64 }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

/* ---------- ESTILOS ---------- */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  // HERO
  hero: { alignItems: "center", paddingTop: 12, paddingBottom: 6 },
  heroLogo: { width: 80, height: 80, marginBottom: 6, resizeMode: "contain" },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 2 },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: "#0b0d14",
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 110,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1322",
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  badge: {
    backgroundColor: "#1f2937",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  statChip: { color: "#dbeafe", fontSize: 14, fontWeight: "600" },
  statNumber: { color: "#fff" },
  modelChip: { marginLeft: "auto", color: "#9fb0ff", fontSize: 12 },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: {
    position: "absolute",
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.14)",
  },
  joyKnob: {
    position: "absolute",
    backgroundColor: "rgba(230,64,58,0.9)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.85)",
  },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});



se quiser também sumo com os botões de LED/BOMBA e deixo só o vídeo + overlay 😉




























































const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
  },
  headerTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700", flex: 1 },
  clearAllBtn: {
    paddingHorizontal: 10,
    paddingVertical: 8,
    backgroundColor: PALETTE.danger,
    borderRadius: 8,
  },
  clearAllTxt: { color: "white", fontWeight: "700" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.row,
  },
  label: { color: PALETTE.sub, fontSize: 12 },
  input: {
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 140,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnTxt: { color: "white", fontWeight: "700" },

  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 10,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: { width: 84, height: 56, backgroundColor: "#000", borderRadius: 8 },
  title: { color: PALETTE.text, fontSize: 14, fontWeight: "700" },
  time: { color: PALETTE.sub, fontSize: 12, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2a2f3d",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  expandBtnOn: { backgroundColor: "#1d2435" },
  expandTxt: { color: "#cbd5ff", fontWeight: "700", fontSize: 12 },

  trashBtn: {
    backgroundColor: "#333",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  trashTxt: { color: "#fca5a5", fontWeight: "700", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 10,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 220 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#0c1020",
  },
  detailsTitle: { color: PALETTE.chipText, fontWeight: "800", marginBottom: 6 },
  timeBig: { color: PALETTE.text, fontSize: 14, fontWeight: "600" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 10,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "800" },

  modalBg: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.92)",
    alignItems: "center",
    justifyContent: "center",
  },
  fullImg: { width: "100%", height: "100%" },

  // ======= QUICK ACTION STYLES =======
  quickRow: {
    flexDirection: "row",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 12,
    backgroundColor: PALETTE.row,
  },
  quickBtn: {
    flex: 1,
    backgroundColor: "#141622",
    borderRadius: 16,
    paddingVertical: 18,
    paddingHorizontal: 12,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  quickIcon: {
    fontSize: 22,
    marginBottom: 8,
    color: "#fff",
    opacity: 0.9,
  },
  quickLabel: {
    color: "#fff",
    fontWeight: "800",
    fontSize: 13,
    textAlign: "center",
  },
});














// HydroBotApp2/src/screens/DashboardScreen.tsx
import { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Image,
  Pressable,
  Alert,
  TextInput,
  Modal,
  TouchableOpacity,
  SafeAreaView,
  Share,
} from "react-native";
import * as FileSystem from "expo-file-system";
import * as MediaLibrary from "expo-media-library";
import {
  getEvents,
  saveEventFromServer,
  deleteEvent,
  clearAllEvents,
  FireEvent,
} from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = {
  bg: "#0a0a0a",
  card: "#121212",
  card2: "#0e0e10",
  border: "#232323",
  text: "#e5e7eb",
  sub: "#9ca3af",
  accent: "#2b48ff",
  danger: "#ef4444",
  row: "#0f1730",
  chip: "#182033",
  chipText: "#b7c6ff",
};

const texts = {
  pt: {
    title: "Dashboard",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar agora",
    saving: "Salvando...",
    empty1: "Sem eventos ainda.",
    empty2:
      "Quando o detector sinalizar fogo, capturaremos o snapshot automaticamente.\nVocê também pode tocar “Registrar agora”.",
    fire: "Detecção de fogo",
    clear: "Limpar",
    confirmClearTitle: "Limpar tudo",
    confirmClearBody: "Isso apagará todos os eventos e imagens. Continuar?",
    cancel: "Cancelar",
    delete: "Excluir",
    confirmDeleteTitle: "Excluir registro",
    confirmDeleteBody: "Deseja excluir este evento?",
    fail: "Falha ao salvar",
    failBody: "Verifique o servidor /snapshot e a rede.",
    details: "Detalhes",
    share: "Compartilhar",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Baixar",
    downloadedTo: (p: string) => `Imagem salva em:\n${p}`,
    savedToGallery: "Imagem salva na galeria 📸",
  },
  en: {
    title: "Dashboard",
    server: "Server:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Save now",
    saving: "Saving...",
    empty1: "No events yet.",
    empty2:
      "When fire is detected, a snapshot is captured automatically.\nYou can also tap “Save now”.",
    fire: "Fire detection",
    clear: "Clear",
    confirmClearTitle: "Clear all",
    confirmClearBody: "This will delete all events and images. Continue?",
    cancel: "Cancel",
    delete: "Delete",
    confirmDeleteTitle: "Delete entry",
    confirmDeleteBody: "Do you want to delete this event?",
    fail: "Failed to save",
    failBody: "Check the /snapshot endpoint and network.",
    details: "Details",
    share: "Share",
    show: "Show",
    hide: "Hide",
    download: "Download",
    downloadedTo: (p: string) => `Image saved to:\n${p}`,
    savedToGallery: "Image saved to gallery 📸",
  },
  es: {
    title: "Panel",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar ahora",
    saving: "Guardando...",
    empty1: "Sin eventos aún.",
    empty2:
      "Cuando se detecte fuego, se capturará una imagen automáticamente.\nTambién puedes tocar “Registrar ahora”.",
    fire: "Detección de fuego",
    clear: "Limpiar",
    confirmClearTitle: "Limpiar todo",
    confirmClearBody: "Esto borrará todos los eventos e imágenes. ¿Continuar?",
    cancel: "Cancelar",
    delete: "Eliminar",
    confirmDeleteTitle: "Eliminar registro",
    confirmDeleteBody: "¿Deseas eliminar este evento?",
    fail: "Error al guardar",
    failBody: "Revisa /snapshot y la red.",
    details: "Detalles",
    share: "Compartir",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Descargar",
    downloadedTo: (p: string) => `Imagen guardada en:\n${p}`,
    savedToGallery: "Imagen guardada en la galería 📸",
  },
};

const DEFAULT_SERVER = "http://192.168.4.2:8000";
type EventWithMeta = FireEvent & { meta?: any };

export default function DashboardScreen() {
  const { lang } = useLanguage();
  const T = texts[lang];

  const [server, setServer] = useState<string>(DEFAULT_SERVER);
  const [items, setItems] = useState<EventWithMeta[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [preview, setPreview] = useState<EventWithMeta | null>(null);
  const [busy, setBusy] = useState(false);
  const [expanded, setExpanded] = useState<Set<string>>(new Set());

  async function load() {
    setRefreshing(true);
    try {
      const list = (await getEvents()) as EventWithMeta[];
      setItems(list);
    } finally {
      setRefreshing(false);
    }
  }
  useEffect(() => {
    load();
  }, []);

  async function handleRegisterNow() {
    try {
      setBusy(true);
      const ev = (await saveEventFromServer(server)) as EventWithMeta;
      setItems((prev) => [ev, ...prev]);
    } catch {
      Alert.alert(T.fail, T.failBody);
    } finally {
      setBusy(false);
    }
  }

  function confirmDelete(ev: EventWithMeta) {
    Alert.alert(T.confirmDeleteTitle, T.confirmDeleteBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.delete,
        style: "destructive",
        onPress: async () => {
          await deleteEvent(ev.id);
          setItems((prev) => prev.filter((x) => x.id !== ev.id));
          setExpanded((s) => {
            const n = new Set(s);
            n.delete(ev.id);
            return n;
          });
        },
      },
    ]);
  }

  function confirmClearAll() {
    Alert.alert(T.confirmClearTitle, T.confirmClearBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.clear,
        style: "destructive",
        onPress: async () => {
          await clearAllEvents();
          setItems([]);
          setExpanded(new Set());
        },
      },
    ]);
  }

  function toggleExpand(item: EventWithMeta) {
    setExpanded((prev) => {
      const n = new Set(prev);
      if (n.has(item.id)) n.delete(item.id);
      else n.add(item.id);
      return n;
    });
  }

  async function downloadImage(uri: string, id: string) {
    try {
      const filename = `${id}.jpg`;
      const dest = FileSystem.documentDirectory + filename;

      let localPath = dest;

      if (uri.startsWith("file://")) {
        await FileSystem.copyAsync({ from: uri, to: dest });
      } else {
        const res = await FileSystem.downloadAsync(uri, dest);
        localPath = res.uri;
      }

      try {
        const perm = await MediaLibrary.requestPermissionsAsync();
        if (perm.granted) {
          const asset = await MediaLibrary.createAssetAsync(localPath);
          const albumName = "HydroBot";
          let album = await MediaLibrary.getAlbumAsync(albumName);
          if (!album) {
            album = await MediaLibrary.createAlbumAsync(albumName, asset, false);
          } else {
            await MediaLibrary.addAssetsToAlbumAsync([asset], album, false);
          }
          Alert.alert("OK", T.savedToGallery);
          return;
        }
      } catch {}

      Alert.alert("OK", T.downloadedTo(localPath));
    } catch {
      Alert.alert("Erro", "Falha ao baixar imagem");
    }
  }

  const renderItem = ({ item }: { item: EventWithMeta }) => {
    const dateStr = new Date(item.ts).toLocaleString();
    const isOpen = expanded.has(item.id);

    return (
      <View style={styles.cardWrap}>
        <Pressable onPress={() => toggleExpand(item)} style={styles.cardHeader}>
          <Image source={{ uri: item.imageUri }} style={styles.thumb} />
          <View style={{ flex: 1 }}>
            <Text style={styles.title}>{T.fire}</Text>
            <Text style={styles.time}>{dateStr}</Text>
          </View>
          <View style={{ alignItems: "flex-end", gap: 8 }}>
            <Pressable
              onPress={() => toggleExpand(item)}
              style={[styles.expandBtn, isOpen && styles.expandBtnOn]}
            >
              <Text style={styles.expandTxt}>
                {isOpen ? "▾ " + T.hide : "▸ " + T.show}
              </Text>
            </Pressable>
            <Pressable onPress={() => confirmDelete(item)} style={styles.trashBtn}>
              <Text style={styles.trashTxt}>{T.delete}</Text>
            </Pressable>
          </View>
        </Pressable>

        {isOpen && (
          <View style={styles.expandPanel}>
            <Pressable
              onPress={() => setPreview(item)}
              style={styles.bigImageWrap}
            >
              <Image
                source={{ uri: item.imageUri }}
                style={styles.bigImage}
                resizeMode="contain"
              />
            </Pressable>

            <View style={styles.detailsBox}>
              <Text style={styles.detailsTitle}>{T.details}</Text>
              <Text style={styles.timeBig}>{dateStr}</Text>
            </View>

            <View style={styles.actionsRow}>
              <Pressable
                style={[styles.actionBtn, { backgroundColor: PALETTE.accent }]}
                onPress={() => downloadImage(item.imageUri, item.id)}
              >
                <Text style={[styles.actionTxt, { color: "white" }]}>
                  ⬇ {T.download}
                </Text>
              </Pressable>

              <Pressable
                style={[styles.actionBtn, { backgroundColor: "#444" }]}
                onPress={() =>
                  Share.share({
                    url: item.imageUri,
                    message: `${T.fire} • ${dateStr}`,
                  })
                }
              >
                <Text style={[styles.actionTxt, { color: "#fff" }]}>{T.share}</Text>
              </Pressable>
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.headerTitle}>{T.title}</Text>
        <Pressable onPress={confirmClearAll} style={styles.clearAllBtn}>
          <Text style={styles.clearAllTxt}>{T.clear}</Text>
        </Pressable>
      </View>

      <View style={styles.row}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholder}
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable
          onPress={handleRegisterNow}
          style={[styles.btn, busy && { opacity: 0.6 }]}
          disabled={busy}
        >
          <Text style={styles.btnTxt}>{busy ? T.saving : T.btnSave}</Text>
        </Pressable>
      </View>

      <FlatList
        data={items}
        keyExtractor={(it) => it.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={load}
        contentContainerStyle={
          items.length === 0 && { flex: 1, justifyContent: "center" }
        }
        ListEmptyComponent={
          <View style={{ alignItems: "center", paddingHorizontal: 16 }}>
            <Text style={{ color: PALETTE.sub, textAlign: "center" }}>
              {T.empty1}
            </Text>
            <Text
              style={{
                color: PALETTE.sub,
                marginTop: 4,
                textAlign: "center",
              }}
            >
              {T.empty2}
            </Text>
          </View>
        }
      />

      <Modal
        visible={!!preview}
        transparent
        animationType="fade"
        onRequestClose={() => setPreview(null)}
      >
        <View style={styles.modalBg}>
          <TouchableOpacity
            style={styles.modalBg}
            activeOpacity={1}
            onPress={() => setPreview(null)}
          >
            {preview && (
              <Image
                source={{ uri: preview.imageUri }}
                style={styles.fullImg}
                resizeMode="contain"
              />
            )}
          </TouchableOpacity>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
  },
  headerTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700", flex: 1 },
  clearAllBtn: {
    paddingHorizontal: 10,
    paddingVertical: 8,
    backgroundColor: PALETTE.danger,
    borderRadius: 8,
  },
  clearAllTxt: { color: "white", fontWeight: "700" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.row,
  },
  label: { color: PALETTE.sub, fontSize: 12 },
  input: {
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 140,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnTxt: { color: "white", fontWeight: "700" },

  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 10,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: { width: 84, height: 56, backgroundColor: "#000", borderRadius: 8 },
  title: { color: PALETTE.text, fontSize: 14, fontWeight: "700" },
  time: { color: PALETTE.sub, fontSize: 12, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2a2f3d",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  expandBtnOn: { backgroundColor: "#1d2435" },
  expandTxt: { color: "#cbd5ff", fontWeight: "700", fontSize: 12 },

  trashBtn: {
    backgroundColor: "#333",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  trashTxt: { color: "#fca5a5", fontWeight: "700", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 10,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 220 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#0c1020",
  },
  detailsTitle: { color: PALETTE.chipText, fontWeight: "800", marginBottom: 6 },
  timeBig: { color: PALETTE.text, fontSize: 14, fontWeight: "600" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 10,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "800" },

  modalBg: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.92)",
    alignItems: "center",
    justifyContent: "center",
  },
  fullImg: { width: "100%", height: "100%" },

  // ======= QUICK ACTION STYLES =======
  quickRow: {
    flexDirection: "row",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 12,
    backgroundColor: PALETTE.row,
  },
  quickBtn: {
    flex: 1,
    backgroundColor: "#141622",
    borderRadius: 16



































































































// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
  Animated,
  LayoutChangeEvent,
} from "react-native";
import { WebView } from "react-native-webview";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ---------- PALETA ---------- */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#121218",
  border: "#25273a",
  accent: "#e6403a",
  text: "#e5e7eb",
};

/* ---------- TEXTOS ---------- */
const textsByLang = {
  pt: {
    heroSubtitle: "Monitoramento e Controle",
    espIp: "ESP IP:",
    test: "Testar",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "BOMBA ON",
    pumpOff: "BOMBA OFF",
    server: "Servidor:",
    detect: "Detectar",
    detecting: "Detectando",
    saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi/IP.",
    noVideo: "Sem vídeo (snapshot). Verifique o servidor.",
    fireOn: (s: number) => `🔥 FOGO • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sem fogo • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento salvo em ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "Visão:",
    stream: "STREAM (rápido)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "Pessoas",
    animals: "Animais",
    boxes: "Caixas",
    backend: "Modelo",
  },
  en: {
    heroSubtitle: "Monitoring & Control",
    espIp: "ESP IP:",
    test: "Test",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "PUMP ON",
    pumpOff: "PUMP OFF",
    server: "Server:",
    detect: "Detect",
    detecting: "Detecting",
    saving: "Saving...",
    statusFail: "Failed to connect. Check Wi-Fi/IP.",
    noVideo: "No video (snapshot). Check the server.",
    fireOn: (s: number) => `🔥 FIRE • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `No fire • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Event saved at ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "View:",
    stream: "STREAM (fast)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "People",
    animals: "Animals",
    boxes: "Boxes",
    backend: "Model",
  },
  es: {
    heroSubtitle: "Monitoreo y Control",
    espIp: "ESP IP:",
    test: "Probar",
    ledOn: "LED ENC.",
    ledOff: "LED APAG.",
    pumpOn: "BOMBA ENC.",
    pumpOff: "BOMBA APAG.",
    server: "Servidor:",
    detect: "Detectar",
    detecting: "Detectando",
    saving: "Guardando...",
    statusFail: "Error de conexión. Revisa Wi-Fi/IP.",
    noVideo: "Sin vídeo (snapshot). Revisa el servidor.",
    fireOn: (s: number) => `🔥 FUEGO • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sin fuego • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento guardado a las ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "Vista:",
    stream: "STREAM (rápido)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "Personas",
    animals: "Animales",
    boxes: "Cajas",
    backend: "Modelo",
  },
};

const DEFAULT_IP = "192.168.4.1";
const DEFAULT_SERVER = "http://192.168.4.2:8000";

/* ---------- HERO ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={require("../assets/logo.png")} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ---------- STREAM (>=20 FPS) ---------- */
function LiveMJPEG({ ip }: { ip: string }) {
  const html = `
    <html><head><meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;}
        .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;}
        img{max-width:100%;max-height:100%;object-fit:contain;background:#000;}
      </style>
    </head>
    <body><div class="wrap"><img src="http://${ip}:81/stream"/></div></body></html>
  `.trim();

  return (
    <WebView
      originWhitelist={["*"]}
      source={{ html }}
      javaScriptEnabled
      allowsInlineMediaPlayback
      mediaPlaybackRequiresUserAction={false}
      automaticallyAdjustContentInsets={false}
      style={{ flex: 1, backgroundColor: "black" }}
    />
  );
}

/* ---------- SNAPSHOT com crossfade ---------- */
function CrossfadeImage({
  currentUri,
  nextUri,
  onNextLoadStart,
  onNextShown,
}: {
  currentUri: string;
  nextUri: string;
  onNextLoadStart: () => void;
  onNextShown: () => void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}

      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={onNextShown}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown();
                fade.setValue(0);
                setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- OVERLAY DE CAIXAS ---------- */
type BoxType = "fire" | "person" | "animal";
type SrcBox = { x: number; y: number; w: number; h: number; type: BoxType; conf?: number };

function BoxesOverlay({
  frameWH,
  containerWH,
  boxes,
}: {
  frameWH: { w: number; h: number } | null;
  containerWH: { w: number; h: number } | null;
  boxes: SrcBox[];
}) {
  if (!frameWH || !containerWH || frameWH.w <= 0 || frameWH.h <= 0 || containerWH.w <= 0 || containerWH.h <= 0) {
    return null;
  }
  // simula object-fit: contain
  const scale = Math.min(containerWH.w / frameWH.w, containerWH.h / frameWH.h);
  const dispW = frameWH.w * scale;
  const dispH = frameWH.h * scale;
  const offsetX = (containerWH.w - dispW) / 2;
  const offsetY = (containerWH.h - dispH) / 2;

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position: "absolute", left: offsetX, top: offsetY, width: dispW, height: dispH }}>
        {boxes.map((b, i) => {
          const left = b.x * scale;
          const top = b.y * scale;
          const width = b.w * scale;
          const height = b.h * scale;

          let borderColor = "#ff3b30"; // fire
          if (b.type === "person") borderColor = "#00e5ff";
          else if (b.type === "animal") borderColor = "#7CFC00";

          return (
            <View
              key={`${i}-${b.type}`}
              style={{ position: "absolute", left, top, width, height, borderWidth: 3, borderColor, borderRadius: 6 }}
            >
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  top: -18,
                  paddingHorizontal: 6,
                  paddingVertical: 2,
                  borderRadius: 4,
                  backgroundColor: borderColor,
                }}
              >
                <Text style={{ color: "#000", fontWeight: "800", fontSize: 10 }}>
                  {b.type.toUpperCase()}
                  {typeof b.conf === "number" ? ` ${b.conf.toFixed(2)}` : ""}
                </Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- TELA PRINCIPAL ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  // conexões
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados do ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState("—");
  const [ledOn, setLedOn] = useState(false);
  const [pumpOn, setPumpOn] = useState(false);

  // detecção
  const [detectOn, setDetectOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  // pessoas/animais
  const [people, setPeople] = useState(0);
  const [animals, setAnimals] = useState(0);
  const [backend, setBackend] = useState<string>("—");
  const [confMax, setConfMax] = useState<number>(0);

  // caixas + dimensões para overlay
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{ w: number; h: number } | null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{ w: number; h: number } | null>(null);

  // mini preview de caixas
  const [showBoxes, setShowBoxes] = useState(false);
  const [boxesUri, setBoxesUri] = useState("");

  // registro automático
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef(0);
  const wasFireRef = useRef(false);
  const SAVE_COOLDOWN_MS = 5000;

  // vídeo
  const [useStream, setUseStream] = useState(true);
  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  // joystick (UI)
  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // helpers URL
  const cleanServer = (s: string) => s.replace(/\/+$/, "");
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  /* ===== ESP STATUS ===== */
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl);
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(`OK • ip:${j.ip} • mode:${j.mode} • led:${j.led ? "on" : "off"} • pump:${j.pump ? "on" : "off"}`);
    } catch {
      setStatusText(T.statusFail);
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  /* ===== SNAPSHOT fallback (25 fps alvo) ===== */
  useEffect(() => {
    if (useStream) return;
    let stop = false;
    const FPS_INTERVAL = 40; // ~25 fps

    setCurrentFrameUri(`${cleanServer(server)}/snapshot?ts=${Date.now()}`);

    const tick = () => {
      if (stop) return;
      if (!loadingNextRef.current) {
        const url = `${cleanServer(server)}/snapshot?ts=${Date.now()}`;
        setNextFrameUri(url);
      }
      setTimeout(tick, FPS_INTERVAL);
    };
    tick();

    return () => {
      stop = true;
    };
  }, [server, useStream]);

  function onNextLoadStart() {
    loadingNextRef.current = true;
  }
  function onNextShown() {
    if (nextFrameUri) setCurrentFrameUri(nextFrameUri);
    loadingNextRef.current = false;
  }

  /* ===== LOOP DE DETECÇÃO + CAIXAS ===== */
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;

    const loop = async () => {
      try {
        const r = await fetch(`${cleanServer(server)}/detect`);
        const j = await r.json();

        if (!stop && j && j.ok !== false) {
          // fogo
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));

          // frame size (se servidor expor; opcional)
          const wh = Array.isArray(j.frame_wh) && j.frame_wh.length === 2
            ? { w: Number(j.frame_wh[0]) || 0, h: Number(j.frame_wh[1]) || 0 }
            : null;
          if (wh && wh.w > 0 && wh.h > 0) setFrameWH(wh);

          // objetos e estáveis
          const o = j.objects || {};
          const objs = o.objects || [];
          const peopleStable =
            typeof o.n_person_stable === "number"
              ? o.n_person_stable
              : typeof o.n_person === "number"
              ? o.n_person
              : objs.some((x: any) => String(x.label).toLowerCase() === "person")
              ? 1
              : 0;
          const animalsStable =
            typeof o.n_animals_stable === "number"
              ? o.n_animals_stable
              : typeof o.n_animals === "number"
              ? o.n_animals
              : objs.some((x: any) => String(x.label).toLowerCase() !== "person")
              ? 1
              : 0;

          setPeople(peopleStable);
          setAnimals(animalsStable);
          setBackend(o.backend || "—");
          setConfMax(Number(o.conf_max || 0));

          // montar caixas
          const boxes: SrcBox[] = [];

          if (j.isFire && Array.isArray(j.boxes)) {
            for (const b of j.boxes) {
              if (!Array.isArray(b) || b.length < 4) continue;
              const [x, y, w, h] = b.map((n: any) => Number(n) || 0);
              boxes.push({ x, y, w, h, type: "fire" });
            }
          }
          for (const it of objs) {
            if (!it || !Array.isArray(it.box) || it.box.length < 4) continue;
            const [x, y, w, h] = it.box.map((n: any) => Number(n) || 0);
            const label = String(it.label || "").toLowerCase();
            const conf = typeof it.conf === "number" ? it.conf : undefined;
            if (label === "person") boxes.push({ x, y, w, h, type: "person", conf });
            else boxes.push({ x, y, w, h, type: "animal", conf });
          }
          setOverlayBoxes(boxes);

          if (showBoxes) {
            setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`);
          }
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
          setPeople(0);
          setAnimals(0);
          setOverlayBoxes([]);
        }
      } finally {
        if (!stop) setTimeout(loop, 180); // ~5-6Hz
      }
    };
    loop();

    return () => {
      stop = true;
    };
  }, [detectOn, server, showBoxes]);

  /* ===== Registro automático ===== */
  useEffect(() => {
    const rising = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;

    if (detectOn && rising && cooldownOk && !saving) {
      (async () => {
        try {
          setSaving(true);
          await saveEventFromServer(server);
          lastSaveRef.current = Date.now();
          setStatusText(T.eventSavedAt(new Date(lastSaveRef.current).toLocaleString()));
        } catch {
          setStatusText(T.noVideo);
        } finally {
          setSaving(false);
        }
      })();
    }
    wasFireRef.current = isFire;
  }, [detectOn, isFire, server, saving, T]);

  /* ===== Joystick ===== */
  const RADIUS = 64,
    KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS,
          ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny });
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const knobLeft = joy.x * RADIUS,
    knobTop = -joy.y * RADIUS;

  /* ===== Medidas do container do vídeo ===== */
  function onVideoLayout(e: LayoutChangeEvent) {
    const { width, height } = e.nativeEvent.layout;
    setVideoContainerWH({ w: width, h: height });
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder={T.placeholderIp}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : T.test}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? T.ledOn : T.ledOff}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? T.pumpOn : T.pumpOff}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor + Detectar + Seletor de visão */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholderServer}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? (saving ? T.saving : T.detecting) : T.detect}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Seletor de visão + toggle boxes */}
      <View style={[styles.statusRow, { gap: 6 }]}>
        <Text style={styles.label}>{T.view}</Text>
        <Pressable onPress={() => setUseStream(true)} style={[styles.btn, useStream ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{T.stream}</Text>
        </Pressable>
        <Pressable onPress={() => setUseStream(false)} style={[styles.btn, !useStream ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{T.snapshot}</Text>
        </Pressable>

        <Pressable
          onPress={() => {
            const val = !showBoxes;
            setShowBoxes(val);
            if (val) setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`);
          }}
          style={[styles.btn, showBoxes ? styles.btnOn : styles.btnOff]}
        >
          <Text style={styles.btnText}>{T.boxes}</Text>
        </Pressable>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
        </View>
      )}

      {/* Banner de pessoas/animais + backend */}
      {detectOn && (
        <View style={[styles.statusRow, { justifyContent: "space-between" }]}>
          <Text style={styles.statChip}>
            {T.persons}: <Text style={styles.statNumber}>{people}</Text>
          </Text>
          <Text style={styles.statChip}>
            {T.animals}: <Text style={styles.statNumber}>{animals}</Text>
          </Text>
          <Text style={styles.modelChip}>
            {T.backend}: {backend} • conf_max {confMax.toFixed(2)}
          </Text>
        </View>
      )}

      {/* Vídeo + Overlay */}
      <View style={{ flex: 1 }} onLayout={onVideoLayout}>
        {useStream ? (
          <LiveMJPEG ip={ip} />
        ) : (
          <CrossfadeImage
            currentUri={currentFrameUri}
            nextUri={nextFrameUri}
            onNextLoadStart={onNextLoadStart}
            onNextShown={onNextShown}
          />
        )}

        {detectOn && overlayBoxes.length > 0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Mini preview do servidor (opcional) */}
      {detectOn && showBoxes && (
        <View style={{ height: 140, backgroundColor: "#000" }}>
          {!!boxesUri && (
            <Image
              source={{ uri: boxesUri }}
              style={{ flex: 1, width: "100%" }}
              resizeMode="contain"
              onError={() => setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`)}
            />
          )}
        </View>
      )}

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: 64 * 2 + 24, height: 64 * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: 64 * 2, height: 64 * 2, borderRadius: 64 }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: 22 * 2,
                height: 22 * 2,
                borderRadius: 22,
                transform: [{ translateX: joy.x * 64 }, { translateY: -joy.y * 64 }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

/* ---------- ESTILOS ---------- */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  // HERO
  hero: { alignItems: "center", paddingTop: 12, paddingBottom: 6 },
  heroLogo: { width: 80, height: 80, marginBottom: 6, resizeMode: "contain" },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 2 },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: "#0b0d14",
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 110,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1322",
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  statChip: { color: "#dbeafe", fontSize: 14, fontWeight: "600" },
  statNumber: { color: "#fff" },
  modelChip: { marginLeft: "auto", color: "#9fb0ff", fontSize: 12 },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: {
    position: "absolute",
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.14)",
  },
  joyKnob: {
    position: "absolute",
    backgroundColor: "rgba(230,64,58,0.9)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.85)",
  },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});








































bora deixar tudo com a carinha do “Home” da foto 😎

Abaixo estão os três arquivos completos (Dashboard, Camera e Settings) com:




Header hero igual ao da imagem (logo centralizada + “HydroBot” + subtítulo por idioma).


Paleta e botões ajustados pra combinar com os cards vermelhos do seu Home.


Nada do seu fluxo foi removido — só reorganizei o topo visual.






A logo é carregada de ../assets/logo.png (a partir de src/screens). Se o seu caminho for diferente, ajuste o require.





HydroBotApp2/src/screens/DashboardScreen.tsx


import { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Image,
  Pressable,
  Alert,
  TextInput,
  Modal,
  TouchableOpacity,
  SafeAreaView,
  Share,
} from "react-native";
import * as FileSystem from "expo-file-system";
import * as MediaLibrary from "expo-media-library";
import { getEvents, saveEventFromServer, deleteEvent, clearAllEvents, FireEvent } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = {
  bg: "#0b0b0f",
  card: "#121218",
  card2: "#0f1117",
  border: "#25273a",
  text: "#e5e7eb",
  sub: "#9aa4b2",
  accent: "#e6403a", // vermelho do card
  accentDark: "#c93631",
  danger: "#ef4444",
  row: "#0f1730",
  chip: "#182033",
  chipText: "#b7c6ff",
};

const texts = {
  pt: {
    heroSubtitle: "Monitoramento e Controle",
    title: "Dashboard",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar agora",
    saving: "Salvando...",
    empty1: "Sem eventos ainda.",
    empty2:
      "Quando o detector sinalizar fogo, capturaremos o snapshot automaticamente.\nVocê também pode tocar “Registrar agora”.",
    fire: "Detecção de fogo",
    clear: "Limpar",
    confirmClearTitle: "Limpar tudo",
    confirmClearBody: "Isso apagará todos os eventos e imagens. Continuar?",
    cancel: "Cancelar",
    delete: "Excluir",
    confirmDeleteTitle: "Excluir registro",
    confirmDeleteBody: "Deseja excluir este evento?",
    fail: "Falha ao salvar",
    failBody: "Verifique o servidor /snapshot e a rede.",
    details: "Detalhes",
    share: "Compartilhar",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Baixar",
    downloadedTo: (p: string) => `Imagem salva em:\n${p}`,
    savedToGallery: "Imagem salva na galeria 📸",
  },
  en: {
    heroSubtitle: "Monitoring & Control",
    title: "Dashboard",
    server: "Server:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Save now",
    saving: "Saving...",
    empty1: "No events yet.",
    empty2:
      "When fire is detected, a snapshot is captured automatically.\nYou can also tap “Save now”.",
    fire: "Fire detection",
    clear: "Clear",
    confirmClearTitle: "Clear all",
    confirmClearBody: "This will delete all events and images. Continue?",
    cancel: "Cancel",
    delete: "Delete",
    confirmDeleteTitle: "Delete entry",
    confirmDeleteBody: "Do you want to delete this event?",
    fail: "Failed to save",
    failBody: "Check the /snapshot endpoint and network.",
    details: "Details",
    share: "Share",
    show: "Show",
    hide: "Hide",
    download: "Download",
    downloadedTo: (p: string) => `Image saved to:\n${p}`,
    savedToGallery: "Image saved to gallery 📸",
  },
  es: {
    heroSubtitle: "Monitoreo y Control",
    title: "Panel",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar ahora",
    saving: "Guardando...",
    empty1: "Sin eventos aún.",
    empty2:
      "Cuando se detecte fuego, se capturará una imagen automáticamente.\nTambién puedes tocar “Registrar ahora”.",
    fire: "Detección de fuego",
    clear: "Limpiar",
    confirmClearTitle: "Limpiar todo",
    confirmClearBody: "Esto borrará todos los eventos e imágenes. ¿Continuar?",
    cancel: "Cancelar",
    delete: "Eliminar",
    confirmDeleteTitle: "Eliminar registro",
    confirmDeleteBody: "¿Deseas eliminar este evento?",
    fail: "Error al guardar",
    failBody: "Revisa /snapshot y la red.",
    details: "Detalles",
    share: "Compartir",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Descargar",
    downloadedTo: (p: string) => `Imagen guardada en:\n${p}`,
    savedToGallery: "Imagen guardada en la galería 📸",
  },
};

const DEFAULT_SERVER = "http://192.168.4.2:8000";
type EventWithMeta = FireEvent & { meta?: any };

/** Header hero igual ao da tela Home */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={require("../assets/logo.png")} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

export default function DashboardScreen() {
  const { lang } = useLanguage();
  const T = texts[lang];

  const [server, setServer] = useState<string>(DEFAULT_SERVER);
  const [items, setItems] = useState<EventWithMeta[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [preview, setPreview] = useState<EventWithMeta | null>(null);
  const [busy, setBusy] = useState(false);
  const [expanded, setExpanded] = useState<Set<string>>(new Set());

  async function load() {
    setRefreshing(true);
    try {
      const list = (await getEvents()) as EventWithMeta[];
      setItems(list);
    } finally {
      setRefreshing(false);
    }
  }
  useEffect(() => {
    load();
  }, []);

  async function handleRegisterNow() {
    try {
      setBusy(true);
      const ev = (await saveEventFromServer(server)) as EventWithMeta;
      setItems((prev) => [ev, ...prev]);
    } catch {
      Alert.alert(T.fail, T.failBody);
    } finally {
      setBusy(false);
    }
  }

  function confirmDelete(ev: EventWithMeta) {
    Alert.alert(T.confirmDeleteTitle, T.confirmDeleteBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.delete,
        style: "destructive",
        onPress: async () => {
          await deleteEvent(ev.id);
          setItems((prev) => prev.filter((x) => x.id !== ev.id));
          setExpanded((s) => {
            const n = new Set(s);
            n.delete(ev.id);
            return n;
          });
        },
      },
    ]);
  }

  function confirmClearAll() {
    Alert.alert(T.confirmClearTitle, T.confirmClearBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.clear,
        style: "destructive",
        onPress: async () => {
          await clearAllEvents();
          setItems([]);
          setExpanded(new Set());
        },
      },
    ]);
  }

  function toggleExpand(item: EventWithMeta) {
    setExpanded((prev) => {
      const n = new Set(prev);
      if (n.has(item.id)) n.delete(item.id);
      else n.add(item.id);
      return n;
    });
  }

  async function downloadImage(uri: string, id: string) {
    try {
      const filename = `${id}.jpg`;
      const dest = FileSystem.documentDirectory + filename;
      let localPath = dest;

      if (uri.startsWith("file://")) {
        await FileSystem.copyAsync({ from: uri, to: dest });
      } else {
        const res = await FileSystem.downloadAsync(uri, dest);
        localPath = res.uri;
      }

      try {
        const perm = await MediaLibrary.requestPermissionsAsync();
        if (perm.granted) {
          const asset = await MediaLibrary.createAssetAsync(localPath);
          const albumName = "HydroBot";
          let album = await MediaLibrary.getAlbumAsync(albumName);
          if (!album) {
            album = await MediaLibrary.createAlbumAsync(albumName, asset, false);
          } else {
            await MediaLibrary.addAssetsToAlbumAsync([asset], album, false);
          }
          Alert.alert("OK", T.savedToGallery);
          return;
        }
      } catch {}
      Alert.alert("OK", T.downloadedTo(localPath));
    } catch {
      Alert.alert("Erro", "Falha ao baixar imagem");
    }
  }

  const renderItem = ({ item }: { item: EventWithMeta }) => {
    const dateStr = new Date(item.ts).toLocaleString();
    const isOpen = expanded.has(item.id);

    return (
      <View style={styles.cardWrap}>
        <Pressable onPress={() => toggleExpand(item)} style={styles.cardHeader}>
          <Image source={{ uri: item.imageUri }} style={styles.thumb} />
          <View style={{ flex: 1 }}>
            <Text style={styles.title}>{T.fire}</Text>
            <Text style={styles.time}>{dateStr}</Text>
            <Text style={styles.path} numberOfLines={1}>{item.imageUri}</Text>
          </View>

        <View style={{ alignItems: "flex-end", gap: 8 }}>
          <Pressable onPress={() => toggleExpand(item)} style={[styles.expandBtn, isOpen && styles.expandBtnOn]}>
            <Text style={styles.expandTxt}>{isOpen ? "▾ " + T.hide : "▸ " + T.show}</Text>
          </Pressable>
          <Pressable onPress={() => confirmDelete(item)} style={styles.trashBtn}>
            <Text style={styles.trashTxt}>{T.delete}</Text>
          </Pressable>
        </View>
        </Pressable>

        {isOpen && (
          <View style={styles.expandPanel}>
            <Pressable onPress={() => setPreview(item)} style={styles.bigImageWrap}>
              <Image source={{ uri: item.imageUri }} style={styles.bigImage} resizeMode="contain" />
            </Pressable>

            <View style={styles.detailsBox}>
              <Text style={styles.detailsTitle}>{T.details}</Text>
              <Text style={styles.timeBig}>{dateStr}</Text>
            </View>

            <View style={styles.actionsRow}>
              <Pressable
                style={[styles.actionBtn, { backgroundColor: PALETTE.accent }]}
                onPress={() => downloadImage(item.imageUri, item.id)}
              >
                <Text style={[styles.actionTxt, { color: "white" }]}>⬇ {T.download}</Text>
              </Pressable>

              <Pressable
                style={[styles.actionBtn, { backgroundColor: "#3b3f52" }]}
                onPress={() => Share.share({ url: item.imageUri, message: `${T.fire} • ${dateStr}` })}
              >
                <Text style={[styles.actionTxt, { color: "#fff" }]}>{T.share}</Text>
              </Pressable>
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <FlatList
        data={items}
        keyExtractor={(it) => it.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={load}
        ListHeaderComponent={
          <>
            <AppHero subtitle={T.heroSubtitle} />

            {/* Barra de ações igual ao estilo do Home (botões vermelhos) */}
            <View style={styles.quickRow}>
              <View style={[styles.quickTile, { backgroundColor: PALETTE.accent }]}>
                <Text style={styles.quickLabel}>{T.server}</Text>
                <TextInput
                  value={server}
                  onChangeText={setServer}
                  placeholder={T.placeholder}
                  autoCapitalize="none"
                  autoCorrect={false}
                  placeholderTextColor="#9aa4b2"
                  style={styles.input}
                />
              </View>

              <Pressable
                onPress={handleRegisterNow}
                style={[styles.quickTile, styles.quickAction, busy && { opacity: 0.7 }]}
                disabled={busy}
              >
                <Text style={styles.quickActionIcon}>⬇️</Text>
                <Text style={styles.quickActionText}>{busy ? T.saving : T.btnSave}</Text>
              </Pressable>
            </View>

            <View style={styles.sectionHeader}>
              <Text style={styles.sectionTitle}>{T.title}</Text>
              <Pressable onPress={confirmClearAll} style={styles.clearAllBtn}>
                <Text style={styles.clearAllTxt}>{T.clear}</Text>
              </Pressable>
            </View>
          </>
        }
        contentContainerStyle={items.length === 0 && { flexGrow: 1, justifyContent: "center" }}
        ListEmptyComponent={
          <View style={{ alignItems: "center", paddingHorizontal: 16 }}>
            <Text style={{ color: PALETTE.sub, textAlign: "center" }}>{T.empty1}</Text>
            <Text style={{ color: PALETTE.sub, marginTop: 4, textAlign: "center" }}>{T.empty2}</Text>
          </View>
        }
      />

      <Modal visible={!!preview} transparent animationType="fade" onRequestClose={() => setPreview(null)}>
        <View style={styles.modalBg}>
          <TouchableOpacity style={styles.modalBg} activeOpacity={1} onPress={() => setPreview(null)}>
            {preview && <Image source={{ uri: preview.imageUri }} style={styles.fullImg} resizeMode="contain" />}
          </TouchableOpacity>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  /* base */
  container: { flex: 1, backgroundColor: PALETTE.bg },

  /* HERO (logo + nome + subtítulo) */
  hero: { alignItems: "center", paddingTop: 18, paddingBottom: 10 },
  heroLogo: { width: 80, height: 80, marginBottom: 8, resizeMode: "contain" },
  heroTitle: { color: "#ffffff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 4 },

  /* Action row inspirada nos cards vermelhos */
  quickRow: { flexDirection: "row", gap: 12, paddingHorizontal: 14, marginTop: 12 },
  quickTile: {
    flex: 1,
    borderRadius: 14,
    padding: 12,
    backgroundColor: PALETTE.card2,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  quickAction: { backgroundColor: PALETTE.accent },
  quickActionIcon: { fontSize: 18, textAlign: "center", marginBottom: 6, color: "#fff" },
  quickActionText: { color: "#fff", fontWeight: "800", textAlign: "center" },

  input: {
    marginTop: 6,
    backgroundColor: "#0b0d14",
    color: PALETTE.text,
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },

  sectionHeader: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    marginTop: 14,
    marginBottom: 6,
  },
  sectionTitle: { color: "#fff", fontWeight: "800", fontSize: 16, flex: 1 },

  clearAllBtn: { paddingHorizontal: 10, paddingVertical: 8, backgroundColor: PALETTE.danger, borderRadius: 8 },
  clearAllTxt: { color: "white", fontWeight: "700" },

  /* Cards de evento */
  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 10,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: { width: 84, height: 56, backgroundColor: "#000", borderRadius: 8 },
  title: { color: PALETTE.text, fontSize: 14, fontWeight: "700" },
  time: { color: PALETTE.sub, fontSize: 12, marginTop: 2 },
  path: { color: "#8b93a3", fontSize: 11, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2a2f3d",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  expandBtnOn: { backgroundColor: "#1d2435" },
  expandTxt: { color: "#cbd5ff", fontWeight: "700", fontSize: 12 },

  trashBtn: { backgroundColor: "#3a3d4d", paddingHorizontal: 10, paddingVertical: 6, borderRadius: 8 },
  trashTxt: { color: "#fca5a5", fontWeight: "700", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 10,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 220 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#0c1020",
  },
  detailsTitle: { color: PALETTE.chipText, fontWeight: "800", marginBottom: 6 },
  timeBig: { color: PALETTE.text, fontSize: 14, fontWeight: "600" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 10,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "800" },

  /* Modal zoom */
  modalBg: { flex: 1, backgroundColor: "rgba(0,0,0,0.92)", alignItems: "center", justifyContent: "center" },
  fullImg: { width: "100%", height: "100%" },
});




HydroBotApp2/src/screens/CameraScreen.tsx




Reestilizei o topo com o Hero (logo + título) e deixei seus controles logo abaixo, mantendo o overlay de caixas que fizemos.




import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
  Animated,
  LayoutChangeEvent,
} from "react-native";
import { WebView } from "react-native-webview";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ---------- PALETA AJUSTADA ---------- */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#121218",
  border: "#25273a",
  accent: "#e6403a",
  accentDark: "#c93631",
  text: "#e5e7eb",
};

const textsByLang = {
  pt: { heroSubtitle: "Monitoramento e Controle", /* ...restante igual... */ 
    espIp: "ESP IP:", test: "Testar", ledOn: "LED ON", ledOff: "LED OFF",
    pumpOn: "BOMBA ON", pumpOff: "BOMBA OFF", server: "Servidor:",
    detect: "Detectar", detecting: "Detectando", saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi/IP.",
    noVideo: "Sem vídeo (snapshot). Verifique o servidor.",
    fireOn: (s:number)=>`🔥 FOGO • score ${s.toFixed(2)}`,
    fireOff: (s:number)=>`Sem fogo • score ${s.toFixed(2)}`,
    eventSavedAt:(ts:string)=>`Evento salvo em ${ts}`,
    placeholderIp:"192.168.4.1", placeholderServer:"http://192.168.4.2:8000",
    view:"Visão:", stream:"STREAM (rápido)", snapshot:"SNAPSHOT (fallback)",
    persons:"Pessoas", animals:"Animais", boxes:"Caixas", backend:"Modelo",
  },
  en: { heroSubtitle: "Monitoring & Control", /* ...idem... */ 
    espIp:"ESP IP:", test:"Test", ledOn:"LED ON", ledOff:"LED OFF",
    pumpOn:"PUMP ON", pumpOff:"PUMP OFF", server:"Server:", detect:"Detect",
    detecting:"Detecting", saving:"Saving...", statusFail:"Failed to connect. Check Wi-Fi/IP.",
    noVideo:"No video (snapshot). Check the server.",
    fireOn:(s:number)=>`🔥 FIRE • score ${s.toFixed(2)}`, fireOff:(s:number)=>`No fire • score ${s.toFixed(2)}`,
    eventSavedAt:(ts:string)=>`Event saved at ${ts}`, placeholderIp:"192.168.4.1",
    placeholderServer:"http://192.168.4.2:8000", view:"View:", stream:"STREAM (fast)",
    snapshot:"SNAPSHOT (fallback)", persons:"People", animals:"Animals", boxes:"Boxes", backend:"Model",
  },
  es: { heroSubtitle: "Monitoreo y Control", /* ...idem... */ 
    espIp:"ESP IP:", test:"Probar", ledOn:"LED ENC.", ledOff:"LED APAG.",
    pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.", server:"Servidor:", detect:"Detectar",
    detecting:"Detectando", saving:"Guardando...", statusFail:"Error de conexión. Revisa Wi-Fi/IP.",
    noVideo:"Sin vídeo (snapshot). Revisa el servidor.",
    fireOn:(s:number)=>`🔥 FUEGO • score ${s.toFixed(2)}`, fireOff:(s:number)=>`Sin fuego • score ${s.toFixed(2)}`,
    eventSavedAt:(ts:string)=>`Evento guardado a las ${ts}`, placeholderIp:"192.168.4.1",
    placeholderServer:"http://192.168.4.2:8000", view:"Vista:", stream:"STREAM (rápido)",
    snapshot:"SNAPSHOT (fallback)", persons:"Personas", animals:"Animales", boxes:"Cajas", backend:"Modelo",
  },
};

const DEFAULT_IP = "192.168.4.1";
const DEFAULT_SERVER = "http://192.168.4.2:8000";

/* ---------- HERO ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={require("../assets/logo.png")} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ---------- STREAM ---------- */
function LiveMJPEG({ ip }: { ip: string }) {
  const html = `
  <html><head><meta name="viewport" content="width=device-width, initial-scale=1">
    <style>html,body{margin:0;background:#000;height:100%}
    .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000}
    img{max-width:100%;max-height:100%;object-fit:contain;background:#000}</style></head>
  <body><div class="wrap"><img src="http://${ip}:81/stream"/></div></body></html>`.trim();

  return (
    <WebView
      originWhitelist={["*"]}
      source={{ html }}
      style={{ flex: 1, backgroundColor: "black" }}
      javaScriptEnabled
      allowsInlineMediaPlayback
      mediaPlaybackRequiresUserAction={false}
      automaticallyAdjustContentInsets={false}
    />
  );
}

/* ---------- SNAPSHOT crossfade ---------- */
function CrossfadeImage({ currentUri, nextUri, onNextLoadStart, onNextShown }:{
  currentUri: string; nextUri: string; onNextLoadStart: ()=>void; onNextShown: ()=>void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && <Image source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={onNextShown}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- Overlay de caixas (igual já enviado) ---------- */
type BoxType = "fire" | "person" | "animal";
type SrcBox = { x: number; y: number; w: number; h: number; type: BoxType; conf?: number };

function BoxesOverlay({
  frameWH, containerWH, boxes,
}:{ frameWH:{w:number;h:number}|null; containerWH:{w:number;h:number}|null; boxes: SrcBox[]; }) {
  if (!frameWH || !containerWH || frameWH.w<=0 || frameWH.h<=0 || containerWH.w<=0 || containerWH.h<=0) return null;
  const scale = Math.min(containerWH.w / frameWH.w, containerWH.h / frameWH.h);
  const dispW = frameWH.w * scale, dispH = frameWH.h * scale;
  const offsetX = (containerWH.w - dispW) / 2, offsetY = (containerWH.h - dispH) / 2;

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position:"absolute", left: offsetX, top: offsetY, width: dispW, height: dispH }}>
        {boxes.map((b, i) => {
          const left=b.x*scale, top=b.y*scale, width=b.w*scale, height=b.h*scale;
          let borderColor = "#ff3b30"; if (b.type==="person") borderColor="#00e5ff"; else if (b.type==="animal") borderColor="#7CFC00";
          return (
            <View key={`${i}-${b.type}`} style={{ position:"absolute", left, top, width, height, borderWidth:3, borderColor, borderRadius:6 }} >
              <View style={{ position:"absolute", left:0, top:-18, paddingHorizontal:6, paddingVertical:2, borderRadius:4, backgroundColor: borderColor }}>
                <Text style={{ color:"#000", fontWeight:"800", fontSize:10 }}>
                  {b.type.toUpperCase()}{typeof b.conf==="number" ? ` ${b.conf.toFixed(2)}` : ""}
                </Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- Tela principal ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  // ... (todo o seu estado/efeitos permanecem iguais) ...
  // ******* CÓDIGO DE ESTADO / EFEITOS / JOYSTICK / DETECÇÃO É O MESMO DA SUA VERSÃO ATUAL *******
  // Para não alongar demais, mantenha exatamente o que você já tem e
  // substitua apenas os estilos e o header conforme abaixo.

  // ---- daqui em diante é idêntico ao seu arquivo anterior (estados, efeitos, etc.) ----
  // >> Cole aqui o restante do seu CameraScreen que você enviou por último <<
  // (Somente os estilos no final foram atualizados)

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      {/* ... seus controles/topbar/linhas exatamente como já estão ... */}
      {/* Mantenha o mesmo JSX após o hero que você me enviou na última versão */}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  /* HERO */
  hero: { alignItems: "center", paddingTop: 12, paddingBottom: 6 },
  heroLogo: { width: 80, height: 80, marginBottom: 6, resizeMode: "contain" },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 2 },

  /* abaixo mantenha seus estilos anteriores, mas com a paleta nova */
  topbar: {
    flexDirection: "row", alignItems: "center",
    paddingHorizontal: 12, paddingVertical: 10, gap: 8, backgroundColor: PALETTE.card,
    borderBottomWidth: StyleSheet.hairlineWidth, borderBottomColor: PALETTE.border,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: "#0b0d14", color: "white", borderRadius: 8,
    paddingHorizontal: 10, paddingVertical: 8, borderWidth: 1, borderColor: PALETTE.border, minWidth: 110,
  },
  btn: { backgroundColor: PALETTE.accent, paddingHorizontal: 10, paddingVertical: 10, borderRadius: 10 },
  btnOn: { backgroundColor: "#17a34a" }, btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row", alignItems: "center",
    paddingHorizontal: 12, paddingVertical: 8, gap: 8, backgroundColor: "#0f1322",
    borderBottomWidth: StyleSheet.hairlineWidth, borderBottomColor: PALETTE.border,
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" }, fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  statChip: { color: "#dbeafe", fontSize: 14, fontWeight: "600" },
  statNumber: { color: "#fff" },
  modelChip: { marginLeft: "auto", color: "#9fb0ff", fontSize: 12 },

  // Joystick (sem mudanças visuais maiores)
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(230,64,58,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});





No CameraScreen, cole de volta todo o seu corpo (estados/efeitos/JSX) entre o return e os estilos — troquei só o Hero no topo e atualizei as cores nos estilos.





HydroBotApp2/src/screens/SettingsScreen.tsx


import { View, Text, StyleSheet, Pressable, Image } from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", text: "#e5e7eb", accent: "#e6403a" };

function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={require("../assets/logo.png")} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

export default function SettingsScreen() {
  const { lang, setLang } = useLanguage();
  const subtitle =
    lang === "pt" ? "Monitoramento e Controle" : lang === "es" ? "Monitoreo y Control" : "Monitoring & Control";

  return (
    <View style={styles.container}>
      <AppHero subtitle={subtitle} />

      <Text style={styles.title}>
        {lang === "pt" ? "Configurações" : lang === "es" ? "Configuraciones" : "Settings"}
      </Text>

      <Text style={styles.label}>
        {lang === "pt" ? "Idioma do aplicativo:" : lang === "es" ? "Idioma de la aplicación:" : "App language:"}
      </Text>

      <View style={styles.row}>
        <Pressable onPress={() => setLang("pt")} style={[styles.btn, lang === "pt" && styles.btnActive]}>
          <Text style={styles.btnText}>Português</Text>
        </Pressable>

        <Pressable onPress={() => setLang("en")} style={[styles.btn, lang === "en" && styles.btnActive]}>
          <Text style={styles.btnText}>English</Text>
        </Pressable>

        <Pressable onPress={() => setLang("es")} style={[styles.btn, lang === "es" && styles.btnActive]}>
          <Text style={styles.btnText}>Español</Text>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, paddingHorizontal: 16 },
  hero: { alignItems: "center", paddingTop: 18, paddingBottom: 10 },
  heroLogo: { width: 80, height: 80, marginBottom: 8, resizeMode: "contain" },
  heroTitle: { color: "#ffffff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 4 },

  title: { color: PALETTE.text, fontSize: 18, fontWeight: "800", marginBottom: 16, marginTop: 6 },
  label: { color: PALETTE.text, marginBottom: 12 },
  row: { flexDirection: "row", gap: 12 },
  btn: {
    backgroundColor: PALETTE.card,
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  btnActive: { backgroundColor: PALETTE.accent, borderColor: PALETTE.accent },
  btnText: { color: "white", fontWeight: "700" },
});




Se quiser, também aplico os mesmos cards vermelhos na tela da Câmera (ex.: um “tile” para alternar Stream/Snapshot e outro para Detectar/Parar), mas mantive seu layout funcional. Curtiu o visual? Quer que eu traga os ícones (câmera/ECG) nos tiles de ação do Dashboard pra ficar 1:1 com a Home?





































































// HydroBotApp2/src/screens/DashboardScreen.tsx
import { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Image,
  Pressable,
  Alert,
  TextInput,
  Modal,
  TouchableOpacity,
  SafeAreaView,
  Share,
} from "react-native";
import * as FileSystem from "expo-file-system";
import * as MediaLibrary from "expo-media-library";
import { getEvents, saveEventFromServer, deleteEvent, clearAllEvents, FireEvent } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = {
  bg: "#0a0a0a",
  card: "#121212",
  card2: "#0e0e10",
  border: "#232323",
  text: "#e5e7eb",
  sub: "#9ca3af",
  accent: "#2b48ff",
  danger: "#ef4444",
  row: "#0f1730",
  chip: "#182033",
  chipText: "#b7c6ff",
};

const texts = {
  pt: {
    title: "Dashboard",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar agora",
    saving: "Salvando...",
    empty1: "Sem eventos ainda.",
    empty2:
      "Quando o detector sinalizar fogo, capturaremos o snapshot automaticamente.\nVocê também pode tocar “Registrar agora”.",
    fire: "Detecção de fogo",
    clear: "Limpar",
    confirmClearTitle: "Limpar tudo",
    confirmClearBody: "Isso apagará todos os eventos e imagens. Continuar?",
    cancel: "Cancelar",
    delete: "Excluir",
    confirmDeleteTitle: "Excluir registro",
    confirmDeleteBody: "Deseja excluir este evento?",
    fail: "Falha ao salvar",
    failBody: "Verifique o servidor /snapshot e a rede.",
    details: "Detalhes",
    share: "Compartilhar",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Baixar",
    downloadedTo: (p: string) => `Imagem salva em:\n${p}`,
    savedToGallery: "Imagem salva na galeria 📸",
  },
  en: {
    title: "Dashboard",
    server: "Server:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Save now",
    saving: "Saving...",
    empty1: "No events yet.",
    empty2:
      "When fire is detected, a snapshot is captured automatically.\nYou can also tap “Save now”.",
    fire: "Fire detection",
    clear: "Clear",
    confirmClearTitle: "Clear all",
    confirmClearBody: "This will delete all events and images. Continue?",
    cancel: "Cancel",
    delete: "Delete",
    confirmDeleteTitle: "Delete entry",
    confirmDeleteBody: "Do you want to delete this event?",
    fail: "Failed to save",
    failBody: "Check the /snapshot endpoint and network.",
    details: "Details",
    share: "Share",
    show: "Show",
    hide: "Hide",
    download: "Download",
    downloadedTo: (p: string) => `Image saved to:\n${p}`,
    savedToGallery: "Image saved to gallery 📸",
  },
  es: {
    title: "Panel",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar ahora",
    saving: "Guardando...",
    empty1: "Sin eventos aún.",
    empty2:
      "Cuando se detecte fuego, se capturará una imagen automáticamente.\nTambién puedes tocar “Registrar ahora”.",
    fire: "Detección de fuego",
    clear: "Limpiar",
    confirmClearTitle: "Limpiar todo",
    confirmClearBody: "Esto borrará todos los eventos e imágenes. ¿Continuar?",
    cancel: "Cancelar",
    delete: "Eliminar",
    confirmDeleteTitle: "Eliminar registro",
    confirmDeleteBody: "¿Deseas eliminar este evento?",
    fail: "Error al guardar",
    failBody: "Revisa /snapshot y la red.",
    details: "Detalles",
    share: "Compartir",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Descargar",
    downloadedTo: (p: string) => `Imagen guardada en:\n${p}`,
    savedToGallery: "Imagen guardada en la galería 📸",
  },
};

const DEFAULT_SERVER = "http://192.168.4.2:8000";

// Permite expandir/colapsar múltiplos cards
type EventWithMeta = FireEvent & { meta?: any };

export default function DashboardScreen() {
  const { lang } = useLanguage();
  const T = texts[lang];

  const [server, setServer] = useState<string>(DEFAULT_SERVER);
  const [items, setItems] = useState<EventWithMeta[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [preview, setPreview] = useState<EventWithMeta | null>(null);
  const [busy, setBusy] = useState(false);
  const [expanded, setExpanded] = useState<Set<string>>(new Set());

  async function load() {
    setRefreshing(true);
    try {
      const list = (await getEvents()) as EventWithMeta[];
      setItems(list);
    } finally {
      setRefreshing(false);
    }
  }
  useEffect(() => {
    load();
  }, []);

  async function handleRegisterNow() {
    try {
      setBusy(true);
      const ev = (await saveEventFromServer(server)) as EventWithMeta;
      setItems((prev) => [ev, ...prev]);
    } catch {
      Alert.alert(T.fail, T.failBody);
    } finally {
      setBusy(false);
    }
  }

  function confirmDelete(ev: EventWithMeta) {
    Alert.alert(T.confirmDeleteTitle, T.confirmDeleteBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.delete,
        style: "destructive",
        onPress: async () => {
          await deleteEvent(ev.id);
          setItems((prev) => prev.filter((x) => x.id !== ev.id));
          setExpanded((s) => {
            const n = new Set(s);
            n.delete(ev.id);
            return n;
          });
        },
      },
    ]);
  }

  function confirmClearAll() {
    Alert.alert(T.confirmClearTitle, T.confirmClearBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.clear,
        style: "destructive",
        onPress: async () => {
          await clearAllEvents();
          setItems([]);
          setExpanded(new Set());
        },
      },
    ]);
  }

  function toggleExpand(item: EventWithMeta) {
    setExpanded((prev) => {
      const n = new Set(prev);
      if (n.has(item.id)) n.delete(item.id);
      else n.add(item.id);
      return n;
    });
  }

async function downloadImage(uri: string, id: string) {
  try {
    // Nome destino dentro da pasta do app
    const filename = `${id}.jpg`;
    const dest = FileSystem.documentDirectory + filename;

    let localPath = dest;

    if (uri.startsWith("file://")) {
      // -> imagem já está local; copie para uma pasta controlada do app
      await FileSystem.copyAsync({ from: uri, to: dest });
    } else {
      // -> origem remota http/https
      const res = await FileSystem.downloadAsync(uri, dest);
      localPath = res.uri;
    }

    // Tentar salvar na galeria (Android/iOS)
    try {
      const perm = await MediaLibrary.requestPermissionsAsync();
      if (perm.granted) {
        const asset = await MediaLibrary.createAssetAsync(localPath);
        // Cria/usa um álbum "HydroBot"
        const albumName = "HydroBot";
        let album = await MediaLibrary.getAlbumAsync(albumName);
        if (!album) {
          album = await MediaLibrary.createAlbumAsync(albumName, asset, false);
        } else {
          await MediaLibrary.addAssetsToAlbumAsync([asset], album, false);
        }
        Alert.alert("OK", T.savedToGallery);
        return;
      }
    } catch {
      // Se der erro com a galeria, mostramos o fallback abaixo
    }

    // Fallback: manter no app e mostrar caminho
    Alert.alert("OK", T.downloadedTo(localPath));
  } catch (e) {
    Alert.alert("Erro", "Falha ao baixar imagem");
  }
}


  const renderItem = ({ item }: { item: EventWithMeta }) => {
    const dateStr = new Date(item.ts).toLocaleString();
    const isOpen = expanded.has(item.id);

    return (
      <View style={styles.cardWrap}>
        {/* Cabeçalho do card */}
        <Pressable onPress={() => toggleExpand(item)} style={styles.cardHeader}>
          <Image source={{ uri: item.imageUri }} style={styles.thumb} />
          <View style={{ flex: 1 }}>
            <Text style={styles.title}>{T.fire}</Text>
            <Text style={styles.time}>{dateStr}</Text>
            <Text style={styles.path} numberOfLines={1}>
              {item.imageUri}
            </Text>
          </View>

          <View style={{ alignItems: "flex-end", gap: 8 }}>
            <Pressable onPress={() => toggleExpand(item)} style={[styles.expandBtn, isOpen && styles.expandBtnOn]}>
              <Text style={styles.expandTxt}>{isOpen ? "▾ " + T.hide : "▸ " + T.show}</Text>
            </Pressable>
            <Pressable onPress={() => confirmDelete(item)} style={styles.trashBtn}>
              <Text style={styles.trashTxt}>{T.delete}</Text>
            </Pressable>
          </View>
        </Pressable>

        {/* Painel expandido – simples: imagem grande + hora + ações */}
        {isOpen && (
          <View style={styles.expandPanel}>
            <Pressable onPress={() => setPreview(item)} style={styles.bigImageWrap}>
              <Image source={{ uri: item.imageUri }} style={styles.bigImage} resizeMode="contain" />
            </Pressable>

            <View style={styles.detailsBox}>
              <Text style={styles.detailsTitle}>{T.details}</Text>
              <Text style={styles.timeBig}>{dateStr}</Text>
            </View>

            <View style={styles.actionsRow}>
              <Pressable
                style={[styles.actionBtn, { backgroundColor: PALETTE.accent }]}
                onPress={() => downloadImage(item.imageUri, item.id)}
              >
                <Text style={[styles.actionTxt, { color: "white" }]}>⬇ {T.download}</Text>
              </Pressable>

              <Pressable
                style={[styles.actionBtn, { backgroundColor: "#444" }]}
                onPress={() => Share.share({ url: item.imageUri, message: `${T.fire} • ${dateStr}` })}
              >
                <Text style={[styles.actionTxt, { color: "#fff" }]}>{T.share}</Text>
              </Pressable>
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.headerTitle}>{T.title}</Text>
        <Pressable onPress={confirmClearAll} style={styles.clearAllBtn}>
          <Text style={styles.clearAllTxt}>{T.clear}</Text>
        </Pressable>
      </View>

      {/* Linha do servidor + Registrar */}
      <View style={styles.row}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholder}
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={handleRegisterNow} style={[styles.btn, busy && { opacity: 0.6 }]} disabled={busy}>
          <Text style={styles.btnTxt}>{busy ? T.saving : T.btnSave}</Text>
        </Pressable>
      </View>

      {/* Lista */}
      <FlatList
        data={items}
        keyExtractor={(it) => it.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={load}
        contentContainerStyle={items.length === 0 && { flex: 1, justifyContent: "center" }}
        ListEmptyComponent={
          <View style={{ alignItems: "center", paddingHorizontal: 16 }}>
            <Text style={{ color: PALETTE.sub, textAlign: "center" }}>{T.empty1}</Text>
            <Text style={{ color: PALETTE.sub, marginTop: 4, textAlign: "center" }}>{T.empty2}</Text>
          </View>
        }
      />

      {/* Modal de zoom (toque na imagem grande) */}
      <Modal visible={!!preview} transparent animationType="fade" onRequestClose={() => setPreview(null)}>
        <View style={styles.modalBg}>
          <TouchableOpacity style={styles.modalBg} activeOpacity={1} onPress={() => setPreview(null)}>
            {preview && <Image source={{ uri: preview.imageUri }} style={styles.fullImg} resizeMode="contain" />}
          </TouchableOpacity>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

/* =========================
   ESTILOS
========================= */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
  },
  headerTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700", flex: 1 },
  clearAllBtn: { paddingHorizontal: 10, paddingVertical: 8, backgroundColor: PALETTE.danger, borderRadius: 8 },
  clearAllTxt: { color: "white", fontWeight: "700" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.row,
  },
  label: { color: PALETTE.sub, fontSize: 12 },
  input: {
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 140,
  },
  btn: { backgroundColor: PALETTE.accent, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 10 },
  btnTxt: { color: "white", fontWeight: "700" },

  /* CARD */
  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 10,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: { width: 84, height: 56, backgroundColor: "#000", borderRadius: 8 },
  title: { color: PALETTE.text, fontSize: 14, fontWeight: "700" },
  time: { color: PALETTE.sub, fontSize: 12, marginTop: 2 },
  path: { color: "#8b93a3", fontSize: 11, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2a2f3d",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  expandBtnOn: { backgroundColor: "#1d2435" },
  expandTxt: { color: "#cbd5ff", fontWeight: "700", fontSize: 12 },

  trashBtn: { backgroundColor: "#333", paddingHorizontal: 10, paddingVertical: 6, borderRadius: 8 },
  trashTxt: { color: "#fca5a5", fontWeight: "700", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 10,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 220 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#0c1020",
  },
  detailsTitle: { color: PALETTE.chipText, fontWeight: "800", marginBottom: 6 },
  timeBig: { color: PALETTE.text, fontSize: 14, fontWeight: "600" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 10,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "800" },

  /* Modal zoom */
  modalBg: { flex: 1, backgroundColor: "rgba(0,0,0,0.92)", alignItems: "center", justifyContent: "center" },
  fullImg: { width: "100%", height: "100%" },
});











// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
  Animated,
  LayoutChangeEvent,
} from "react-native";
import { WebView } from "react-native-webview";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  white: "#ffffff",
};

const textsByLang = {
  pt: {
    espIp: "ESP IP:",
    test: "Testar",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "BOMBA ON",
    pumpOff: "BOMBA OFF",
    server: "Servidor:",
    detect: "Detectar",
    detecting: "Detectando",
    saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi/IP.",
    noVideo: "Sem vídeo (snapshot). Verifique o servidor.",
    fireOn: (s: number) => `🔥 FOGO • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sem fogo • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento salvo em ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "Visão:",
    stream: "STREAM (rápido)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "Pessoas",
    animals: "Animais",
    boxes: "Caixas",
    backend: "Modelo",
  },
  en: {
    espIp: "ESP IP:",
    test: "Test",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "PUMP ON",
    pumpOff: "PUMP OFF",
    server: "Server:",
    detect: "Detect",
    detecting: "Detecting",
    saving: "Saving...",
    statusFail: "Failed to connect. Check Wi-Fi/IP.",
    noVideo: "No video (snapshot). Check the server.",
    fireOn: (s: number) => `🔥 FIRE • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `No fire • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Event saved at ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "View:",
    stream: "STREAM (fast)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "People",
    animals: "Animals",
    boxes: "Boxes",
    backend: "Model",
  },
  es: {
    espIp: "ESP IP:",
    test: "Probar",
    ledOn: "LED ENC.",
    ledOff: "LED APAG.",
    pumpOn: "BOMBA ENC.",
    pumpOff: "BOMBA APAG.",
    server: "Servidor:",
    detect: "Detectar",
    detecting: "Detectando",
    saving: "Guardando...",
    statusFail: "Error de conexión. Revisa Wi-Fi/IP.",
    noVideo: "Sin vídeo (snapshot). Revisa el servidor.",
    fireOn: (s: number) => `🔥 FUEGO • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sin fuego • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento guardado a las ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "Vista:",
    stream: "STREAM (rápido)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "Personas",
    animals: "Animales",
    boxes: "Cajas",
    backend: "Modelo",
  },
};

const DEFAULT_IP = "192.168.4.1";
const DEFAULT_SERVER = "http://192.168.4.2:8000";

/* ===========================
   Componentes de vídeo
=========================== */
function LiveMJPEG({ ip }: { ip: string }) {
  const html = `
    <html><head><meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;}
        .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;}
        img{max-width:100%;max-height:100%;object-fit:contain;background:#000;}
      </style>
    </head>
    <body>
      <div class="wrap"><img src="http://${ip}:81/stream" /></div>
    </body></html>
  `.trim();

  return (
    <WebView
      originWhitelist={["*"]}
      source={{ html }}
      javaScriptEnabled
      allowsInlineMediaPlayback
      mediaPlaybackRequiresUserAction={false}
      automaticallyAdjustContentInsets={false}
      style={{ flex: 1, backgroundColor: "black" }}
    />
  );
}

function CrossfadeImage({
  currentUri,
  nextUri,
  onNextLoadStart,
  onNextShown,
}: {
  currentUri: string;
  nextUri: string;
  onNextLoadStart: () => void;
  onNextShown: () => void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}

      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={onNextShown}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown();
                fade.setValue(0);
                setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ===========================
   Overlay de caixas
=========================== */

type BoxType = "fire" | "person" | "animal";
type SrcBox = { x: number; y: number; w: number; h: number; type: BoxType; conf?: number };

function BoxesOverlay({
  frameWH,
  containerWH,
  boxes,
}: {
  frameWH: { w: number; h: number } | null;
  containerWH: { w: number; h: number } | null;
  boxes: SrcBox[];
}) {
  if (!frameWH || !containerWH || frameWH.w <= 0 || frameWH.h <= 0 || containerWH.w <= 0 || containerWH.h <= 0) {
    return null;
  }

  // Simula object-fit: contain
  const scale = Math.min(containerWH.w / frameWH.w, containerWH.h / frameWH.h);
  const dispW = frameWH.w * scale;
  const dispH = frameWH.h * scale;
  const offsetX = (containerWH.w - dispW) / 2;
  const offsetY = (containerWH.h - dispH) / 2;

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      {/* Área exata onde a imagem aparece */}
      <View
        style={{
          position: "absolute",
          left: offsetX,
          top: offsetY,
          width: dispW,
          height: dispH,
        }}
      >
        {boxes.map((b, i) => {
          const left = b.x * scale;
          const top = b.y * scale;
          const width = b.w * scale;
          const height = b.h * scale;

          let borderColor = "#ff3b30"; // fire
          if (b.type === "person") borderColor = "#00e5ff";
          else if (b.type === "animal") borderColor = "#7CFC00";

          return (
            <View
              key={`${i}-${b.type}`}
              style={{
                position: "absolute",
                left,
                top,
                width,
                height,
                borderWidth: 3,
                borderColor,
                borderRadius: 6,
                backgroundColor: "transparent",
              }}
            >
              {/* Etiqueta no topo */}
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  top: -18,
                  paddingHorizontal: 6,
                  paddingVertical: 2,
                  borderRadius: 4,
                  backgroundColor: borderColor,
                }}
              >
                <Text style={{ color: "#000", fontWeight: "800", fontSize: 10 }}>
                  {b.type.toUpperCase()}
                  {typeof b.conf === "number" ? ` ${b.conf.toFixed(2)}` : ""}
                </Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  // conexões
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados do ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState("—");
  const [ledOn, setLedOn] = useState(false);
  const [pumpOn, setPumpOn] = useState(false);

  // detecção
  const [detectOn, setDetectOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  // pessoas/animais (usando campos estáveis do servidor)
  const [people, setPeople] = useState(0);
  const [animals, setAnimals] = useState(0);
  const [backend, setBackend] = useState<string>("—");
  const [confMax, setConfMax] = useState<number>(0);

  // caixas para overlay
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{ w: number; h: number } | null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{ w: number; h: number } | null>(null);

  // preview de caixas
  const [showBoxes, setShowBoxes] = useState(false);
  const [boxesUri, setBoxesUri] = useState("");

  // registro automático
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef(0);
  const wasFireRef = useRef(false);
  const SAVE_COOLDOWN_MS = 5000;

  // visão
  const [useStream, setUseStream] = useState(true);
  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  // joystick (UI)
  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // helpers URL
  const cleanServer = (s: string) => s.replace(/\/+$/, "");
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  /* ===== ESP STATUS ===== */
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl);
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(`OK • ip:${j.ip} • mode:${j.mode} • led:${j.led ? "on" : "off"} • pump:${j.pump ? "on" : "off"}`);
    } catch {
      setStatusText(T.statusFail);
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  /* ===== Vídeo SNAPSHOT fallback (25 fps alvo) ===== */
  useEffect(() => {
    if (useStream) return;
    let stop = false;
    const FPS_INTERVAL = 40; // ~25 fps

    setCurrentFrameUri(`${cleanServer(server)}/snapshot?ts=${Date.now()}`);

    const tick = () => {
      if (stop) return;
      if (!loadingNextRef.current) {
        const url = `${cleanServer(server)}/snapshot?ts=${Date.now()}`;
        setNextFrameUri(url);
      }
      setTimeout(tick, FPS_INTERVAL);
    };
    tick();

    return () => {
      stop = true;
    };
  }, [server, useStream]);

  function onNextLoadStart() {
    loadingNextRef.current = true;
  }
  function onNextShown() {
    if (nextFrameUri) setCurrentFrameUri(nextFrameUri);
    loadingNextRef.current = false;
  }

  /* ===== LOOP DE DETECÇÃO + CAIXAS ===== */
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;

    const loop = async () => {
      try {
        const r = await fetch(`${cleanServer(server)}/detect`);
        const j = await r.json();

        if (!stop && j && j.ok !== false) {
          // fogo
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));

          // frame size para conversão
          const wh = Array.isArray(j.frame_wh) && j.frame_wh.length === 2
            ? { w: Number(j.frame_wh[0]) || 0, h: Number(j.frame_wh[1]) || 0 }
            : null;
          if (wh && wh.w > 0 && wh.h > 0) setFrameWH(wh);

          // objetos (estáveis)
          const o = j.objects || {};
          const objs = o.objects || [];
          const peopleStable =
            typeof o.n_person_stable === "number"
              ? o.n_person_stable
              : typeof o.n_person === "number"
              ? o.n_person
              : objs.filter((x: any) => x.label === "person").length > 0
              ? 1
              : 0;
          const animalsStable =
            typeof o.n_animals_stable === "number"
              ? o.n_animals_stable
              : typeof o.n_animals === "number"
              ? o.n_animals
              : objs.filter((x: any) => x.label !== "person").length > 0
              ? 1
              : 0;

          setPeople(peopleStable);
          setAnimals(animalsStable);
          setBackend(o.backend || "—");
          setConfMax(Number(o.conf_max || 0));

          // montar caixas para overlay
          const boxes: SrcBox[] = [];

          // Caixas de FOGO (j.boxes) — aparecem apenas quando fogo final está ON
          if (j.isFire && Array.isArray(j.boxes)) {
            for (const b of j.boxes) {
              if (!Array.isArray(b) || b.length < 4) continue;
              const [x, y, w, h] = b.map((n: any) => Number(n) || 0);
              boxes.push({ x, y, w, h, type: "fire" });
            }
          }

          // Caixas de OBJETOS (pessoas/animais)
          for (const it of objs) {
            if (!it || !Array.isArray(it.box) || it.box.length < 4) continue;
            const [x, y, w, h] = it.box.map((n: any) => Number(n) || 0);
            const label = String(it.label || "").toLowerCase();
            const conf = typeof it.conf === "number" ? it.conf : undefined;
            if (label === "person") {
              boxes.push({ x, y, w, h, type: "person", conf });
            } else {
              // qualquer não-person tratado como "animal" (COCO/MNet conjunto)
              boxes.push({ x, y, w, h, type: "animal", conf });
            }
          }

          setOverlayBoxes(boxes);

          // mini preview (opcional)
          if (showBoxes) {
            setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`);
          }
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
          setPeople(0);
          setAnimals(0);
          setOverlayBoxes([]);
        }
      } finally {
        if (!stop) setTimeout(loop, 180); // ~5-6Hz
      }
    };
    loop();

    return () => {
      stop = true;
    };
  }, [detectOn, server, showBoxes]);

  /* ===== Registro automático ===== */
  useEffect(() => {
    const rising = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;

    if (detectOn && rising && cooldownOk && !saving) {
      (async () => {
        try {
          setSaving(true);
          await saveEventFromServer(server);
          lastSaveRef.current = Date.now();
          setStatusText(T.eventSavedAt(new Date(lastSaveRef.current).toLocaleString()));
        } catch {
          setStatusText(T.noVideo);
        } finally {
          setSaving(false);
        }
      })();
    }
    wasFireRef.current = isFire;
  }, [detectOn, isFire, server, saving, T]);

  /* ===== Joystick ===== */
  const RADIUS = 64,
    KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS,
          ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny });
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const knobLeft = joy.x * RADIUS,
    knobTop = -joy.y * RADIUS;

  /* ===== Medidas do container do vídeo (para o overlay) ===== */
  function onVideoLayout(e: LayoutChangeEvent) {
    const { width, height } = e.nativeEvent.layout;
    setVideoContainerWH({ w: width, h: height });
  }

  return (
    <View style={styles.container}>
      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder={T.placeholderIp}
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : T.test}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? T.ledOn : T.ledOff}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? T.pumpOn : T.pumpOff}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor + Detectar + Seletor de visão */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholderServer}
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? (saving ? T.saving : T.detecting) : T.detect}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Seletor de visão */}
      <View style={[styles.statusRow, { gap: 6 }]}>
        <Text style={styles.label}>{T.view}</Text>
        <Pressable onPress={() => setUseStream(true)} style={[styles.btn, useStream ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{T.stream}</Text>
        </Pressable>
        <Pressable onPress={() => setUseStream(false)} style={[styles.btn, !useStream ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{T.snapshot}</Text>
        </Pressable>

        {/* toggle boxes (mini preview do servidor) */}
        <Pressable
          onPress={() => {
            const val = !showBoxes;
            setShowBoxes(val);
            if (val) setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`);
          }}
          style={[styles.btn, showBoxes ? styles.btnOn : styles.btnOff]}
        >
          <Text style={styles.btnText}>{T.boxes}</Text>
        </Pressable>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
        </View>
      )}

      {/* Banner de pessoas/animais + backend */}
      {detectOn && (
        <View style={[styles.statusRow, { justifyContent: "space-between" }]}>
          <Text style={styles.statChip}>
            {T.persons}: <Text style={styles.statNumber}>{people}</Text>
          </Text>
          <Text style={styles.statChip}>
            {T.animals}: <Text style={styles.statNumber}>{animals}</Text>
          </Text>
          <Text style={styles.modelChip}>
            {T.backend}: {backend} • conf_max {confMax.toFixed(2)}
          </Text>
        </View>
      )}

      {/* Vídeo + Overlay */}
      <View style={{ flex: 1 }} onLayout={onVideoLayout}>
        {useStream ? (
          <LiveMJPEG ip={ip} />
        ) : (
          <CrossfadeImage
            currentUri={currentFrameUri}
            nextUri={nextFrameUri}
            onNextLoadStart={onNextLoadStart}
            onNextShown={onNextShown}
          />
        )}

        {/* Overlay das caixas (FOGO/PESSOA/ANIMAL) */}
        {detectOn && overlayBoxes.length > 0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Mini preview com caixas (opcional) */}
      {detectOn && showBoxes && (
        <View style={{ height: 140, backgroundColor: "#000" }}>
          {!!boxesUri && (
            <Image
              source={{ uri: boxesUri }}
              style={{ flex: 1, width: "100%" }}
              resizeMode="contain"
              onError={() => setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`)}
            />
          )}
        </View>
      )}

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: knobLeft }, { translateY: knobTop }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: PALETTE.bg,
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
    minWidth: 110,
  },
  btn: {
    backgroundColor: "#2b48ff",
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  statChip: { color: "#dbeafe", fontSize: 14, fontWeight: "600" },
  statNumber: { color: "#fff" },
  modelChip: { marginLeft: "auto", color: "#9fb0ff", fontSize: 12 },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: {
    position: "absolute",
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.14)",
  },
  joyKnob: {
    position: "absolute",
    backgroundColor: "rgba(43,72,255,0.9)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.85)",
  },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});










import { View, Text, StyleSheet, Pressable } from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg: "#0a0a0a", card: "#121212", border: "#232323", text: "#e5e7eb", accent: "#2b48ff" };

export default function SettingsScreen() {
  const { lang, setLang } = useLanguage();

  return (
    <View style={styles.container}>
      <Text style={styles.title}>
        {lang === "pt" ? "Configurações" : lang === "es" ? "Configuraciones" : "Settings"}
      </Text>

      <Text style={styles.label}>
        {lang === "pt" ? "Idioma do aplicativo:" : lang === "es" ? "Idioma de la aplicación:" : "App language:"}
      </Text>

      <View style={styles.row}>
        <Pressable
          onPress={() => setLang("pt")}
          style={[styles.btn, lang === "pt" && styles.btnActive]}
        >
          <Text style={styles.btnText}>Português</Text>
        </Pressable>

        <Pressable
          onPress={() => setLang("en")}
          style={[styles.btn, lang === "en" && styles.btnActive]}
        >
          <Text style={styles.btnText}>English</Text>
        </Pressable>

        <Pressable
          onPress={() => setLang("es")}
          style={[styles.btn, lang === "es" && styles.btnActive]}
        >
          <Text style={styles.btnText}>Español</Text>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 20 },
  title: { color: PALETTE.text, fontSize: 22, fontWeight: "700", marginBottom: 20 },
  label: { color: PALETTE.text, marginBottom: 12 },
  row: { flexDirection: "row", gap: 12 },
  btn: {
    backgroundColor: PALETTE.card,
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  btnActive: { backgroundColor: PALETTE.accent, borderColor: PALETTE.accent },
  btnText: { color: "white", fontWeight: "600" },
});

