
perfeito ‚Äî se o joystick e a bomba n√£o responderam, vamos deixar o Arduino √† prova de bala.

Abaixo vai um .ino completo que:




entende tanto CMD:... quanto requisi√ß√µes do ESP do tipo

GET /uart?line=..., GET /pump?on=1, GET /joystick?x=...&y=...


faz URL-decode (ex.: CMD%3ASTOP ‚Üí CMD:STOP)


implementa movimento n√£o-bloqueante (pulsos com timeout) e failsafe (para se parar de receber comandos)


mant√©m os pinos iguais ao seu sketch






Pode substituir seu arquivo pelo c√≥digo abaixo e compilar para UNO/Nano.

Baud: 115200 (igual ao ESP). Ligue GND comum entre ESP e Arduino.





// ====== HydroBot Arduino - Driver & Sensors (robusto p/ ESP HTTP bridge) ======
// Aceita comandos por UART em v√°rios formatos:
//  1) "CMD:FWD:ms=400:spd=70", "CMD:BACK:ms=300", "CMD:LEFT:ms=200", "CMD:RIGHT:ms=200", "CMD:STOP"
//  2) "REQ:STATUS", "SET:SPEED:NN", "SET:LED:n", "CMD:PUMP:1|0"
//  3) Linha de HTTP do ESP (caso ele encaminhe o caminho puro):
//     - "GET /uart?line=CMD%3AFWD%3Ams%3D200 HTTP/1.1"
//     - "GET /pump?on=1 HTTP/1.1"
//     - "GET /joystick?x=0.42&y=-0.15 HTTP/1.1"
//
// Movimento n√£o-bloqueante: envia pulso e para sozinho quando o tempo acabar.
// Failsafe: se n√£o chegar comando de movimento por ~1s, para motores.
//
// ---------------- PINOS ----------------
#include <Arduino.h>
#define IN1 8
#define IN2 9
#define IN3 10
#define IN4 11
#define BOMBA_PIN 13
#define LED_VERMELHO 3

#define SENSOR_FOGO_DIR A0
#define SENSOR_FOGO_MEIO A1
#define SENSOR_FOGO_ESQ A2
#define NIVEL_AGUA_PIN  A3

// ---------------- CONFIG ----------------
static uint8_t baseSpeed = 70; // 0..100 (documental)
static bool pumpOn = false;

// ---------------- ESTADO DE MOVIMENTO (n√£o-bloqueante) ----------------
enum Dir { DIR_STOP=0, DIR_FWD, DIR_BACK, DIR_LEFT, DIR_RIGHT };
static Dir currentDir = DIR_STOP;
static bool motionActive = false;
static unsigned long motionEndMs = 0;
static unsigned long lastMoveCmdAt = 0; // para failsafe

// ---------------- HELPERS DE HARDWARE ----------------
void motorsStop() {
  digitalWrite(IN1, LOW); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW); digitalWrite(IN4, LOW);
  currentDir = DIR_STOP;
}
void motorsFwd() {
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
  currentDir = DIR_FWD;
}
void motorsBack() {
  digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);
  currentDir = DIR_BACK;
}
void motorsLeftTurn() { // piv√¥: esquerda r√©, direita frente
  digitalWrite(IN1, LOW);  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
  currentDir = DIR_LEFT;
}
void motorsRightTurn() { // piv√¥: esquerda frente, direita r√©
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);  digitalWrite(IN4, HIGH);
  currentDir = DIR_RIGHT;
}
void applyDir(Dir d) {
  switch (d) {
    case DIR_FWD:   motorsFwd(); break;
    case DIR_BACK:  motorsBack(); break;
    case DIR_LEFT:  motorsLeftTurn(); break;
    case DIR_RIGHT: motorsRightTurn(); break;
    default:        motorsStop(); break;
  }
}
void setMotion(Dir d, uint16_t ms /*120..600*/) {
  if (ms == 0 || d == DIR_STOP) {
    motorsStop();
    motionActive = false;
    return;
  }
  applyDir(d);
  motionActive  = true;
  motionEndMs   = millis() + (unsigned long)ms;
  lastMoveCmdAt = millis();
}

void pumpWrite(bool on) {
  pumpOn = on;
  digitalWrite(BOMBA_PIN, on ? HIGH : LOW);
}

uint8_t waterPercent() {
  int raw = analogRead(NIVEL_AGUA_PIN); // 0..1023
  int pct = map(raw, 0, 1023, 0, 100);
  pct = constrain(pct, 0, 100);
  return (uint8_t)pct;
}

void ledLevelByWater(uint8_t pct) {
  static unsigned long lastBlink=0;
  static bool state=false;
  if (pct >= 50) {
    analogWrite(LED_VERMELHO, 0);
  } else if (pct >= 25) {
    analogWrite(LED_VERMELHO, 100);
  } else if (pct >= 15) {
    if (millis()-lastBlink>1000) {
      state=!state;
      analogWrite(LED_VERMELHO, state?200:0);
      lastBlink=millis();
    }
  } else {
    if (millis()-lastBlink>300) {
      state=!state;
      analogWrite(LED_VERMELHO, state?255:0);
      lastBlink=millis();
    }
  }
}

void emitStatus() {
  int ax = analogRead(SENSOR_FOGO_ESQ);
  int am = analogRead(SENSOR_FOGO_MEIO);
  int ad = analogRead(SENSOR_FOGO_DIR);
  uint8_t wp = waterPercent();
  Serial.print(F("STAT:ax=")); Serial.print(ax);
  Serial.print(F(":am=")); Serial.print(am);
  Serial.print(F(":ad=")); Serial.print(ad);
  Serial.print(F(":water=")); Serial.print(wp);
  Serial.print(F(":pump=")); Serial.print(pumpOn?1:0);
  Serial.print(F(":batt=")); Serial.println(0); // placeholder
}

// ---------------- URL-DECODE / PARSE ----------------
static inline int _hex(char c) {
  if (c>='0' && c<='9') return c-'0';
  if (c>='A' && c<='F') return 10 + (c-'A');
  if (c>='a' && c<='f') return 10 + (c-'a');
  return -1;
}

String urlDecode(const String &s) {
  String out; out.reserve(s.length());
  for (size_t i=0; i<s.length(); ++i) {
    char c = s[i];
    if (c == '+') out += ' ';
    else if (c == '%' && i+2 < s.length()) {
      int h1 = _hex(s[i+1]), h2 = _hex(s[i+2]);
      if (h1>=0 && h2>=0) { out += char((h1<<4) | h2); i+=2; }
      else out += c;
    } else out += c;
  }
  return out;
}

bool getQueryFloat(const String &path, const String &key, float &valOut) {
  int p = path.indexOf(key + "=");
  if (p < 0) return false;
  int start = p + key.length() + 1;
  int amp = path.indexOf('&', start);
  int sp  = path.indexOf(' ', start);
  int end = (amp<0 ? sp : (sp<0 ? amp : min(amp, sp)));
  if (end < 0) end = path.length();
  String sub = path.substring(start, end);
  sub.trim();
  valOut = sub.toFloat();
  return true;
}

// ---------------- PARSERS DE COMANDOS ----------------
void handleMoveCmd(const String &cmd) {
  // aceita: FWD/BACK/LEFT/RIGHT/STOP e opcional "ms=" "spd="
  uint16_t ms = 200;
  uint8_t spd = baseSpeed;

  int pms = cmd.indexOf("ms=");
  if (pms >= 0) ms = (uint16_t) cmd.substring(pms+3).toInt();
  int pspd = cmd.indexOf("spd=");
  if (pspd >= 0) spd = (uint8_t) cmd.substring(pspd+4).toInt();
  ms = constrain(ms, 80, 600);
  (void)spd;

  if      (cmd.indexOf("FWD")   >= 0) setMotion(DIR_FWD,   ms);
  else if (cmd.indexOf("BACK")  >= 0) setMotion(DIR_BACK,  ms);
  else if (cmd.indexOf("LEFT")  >= 0) setMotion(DIR_LEFT,  ms);
  else if (cmd.indexOf("RIGHT") >= 0) setMotion(DIR_RIGHT, ms);
  else if (cmd.indexOf("STOP")  >= 0) setMotion(DIR_STOP,  0);
}

void handleCMDLine(const String &line) {
  // Ex.: "CMD:FWD:ms=400:spd=70" ou "CMD:PUMP:1"
  if (line.indexOf("CMD:PUMP:") >= 0) {
    bool on = line.endsWith("1");
    if (on && waterPercent() <= 15) {
      pumpWrite(false);
      Serial.println(F("WARN:NO_WATER"));
    } else {
      pumpWrite(on);
      Serial.println(on ? F("OK:PUMP_ON") : F("OK:PUMP_OFF"));
    }
    return;
  }
  handleMoveCmd(line);
}

void handleHTTPLine(const String &lineIn) {
  // Pega apenas o caminho: "/xxx?..." (entre primeiro espa√ßo e o pr√≥ximo)
  int sp1 = lineIn.indexOf(' ');
  if (sp1 < 0) return;
  int sp2 = lineIn.indexOf(' ', sp1+1);
  if (sp2 < 0) return;
  String path = lineIn.substring(sp1+1, sp2); // "/uart?line=..."
  // UART proxy
  if (path.startsWith("/uart")) {
    int p = path.indexOf("line=");
    if (p >= 0) {
      String enc = path.substring(p+5);
      int amp = enc.indexOf('&');
      if (amp >= 0) enc = enc.substring(0, amp);
      String dec = urlDecode(enc);
      dec.trim();
      handleCMDLine(dec);
    }
    return;
  }
  // Bomba
  if (path.startsWith("/pump")) {
    int p = path.indexOf("on=");
    if (p >= 0) {
      char v = path.charAt(p+3);
      bool on = (v=='1' || v=='t' || v=='T');
      if (on && waterPercent() <= 15) {
        pumpWrite(false);
        Serial.println(F("WARN:NO_WATER"));
      } else {
        pumpWrite(on);
        Serial.println(on ? F("OK:PUMP_ON") : F("OK:PUMP_OFF"));
      }
    }
    return;
  }
  // Joystick
  if (path.startsWith("/joystick")) {
    float x=0, y=0;
    if (getQueryFloat(path, "x", x) | getQueryFloat(path, "y", y)) {
      // converte vetor em dire√ß√£o discreta + pulso proporcional
      float mag = sqrtf(x*x + y*y);
      if (mag < 0.20f) { setMotion(DIR_STOP, 0); return; }
      float deg = atan2f(y, x) * 57.2957795f; // RAD2DEG
      Dir d;
      if (deg > -45 && deg <= 45) d = DIR_RIGHT;
      else if (deg > 45 && deg <= 135) d = DIR_FWD;
      else if (deg <= -45 && deg > -135) d = DIR_BACK;
      else d = DIR_LEFT;
      uint16_t ms = 120 + (uint16_t)(min(1.0f, mag) * 260.0f); // 120..380ms
      setMotion(d, ms);
    }
    return;
  }
}

// ---------------- SETUP / LOOP ----------------
String line;

void setup() {
  Serial.begin(115200);

  pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);
  pinMode(BOMBA_PIN, OUTPUT);
  pinMode(LED_VERMELHO, OUTPUT);

  motorsStop();
  pumpWrite(false);

  Serial.println(F("ARDUINO_READY"));
}

void loop() {
  // LED de n√≠vel
  ledLevelByWater(waterPercent());

  // encerra pulso atual (n√£o-bloqueante)
  if (motionActive && (long)(millis() - motionEndMs) >= 0) {
    motorsStop();
    motionActive = false;
  }

  // failsafe: se ficar muito tempo sem comando de movimento, garante STOP
  if ((millis() - lastMoveCmdAt) > 1000 && currentDir != DIR_STOP) {
    motorsStop();
    motionActive = false;
  }

  // UART parsing linha-a-linha
  while (Serial.available()) {
    char c = Serial.read();
    if (c=='\n' || c=='\r') {
      if (line.length() > 0) {
        String s = line; line = "";
        s.trim();

        if (s.startsWith("CMD:")) {
          handleCMDLine(s);
          continue;
        }
        if (s.startsWith("REQ:STATUS")) {
          emitStatus();
          continue;
        }
        if (s.startsWith("SET:SPEED:")) {
          int v = s.substring(10).toInt();
          baseSpeed = (uint8_t) constrain(v,0,100);
          Serial.println(F("OK:SPEED"));
          continue;
        }
        if (s.startsWith("SET:LED:")) {
          int v = s.substring(8).toInt();
          analogWrite(LED_VERMELHO, constrain(v,0,255));
          Serial.println(F("OK:LED"));
          continue;
        }

        // Pode ter vindo uma linha HTTP do ESP
        if (s.startsWith("GET ")) {
          handleHTTPLine(s);
          continue;
        }

        // Curto-circuitos extras (caso venham formas diferentes)
        if (s.indexOf("PUMP=1")>=0 || s.indexOf("pump=1")>=0) { pumpWrite(true);  Serial.println(F("OK:PUMP_ON"));  continue; }
        if (s.indexOf("PUMP=0")>=0 || s.indexOf("pump=0")>=0) { pumpWrite(false); Serial.println(F("OK:PUMP_OFF")); continue; }

        Serial.println(F("ERR:UNKNOWN"));
      }
    } else {
      line += c;
      if (line.length() > 240) line.remove(0); // evita overflow de linha malformada
    }
  }
}



por que isso resolve




Mesmo que o ESP n√£o envie a string ‚Äúlimpa‚Äù, o Arduino agora entende a URL e decodifica %xx.


O joystick vira pulsos proporcionais ao m√≥dulo do vetor (quanto mais longe, mais tempo), com timeout autom√°tico.


A bomba aceita CMD:PUMP:1 ou GET /pump?on=1.






Se ainda n√£o mexer, abra o Monitor Serial do Arduino (115200) enquanto move o joystick e aperta a bomba. Voc√™ dever√° ver OK:FWD/LEFT/... e OK:PUMP_ON/OFF.

Se nada aparecer, √© fia√ß√£o/baud/serial entre ESP‚ÜîArduino (TX/RX cruzados e GND comum).
















































































































beleza ‚Äî reboot em loop no ESP32-CAM quase sempre √© uma combina√ß√£o de alimenta√ß√£o fraca + c√¢mera pesada + UART compartilhada. Vou te passar:




um firmware ‚Äúfailsafe‚Äù pro ESP32-CAM (bem leve, sem nada que estresse mem√≥ria/alimenta√ß√£o)


o checklist el√©trico (onde geralmente est√° o problema)


passos de teste r√°pido pra isolar a causa





1) ESP32-CAM ‚Äúfailsafe‚Äù (est√°vel)




Wi-Fi no roteador (troque SSID/SENHA, IP fixo 192.168.3.3)


Endpoints:



/status (JSON)


/snapshot (JPEG com headers no-store)


/uart?line=... ‚Üí envia line\n na Serial


/pump?on=0|1 ‚Üí envia CMD:PUMP:0|1\n


/joystick?x=&y= ‚Üí reenvia a linha GET pro Arduino e manda um CMD discreto (redundante)






C√¢mera em QQVGA (160√ó120), jpeg_quality=15, fb_count=1 (bem leve)


Brownout detector desligado (ajuda quando a fonte √© no limite)


Zero logs pela Serial (para n√£o atrapalhar o Arduino)






Cole este sketch e grave no ESP32-CAM AI-Thinker (Board: AI Thinker ESP32-CAM, PSRAM: Enabled).

Para gravar, desconecte Arduino dos pinos RX/TX, coloque IO0=GND (modo flash) e alimente em 5V bom.




#include <WiFi.h>
#include <WebServer.h>
#include "esp_camera.h"
#include "soc/rtc_cntl_reg.h"

// -------- Wi-Fi (roteador) --------
const char* SSID = "HydroBot";
const char* PASS = "loud2025emibr";

// IP fixo 192.168.3.3
IPAddress local_IP(192,168,3,3);
IPAddress gateway (192,168,3,1);
IPAddress subnet  (255,255,255,0);
IPAddress dns1    (8,8,8,8);
IPAddress dns2    (1,1,1,1);

WebServer server(80);

// ---- Pinos c√¢mera (AI Thinker) ----
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27

#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ---- Helpers (sem logs na Serial) ----
static String urlDecode(const String &s) {
  String out; out.reserve(s.length());
  auto hx=[](char c)->int{
    if(c>='0'&&c<='9')return c-'0';
    if(c>='A'&&c<='F')return 10+(c-'A');
    if(c>='a'&&c<='f')return 10+(c-'a');
    return -1;
  };
  for (size_t i=0;i<s.length();++i){
    char c=s[i];
    if(c=='+') out+=' ';
    else if(c=='%' && i+2<s.length()){
      int h1=hx(s[i+1]), h2=hx(s[i+2]);
      if(h1>=0 && h2>=0){ out += char((h1<<4)|h2); i+=2; }
      else out += c;
    } else out += c;
  }
  return out;
}

void handle_status(){
  String json = "{\"ok\":true,\"ip\":\"";
  json += WiFi.localIP().toString();
  json += "\",\"mode\":\"snapshot\"}";
  server.send(200,"application/json",json);
}

void handle_uart(){
  if(!server.hasArg("line")){ server.send(400,"text/plain","missing 'line'\n"); return; }
  String line = urlDecode(server.arg("line"));
  // envia para Arduino (UART0) e garante newline
  Serial.print(line);
  if(!line.endsWith("\n")) Serial.print("\n");
  server.send(200,"text/plain","OK\n");
}

void handle_pump(){
  if(!server.hasArg("on")){ server.send(400,"text/plain","missing 'on'\n"); return; }
  bool on = server.arg("on")=="1" || server.arg("on")=="true" || server.arg("on")=="TRUE";
  Serial.printf("CMD:PUMP:%d\n", on?1:0);
  server.send(200,"text/plain", on? "PUMP_ON\n":"PUMP_OFF\n");
}

void handle_joystick(){
  float x = server.hasArg("x") ? server.arg("x").toFloat() : 0.f;
  float y = server.hasArg("y") ? server.arg("y").toFloat() : 0.f;

  // Encaminha a pr√≥pria linha GET (seu Arduino entende)
  String raw = "GET /joystick?x="+String(x,3)+"&y="+String(y,3)+" HTTP/1.1";
  Serial.println(raw);

  // Redund√¢ncia: comando discreto
  float mag = sqrtf(x*x+y*y);
  if (mag < 0.20f) {
    Serial.println("CMD:STOP");
  } else {
    float deg = atan2f(y,x)*57.29578f;
    const char* dir="LEFT";
    if (deg > -45 && deg <= 45) dir="RIGHT";
    else if (deg > 45 && deg <= 135) dir="FWD";
    else if (deg <= -45 && deg > -135) dir="BACK";
    uint16_t ms = 120 + (uint16_t)(min(1.0f, mag)*260.0f);
    Serial.printf("CMD:%s:ms=%u:spd=70\n", dir, ms);
  }
  server.send(200,"text/plain","JOY\n");
}

void handle_snapshot(){
  camera_fb_t *fb = esp_camera_fb_get();
  if(!fb || fb->format!=PIXFORMAT_JPEG){
    if(fb) esp_camera_fb_return(fb);
    server.send(503,"text/plain","no frame\n");
    return;
  }
  server.sendHeader("Cache-Control","no-store, no-cache, must-revalidate, max-age=0");
  server.sendHeader("Pragma","no-cache");
  server.sendHeader("Expires","0");
  server.setContentLength(fb->len);
  server.send(200,"image/jpeg","");
  WiFiClient c = server.client();
  c.write(fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

bool camera_begin_lowmem(){
  camera_config_t cfg;
  cfg.ledc_channel = LEDC_CHANNEL_0;
  cfg.ledc_timer   = LEDC_TIMER_0;
  cfg.pin_d0 = Y2_GPIO_NUM;  cfg.pin_d1 = Y3_GPIO_NUM;
  cfg.pin_d2 = Y4_GPIO_NUM;  cfg.pin_d3 = Y5_GPIO_NUM;
  cfg.pin_d4 = Y6_GPIO_NUM;  cfg.pin_d5 = Y7_GPIO_NUM;
  cfg.pin_d6 = Y8_GPIO_NUM;  cfg.pin_d7 = Y9_GPIO_NUM;
  cfg.pin_xclk = XCLK_GPIO_NUM;
  cfg.pin_pclk = PCLK_GPIO_NUM;
  cfg.pin_vsync = VSYNC_GPIO_NUM;
  cfg.pin_href = HREF_GPIO_NUM;
  cfg.pin_sccb_sda = SIOD_GPIO_NUM;
  cfg.pin_sccb_scl = SIOC_GPIO_NUM;
  cfg.pin_pwdn = PWDN_GPIO_NUM;
  cfg.pin_reset = RESET_GPIO_NUM;

  cfg.xclk_freq_hz = 20000000;
  cfg.pixel_format = PIXFORMAT_JPEG;
  cfg.frame_size   = FRAMESIZE_QQVGA; // 160x120 super leve
  cfg.jpeg_quality = 15;              // mais leve
  cfg.fb_count     = 1;               // 1 framebuffer
  cfg.fb_location  = CAMERA_FB_IN_PSRAM;
  cfg.grab_mode    = CAMERA_GRAB_LATEST;

  return esp_camera_init(&cfg) == ESP_OK;
}

void setup(){
  // UART0 para Arduino
  Serial.begin(115200);

  // desliga brownout (diminui resets por queda de tens√£o)
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  // inicializa c√¢mera no perfil mais leve poss√≠vel
  camera_begin_lowmem();

  // Wi-Fi STA + IP fixo
  WiFi.mode(WIFI_STA);
  WiFi.config(local_IP, gateway, subnet, dns1, dns2);
  WiFi.begin(SSID, PASS);
  unsigned long t0 = millis();
  while (WiFi.status()!=WL_CONNECTED && millis()-t0 < 15000) delay(200);

  // HTTP
  server.on("/status",   HTTP_GET, handle_status);
  server.on("/snapshot", HTTP_GET, handle_snapshot);
  server.on("/uart",     HTTP_GET, handle_uart);
  server.on("/pump",     HTTP_GET, handle_pump);
  server.on("/joystick", HTTP_GET, handle_joystick);
  server.onNotFound([](){ server.send(404,"text/plain","NF\n"); });
  server.begin();
}

void loop(){
  // manter o servidor responsivo evita WDT
  server.handleClient();
  delay(1);
}



Por que esse sketch √© mais est√°vel




QQVGA/qualidade 15/fb=1 ‚Üí consumo m√≠nimo de RAM/PSRAM e CPU.


Brownout desativado (se sua fonte for borderline n√£o derruba).


Sem prints de log na Serial (n√£o perturba o Arduino).


Loop leve e delay(1) ‚Üí evita WDT reset.






Depois que tudo estiver OK, voc√™ pode subir para FRAMESIZE_QVGA e jpeg_quality 10‚Äì12.





2) Checklist el√©trico (onde normalmente est√° o reboot)




Fonte do ESP32-CAM: use 5V em pelo menos 1A (ideal: 2A).

FTDI em 5V geralmente n√£o aguenta a c√¢mera (brownout ‚Üí reboot).


GND comum entre ESP e Arduino.


RX do ESP (GPIO3) vindo do TX do Arduino precisa de divisor 5V‚Üí3.3V

(1k em s√©rie + 2k2 para GND j√° resolve).


IO0 livre (s√≥ aterre para gravar; depois solte). Se mantiver no GND, o ESP entra em modo bootloader e ‚Äúreinicia‚Äù ao tentar rodar.


Cabos curtos e bons; falsos contatos d√£o brownout.


N√£o alimente motores/bomba da mesma fonte do ESP sem um regulador decente ‚Äî ru√≠do de motor derruba o m√≥dulo.





3) Teste r√°pido (sem app)




Acesse http://192.168.3.3/status ‚Üí tem JSON?


Acesse http://192.168.3.3/snapshot ‚Üí baixa um JPEG (pequeno por ser QQVGA).


Com Arduino conectado na UART:



http://192.168.3.3/uart?line=CMD%3AFWD%3Ams%3D300 ‚Üí deve andar √† frente ~300 ms.


http://192.168.3.3/pump?on=1 / ...on=0 ‚Üí liga/desliga bomba.


http://192.168.3.3/joystick?x=0.9&y=0.2 ‚Üí deve girar/andar.








Se (1) ou (2) j√° reinicia, √© alimenta√ß√£o; se s√≥ cai quando manda /snapshot, a c√¢mera ainda est√° pesada ‚Üí mantenha QQVGA; se mesmo assim reinicia, a fonte est√° no limite.



Dicas finais




Depois de est√°vel, volte seu server e app (j√° com IPs .3.3 / .3.4). O app vai puxar snapshot do servidor, mas voc√™ tamb√©m pode apontar direto pro ESP pra testar.


Se quiser eliminar qualquer interfer√™ncia do compartilhamento de UART, d√° para mover a ponte para Serial1 (UART2) do ESP32, mas nos pinos dispon√≠veis do AI-Thinker √© arriscado por causa do SD; por isso o padr√£o √© usar UART0 mesmo (funciona bem com boa alimenta√ß√£o).




Se ainda rebootar, me diga: aparece ‚ÄúBrownout detector was triggered‚Äù no serial do FTDI? E me conte qual fonte voc√™ est√° usando para o ESP32-CAM. Isso fecha o diagn√≥stico.










































































bora! abaixo est√° o CameraScreen.tsx completo com:




IP padr√£o do ESP: 192.168.3.3


URL padr√£o do server (FastAPI): http://192.168.3.4:8000


Snapshot & detec√ß√£o continuam vindo do server


Joystick controla o carro diretamente no ESP (/joystick com fallback para /uart com CMD:FWD|BACK|LEFT|RIGHT|STOP)


Bot√£o ‚ÄúBOMBA ON/OFF‚Äù liga/desliga a bomba no ESP (/pump?on=1|0)


<Image/> com key={uri} e server /snapshot com headers (que voc√™ j√° aplicou) ‚Üí frames aparecem




Cole o arquivo inteiro no caminho HydroBotApp2/src/screens/CameraScreen.tsx.



// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
  Animated,
  LayoutChangeEvent,
  AppState,
} from "react-native";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ---------- PALETA ---------- */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#121218",
  border: "#25273a",
  accent: "#e6403a",
  text: "#e5e7eb",
};

/* ---------- TEXTOS ---------- */
const textsByLang = {
  pt: {
    heroSubtitle: "Monitoramento e Controle",
    espIp: "ESP IP:",
    test: "Testar",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "BOMBA ON",
    pumpOff: "BOMBA OFF",
    server: "Servidor:",
    detecting: "Detectando‚Ä¶",
    saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi/IP.",
    noVideo: "Sem v√≠deo (snapshot). Verifique o servidor.",
    fireOn: (s: number) => `üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sem fogo ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento salvo em ${ts}`,
    placeholderIp: "192.168.3.3",
    placeholderServer: "http://192.168.3.4:8000",
    persons: "Pessoas",
    animals: "Animais",
    backend: "Modelo",
    waiting: "Aguardando servidor‚Ä¶",
    synced: "Server sync OK",
  },
  en: {
    heroSubtitle: "Monitoring & Control",
    espIp: "ESP IP:",
    test: "Test",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "PUMP ON",
    pumpOff: "PUMP OFF",
    server: "Server:",
    detecting: "Detecting‚Ä¶",
    saving: "Saving...",
    statusFail: "Failed to connect. Check Wi-Fi/IP.",
    noVideo: "No video (snapshot). Check the server.",
    fireOn: (s: number) => `üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `No fire ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Event saved at ${ts}`,
    placeholderIp: "192.168.3.3",
    placeholderServer: "http://192.168.3.4:8000",
    persons: "People",
    animals: "Animals",
    backend: "Model",
    waiting: "Waiting for server‚Ä¶",
    synced: "Server sync OK",
  },
  es: {
    heroSubtitle: "Monitoreo y Control",
    espIp: "ESP IP:",
    test: "Probar",
    ledOn: "LED ENC.",
    ledOff: "LED APAG.",
    pumpOn: "BOMBA ENC.",
    pumpOff: "BOMBA APAG.",
    server: "Servidor:",
    detecting: "Detectando‚Ä¶",
    saving: "Guardando...",
    statusFail: "Error de conexi√≥n. Revisa Wi-Fi/IP.",
    noVideo: "Sin v√≠deo (snapshot). Revisa el servidor.",
    fireOn: (s: number) => `üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sin fuego ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento guardado a las ${ts}`,
    placeholderIp: "192.168.3.3",
    placeholderServer: "http://192.168.3.4:8000",
    persons: "Personas",
    animals: "Animales",
    backend: "Modelo",
    waiting: "Esperando servidor‚Ä¶",
    synced: "Server sync OK",
  },
};

const DEFAULT_IP = "192.168.3.3"; // ESP
const DEFAULT_SERVER = "http://192.168.3.4:8000"; // FastAPI
const DEFAULT_FRAME_WH = { w: 640, h: 480 };

const appLogo = require("../../assets/logo.png");

/* ---------- HERO ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ---------- SNAPSHOT com crossfade ---------- */
function CrossfadeImage({
  currentUri,
  nextUri,
  onNextLoadStart,
  onNextShown,
}: {
  currentUri: string;
  nextUri: string;
  onNextLoadStart: () => void;
  onNextShown: (ok: boolean) => void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image
          key={currentUri} // for√ßa re-render
          source={{ uri: currentUri }}
          style={{ flex: 1, width: "100%" }}
          resizeMode="contain"
        />
      )}

      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri} // for√ßa re-render
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={() => {
              onNextShown(false);
              fade.setValue(0);
              setShowNext(false);
            }}
            onLoadEnd={() => {
              Animated.timing(fade, {
                toValue: 1,
                duration: 80,
                useNativeDriver: true,
              }).start(() => {
                onNextShown(true);
                fade.setValue(0);
                setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- OVERLAY DE CAIXAS ---------- */
type BoxType = "fire" | "person" | "animal";
type SrcBox = {
  x: number;
  y: number;
  w: number;
  h: number;
  type: BoxType;
  conf?: number;
};

function BoxesOverlay({
  frameWH,
  containerWH,
  boxes,
}: {
  frameWH: { w: number; h: number } | null;
  containerWH: { w: number; h: number } | null;
  boxes: SrcBox[];
}) {
  const f = frameWH && frameWH.w > 0 && frameWH.h > 0 ? frameWH : DEFAULT_FRAME_WH;
  if (!containerWH || containerWH.w <= 0 || containerWH.h <= 0) return null;

  const scale = Math.min(containerWH.w / f.w, containerWH.h / f.h);
  const dispW = f.w * scale;
  const dispH = f.h * scale;
  const offsetX = (containerWH.w - dispW) / 2;
  const offsetY = (containerWH.h - dispH) / 2;

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View
        style={{
          position: "absolute",
          left: offsetX,
          top: offsetY,
          width: dispW,
          height: dispH,
        }}
      >
        {boxes.map((b, i) => {
          const left = b.x * scale;
          const top = b.y * scale;
          const width = b.w * scale;
          const height = b.h * scale;

          let borderColor = "#ff3b30"; // fogo
          if (b.type === "person") borderColor = "#00e5ff";
          else if (b.type === "animal") borderColor = "#7CFC00";

          return (
            <View
              key={`${i}-${b.type}`}
              style={{
                position: "absolute",
                left,
                top,
                width,
                height,
                borderWidth: 3,
                borderColor,
                borderRadius: 6,
              }}
            >
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  top: -18,
                  paddingHorizontal: 6,
                  paddingVertical: 2,
                  borderRadius: 4,
                  backgroundColor: borderColor,
                }}
              >
                <Text style={{ color: "#000", fontWeight: "800", fontSize: 10 }}>
                  {b.type.toUpperCase()}
                  {typeof b.conf === "number" ? ` ${b.conf.toFixed(2)}` : ""}
                </Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- TELA PRINCIPAL ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados do ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState(T.waiting);
  const [ledOn, setLedOn] = useState(false);
  const [pumpOn, setPumpOn] = useState(false);

  // detec√ß√£o (sempre ativa)
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  // pessoas/animais
  const [people, setPeople] = useState(0);
  const [animals, setAnimals] = useState(0);
  const [backend, setBackend] = useState<string>("‚Äî");
  const [confMax, setConfMax] = useState<number>(0);

  // caixas + dimens√µes para overlay
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{ w: number; h: number } | null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{ w: number; h: number } | null>(null);

  // registro autom√°tico
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef(0);
  const wasFireRef = useRef(false);
  const SAVE_COOLDOWN_MS = 5000;

  // vis√£o: SNAPSHOT (sempre)
  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  // joystick (UI)
  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // health gate
  const [ready, setReady] = useState(false);

  // helpers URL
  const cleanServer = (s: string) => s.replace(/\/+$/, "");
  // server (frames + detec√ß√£o)
  const healthUrl = useMemo(() => `${cleanServer(server)}/healthz`, [server]);
  const detectUrl = useMemo(() => `${cleanServer(server)}/detect`, [server]);
  const snapshotUrl = useMemo(() => `${cleanServer(server)}/snapshot`, [server]);
  const configUrl = useMemo(() => `${cleanServer(server)}/config`, [server]);
  // ESP (controle direto)
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);
  const joystickUrl = useMemo(
    () => (x: number, y: number) => `http://${ip}/joystick?x=${x.toFixed(2)}&y=${y.toFixed(2)}`,
    [ip]
  );
  const uartUrl = useMemo(
    () => (line: string) => `http://${ip}/uart?line=${encodeURIComponent(line)}`,
    [ip]
  );

  /* ===== AppState pausa/retoma loops ===== */
  const appStateRef = useRef(AppState.currentState);
  useEffect(() => {
    const sub = AppState.addEventListener("change", (s) => {
      appStateRef.current = s;
    });
    return () => sub.remove();
  }, []);

  /* ===== Sincroniza IP do ESP dentro do server ===== */
  useEffect(() => {
    let aborted = false;
    (async () => {
      try {
        const r = await fetch(configUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ camera_ip: ip }),
        });
        const j = await r.json();
        if (!aborted && j?.ok) setStatusText(T.synced + ` (${j.camera_ip})`);
      } catch {
        if (!aborted) setStatusText(T.statusFail);
      }
    })();
    return () => {
      aborted = true;
    };
  }, [ip, configUrl, T]);

  /* ===== ESP STATUS ===== */
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl);
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip ?? ip} ‚Ä¢ mode:${j.mode ?? "‚Äî"} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${
          j.pump ? "on" : "off"
        }`
      );
    } catch {
      setStatusText(T.statusFail);
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  /* ===== HEALTH-CHECK DO SERVIDOR ===== */
  useEffect(() => {
    let stop = false;
    let backoff = 500; // ms
    const controller = new AbortController();

    const poll = async () => {
      if (stop) return;
      try {
        const r = await fetch(healthUrl, { signal: controller.signal });
        const j = await r.json();
        if (j?.ok) {
          setReady(true);
          setStatusText(`Server OK ‚Ä¢ fps_in:${j.fps_in} ‚Ä¢ hasFrame:${j.hasFrame}`);
          return;
        }
      } catch {
        // ignore
      }
      setReady(false);
      setStatusText(T.waiting);
      setTimeout(poll, backoff);
      backoff = Math.min(backoff * 1.6, 5000);
    };

    poll();
    return () => {
      stop = true;
      controller.abort();
    };
  }, [healthUrl, T]);

  /* ===== SNAPSHOT LOOP (~10‚Äì12 fps) ===== */
  useEffect(() => {
    if (!ready) return;
    let stop = false;
    let interval = 90; // est√°vel no Wi-Fi do roteador

    setCurrentFrameUri(`${snapshotUrl}?ts=${Date.now()}`);

    const tick = async () => {
      if (stop || appStateRef.current !== "active") return;
      try {
        if (!loadingNextRef.current) {
          const url = `${snapshotUrl}?ts=${Date.now()}`;
          setNextFrameUri(url);
        }
        interval = 90;
      } catch {
        interval = Math.min(interval * 1.7, 1200);
      }
      setTimeout(tick, interval);
    };
    tick();

    return () => {
      stop = true;
    };
  }, [snapshotUrl, ready]);

  function onNextLoadStart() {
    loadingNextRef.current = true;
  }
  function onNextShown(ok: boolean) {
    if (ok && nextFrameUri) setCurrentFrameUri(nextFrameUri);
    loadingNextRef.current = false;
  }

  /* ===== LOOP DE DETEC√á√ÉO + CAIXAS (5‚Äì6 Hz) ===== */
  useEffect(() => {
    if (!ready) return;
    let stop = false;
    let interval = 180;
    const controller = new AbortController();

    const loop = async () => {
      if (stop || appStateRef.current !== "active") return;
      try {
        const r = await fetch(detectUrl, { signal: controller.signal });
        const j = await r.json();

        if (j && j.ok !== false) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));

          // frame size
          const wh =
            Array.isArray(j.frame_wh) && j.frame_wh.length === 2
              ? { w: Number(j.frame_wh[0]) || 0, h: Number(j.frame_wh[1]) || 0 }
              : null;
          if (wh && wh.w > 0 && wh.h > 0) setFrameWH(wh);

          // objetos
          const o = j.objects || {};
          const objs = o.objects || [];
          const nPerson =
            typeof o.n_person_stable === "number"
              ? o.n_person_stable
              : typeof o.n_person === "number"
              ? o.n_person
              : objs.filter((x: any) => String(x.label).toLowerCase() === "person").length;
          const nAnimals =
            typeof o.n_animals_stable === "number"
              ? o.n_animals_stable
              : typeof o.n_animals === "number"
              ? o.n_animals
              : objs.filter((x: any) => String(x.label).toLowerCase() !== "person").length;

          setPeople(nPerson || 0);
          setAnimals(nAnimals || 0);
          setBackend(o.backend || "‚Äî");
          setConfMax(Number(o.conf_max || 0));

          // montar caixas
          const boxes: SrcBox[] = [];
          if (j.isFire && Array.isArray(j.boxes)) {
            for (const b of j.boxes) {
              if (!Array.isArray(b) || b.length < 4) continue;
              const [x, y, w, h] = b.map((n: any) => Number(n) || 0);
              boxes.push({ x, y, w, h, type: "fire" });
            }
          }
          for (const it of objs) {
            if (!it || !Array.isArray(it.box) || it.box.length < 4) continue;
            const [x, y, w, h] = it.box.map((n: any) => Number(n) || 0);
            const label = String(it.label || "").toLowerCase();
            const conf = typeof it.conf === "number" ? it.conf : undefined;
            if (label === "person") boxes.push({ x, y, w, h, type: "person", conf });
            else boxes.push({ x, y, w, h, type: "animal", conf });
          }
          setOverlayBoxes(boxes);

          interval = 180;
        }
      } catch {
        // zera UI sem quebrar
        setIsFire(false);
        setFireScore(0);
        setPeople(0);
        setAnimals(0);
        setOverlayBoxes([]);
        interval = Math.min(interval * 1.5, 1500);
      } finally {
        setTimeout(loop, interval);
      }
    };
    loop();

    return () => {
      stop = true;
      controller.abort();
    };
  }, [detectUrl, ready]);

  /* ===== Registro autom√°tico (rising edge) ===== */
  useEffect(() => {
    const rising = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;

    if (rising && cooldownOk && !saving) {
      (async () => {
        try {
          setSaving(true);
          await saveEventFromServer(server);
          lastSaveRef.current = Date.now();
          setStatusText(T.eventSavedAt(new Date(lastSaveRef.current).toLocaleString()));
        } catch {
          setStatusText(T.noVideo);
        } finally {
          setSaving(false);
        }
      })();
    }
    wasFireRef.current = isFire;
  }, [isFire, server, saving, T]);

  /* ===== Joystick: envia para o ESP =====
     1) Tenta /joystick?x=&y= (controle cont√≠nuo no ESP)
     2) Se falhar, fallback em comandos discretos via /uart?line=CMD:...
  */
  const RADIUS = 64,
    KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS,
          ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny }); // y invertido: pra cima = +y
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const lastSendRef = useRef(0);
  const lastDirRef = useRef<string>("STOP");

  const trySendJoystick = async (x: number, y: number) => {
    try {
      await fetch(joystickUrl(x, y), { method: "GET" });
      return true;
    } catch {
      return false;
    }
  };
  const sendDiscreteCmd = async (
    dir: "FWD" | "BACK" | "LEFT" | "RIGHT" | "STOP",
    ms = 180,
    spd = 70
  ) => {
    const line =
      dir === "STOP"
        ? "CMD:STOP"
        : `CMD:${dir}:ms=${Math.max(80, Math.min(ms, 600))}:spd=${Math.max(30, Math.min(
            spd,
            100
          ))}`;
    try {
      await fetch(uartUrl(line), { method: "GET" });
      return true;
    } catch {
      return false;
    }
  };
  const vecToDir = (x: number, y: number): "FWD" | "BACK" | "LEFT" | "RIGHT" | "STOP" => {
    const mag = Math.hypot(x, y);
    if (mag < 0.2) return "STOP";
    const deg = (Math.atan2(y, x) * 180) / Math.PI;
    if (deg > -45 && deg <= 45) return "RIGHT";
    if (deg > 45 && deg <= 135) return "FWD";
    if (deg <= -45 && deg > -135) return "BACK";
    return "LEFT";
  };

  useEffect(() => {
    let cancelled = false;

    const tick = async () => {
      if (cancelled) return;
      const now = Date.now();
      if (now - lastSendRef.current < 120) {
        setTimeout(tick, 20);
        return;
      }
      lastSendRef.current = now;

      const x = joy.x;
      const y = joy.y;
      const mag = Math.hypot(x, y);

      // 1) controle cont√≠nuo no ESP
      const ok = await trySendJoystick(x, y);
      if (ok) {
        // enviar STOP discreto ao soltar (garantia)
        if (mag < 0.2 && lastDirRef.current !== "STOP") {
          await sendDiscreteCmd("STOP");
          lastDirRef.current = "STOP";
        }
        setTimeout(tick, 120);
        return;
      }

      // 2) fallback discreto por pulsos
      const dir = vecToDir(x, y);
      if (dir !== lastDirRef.current) {
        const ms = 140 + Math.round(260 * Math.min(1, mag)); // 140..400
        const spd = 50 + Math.round(50 * Math.min(1, mag)); // 50..100
        await sendDiscreteCmd(dir, ms, spd);
        lastDirRef.current = dir;
      } else if (dir !== "STOP") {
        const ms = 120 + Math.round(200 * Math.min(1, mag));
        const spd = 50 + Math.round(50 * Math.min(1, mag));
        await sendDiscreteCmd(dir, ms, spd);
      }
      setTimeout(tick, 120);
    };

    if (AppState.currentState === "active") tick();
    return () => {
      cancelled = true;
    };
  }, [joy, ip]); // envia para o ESP

  // STOP garantido ao sair da tela/app
  useEffect(() => {
    const handleBg = (s: string) => {
      if (s !== "active") {
        sendDiscreteCmd("STOP");
        lastDirRef.current = "STOP";
      }
    };
    const sub = AppState.addEventListener("change", handleBg);
    return () => sub.remove();
  }, []);

  /* ===== Medidas do container do v√≠deo ===== */
  function onVideoLayout(e: LayoutChangeEvent) {
    const { width, height } = e.nativeEvent.layout;
    setVideoContainerWH({ w: width, h: height });
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder={T.placeholderIp}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : T.test}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? T.ledOn : T.ledOff}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? T.pumpOn : T.pumpOff}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor + indicador */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={(s) => {
            setServer(s);
            setReady(false); // for√ßa novo health-check
            setStatusText(T.waiting);
          }}
          placeholder={T.placeholderServer}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <View style={[styles.badge, { backgroundColor: ready ? "#065f46" : "#1f2937" }]}>
          <Text style={{ color: "#fff", fontWeight: "800" }}>
            {ready ? T.detecting : T.waiting}
          </Text>
        </View>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Banner de fogo */}
      <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      {/* Banner de pessoas/animais + backend */}
      <View style={[styles.statusRow, { justifyContent: "space-between" }]}>
        <Text style={styles.statChip}>
          {T.persons}: <Text style={styles.statNumber}>{people}</Text>
        </Text>
        <Text style={styles.statChip}>
          {T.animals}: <Text style={styles.statNumber}>{animals}</Text>
        </Text>
        <Text style={styles.modelChip}>
          {T.backend}: {backend} ‚Ä¢ conf_max {confMax.toFixed(2)}
        </Text>
      </View>

      {/* V√≠deo (snapshot) + Overlay */}
      <View style={{ flex: 1 }} onLayout={onVideoLayout}>
        <CrossfadeImage
          currentUri={currentFrameUri}
          nextUri={nextFrameUri}
          onNextLoadStart={onNextLoadStart}
          onNextShown={onNextShown}
        />
        {overlayBoxes.length > 0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View
          style={[styles.joyWrap, { width: 64 * 2 + 24, height: 64 * 2 + 24 }]}
          {...pan.panHandlers}
        >
          <View style={[styles.joyBase, { width: 64 * 2, height: 64 * 2, borderRadius: 64 }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: 22 * 2,
                height: 22 * 2,
                borderRadius: 22,
                transform: [{ translateX: joy.x * 64 }, { translateY: -joy.y * 64 }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

/* ---------- ESTILOS ---------- */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  // HERO
  hero: { alignItems: "center", paddingTop: 12, paddingBottom: 6 },
  heroLogo: { width: 80, height: 80, marginBottom: 6, resizeMode: "contain" },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 2 },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: "#0b0d14",
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 110,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1322",
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  badge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  statChip: { color: "#dbeafe", fontSize: 14, fontWeight: "600" },
  statNumber: { color: "#fff" },
  modelChip: { marginLeft: "auto", color: "#9fb0ff", fontSize: 12 },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: {
    position: "absolute",
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.14)",
  },
  joyKnob: {
    position: "absolute",
    backgroundColor: "rgba(230,64,58,0.9)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.85)",
  },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});



O que isso faz




O joystick manda continuamente GET http://<ESP>/joystick?x=&y=; se n√£o responder, cai no fallback GET /uart?line=CMD:..., exatamente no formato que o seu c√≥digo do Arduino j√° entende.


O bot√£o BOMBA ON/OFF chama GET http://<ESP>/pump?on=1|0, que o seu firmware do ESP repassa ao Arduino via pino que voc√™ conectou (ou apenas liga/desliga o rel√©, conforme implementado).




Se algo n√£o mover o rob√¥: abra o Serial do Arduino e confirme que chegam linhas como CMD:FWD:ms=...:spd=... quando voc√™ mexe o joystick; se n√£o estiver chegando, me avise que ajusto o lado do ESP.

























































































// ====== HydroBot Arduino - Driver & Sensors (sem servo) ======
// Motores, bomba, LED e sensores ficam aqui. ESP32-CAM comanda via UART.
// Protocolo linha-a-linha (terminado em '\n'):
//  - "CMD:FWD:ms=400:spd=70"
//  - "CMD:BACK:ms=300"
//  - "CMD:LEFT:ms=200" / "CMD:RIGHT:ms=200"
//  - "CMD:STOP"
//  - "CMD:PUMP:1"  (liga)  / "CMD:PUMP:0" (desliga)
//  - "REQ:STATUS"  (Arduino responde "STAT:...")
//  - "SET:SPEED:NN" (0..100 - fator PWM soft)
//  - "SET:LED:n"    (0..255)
//
// Resposta STATUS (exemplo):
// STAT:ax=512:am=480:ad=505:water=73:pump=0:batt=0

#include <Arduino.h>

// ===== PINOS =====
#define IN1 8
#define IN2 9
#define IN3 10
#define IN4 11
#define BOMBA_PIN 13
#define LED_VERMELHO 3

#define SENSOR_FOGO_DIR A0
#define SENSOR_FOGO_MEIO A1
#define SENSOR_FOGO_ESQ A2
#define NIVEL_AGUA_PIN  A3

// ===== CONFIG =====
static uint8_t baseSpeed = 70; // 0..100 (fator de duty "soft" por tempo)
static bool pumpOn = false;

// ===== HELPERS =====
void motorsStop() {
  digitalWrite(IN1, LOW); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW); digitalWrite(IN4, LOW);
}
void motorsFwd() {
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
}
void motorsBack() {
  digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);
}
void motorsLeftTurn() { // piv√¥ esquerdo: esquerda r√©, direita frente
  digitalWrite(IN1, LOW);  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
}
void motorsRightTurn() { // piv√¥ direito: esquerda frente, direita r√©
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);  digitalWrite(IN4, HIGH);
}

void pumpWrite(bool on) {
  pumpOn = on;
  digitalWrite(BOMBA_PIN, on ? HIGH : LOW);
}

uint8_t waterPercent() {
  int raw = analogRead(NIVEL_AGUA_PIN); // 0..1023
  int pct = map(raw, 0, 1023, 0, 100);
  pct = constrain(pct, 0, 100);
  return (uint8_t)pct;
}

void ledLevelByWater(uint8_t pct) {
  static unsigned long lastBlink=0;
  static bool state=false;
  if (pct >= 50) {
    analogWrite(LED_VERMELHO, 0);
  } else if (pct >= 25) {
    analogWrite(LED_VERMELHO, 100);
  } else if (pct >= 15) {
    if (millis()-lastBlink>1000) {
      state=!state;
      analogWrite(LED_VERMELHO, state?200:0);
      lastBlink=millis();
    }
  } else {
    if (millis()-lastBlink>300) {
      state=!state;
      analogWrite(LED_VERMELHO, state?255:0);
      lastBlink=millis();
    }
  }
}

void emitStatus() {
  int ax = analogRead(SENSOR_FOGO_ESQ);
  int am = analogRead(SENSOR_FOGO_MEIO);
  int ad = analogRead(SENSOR_FOGO_DIR);
  uint8_t wp = waterPercent();
  Serial.print(F("STAT:ax=")); Serial.print(ax);
  Serial.print(F(":am=")); Serial.print(am);
  Serial.print(F(":ad=")); Serial.print(ad);
  Serial.print(F(":water=")); Serial.print(wp);
  Serial.print(F(":pump=")); Serial.print(pumpOn?1:0);
  Serial.print(F(":batt=")); Serial.println(0); // placeholder
}

void softMove(void (*fnDir)(), uint16_t ms, uint8_t spd) {
  // simples controle por tempo; spd s√≥ documenta inten√ß√£o
  (void)spd;
  fnDir();
  delay(ms);
  motorsStop();
}

void setup() {
  Serial.begin(115200);

  pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);
  pinMode(BOMBA_PIN, OUTPUT);
  pinMode(LED_VERMELHO, OUTPUT);

  motorsStop();
  pumpWrite(false);

  Serial.println(F("ARDUINO_READY"));
}

String line;

void loop() {
  // LED de n√≠vel (local, independente de comandos)
  ledLevelByWater(waterPercent());

  // UART parsing
  while (Serial.available()) {
    char c = Serial.read();
    if (c=='\n' || c=='\r') {
      if (line.length()>0) {
        line.trim();

        if (line.startsWith("CMD:")) {
          // exemplos: CMD:FWD:ms=400:spd=70
          if (line.indexOf("FWD")>0) {
            uint16_t ms=400; uint8_t sp=baseSpeed;
            int p=line.indexOf("ms=");
            if (p>0) ms = (uint16_t) line.substring(p+3).toInt();
            p=line.indexOf("spd=");
            if (p>0) sp = (uint8_t) line.substring(p+4).toInt();
            softMove(motorsFwd, ms, sp);
            Serial.println(F("OK:FWD"));
          }
          else if (line.indexOf("BACK")>0) {
            uint16_t ms=300; uint8_t sp=baseSpeed;
            int p=line.indexOf("ms=");
            if (p>0) ms = (uint16_t) line.substring(p+3).toInt();
            softMove(motorsBack, ms, sp);
            Serial.println(F("OK:BACK"));
          }
          else if (line.indexOf("LEFT")>0) {
            uint16_t ms=200;
            int p=line.indexOf("ms=");
            if (p>0) ms = (uint16_t) line.substring(p+3).toInt();
            softMove(motorsLeftTurn, ms, baseSpeed);
            Serial.println(F("OK:LEFT"));
          }
          else if (line.indexOf("RIGHT")>0) {
            uint16_t ms=200;
            int p=line.indexOf("ms=");
            if (p>0) ms = (uint16_t) line.substring(p+3).toInt();
            softMove(motorsRightTurn, ms, baseSpeed);
            Serial.println(F("OK:RIGHT"));
          }
          else if (line.indexOf("STOP")>0) {
            motorsStop();
            Serial.println(F("OK:STOP"));
          }
          else if (line.indexOf("PUMP:")>0) {
            bool on = line.endsWith("1");
            if (on && waterPercent()<=15) {
              pumpWrite(false);
              Serial.println(F("WARN:NO_WATER"));
            } else {
              pumpWrite(on);
              Serial.println(on?F("OK:PUMP_ON"):F("OK:PUMP_OFF"));
            }
          }
          else {
            Serial.println(F("ERR:CMD"));
          }
        }
        else if (line.startsWith("REQ:STATUS")) {
          emitStatus();
        }
        else if (line.startsWith("SET:SPEED:")) {
          int v = line.substring(10).toInt();
          baseSpeed = (uint8_t) constrain(v,0,100);
          Serial.println(F("OK:SPEED"));
        }
        else if (line.startsWith("SET:LED:")) {
          int v = line.substring(8).toInt();
          analogWrite(LED_VERMELHO, constrain(v,0,255));
          Serial.println(F("OK:LED"));
        }
        else {
          Serial.println(F("ERR:UNKNOWN"));
        }
        line = "";
      }
    } else {
      line += c;
    }
  }
}
