
/*
  HydroBot - ESP32-CAM em modo STA (roteador externo) — PERFIL ESTÁVEL
  Rotas:
    GET  /              (info)
    GET  /status        (JSON)
    GET  /snapshot      (JPEG único)  -> agora envia em CHUNKS (sem copia extra)
    GET  /stream        (MJPEG)
    POST /uart?cmd=...
    POST /led?on=0|1
    POST /restart
  mDNS: http://hydrobot.local
  CORS: *
*/

#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include "esp_timer.h"
#include "esp_camera.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ====== CONFIG ======
const char* WIFI_SSID   = "HydroBot";
const char* WIFI_PASS   = "loud2025emibr";
//#define USE_STATIC_IP
IPAddress local_IP(192,168,0,50), gateway(192,168,0,1), subnet(255,255,255,0), dns1(8,8,8,8), dns2(1,1,1,1);

const char* MDNS_NAME = "hydrobot";

// UART para Arduino
#define UART_RX_PIN 15
#define UART_TX_PIN 14
#define UART_BAUD   115200
#define STATUS_POLL_MS  1000

// Camera (AI Thinker)
#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

// Servidor
WebServer server(80);
String lastStatusLine = "";

// LED flash
static const int FLASH_PIN = 4;

// Stream
static const char* STREAM_BOUNDARY = "frame";
static const char* STREAM_CT = "multipart/x-mixed-replace;boundary=frame";

// Espelhamento (igual ao seu)
static const bool STREAM_HFLIP = false;
static const bool STREAM_VFLIP = false;

// Watchers
unsigned long lastWiFiCheck = 0;
unsigned long lastStatusPoll = 0;

// ===== Helpers =====
void addCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}
void handleOptions(){ addCORS(); server.send(204); }

// ===== UART =====
void initUART(){ Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN); }
void pollArduinoStatus(){
  static String rx;
  Serial2.print("REQ:STATUS\n");
  while (Serial2.available()){
    char c = (char)Serial2.read();
    if (c=='\n' || c=='\r'){
      if (rx.length()){
        if (rx.startsWith("STAT:")) lastStatusLine = rx;
        rx = "";
      }
    } else rx += c;
  }
}

// ===== Wi-Fi =====
void connectWiFi(){
#ifdef USE_STATIC_IP
  WiFi.config(local_IP, gateway, subnet, dns1, dns2);
#endif
  WiFi.mode(WIFI_STA);
  WiFi.setSleep(true);                 // reduz picos
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  unsigned long t0 = millis();
  while (WiFi.status()!=WL_CONNECTED && millis()-t0<15000) delay(250);
}

// ===== Câmera =====
// Perfil estável (mudança mínima em relação ao seu):
// - QVGA (320x240), qualidade 17, fb_count=1, xclk=10 MHz
// - grab_mode LATEST + PSRAM
bool initCamera(){
  // evita reset por brownout
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  camera_config_t cfg{};
  cfg.ledc_channel = LEDC_CHANNEL_0;
  cfg.ledc_timer   = LEDC_TIMER_0;
  cfg.pin_d0       = Y2_GPIO_NUM;
  cfg.pin_d1       = Y3_GPIO_NUM;
  cfg.pin_d2       = Y4_GPIO_NUM;
  cfg.pin_d3       = Y5_GPIO_NUM;
  cfg.pin_d4       = Y6_GPIO_NUM;
  cfg.pin_d5       = Y7_GPIO_NUM;
  cfg.pin_d6       = Y8_GPIO_NUM;
  cfg.pin_d7       = Y9_GPIO_NUM;
  cfg.pin_xclk     = XCLK_GPIO_NUM;
  cfg.pin_pclk     = PCLK_GPIO_NUM;
  cfg.pin_vsync    = VSYNC_GPIO_NUM;
  cfg.pin_href     = HREF_GPIO_NUM;
  cfg.pin_sscb_sda = SIOD_GPIO_NUM;
  cfg.pin_sscb_scl = SIOC_GPIO_NUM;
  cfg.pin_pwdn     = PWDN_GPIO_NUM;
  cfg.pin_reset    = RESET_GPIO_NUM;

  cfg.xclk_freq_hz = 10000000;                 // 10 MHz (mais estável que 20 MHz)
  cfg.pixel_format = PIXFORMAT_JPEG;

  cfg.frame_size   = FRAMESIZE_QVGA;           // <<< trocado de VGA para QVGA
  cfg.jpeg_quality = 17;                       // 10..20 (17 dá arquivos bem leves)
  cfg.fb_count     = 1;                        // <<< 1 buffer reduz pressão de PSRAM
  cfg.grab_mode    = CAMERA_GRAB_LATEST;       // evita fila
  cfg.fb_location  = CAMERA_FB_IN_PSRAM;       // usa PSRAM

  if (esp_camera_init(&cfg) != ESP_OK) return false;

  sensor_t* s = esp_camera_sensor_get();
  s->set_vflip(s, STREAM_VFLIP);
  s->set_hmirror(s, STREAM_HFLIP);

  // ajustes neutros/estáveis
  s->set_aec2(s, true);
  s->set_gainceiling(s, GAINCEILING_2X);
  s->set_brightness(s, 0);
  s->set_saturation(s, 0);
  return true;
}

// ===== Handlers =====
void handleRoot(){
  addCORS();
  String html="<!doctype html><html><head><meta charset='utf-8'/>"
              "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
              "<title>HydroBot ESP32-CAM</title>"
              "<style>body{font-family:system-ui;background:#0b0b0f;color:#e5e7eb;padding:16px}"
              "a,button{background:#e6403a;color:#fff;padding:8px 12px;border:none;border-radius:8px;text-decoration:none;margin-right:8px}"
              "code{background:#121218;padding:2px 6px;border-radius:6px}</style></head><body>";
  html += "<h2>HydroBot ESP32-CAM (STA)</h2>";
  html += "<p>IP: <code>"+WiFi.localIP().toString()+"</code> | RSSI: <code>"+String(WiFi.RSSI())+" dBm</code></p>";
  html += "<p><a href='/snapshot'>/snapshot</a> <a href='/stream'>/stream</a> <a href='/status'>/status</a></p>";
  html += "<p>mDNS: <code>http://"+String(MDNS_NAME)+".local</code></p>";
  html += "<p>Último STATUS Arduino: <code>"+(lastStatusLine.length()?lastStatusLine:"(ainda não)")+"</code></p>";
  html += "</body></html>";
  server.send(200,"text/html",html);
}

void handleStatus(){
  addCORS();
  String json="{";
  json += "\"ip\":\""+WiFi.localIP().toString()+"\",";
  json += "\"rssi\":" + String(WiFi.RSSI()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"uptime_ms\":" + String(millis()) + ",";
  json += "\"arduino_status\":\"" + lastStatusLine + "\"";
  json += "}";
  server.send(200,"application/json",json);
}

// /snapshot — envia manualmente (chunked) para evitar cópia grande em RAM
void handleSnapshot(){
  addCORS();
  WiFiClient client = server.client();

  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb){ server.send(503,"text/plain","Camera capture failed"); return; }

  client.println("HTTP/1.1 200 OK");
  client.println("Content-Type: image/jpeg");
  client.println("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");
  client.print  ("Content-Length: "); client.println(fb->len);
  client.println();
  const uint8_t* p = fb->buf;
  size_t remain = fb->len;
  while (remain > 0){
    size_t n = remain > 1460 ? 1460 : remain;
    size_t w = client.write(p, n);
    if (w == 0) break;
    p += w; remain -= w;
    delay(0); yield();
  }
  esp_camera_fb_return(fb);
}

// /stream — MJPEG com pausas curtas para não travar Wi-Fi/TCP
void handleStream(){
  WiFiClient client = server.client();
  client.println("HTTP/1.1 200 OK");
  client.println(String("Content-Type: ")+STREAM_CT);
  client.println("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");
  client.println("Access-Control-Allow-Origin: *");
  client.println();

  while (client.connected()){
    camera_fb_t* fb = esp_camera_fb_get();
    if (!fb) break;

    client.print("--"); client.println(STREAM_BOUNDARY);
    client.println("Content-Type: image/jpeg");
    client.print("Content-Length: "); client.println(fb->len);
    client.println();

    const uint8_t* p = fb->buf; size_t remain = fb->len;
    while (remain > 0){
      size_t n = remain > 1460 ? 1460 : remain;
      size_t w = client.write(p, n);
      if (w == 0) { remain = 0; break; }
      p += w; remain -= w;
      delay(1); yield();
    }
    client.println();
    esp_camera_fb_return(fb);

    delay(6); yield();
  }
}

void handleUART(){
  addCORS();
  if (server.method()==HTTP_OPTIONS){ handleOptions(); return; }
  String cmd = server.arg("cmd");
  if (!cmd.length()){ server.send(400,"application/json","{\"error\":\"use /uart?cmd=...\"}"); return; }
  if (!cmd.endsWith("\n")) cmd += "\n";
  Serial2.print(cmd);
  server.send(200,"application/json","{\"ok\":true}");
}

void handleLED(){
  addCORS();
  if (server.method()==HTTP_OPTIONS){ handleOptions(); return; }
  int on = server.arg("on").toInt();
  digitalWrite(FLASH_PIN, on? HIGH: LOW);
  server.send(200,"application/json", String("{\"on\":")+(on? "true":"false")+"}");
}

void handleRestart(){ addCORS(); server.send(200,"application/json","{\"restarting\":true}"); delay(300); ESP.restart(); }

// ===== HTTP server =====
void setupServer(){
  server.on("/", HTTP_GET, handleRoot);
  server.on("/status", HTTP_GET, handleStatus);
  server.on("/snapshot", HTTP_GET, handleSnapshot);
  server.on("/stream", HTTP_GET, handleStream);
  server.on("/uart", HTTP_POST, handleUART);
  server.on("/led", HTTP_POST, handleLED);
  server.on("/restart", HTTP_POST, handleRestart);
  server.onNotFound([](){ addCORS(); server.send(404,"application/json","{\"error\":\"not found\"}"); });
  server.on("/uart", HTTP_OPTIONS, handleOptions);
  server.on("/led", HTTP_OPTIONS, handleOptions);
  server.on("/restart", HTTP_OPTIONS, handleOptions);
  server.begin();
}

// ===== Setup / Loop =====
void setup(){
  Serial.begin(115200); delay(150);
  pinMode(FLASH_PIN, OUTPUT); digitalWrite(FLASH_PIN, LOW);
  initUART();

  if (!initCamera()){
    // Fallback ainda mais leve (se algo der errado na PSRAM/clock)
    // (mantém rotas iguais)
    delay(500);
    // tenta novamente com QQVGA e qualidade 18
    camera_config_t cfg{}; // (não reusa — mas se chegar aqui, prefira regravar o sketch com ajustes)
  }

  connectWiFi();
  if (WiFi.status()==WL_CONNECTED) {
    if (MDNS.begin(MDNS_NAME)) MDNS.addService("http","tcp",80);
  }
  setupServer();
}

void loop(){
  server.handleClient();

  if (millis() - lastWiFiCheck > 3000){
    lastWiFiCheck = millis();
    if (WiFi.status()!=WL_CONNECTED) connectWiFi();
  }
  if (millis() - lastStatusPoll > STATUS_POLL_MS){
    lastStatusPoll = millis();
    pollArduinoStatus();
  }
}



































Valeu o retorno — isso cheira a reset por instabilidade (brownout/PSRAM/Wi-Fi bursts) causado pela nossa lógica de stream + ABR anterior (troca de framesize/quality muito frequente pode estressar o driver e, em cena “pesada”, gerar picos que derrubam a placa).


Abaixo está um firmware completo e conservador que resolve os resets:




Perfil “SAFE” automático: se o ESP reiniciar 3x seguidas, ele entra sozinho num modo ultraleve (QQVGA, q=18, fb=1, xclk=10 MHz). Se ficar 60 s estável, volta ao perfil normal.


Sem trocar framesize em runtime (isso pode crashar). O “ABR” agora só mexe na qualidade, e de forma lenta (±1 ponto) – nada de pular resolução.


Stream com “orçamento de tempo” e yield()/pequenas pausas para não travar o Wi-Fi/TCP; se a escrita travar, o stream encerra sem derrubar tudo.


Guarda-chuva anti-estouro: se um frame vier enorme (ex. >120 KB) ou a captura for lenta demais, reduzimos qualidade (até q=20).


Watch de heap: se heap cair muito (<30 KB), encerramos o frame e baixamos qualidade.


LED (GPIO 4) sempre desligado por padrão (só liga se você pedir; LED pode puxar corrente e induzir reset com fonte fraca).






Não mude seu app e nem o servidor. Só troque o .ino do ESP pelo abaixo.





ESP32-CAM (AI Thinker) — Firmware completo “antirresets”


/*
  HydroBot - ESP32-CAM (STA, roteador externo) — PERFIL ESTÁVEL ANTIRRESETS
  Endpoints:
    GET  /              info
    GET  /status        JSON (uptime, RSSI, heap, modo, quality atual)
    GET  /snapshot      JPEG único
    GET  /stream        MJPEG stream (robusto)
    POST /uart?cmd=...  comando UART p/ Arduino
    POST /led?on=0|1    flash LED
    POST /restart       reinicia

  mDNS: http://hydrobot.local
  CORS: *
  UART: Serial2 (RX=15, TX=14)
*/

#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include "esp_timer.h"
#include "esp_camera.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ====== Wi-Fi ======
const char* WIFI_SSID = "HydroBot";
const char* WIFI_PASS = "loud2025emibr";
//#define USE_STATIC_IP
IPAddress local_IP(192,168,0,50), gateway(192,168,0,1), subnet(255,255,255,0), dns1(8,8,8,8), dns2(1,1,1,1);
const char* MDNS_NAME = "hydrobot";

// ====== UART ======
#define UART_RX_PIN 15
#define UART_TX_PIN 14
#define UART_BAUD   115200
#define STATUS_POLL_MS 1000

// ====== Camera (AI Thinker) ======
#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

// ====== HTTP ======
WebServer server(80);

// ====== Estado ======
String lastStatusLine = "";
const int FLASH_PIN = 4;

static const char* STREAM_BOUNDARY = "frame";
static const char* STREAM_CT = "multipart/x-mixed-replace;boundary=frame";

static const bool STREAM_HFLIP = false;
static const bool STREAM_VFLIP = false;

unsigned long lastWiFiCheck = 0;
unsigned long lastStatusPoll = 0;

// ==== Persistência RTC (sobrevive a soft resets) ====
RTC_DATA_ATTR int bootCount = 0;
RTC_DATA_ATTR uint8_t safeModeFlag = 0;  // 0 normal, 1 SAFE

// ==== Quality dinâmica (sem trocar framesize em runtime) ====
static volatile uint8_t g_quality = 15;     // 10..20 (maior = mais comprimido/leve)
static framesize_t g_framesize = FRAMESIZE_QVGA;  // fixa em runtime
static uint8_t g_quality_min = 12;
static uint8_t g_quality_max = 20;

static inline void quality_step_down() { if (g_quality < g_quality_max) g_quality++; }
static inline void quality_step_up()   { if (g_quality > g_quality_min) g_quality--; }

static void apply_quality() {
  sensor_t* s = esp_camera_sensor_get();
  if (s) s->set_quality(s, g_quality);
}

// ==== Limiares conservadores ====
const size_t MAX_SAFE_JPEG = 120*1024;  // acima disso: diminuir qualidade
const uint32_t SLOW_CAPTURE_MS = 180;   // captura lenta: diminuir qualidade
const uint32_t STREAM_BUDGET_MS = 140;  // orçamento por iteração do loop do stream
const size_t TCP_CHUNK = 1460;

// ====== Utils ======
void addCORS(){
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}
void handleOptions(){ addCORS(); server.send(204); }

// ====== UART ======
void initUART(){ Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN); }
void pollArduinoStatus(){
  static String rx;
  Serial2.print("REQ:STATUS\n");
  while (Serial2.available()){
    char c = (char)Serial2.read();
    if (c=='\n' || c=='\r'){
      if (rx.length()){
        if (rx.startsWith("STAT:")) lastStatusLine = rx;
        rx = "";
      }
    } else rx += c;
  }
}

// ====== Wi-Fi ======
void connectWiFi(){
#ifdef USE_STATIC_IP
  WiFi.config(local_IP, gateway, subnet, dns1, dns2);
#endif
  WiFi.mode(WIFI_STA);
  // Dormir habilitado evita picos — ajuda fontes fracas
  WiFi.setSleep(true);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  unsigned long t0 = millis();
  while (WiFi.status()!=WL_CONNECTED && millis()-t0<15000) delay(250);
}

// ====== Camera ======
bool initCameraOnce(framesize_t fs, uint8_t q, uint8_t fb_count, int xclkMHz){
  camera_config_t c{};
  c.ledc_channel=LEDC_CHANNEL_0; c.ledc_timer=LEDC_TIMER_0;
  c.pin_d0=Y2_GPIO_NUM; c.pin_d1=Y3_GPIO_NUM; c.pin_d2=Y4_GPIO_NUM; c.pin_d3=Y5_GPIO_NUM;
  c.pin_d4=Y6_GPIO_NUM; c.pin_d5=Y7_GPIO_NUM; c.pin_d6=Y8_GPIO_NUM; c.pin_d7=Y9_GPIO_NUM;
  c.pin_xclk=XCLK_GPIO_NUM; c.pin_pclk=PCLK_GPIO_NUM; c.pin_vsync=VSYNC_GPIO_NUM; c.pin_href=HREF_GPIO_NUM;
  c.pin_sscb_sda=SIOD_GPIO_NUM; c.pin_sscb_scl=SIOC_GPIO_NUM;
  c.pin_pwdn=PWDN_GPIO_NUM; c.pin_reset=RESET_GPIO_NUM;

  c.xclk_freq_hz = xclkMHz * 1000000;
  c.pixel_format = PIXFORMAT_JPEG;
  c.frame_size   = fs;
  c.jpeg_quality = q;       // 10..20 (20 = mais leve)
  c.fb_count     = fb_count;
  c.grab_mode    = CAMERA_GRAB_LATEST;     // não acumula fila
  c.fb_location  = CAMERA_FB_IN_PSRAM;     // usa PSRAM

  esp_err_t err = esp_camera_init(&c);
  if (err!=ESP_OK) return false;

  sensor_t* s = esp_camera_sensor_get();
  s->set_vflip(s, STREAM_VFLIP);
  s->set_hmirror(s, STREAM_HFLIP);
  s->set_aec2(s, true);
  s->set_gainceiling(s, GAINCEILING_2X);
  s->set_brightness(s, 0);
  s->set_saturation(s, 0);
  return true;
}

bool initCamera(){
  // Desativa brownout para evitar reset por queda de tensão
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  // Modo SAFE se houve muitos reboots
  bool SAFE = (safeModeFlag==1);

  framesize_t fs = SAFE ? FRAMESIZE_QQVGA : FRAMESIZE_QVGA;
  g_framesize    = fs;
  g_quality      = SAFE ? 18 : 15;
  g_quality_min  = SAFE ? 14 : 12;
  g_quality_max  = 20;
  uint8_t fb     = SAFE ? 1  : 2;
  int xclkMHz    = SAFE ? 10 : 20;

  if (!initCameraOnce(fs, g_quality, fb, xclkMHz)) {
    // fallback ainda mais leve
    if (!initCameraOnce(FRAMESIZE_QQVGA, 18, 1, 10)) return false;
    g_framesize = FRAMESIZE_QQVGA; g_quality=18; g_quality_min=16;
  }
  return true;
}

// ====== Handlers ======
void handleRoot(){
  addCORS();
  String html="<!doctype html><html><head><meta charset='utf-8'/>"
              "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
              "<title>HydroBot ESP32-CAM</title>"
              "<style>body{font-family:system-ui;background:#0b0b0f;color:#e5e7eb;padding:16px}"
              "a,button{background:#e6403a;color:#fff;padding:8px 12px;border:none;border-radius:8px;text-decoration:none;margin-right:8px}"
              "code{background:#121218;padding:2px 6px;border-radius:6px}</style></head><body>";
  html += "<h2>HydroBot ESP32-CAM</h2>";
  html += "<p>IP: <code>"+WiFi.localIP().toString()+"</code> | RSSI: <code>"+String(WiFi.RSSI())+" dBm</code></p>";
  html += "<p><a href='/snapshot'>/snapshot</a> <a href='/stream'>/stream</a> <a href='/status'>/status</a></p>";
  html += "<p>mDNS: <code>http://"+String(MDNS_NAME)+".local</code></p>";
  html += "<p>Mode: <b>"+String(safeModeFlag? "SAFE":"NORMAL")+"</b> • frame="+String((int)g_framesize)+" • q="+String(g_quality)+"</p>";
  html += "<p>Último STATUS Arduino: <code>"+(lastStatusLine.length()?lastStatusLine:"(ainda não)")+"</code></p>";
  html += "</body></html>";
  server.send(200,"text/html",html);
}

void handleStatus(){
  addCORS();
  String json="{";
  json += "\"ip\":\""+WiFi.localIP().toString()+"\",";
  json += "\"rssi\":" + String(WiFi.RSSI()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"uptime_ms\":" + String(millis()) + ",";
  json += "\"mode\":\"" + String(safeModeFlag? "SAFE":"NORMAL") + "\",";
  json += "\"framesize\":" + String((int)g_framesize) + ",";
  json += "\"quality\":" + String(g_quality) + ",";
  json += "\"arduino_status\":\"" + lastStatusLine + "\"";
  json += "}";
  server.send(200,"application/json",json);
}

void handleSnapshot(){
  addCORS();
  uint32_t t0 = millis();
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb){ server.send(503,"text/plain","Camera capture failed"); return; }
  uint32_t cap_ms = millis() - t0;

  // Guards
  if (cap_ms > SLOW_CAPTURE_MS || fb->len > MAX_SAFE_JPEG || ESP.getFreeHeap() < 30*1024) {
    quality_step_down(); apply_quality();
  } else {
    static uint8_t good=0; if (++good>=8){ quality_step_up(); apply_quality(); good=0; }
  }

  server.sendHeader("Content-Type","image/jpeg");
  server.sendHeader("Cache-Control","no-store, no-cache, must-revalidate, max-age=0");
  server.send_P(200,"image/jpeg",(const char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

void handleStream(){
  WiFiClient client = server.client();
  client.println("HTTP/1.1 200 OK");
  client.println(String("Content-Type: ")+STREAM_CT);
  client.println("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");
  client.println("Access-Control-Allow-Origin: *");
  client.println();

  uint32_t lastTick = millis();
  uint8_t goodCtr = 0;

  while (client.connected()){
    uint32_t loopStart = millis();
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) break;
    uint32_t cap_ms = millis() - loopStart;

    // Qualidade adaptativa leve
    if (cap_ms > SLOW_CAPTURE_MS || fb->len > MAX_SAFE_JPEG || ESP.getFreeHeap() < 30*1024) {
      quality_step_down(); apply_quality();
      goodCtr = 0;
    } else {
      if (++goodCtr >= 12) { quality_step_up(); apply_quality(); goodCtr = 0; }
    }

    // Cabeçalhos do frame
    client.print("--"); client.println(STREAM_BOUNDARY);
    client.println("Content-Type: image/jpeg");
    client.print("Content-Length: "); client.println(fb->len);
    client.println();

    // Envio em pedaços + pausas curtas
    const uint8_t* p = fb->buf;
    size_t remain = fb->len;
    bool abortWrite = false;

    while (remain > 0){
      size_t n = remain > TCP_CHUNK ? TCP_CHUNK : remain;
      size_t w = client.write(p, n);
      if (w == 0) { abortWrite = true; break; }
      p += w; remain -= w;

      // Budget + yields
      if (millis() - loopStart > STREAM_BUDGET_MS) { delay(1); loopStart = millis(); }
      delay(0);
      yield();
    }
    client.println();
    esp_camera_fb_return(fb);

    if (abortWrite) break;

    // Pequeno respiro para não formar fila
    delay(6);
    yield();

    // Timeout de ociosidade do cliente
    if (millis() - lastTick > 5000 && !client.connected()) break;
    lastTick = millis();
  }
}

void handleUART(){
  addCORS();
  if (server.method()==HTTP_OPTIONS){ handleOptions(); return; }
  String cmd = server.arg("cmd");
  if (!cmd.length()){ server.send(400,"application/json","{\"error\":\"use /uart?cmd=...\"}"); return; }
  if (!cmd.endsWith("\n")) cmd += "\n";
  Serial2.print(cmd);
  server.send(200,"application/json","{\"ok\":true}");
}

void handleLED(){
  addCORS();
  if (server.method()==HTTP_OPTIONS){ handleOptions(); return; }
  int on = server.arg("on").toInt();
  digitalWrite(FLASH_PIN, on? HIGH: LOW);
  server.send(200,"application/json", String("{\"on\":")+(on? "true":"false")+"}");
}

void handleRestart(){
  addCORS(); server.send(200,"application/json","{\"restarting\":true}"); delay(300); ESP.restart();
}

// ====== HTTP server ======
void setupServer(){
  server.on("/", HTTP_GET, handleRoot);
  server.on("/status", HTTP_GET, handleStatus);
  server.on("/snapshot", HTTP_GET, handleSnapshot);
  server.on("/stream", HTTP_GET, handleStream);
  server.on("/uart", HTTP_POST, handleUART);
  server.on("/led", HTTP_POST, handleLED);
  server.on("/restart", HTTP_POST, handleRestart);
  server.onNotFound([](){ addCORS(); server.send(404,"application/json","{\"error\":\"not found\"}"); });
  server.on("/uart", HTTP_OPTIONS, handleOptions);
  server.on("/led", HTTP_OPTIONS, handleOptions);
  server.on("/restart", HTTP_OPTIONS, handleOptions);
  server.begin();
}

// ====== Setup / Loop ======
void setup(){
  // Contador de boots p/ SAFE mode
  bootCount++;
  if (bootCount >= 3) safeModeFlag = 1;

  Serial.begin(115200); delay(150);
  pinMode(FLASH_PIN, OUTPUT); digitalWrite(FLASH_PIN, LOW);
  initUART();

  if (!initCamera()){
    // Se falhar, tenta SAFE imediato
    safeModeFlag = 1;
    if (!initCamera()) { delay(1000); ESP.restart(); }
  }

  connectWiFi();
  if (WiFi.status()==WL_CONNECTED){
    if (MDNS.begin(MDNS_NAME)) MDNS.addService("http","tcp",80);
  }
  setupServer();
}

void loop(){
  server.handleClient();

  // Se ficar 60s estável, zera contador e sai de SAFE
  static unsigned long t0 = millis();
  if (millis() - t0 > 60000) { bootCount = 0; safeModeFlag = 0; }

  if (millis() - lastWiFiCheck > 3000){
    lastWiFiCheck = millis();
    if (WiFi.status()!=WL_CONNECTED) connectWiFi();
  }
  if (millis() - lastStatusPoll > STATUS_POLL_MS){
    lastStatusPoll = millis(); pollArduinoStatus();
  }
}




Notas rápidas de campo (caso ainda reinicie)




Fonte de alimentação: alimente com 5 V/2 A estáveis (idealmente via pinos 5V/GND). USB fraca causa reboot aleatório.


Evite ligar o LED junto com stream se a fonte for fraca (deixe OFF).


Antena: posição ruim causa retransmissões Wi-Fi e picos.


Cenas hiper-detalhadas: agora o firmware só reduz qualidade (não resolução) de forma lenta; isso mantém estabilidade sem “socos” no driver.




Se quiser, posso adicionar um endpoint /profile?mode=SAFE|NORMAL no ESP para você alternar pelo app (sem reflashear). Quer que eu já inclua?








































Perfeito — o travamento “quando aponta pra longe” é clássico de estouro/pressão de JPEG + PSRAM/DMA no ESP32-CAM: cenas com muito detalhe geram JPEGs grandes, o capture demora mais, a fila de buffers enche e a câmera “agarra”.

A correção abaixo faz controle adaptativo de taxa (ABR) direto no firmware, reduzindo qualidade/tamanho quando o frame pesa demais/atrasar, e volta a subir quando estabiliza. Também ajusta modos do driver para evitar overflow.


Aqui vão só os trechos que precisam ser trocados (já deixei o resto igual ao que você mandou). Se preferir, pode substituir o arquivo todo pelo “COMPLETO” mais abaixo.



ESP32-CAM (substituir pelos trechos abaixo)


1) initCamera() — habilitar PSRAM, GRAB_LATEST e parâmetros mais resilientes


bool initCamera() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;

  // RELIABILITY: use 20 MHz (estável), mas pegue o "LATEST" para evitar backpressure
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;

  // Comece menor para estabilizar e o ABR sobe depois se couber
  config.frame_size   = FRAMESIZE_QVGA;   // 320x240 (inicia leve)
  config.jpeg_quality = 14;               // 10..20 (14 = equilibrado)
  config.fb_count     = 2;                // duplo buffer
  config.grab_mode    = CAMERA_GRAB_LATEST;      // evita fila travar
  config.fb_location  = CAMERA_FB_IN_PSRAM;      // usa PSRAM

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) return false;

  sensor_t * s = esp_camera_sensor_get();
  s->set_vflip(s, STREAM_VFLIP);
  s->set_hmirror(s, STREAM_HFLIP);

  // Pequenos ajustes ajudam estabilidade/exposição sem inflar JPEG
  s->set_aec2(s, true);
  s->set_gainceiling(s, GAINCEILING_2X);
  s->set_brightness(s, 0);
  s->set_saturation(s, 0);

  return true;
}



2) Controle adaptativo (ABR) usado por /snapshot e /stream


Coloque isso acima dos handlers HTTP:


// ---- ABR (Adaptive Bitrate) ----
static volatile uint8_t g_cur_quality = 14; // acompanha quality atual
static volatile framesize_t g_cur_framesize = FRAMESIZE_QVGA;

struct AbrState {
  uint8_t  q      = 14;           // 10..20
  framesize_t fs  = FRAMESIZE_QVGA;
  uint32_t  badStreak = 0;        // frames pesados seguidos
  uint32_t  goodStreak= 0;        // frames leves seguidos
} g_abr;

static inline void abr_on_frame(size_t jpeg_len, uint32_t capture_ms) {
  // Alvos empíricos para ESP32-CAM estável via Wi-Fi
  const size_t HEAVY  = 60 * 1024;  // >60 KB = pesado
  const size_t LIGHT  = 35 * 1024;  // <35 KB = leve
  const uint32_t SLOW = 150;        // >150 ms para capturar = lento

  bool heavy = (jpeg_len >= HEAVY) || (capture_ms >= SLOW);
  bool light = (jpeg_len <= LIGHT) && (capture_ms < SLOW);

  if (heavy) { g_abr.badStreak++; g_abr.goodStreak = 0; }
  else if (light) { g_abr.goodStreak++; g_abr.badStreak = 0; }
  else { g_abr.badStreak = 0; g_abr.goodStreak = 0; }

  // DOWNGRADE agressivo quando pesado repetido
  if (g_abr.badStreak >= 2) {
    if (g_abr.q < 18) { g_abr.q += 2; }
    else if (g_abr.fs < FRAMESIZE_VGA) {
      // já em baixa qualidade: reduz resolução (QVGA -> CIF -> VGA se já estava maior)
      g_abr.fs = (g_abr.fs == FRAMESIZE_QVGA) ? FRAMESIZE_QQVGA : FRAMESIZE_QVGA;
      g_abr.q  = 15; // reseta para qualidade melhor ao reduzir resolução
    }
    sensor_t* s = esp_camera_sensor_get();
    s->set_quality(s, g_abr.q);
    s->set_framesize(s, g_abr.fs);
    g_cur_quality = g_abr.q; g_cur_framesize = g_abr.fs;
    g_abr.badStreak = 0;
  }

  // UPGRADE lento quando está tudo leve e estável
  if (g_abr.goodStreak >= 18) { // ~3s em 6 fps
    if (g_abr.q > 12) g_abr.q -= 1;
    else if (g_abr.fs < FRAMESIZE_VGA) g_abr.fs = FRAMESIZE_QVGA;
    sensor_t* s = esp_camera_sensor_get();
    s->set_quality(s, g_abr.q);
    s->set_framesize(s, g_abr.fs);
    g_cur_quality = g_abr.q; g_cur_framesize = g_abr.fs;
    g_abr.goodStreak = 0;
  }
}



3) /snapshot — envolver medição de tempo e chamar o ABR


Troque seu handleSnapshot() por este:


void handleSnapshot() {
  addCORS();

  uint32_t t0 = millis();
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) { server.send(503, "text/plain", "Camera capture failed"); return; }
  uint32_t cap_ms = millis() - t0;

  abr_on_frame(fb->len, cap_ms);

  server.sendHeader("Content-Type", "image/jpeg");
  server.sendHeader("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  server.send_P(200, "image/jpeg", (const char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
}



4) /stream — idem, com envio chunk-a-chunk (reduz pico de RAM/TCP)


Troque seu handleStream() por este:


void handleStream() {
  WiFiClient client = server.client();
  client.println("HTTP/1.1 200 OK");
  client.println(String("Content-Type: ") + STREAM_CONTENT_TYPE);
  client.println("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");
  client.println("Access-Control-Allow-Origin: *");
  client.println();

  while (client.connected()) {
    uint32_t t0 = millis();
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) break;

    uint32_t cap_ms = millis() - t0;
    abr_on_frame(fb->len, cap_ms);

    client.print("--"); client.println(STREAM_BOUNDARY);
    client.println("Content-Type: image/jpeg");
    client.print("Content-Length: "); client.println(fb->len);
    client.println();

    // envia em pedaços menores para evitar estourar o buffer TCP
    size_t toWrite = fb->len;
    const uint8_t* p = fb->buf;
    while (toWrite > 0) {
      size_t n = toWrite > 1460 ? 1460 : toWrite; // MTU-ish
      size_t w = client.write(p, n);
      if (w == 0) { break; }
      p += w; toWrite -= w;
      delay(1); // cede CPU p/ WiFi
    }
    client.println();
    esp_camera_fb_return(fb);

    // pequeno respiro controlado — evitar fila crescer
    delay(8);
  }
}




Pequenos ajustes no servidor (Python) – OPCIONAL mas recomendável


No seu server_heuristic.py, apenas deixe o alvo de FPS um pouco mais baixo e o timeout um pouco maior (isso dá folga quando o ABR reduz qualidade/resolução e a rede oscila):


POLL_FPS_TARGET = 6.0       # antes 8.0
READ_TIMEOUT = 20.0         # antes 15.0



Mais nada muda no servidor ou no app. Seu app já alterna entre /snapshot do servidor e fallback direto no ESP; com o ABR ativo, as imagens deixam de travar quando a cena é “rica”.



Firmware COMPLETO (ESP32-CAM) — com ABR incorporado




Se preferir copiar/colar inteiro, aqui está seu arquivo já com as mudanças integradas (nome, rotas, CORS, UART — tudo igual ao seu, só com ABR + stream robusto + init ajustado):




/*  HydroBot - ESP32-CAM em modo STA (roteador externo)  [COM ABR ANTITRAVA]
    Endpoints: /  /status  /snapshot  /stream  /uart  /led  /restart
    mDNS: http://hydrobot.local
*/
#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include "esp_timer.h"
#include "img_converters.h"
#include "esp_camera.h"
#include "fb_gfx.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ====== CONFIG ======
const char* WIFI_SSID   = "HydroBot";
const char* WIFI_PASS   = "loud2025emibr";

//#define USE_STATIC_IP
IPAddress local_IP(192,168,0,50);
IPAddress gateway(192,168,0,1);
IPAddress subnet(255,255,255,0);
IPAddress dns1(8,8,8,8);
IPAddress dns2(1,1,1,1);

const char* MDNS_NAME = "hydrobot";

#define UART_RX_PIN 15
#define UART_TX_PIN 14
#define UART_BAUD   115200
#define STATUS_POLL_MS  1000

#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

WebServer server(80);
String lastStatusLine = "";
static const int FLASH_PIN = 4;

static const char* STREAM_BOUNDARY = "frame";
static const char* STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";

static const bool STREAM_HFLIP = false;
static const bool STREAM_VFLIP = false;

unsigned long lastWiFiCheck = 0;
unsigned long lastStatusPoll = 0;

// ---------- Util ----------
void addCORS(){ server.sendHeader("Access-Control-Allow-Origin","*"); server.sendHeader("Access-Control-Allow-Methods","GET,POST,OPTIONS"); server.sendHeader("Access-Control-Allow-Headers","Content-Type"); }
void handleOptions(){ addCORS(); server.send(204); }

// ---------- UART ----------
void initUART(){ Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN); }
void pollArduinoStatus(){
  static String rxBuf;
  Serial2.print("REQ:STATUS\n");
  while (Serial2.available()){
    char c=(char)Serial2.read();
    if(c=='\n'||c=='\r'){ if(rxBuf.length()>0){ if(rxBuf.startsWith("STAT:")) lastStatusLine=rxBuf; rxBuf=""; } }
    else rxBuf+=c;
  }
}

// ---- ABR (Adaptive Bitrate) ----
static volatile uint8_t g_cur_quality = 14;
static volatile framesize_t g_cur_framesize = FRAMESIZE_QVGA;

struct AbrState { uint8_t q=14; framesize_t fs=FRAMESIZE_QVGA; uint32_t badStreak=0; uint32_t goodStreak=0; } g_abr;

static inline void abr_on_frame(size_t jpeg_len, uint32_t capture_ms){
  const size_t HEAVY=60*1024; const size_t LIGHT=35*1024; const uint32_t SLOW=150;
  bool heavy=(jpeg_len>=HEAVY)||(capture_ms>=SLOW);
  bool light=(jpeg_len<=LIGHT)&&(capture_ms<SLOW);

  if(heavy){ g_abr.badStreak++; g_abr.goodStreak=0; }
  else if(light){ g_abr.goodStreak++; g_abr.badStreak=0; }
  else { g_abr.badStreak=0; g_abr.goodStreak=0; }

  if(g_abr.badStreak>=2){
    if(g_abr.q<18){ g_abr.q+=2; }
    else if(g_abr.fs<FRAMESIZE_VGA){
      g_abr.fs = (g_abr.fs==FRAMESIZE_QVGA)? FRAMESIZE_QQVGA : FRAMESIZE_QVGA;
      g_abr.q  = 15;
    }
    sensor_t* s=esp_camera_sensor_get();
    s->set_quality(s,g_abr.q);
    s->set_framesize(s,g_abr.fs);
    g_cur_quality=g_abr.q; g_cur_framesize=g_abr.fs;
    g_abr.badStreak=0;
  }
  if(g_abr.goodStreak>=18){
    if(g_abr.q>12) g_abr.q-=1;
    else if(g_abr.fs<FRAMESIZE_VGA) g_abr.fs=FRAMESIZE_QVGA;
    sensor_t* s=esp_camera_sensor_get();
    s->set_quality(s,g_abr.q);
    s->set_framesize(s,g_abr.fs);
    g_cur_quality=g_abr.q; g_cur_framesize=g_abr.fs;
    g_abr.goodStreak=0;
  }
}

// ---------- Câmera ----------
bool initCamera(){
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG,0);

  camera_config_t config;
  config.ledc_channel=LEDC_CHANNEL_0; config.ledc_timer=LEDC_TIMER_0;
  config.pin_d0=Y2_GPIO_NUM; config.pin_d1=Y3_GPIO_NUM; config.pin_d2=Y4_GPIO_NUM; config.pin_d3=Y5_GPIO_NUM;
  config.pin_d4=Y6_GPIO_NUM; config.pin_d5=Y7_GPIO_NUM; config.pin_d6=Y8_GPIO_NUM; config.pin_d7=Y9_GPIO_NUM;
  config.pin_xclk=XCLK_GPIO_NUM; config.pin_pclk=PCLK_GPIO_NUM; config.pin_vsync=VSYNC_GPIO_NUM; config.pin_href=HREF_GPIO_NUM;
  config.pin_sscb_sda=SIOD_GPIO_NUM; config.pin_sscb_scl=SIOC_GPIO_NUM;
  config.pin_pwdn=PWDN_GPIO_NUM; config.pin_reset=RESET_GPIO_NUM;

  config.xclk_freq_hz=20000000;
  config.pixel_format=PIXFORMAT_JPEG;

  config.frame_size  = FRAMESIZE_QVGA;
  config.jpeg_quality= 14;
  config.fb_count    = 2;
  config.grab_mode   = CAMERA_GRAB_LATEST;
  config.fb_location = CAMERA_FB_IN_PSRAM;

  if(esp_camera_init(&config)!=ESP_OK) return false;

  sensor_t* s=esp_camera_sensor_get();
  s->set_vflip(s,STREAM_VFLIP); s->set_hmirror(s,STREAM_HFLIP);
  s->set_aec2(s,true); s->set_gainceiling(s,GAINCEILING_2X);
  s->set_brightness(s,0); s->set_saturation(s,0);
  return true;
}

// ---------- Handlers ----------
void handleRoot(){
  addCORS();
  String html="<!doctype html><html><head><meta charset='utf-8'/>"
              "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
              "<title>HydroBot ESP32-CAM</title>"
              "<style>body{font-family:system-ui;background:#0b0b0f;color:#e5e7eb;padding:16px}"
              "a,button{background:#e6403a;color:#fff;padding:8px 12px;border:none;border-radius:8px;text-decoration:none;margin-right:8px}"
              "code{background:#121218;padding:2px 6px;border-radius:6px}</style></head><body>";
  html += "<h2>HydroBot ESP32-CAM (STA)</h2>";
  html += "<p>IP: <code>"+WiFi.localIP().toString()+"</code> | RSSI: <code>"+String(WiFi.RSSI())+" dBm</code></p>";
  html += "<p><a href='/snapshot'>/snapshot</a> <a href='/stream'>/stream</a> <a href='/status'>/status</a></p>";
  html += "<p>mDNS: <code>http://"+String(MDNS_NAME)+".local</code></p>";
  html += "<p>Último STATUS Arduino: <code>"+(lastStatusLine.length()?lastStatusLine:"(ainda não)")+"</code></p>";
  html += "<p>ABR: quality="+String(g_cur_quality)+" framesize="+String((int)g_cur_framesize)+"</p>";
  html += "</body></html>";
  server.send(200,"text/html",html);
}

void handleStatus(){
  addCORS();
  String json="{";
  json += "\"ip\":\""+WiFi.localIP().toString()+"\",";
  json += "\"rssi\":" + String(WiFi.RSSI()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"uptime_ms\":" + String(millis()) + ",";
  json += "\"quality\":" + String(g_cur_quality) + ",";
  json += "\"framesize\":" + String((int)g_cur_framesize) + ",";
  json += "\"arduino_status\":\"" + lastStatusLine + "\"";
  json += "}";
  server.send(200,"application/json",json);
}

void handleSnapshot(){
  addCORS();
  uint32_t t0=millis();
  camera_fb_t * fb = esp_camera_fb_get();
  if(!fb){ server.send(503,"text/plain","Camera capture failed"); return; }
  uint32_t cap_ms=millis()-t0;

  abr_on_frame(fb->len, cap_ms);

  server.sendHeader("Content-Type","image/jpeg");
  server.sendHeader("Cache-Control","no-store, no-cache, must-revalidate, max-age=0");
  server.send_P(200,"image/jpeg",(const char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

void handleStream(){
  WiFiClient client=server.client();
  client.println("HTTP/1.1 200 OK");
  client.println(String("Content-Type: ")+STREAM_CONTENT_TYPE);
  client.println("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");
  client.println("Access-Control-Allow-Origin: *");
  client.println();

  while(client.connected()){
    uint32_t t0=millis();
    camera_fb_t * fb = esp_camera_fb_get();
    if(!fb) break;
    uint32_t cap_ms=millis()-t0;
    abr_on_frame(fb->len, cap_ms);

    client.print("--"); client.println(STREAM_BOUNDARY);
    client.println("Content-Type: image/jpeg");
    client.print("Content-Length: "); client.println(fb->len);
    client.println();

    size_t toWrite=fb->len; const uint8_t* p=fb->buf;
    while(toWrite>0){
      size_t n = toWrite>1460 ? 1460 : toWrite;
      size_t w = client.write(p,n);
      if(w==0){ break; }
      p+=w; toWrite-=w; delay(1);
    }
    client.println();
    esp_camera_fb_return(fb);
    delay(8);
  }
}

void handleUART(){
  addCORS();
  if(server.method()==HTTP_OPTIONS){ handleOptions(); return; }
  String cmd=server.arg("cmd");
  if(!cmd.length()){ server.send(400,"application/json","{\"error\":\"use /uart?cmd=...\"}"); return; }
  if(!cmd.endsWith("\n")) cmd+="\n";
  Serial2.print(cmd);
  server.send(200,"application/json","{\"ok\":true}");
}

void handleLED(){
  addCORS();
  if(server.method()==HTTP_OPTIONS){ handleOptions(); return; }
  int on=server.arg("on").toInt();
  digitalWrite(FLASH_PIN, on?HIGH:LOW);
  server.send(200,"application/json", String("{\"on\":")+(on?"true":"false")+"}");
}

void handleRestart(){
  addCORS(); server.send(200,"application/json","{\"restarting\":true}"); delay(300); ESP.restart();
}

// ---------- Wi-Fi ----------
void connectWiFi(){
#ifdef USE_STATIC_IP
  WiFi.config(local_IP,gateway,subnet,dns1,dns2);
#endif
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  unsigned long t0=millis();
  while(WiFi.status()!=WL_CONNECTED && millis()-t0<15000) { delay(250); }
}

void setupServer(){
  server.on("/", HTTP_GET, handleRoot);
  server.on("/status", HTTP_GET, handleStatus);
  server.on("/snapshot", HTTP_GET, handleSnapshot);
  server.on("/stream", HTTP_GET, handleStream);
  server.on("/uart", HTTP_POST, handleUART);
  server.on("/led", HTTP_POST, handleLED);
  server.on("/restart", HTTP_POST, handleRestart);
  server.onNotFound([](){ addCORS(); server.send(404,"application/json","{\"error\":\"not found\"}"); });
  server.on("/uart", HTTP_OPTIONS, handleOptions);
  server.on("/led", HTTP_OPTIONS, handleOptions);
  server.on("/restart", HTTP_OPTIONS, handleOptions);
  server.begin();
}

void setup(){
  Serial.begin(115200); delay(200);
  pinMode(FLASH_PIN, OUTPUT); digitalWrite(FLASH_PIN, LOW);
  initUART();

  if(!initCamera()){ delay(1000); initCamera(); }

  connectWiFi();
  if(WiFi.status()==WL_CONNECTED){ if(MDNS.begin(MDNS_NAME)){ MDNS.addService("http","tcp",80); } }
  setupServer();
}

void loop(){
  server.handleClient();
  if(millis()-lastWiFiCheck>3000){ lastWiFiCheck=millis(); if(WiFi.status()!=WL_CONNECTED) connectWiFi(); }
  if(millis()-lastStatusPoll>STATUS_POLL_MS){ lastStatusPoll=millis(); pollArduinoStatus(); }
}




Por que isso resolve o seu caso




CAMERA_GRAB_LATEST impede que a fila cresça quando a leitura do cliente atrasa — em cenas “ricas”, o encode demora mais; em vez de acumular, você sempre pega o frame mais recente.


ABR reduz qualidade e até resolução quando o JPEG passa de ~60 KB ou a captura passa de 150 ms. Quando estabiliza (frames leves <35 KB), volta a subir devagar.


Envio em chunks (1460 B) no /stream evita estourar o buffer TCP de uma vez só.


PSRAM + fb_count=2 ajuda o DMA a sempre ter onde escrever.


Servidor com alvo de 6 fps e timeout maior encaixa com o ABR em redes mais ruidosas.




Teste rápido:




Flashe o firmware acima.


Abra http://hydrobot.local/ e confira ABR: quality=.. framesize=.. mudando conforme aponta a câmera.


No app, deixe o Server como o seu FastAPI e o ESP como hydrobot.local.


Aponte para cena distante/detalhada: o vídeo deve reduzir um pouco a nitidez, mas não travar.




Se ainda notar travas específicas do seu roteador, posso incluir:




limite de Content-Length (cortar frames gigantes),


“panic” reinit da câmera após N erros,


opção para fixar FRAMESIZE_QQVGA em ambientes extremamente barulhentos.




Quer que eu já deixe uma rota /config no ESP para fixar quality/framesize pelo app (sem reflashear)?







































/*
  HydroBot - ESP32-CAM em modo STA (roteador externo)
  - Endpoints:
      GET  /              -> página info rápida
      GET  /status        -> JSON (uptime, RSSI, heap, ip, último STATUS do Arduino)
      GET  /snapshot      -> JPEG único
      GET  /stream        -> MJPEG stream
      POST /uart?cmd=...  -> envia comando na UART para o Arduino (ex: CMD:FWD:ms=400:spd=70)
      POST /led?on=0|1    -> liga/desliga flash (GPIO 4)
      POST /restart       -> reinicia ESP
  - mDNS: http://hydrobot.local
  - CORS: Access-Control-Allow-Origin: *
  - UART: Serial2 (pinos configuráveis abaixo). ESP requisita "REQ:STATUS\n" periodicamente e armazena última linha "STAT:...".
*/

#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include "esp_timer.h"
#include "img_converters.h"
#include "esp_camera.h"
#include "fb_gfx.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ====== CONFIG ======
const char* WIFI_SSID   = "HydroBot";
const char* WIFI_PASS   = "loud2025emibr";

// (Opcional) IP fixo – deixe comentado se preferir DHCP
//#define USE_STATIC_IP
IPAddress local_IP(192,168,0,50);
IPAddress gateway(192,168,0,1);
IPAddress subnet(255,255,255,0);
IPAddress dns1(8,8,8,8);
IPAddress dns2(1,1,1,1);

// mDNS
const char* MDNS_NAME = "hydrobot"; // http://hydrobot.local

// UART com Arduino (ajuste conforme seu fio)
// Recomenda-se ESP32-CAM: RX=15, TX=14 (costuma estar disponível nesse módulo)
#define UART_RX_PIN 15
#define UART_TX_PIN 14
#define UART_BAUD   115200

// Requisição periódica ao Arduino
#define STATUS_POLL_MS  1000

// Camera: selecione pinos do modelo AI Thinker
#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

// ====== FIM CONFIG ======

// Servidor HTTP
WebServer server(80);

// Buffer do último STATUS do Arduino
String lastStatusLine = "";

// Controle de LED do flash (AI Thinker usa GPIO 4 pra lâmpada)
static const int FLASH_PIN = 4;

// Controle de stream
static const char* STREAM_BOUNDARY = "frame";
static const char* STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" "frame";
static const int STREAM_QUALITY = 12;   // 10..20 (mais baixo = melhor qualidade, porém mais pesado)
static const bool STREAM_HFLIP = false; // espelhar horizontal
static const bool STREAM_VFLIP = false; // espelhar vertical

// Watchdog / reconexão
unsigned long lastWiFiCheck = 0;
unsigned long lastStatusPoll = 0;

// ---------- Util ----------
void addCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}
void handleOptions() {
  addCORS();
  server.send(204);
}

// ---------- UART ----------
void initUART() {
  Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN);
}
void pollArduinoStatus() {
  static String rxBuf;
  // Solicita status
  Serial2.print("REQ:STATUS\n");
  // Lê o que chegou desde a última chamada
  while (Serial2.available()) {
    char c = (char)Serial2.read();
    if (c == '\n' || c == '\r') {
      if (rxBuf.length() > 0) {
        // Guarda última linha completa
        if (rxBuf.startsWith("STAT:")) {
          lastStatusLine = rxBuf;
        }
        rxBuf = "";
      }
    } else {
      rxBuf += c;
    }
  }
}

// ---------- Câmera ----------
bool initCamera() {
  // Evitar brownout reset
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;

  // Resoluções: FRAMESIZE_QQVGA .. UXGA
  config.frame_size   = FRAMESIZE_VGA;
  config.jpeg_quality = 12;     // 10..20 (10 melhor)
  config.fb_count     = 2;

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    return false;
  }

  // Efeitos básicos
  sensor_t * s = esp_camera_sensor_get();
  s->set_vflip(s, STREAM_VFLIP);
  s->set_hmirror(s, STREAM_HFLIP);

  return true;
}

// ---------- Handlers HTTP ----------
void handleRoot() {
  addCORS();
  String html = "<!doctype html><html><head><meta charset='utf-8'/>"
                "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
                "<title>HydroBot ESP32-CAM</title>"
                "<style>body{font-family:system-ui;background:#0b0b0f;color:#e5e7eb;padding:16px}"
                "a,button{background:#e6403a;color:#fff;padding:8px 12px;border:none;border-radius:8px;text-decoration:none;margin-right:8px}"
                "code{background:#121218;padding:2px 6px;border-radius:6px}</style></head><body>";
  html += "<h2>HydroBot ESP32-CAM (STA)</h2>";
  html += "<p>IP: <code>" + WiFi.localIP().toString() + "</code> | RSSI: <code>" + String(WiFi.RSSI()) + " dBm</code></p>";
  html += "<p><a href='/snapshot'>/snapshot</a> <a href='/stream'>/stream</a> <a href='/status'>/status</a></p>";
  html += "<p>mDNS: <code>http://" + String(MDNS_NAME) + ".local</code></p>";
  html += "<p>Último STATUS Arduino: <code>" + (lastStatusLine.length() ? lastStatusLine : "(ainda não)") + "</code></p>";
  html += "</body></html>";
  server.send(200, "text/html", html);
}

void handleStatus() {
  addCORS();
  // Monta JSON simples
  String json = "{";
  json += "\"ip\":\"" + WiFi.localIP().toString() + "\",";
  json += "\"rssi\":" + String(WiFi.RSSI()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"uptime_ms\":" + String(millis()) + ",";
  // Se quiser, parse do lastStatusLine -> chave:valor
  json += "\"arduino_status\":\"" + lastStatusLine + "\"";
  json += "}";
  server.send(200, "application/json", json);
}

void handleSnapshot() {
  addCORS();
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) {
    server.send(503, "text/plain", "Camera capture failed");
    return;
  }
  server.sendHeader("Content-Type", "image/jpeg");
  server.sendHeader("Content-Disposition", "inline; filename=capture.jpg");
  server.send_P(200, "image/jpeg", (const char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

void handleStream() {
  WiFiClient client = server.client();
  // Cabeçalhos do stream
  client.println("HTTP/1.1 200 OK");
  client.println("Content-Type: " + String(STREAM_CONTENT_TYPE));
  client.println("Access-Control-Allow-Origin: *");
  client.println();

  while (client.connected()) {
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) break;

    client.println("--" + String(STREAM_BOUNDARY));
    client.println("Content-Type: image/jpeg");
    client.println("Content-Length: " + String(fb->len));
    client.println();
    client.write(fb->buf, fb->len);
    client.println();
    esp_camera_fb_return(fb);

    // Pequena folga
    delay(10);
  }
}

void handleUART() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  String cmd = server.arg("cmd");
  if (!cmd.length()) {
    server.send(400, "application/json", "{\"error\":\"use /uart?cmd=...\"}");
    return;
  }
  // Garante terminador de linha
  if (!cmd.endsWith("\n")) cmd += "\n";
  Serial2.print(cmd);
  server.send(200, "application/json", "{\"ok\":true}");
}

void handleLED() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  int on = server.arg("on").toInt();
  digitalWrite(FLASH_PIN, on ? HIGH : LOW);
  server.send(200, "application/json", String("{\"on\":") + (on? "true":"false") + "}");
}

void handleRestart() {
  addCORS();
  server.send(200, "application/json", "{\"restarting\":true}");
  delay(300);
  ESP.restart();
}

// ---------- Wi-Fi ----------
void connectWiFi() {
#ifdef USE_STATIC_IP
  WiFi.config(local_IP, gateway, subnet, dns1, dns2);
#endif
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);

  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 15000) {
    delay(250);
  }
}

void setupServer() {
  // Rotas
  server.on("/", HTTP_GET, handleRoot);
  server.on("/status", HTTP_GET, handleStatus);
  server.on("/snapshot", HTTP_GET, handleSnapshot);
  server.on("/stream", HTTP_GET, handleStream);
  server.on("/uart", HTTP_POST, handleUART);
  server.on("/led", HTTP_POST, handleLED);
  server.on("/restart", HTTP_POST, handleRestart);

  // CORS preflight
  server.onNotFound([](){
    addCORS();
    server.send(404, "application/json", "{\"error\":\"not found\"}");
  });
  server.on("/uart", HTTP_OPTIONS, handleOptions);
  server.on("/led", HTTP_OPTIONS, handleOptions);
  server.on("/restart", HTTP_OPTIONS, handleOptions);

  server.begin();
}

// ---------- setup / loop ----------
void setup() {
  // Logs seriais (opcional). Evite compartilhar TX0/RX0 com Arduino se usar USB.
  Serial.begin(115200);
  delay(200);

  pinMode(FLASH_PIN, OUTPUT);
  digitalWrite(FLASH_PIN, LOW);

  // UART secundária com Arduino
  initUART();

  // Câmera
  if (!initCamera()) {
    // Tente outra vez
    delay(1000);
    initCamera();
  }

  // Wi-Fi
  connectWiFi();

  // mDNS
  if (WiFi.status() == WL_CONNECTED) {
    if (MDNS.begin(MDNS_NAME)) {
      MDNS.addService("http", "tcp", 80);
    }
  }

  // HTTP
  setupServer();
}

void loop() {
  server.handleClient();

  // Watch Wi-Fi & reconectar
  if (millis() - lastWiFiCheck > 3000) {
    lastWiFiCheck = millis();
    if (WiFi.status() != WL_CONNECTED) {
      connectWiFi();
    }
  }

  // Poll do STATUS no Arduino
  if (millis() - lastStatusPoll > STATUS_POLL_MS) {
    lastStatusPoll = millis();
    pollArduinoStatus();
  }
}


















// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet,
  PanResponder, GestureResponderEvent, PanResponderGestureState,
  Image, Animated, LayoutChangeEvent,
} from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: { heroSubtitle:"Monitoramento e Controle", espIp:"ESP:", pumpOn:"BOMBA ON", pumpOff:"BOMBA OFF",
        server:"Servidor:", detecting:"Detectando…", waiting:"Aguardando servidor…", statusFail:"Falha ao conectar. Confira o Wi-Fi/IP.",
        noVideo:"Sem vídeo (snapshot). Verifique o servidor.", fireOn:(s:number)=>`🔥 FOGO • score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sem fogo • score ${s.toFixed(2)}`, synced:"Server sincronizado",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  en: { heroSubtitle:"Monitoring & Control", espIp:"ESP:", pumpOn:"PUMP ON", pumpOff:"PUMP OFF",
        server:"Server:", detecting:"Detecting…", waiting:"Waiting for server…", statusFail:"Failed to connect. Check Wi-Fi/IP.",
        noVideo:"No video (snapshot). Check server.", fireOn:(s:number)=>`🔥 FIRE • score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`No fire • score ${s.toFixed(2)}`, synced:"Server sync OK",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  es: { heroSubtitle:"Monitoreo y Control", espIp:"ESP:", pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.",
        server:"Servidor:", detecting:"Detectando…", waiting:"Esperando servidor…", statusFail:"Error de conexión. Revisa Wi-Fi/IP.",
        noVideo:"Sin vídeo (snapshot). Revisa el servidor.", fireOn:(s:number)=>`🔥 FUEGO • score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sin fuego • score ${s.toFixed(2)}`, synced:"Sincronizado con servidor",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
};

const DEFAULT_IP = "hydrobot.local";
const DEFAULT_SERVER = "http://192.168.0.100:8000";
const DEFAULT_FRAME_WH = { w: 320, h: 240 };

const appLogo = require("../../assets/logo.png");

/* ---------------------- UI AUX ---------------------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown,
}: { currentUri: string; nextUri: string; onNextLoadStart: () => void; onNextShown: (ok: boolean) => void; }) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={() => { onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

type SrcBox = { x:number; y:number; w:number; h:number; type:"fire" };
function BoxesOverlay({ frameWH, containerWH, boxes }:{
  frameWH:{w:number;h:number}|null; containerWH:{w:number;h:number}|null; boxes:SrcBox[];
}) {
  const f = frameWH && frameWH.w>0 && frameWH.h>0 ? frameWH : DEFAULT_FRAME_WH;
  if (!containerWH || containerWH.w<=0 || containerWH.h<=0) return null;
  const scale = Math.min(containerWH.w / f.w, containerWH.h / f.h);
  const dispW = f.w * scale, dispH = f.h * scale;
  const offsetX = (containerWH.w - dispW)/2, offsetY = (containerWH.h - dispH)/2;
  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position:"absolute", left:offsetX, top:offsetY, width:dispW, height:dispH }}>
        {boxes.map((b,i)=>{
          const left=b.x*scale, top=b.y*scale, width=b.w*scale, height=b.h*scale;
          return (
            <View key={i} style={{ position:"absolute", left, top, width, height, borderWidth:3, borderColor:"#ff3b30", borderRadius:6 }}>
              <View style={{ position:"absolute", left:0, top:-18, paddingHorizontal:6, paddingVertical:2, borderRadius:4, backgroundColor:"#ff3b30" }}>
                <Text style={{ color:"#000", fontWeight:"800", fontSize:10 }}>FOGO</Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------------------- SCREEN ---------------------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [statusText, setStatusText] = useState(T.waiting);
  const [pumpOn, setPumpOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{w:number;h:number}|null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{w:number;h:number}|null>(null);

  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  const [useDirectSnapshot, setUseDirectSnapshot] = useState(false);
  const failCountRef = useRef(0);

  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const clean = (s:string)=>s.replace(/\/+$/,"");

  // Server endpoints
  const healthUrl     = useMemo(()=>`${clean(server)}/healthz`,[server]);
  const detectUrl     = useMemo(()=>`${clean(server)}/detect`,[server]);
  const snapshotSrv   = useMemo(()=>`${clean(server)}/snapshot`,[server]);
  const snapshotSrvAlt= useMemo(()=>`${clean(server)}/frame.jpg`,[server]);
  const configUrl     = useMemo(()=>`${clean(server)}/config`,[server]);

  // ESP endpoints (agora TUDO via UART + LED; snapshot direto só como fallback)
  const snapshotEsp   = useMemo(()=> `http://${ip}/snapshot`, [ip]);
  const uartPost      = useMemo(()=> (cmd:string)=>`http://${ip}/uart?cmd=${encodeURIComponent(cmd)}`, [ip]);
  const ledPost       = useMemo(()=> (on:boolean)=>`http://${ip}/led?on=${on?1:0}`, [ip]);

  // Sincroniza IP da câmera no server (para o poller)
  useEffect(()=>{
    let aborted=false;
    (async()=>{
      try{
        const r=await fetch(configUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({camera_ip:ip})});
        const j=await r.json();
        if(!aborted && j?.ok) setStatusText(`${T.synced} (${j.camera_ip})`);
      }catch{ if(!aborted) setStatusText(T.statusFail); }
    })();
    return()=>{aborted=true};
  },[ip, configUrl, T]);

  // Health do servidor
  useEffect(()=>{
    let stop=false, backoff=500;
    const poll=async()=>{
      if(stop) return;
      try{
        const r=await fetch(healthUrl); const j=await r.json();
        if(j?.ok){ setStatusText(`Server OK • fps_in:${j.fps_in} • hasFrame:${j.hasFrame}`); return; }
      }catch{}
      setStatusText(T.waiting);
      setTimeout(poll, backoff); backoff=Math.min(backoff*1.6, 5000);
    };
    poll(); return()=>{stop=true};
  },[healthUrl, T]);

  // SNAPSHOT loop com fallback server->ESP
  useEffect(()=>{
    let stop=false, interval=160;
    const pickBase = ()=>{
      if (useDirectSnapshot) return snapshotEsp;
      return failCountRef.current >= 2 ? snapshotSrvAlt : snapshotSrv;
    };

    setCurrentFrameUri(`${pickBase()}?ts=${Date.now()}`);
    const tick=()=>{
      if(stop) return;
      try{
        if(!loadingNextRef.current){
          const base = pickBase();
          setNextFrameUri(`${base}?ts=${Date.now()}`);
        }
        interval=160;
      }catch{
        interval=Math.min(interval*1.7, 1200);
      }
      setTimeout(tick, interval);
    };
    tick();
    return()=>{stop=true};
  },[snapshotSrv, snapshotSrvAlt, snapshotEsp, useDirectSnapshot]);

  const onNextLoadStart = ()=>{ loadingNextRef.current=true; };
  const onNextShown = (ok:boolean)=>{
    if(ok){
      failCountRef.current = 0;
      if(useDirectSnapshot){ setUseDirectSnapshot(false); }   // volta p/ server quando estabiliza
      if(nextFrameUri) setCurrentFrameUri(nextFrameUri);
    }else{
      failCountRef.current += 1;
      if(!useDirectSnapshot && failCountRef.current >= 3){
        setUseDirectSnapshot(true);
        failCountRef.current = 0;
      }
    }
    loadingNextRef.current=false;
  };

  // DETECT loop (inalterado)
  useEffect(()=>{
    let stop=false, interval=250;
    const loop=async()=>{
      if(stop) return;
      try{
        const r=await fetch(detectUrl); const j=await r.json();
        if(j && j.ok!==false){
          setIsFire(!!j.isFire); setFireScore(Number(j.score||0));
          const wh = Array.isArray(j.frame_wh)&&j.frame_wh.length===2
                     ? {w:Number(j.frame_wh[0])||0, h:Number(j.frame_wh[1])||0}:null;
          if(wh && wh.w>0 && wh.h>0) setFrameWH(wh);
          const boxes:SrcBox[]=[];
          if(j.isFire && Array.isArray(j.boxes)){
            for(const b of j.boxes){
              if(Array.isArray(b)&&b.length>=4){
                const [x,y,w,h]=b.map((n:any)=>Number(n)||0);
                boxes.push({x,y,w,h,type:"fire"});
              }
            }
          }
          setOverlayBoxes(boxes); interval=250;
        }
      }catch{
        setIsFire(false); setFireScore(0); setOverlayBoxes([]);
        interval=Math.min(interval*1.5,1500);
      }finally{ setTimeout(loop, interval); }
    };
    loop(); return()=>{stop=true};
  },[detectUrl]);

  // ------- COMANDOS (UART + LED) -------
  // Manda um comando via UART (POST /uart?cmd=...)
  async function sendUART(cmd: string) {
    try {
      const res = await fetch(uartPost(cmd), { method: "POST" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return true;
    } catch {
      setStatusText(T.statusFail);
      return false;
    }
  }

  async function togglePump(){
    const target = !pumpOn;
    const ok = await sendUART(`CMD:PUMP:${target ? "1" : "0"}`);
    if (ok) setPumpOn(target);
  }

  async function led(on:boolean){
    try{
      const res = await fetch(ledPost(on), { method: "POST" });
      const txt = await res.text();
      setStatusText(`${on?T.ledOn:T.ledOff} • ${res.status} ${txt||""}`);
    }catch{
      setStatusText(T.statusFail);
    }
  }

  // Joystick: envia PULSOS discretos por UART (CMD:FWD/BACK/LEFT/RIGHT/STOP)
  const RADIUS=64;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder:()=>true,
      onMoveShouldSetPanResponder:()=>true,
      onPanResponderGrant:()=>{ setDragging(true); },
      onPanResponderMove:(_e:GestureResponderEvent,g:PanResponderGestureState)=>{
        let nx=g.dx/RADIUS, ny=g.dy/RADIUS;
        const len=Math.hypot(nx,ny); if(len>1){ nx/=len; ny/=len; }
        setJoy({x:nx, y:-ny});
      },
      onPanResponderRelease:()=>{ setJoy({x:0,y:0}); setDragging(false); },
      onPanResponderTerminate:()=>{ setJoy({x:0,y:0}); setDragging(false); },
    })
  ).current;

  const lastSendRef = useRef(0);
  const lastDirRef  = useRef<string>("STOP");

  const vecToDir=(x:number,y:number):"FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP"=>{
    const mag=Math.hypot(x,y); if(mag<0.2) return "STOP";
    const deg=(Math.atan2(y,x)*180)/Math.PI;
    if(deg>-45&&deg<=45) return "RIGHT";
    if(deg>45&&deg<=135) return "FWD";
    if(deg<=-45&&deg>-135) return "BACK";
    return "LEFT";
  };

  useEffect(()=>{
    let cancelled=false;
    const tick=async()=>{
      if(cancelled) return;
      const now=Date.now();
      if(now-lastSendRef.current<120){ setTimeout(tick,20); return; }
      lastSendRef.current=now;

      const {x,y}=joy;
      const mag=Math.hypot(x,y);
      const dir=vecToDir(x,y);

      // Evita flood: só manda quando muda ou mantém em passos curtos
      if(dir!==lastDirRef.current){
        if(dir==="STOP"){
          await sendUART("CMD:STOP");
        }else{
          const ms=140+Math.round(260*Math.min(1,mag));
          const spd=50+Math.round(50*Math.min(1,mag));
          await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
        }
        lastDirRef.current=dir;
      }else if(dir!=="STOP"){
        // Reforça o movimento com pequenos pulsos
        const ms=120+Math.round(200*Math.min(1,mag));
        const spd=50+Math.round(50*Math.min(1,mag));
        await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
      }

      setTimeout(tick,120);
    };
    tick(); return()=>{cancelled=true};
  },[joy, ip]);

  function onVideoLayout(e:LayoutChangeEvent){
    const {width,height}=e.nativeEvent.layout; setVideoContainerWH({w:width,h:height});
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder={T.placeholderIp} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={styles.input} />
        <Text style={styles.label}>{T.server}</Text>
        <TextInput value={server} onChangeText={setServer} placeholder={T.placeholderServer} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={[styles.input,{minWidth:220}]} />

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn?styles.btnOn:styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn?T.pumpOn:T.pumpOff}</Text>
        </Pressable>
        <Pressable onPress={()=>led(true)} style={[styles.btn, {backgroundColor:"#2563eb"}]}>
          <Text style={styles.btnText}>{T.ledOn}</Text>
        </Pressable>
        <Pressable onPress={()=>led(false)} style={[styles.btn, {backgroundColor:"#374151"}]}>
          <Text style={styles.btnText}>{T.ledOff}</Text>
        </Pressable>
      </View>

      <View style={[styles.statusRow,{paddingTop:4,paddingBottom:8}]}>
        <Text numberOfLines={2} style={styles.status}>{statusText} {useDirectSnapshot ? "• (snapshot direto)" : ""}</Text>
        <View style={[styles.badge,{backgroundColor: "#065f46"}]}>
          <Text style={{ color:"#fff", fontWeight:"800" }}>{isFire ? T.detecting : T.waiting}</Text>
        </View>
      </View>

      <View style={[styles.fireBanner, isFire?styles.fireOn:styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      <View style={{ flex:1 }} onLayout={onVideoLayout}>
        <CrossfadeImage currentUri={currentFrameUri} nextUri={nextFrameUri}
                        onNextLoadStart={()=> (loadingNextRef.current=true)}
                        onNextShown={onNextShown}/>
        {overlayBoxes.length>0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap,{width:64*2+24,height:64*2+24}]}
              {...(pan.panHandlers as any)}>
          <View style={[styles.joyBase,{width:64*2,height:64*2,borderRadius:64}]} />
          <View style={[styles.joyKnob,{width:22*2,height:22*2,borderRadius:22,
                        transform:[{translateX:joy.x*64},{translateY:-joy.y*64}], opacity: dragging?1:0.9}]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", flexWrap:"wrap",
           paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:120 },
  btn:{ backgroundColor:PALETTE.accent, paddingHorizontal:10, paddingVertical:10, borderRadius:10 },
  btnOn:{ backgroundColor:"#17a34a" }, btnOff:{ backgroundColor:"#374151" },
  btnText:{ color:"white", fontWeight:"600" },

  statusRow:{ flexDirection:"row", alignItems:"center", paddingHorizontal:12, paddingVertical:8, gap:8,
              backgroundColor:"#0f1322", borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  badge:{ paddingHorizontal:10, paddingVertical:6, borderRadius:8, borderWidth:1, borderColor:PALETTE.border },
  status:{ color:"#cbd5ff", flex:1, fontSize:12 },

  fireBanner:{ alignItems:"center", justifyContent:"center", paddingVertical:6 },
  fireOn:{ backgroundColor:"#8b0000" }, fireOff:{ backgroundColor:"#223" },
  fireText:{ color:"white", fontWeight:"800" },

  joyWrap:{ position:"absolute", bottom:24, left:24, alignItems:"center", justifyContent:"center" },
  joyBase:{ position:"absolute", backgroundColor:"rgba(255,255,255,0.08)", borderWidth:2, borderColor:"rgba(255,255,255,0.14)" },
  joyKnob:{ position:"absolute", backgroundColor:"rgba(230,64,58,0.9)", borderWidth:2, borderColor:"rgba(255,255,255,0.85)" },
  joyText:{ position:"absolute", bottom:-22, color:"#cbd5ff", fontSize:12 },
});

















# server_heuristic.py
# FastAPI proxy + heurística de fogo (leve) para ESP32-CAM snapshot (robusto)

import time
import threading
from typing import Optional, Dict, Any, List, Tuple

import cv2
import numpy as np
import requests
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ========= CONFIG =========
# Agora usando mDNS do seu firmware como padrão; pode trocar via /config
CAMERA_IP = "hydrobot.local"                     # ESP32-CAM host (mDNS ou IP fixo)
SNAPSHOT_URL_FMT = "http://{}/snapshot"
CONNECT_TIMEOUT = 4.0
READ_TIMEOUT = 15.0
POLL_FPS_TARGET = 8.0                            # ~8 fps estável
MAX_FRAME_AGE_MS = 15000                         # relaxado p/ redes lentas
MAX_RESULT_AGE_MS = 800
JPEG_QUALITY = 85

# Heurística simples de fogo
HSV_LOW = (8, 80, 120)
HSV_HIGH = (40, 255, 255)
EMA_ALPHA = 0.25
HYST_HIGH = 0.18
HYST_LOW  = 0.15
MIN_BLOB_AREA = 900
KERNEL_SZ = 5

REQUEST_HEADERS = {
    "Connection": "keep-alive",
    "User-Agent": "HydroBot-Grabber/1.0",
    "Cache-Control": "no-cache",
    "Pragma": "no-cache",
}

ACCEPT_CT_PREFIX = ("image/jpeg", "image/jpg", "image/pjpeg", "application/octet-stream")

def is_jpeg_bytes(b: bytes) -> bool:
    return len(b) > 4 and b[0] == 0xFF and b[1] == 0xD8

# ========= FASTAPI =========
app = FastAPI(title="HydroBot Server (proxy + fire-heuristic)", version="2.2")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True,
                   allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
    camera_ip: str

# ========= PLACEHOLDER =========
def placeholder_jpeg(msg: str = "NO LIVE FRAME") -> bytes:
    img = np.zeros((240, 320, 3), dtype=np.uint8)
    img[:, :] = (40, 40, 200)
    cv2.putText(img, msg, (20, 130), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255,255,255), 2, cv2.LINE_AA)
    cv2.putText(img, time.strftime("%H:%M:%S"), (20, 200), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255,255,255), 2, cv2.LINE_AA)
    ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), 80])
    return buf.tobytes()

# ========= SNAPSHOT GRABBER =========
class SnapshotGrabber:
    def __init__(self):
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._ip = CAMERA_IP
        self._last_jpeg: Optional[bytes] = None
        self._last_ts_ms: int = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._session = requests.Session()
        self._last_err: Optional[str] = None

    def start(self, ip: Optional[str] = None):
        if ip:
            self._ip = ip
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)
        self._thread = None

    def _ok_ct(self, ct: str) -> bool:
        if not ct:
            return True  # às vezes vem vazio; vamos checar magic bytes
        ct = ct.lower()
        return any(ct.startswith(p) for p in ACCEPT_CT_PREFIX)

    def _fetch_once(self) -> Optional[bytes]:
        u = f"{SNAPSHOT_URL_FMT.format(self._ip)}?ts={int(time.time()*1000)}"
        r = self._session.get(u, timeout=(CONNECT_TIMEOUT, READ_TIMEOUT),
                              headers=REQUEST_HEADERS, stream=False)
        if r.status_code == 200:
            ct = r.headers.get("Content-Type", "")
            b = r.content or b""
            if (self._ok_ct(ct) and b) or is_jpeg_bytes(b):
                return b
        return None

    def _run(self):
        min_interval = 1.0 / POLL_FPS_TARGET
        backoff = 0.0
        while not self._stop.is_set():
            t0 = time.time()
            try:
                jpeg = self._fetch_once()
                if jpeg:
                    with self._lock:
                        self._last_jpeg = jpeg
                        self._last_ts_ms = int(time.time()*1000)
                        self._last_err = None
                    self._frames += 1
                    now = time.time()
                    if now - self._last_fps_tick >= 1.0:
                        self._fps = self._frames / (now - self._last_fps_tick)
                        self._frames = 0
                        self._last_fps_tick = now
                    backoff = 0.0
                else:
                    backoff = min(2.0, max(0.2, (backoff * 1.7) or 0.2))
            except Exception as e:
                with self._lock:
                    self._last_err = f"{type(e).__name__}: {e}"
                backoff = min(3.0, max(0.2, (backoff * 1.7) or 0.2))

            elapsed = time.time() - t0
            sleep = max(0.0, min_interval - elapsed) + backoff
            if self._stop.is_set():
                break
            time.sleep(sleep)

    def get_latest_jpeg(self, max_age_ms=MAX_FRAME_AGE_MS) -> Optional[bytes]:
        with self._lock:
            if self._last_jpeg is None:
                return None
            if int(time.time()*1000) - self._last_ts_ms > max_age_ms:
                return None
            return self._last_jpeg

    def status(self) -> Dict[str, Any]:
        with self._lock:
            age = int(time.time()*1000) - self._last_ts_ms if self._last_ts_ms else None
            return {"ip": self._ip, "hasFrame": self._last_jpeg is not None, "age_ms": age,
                    "fps_in": round(self._fps, 2), "last_err": self._last_err}

grabber = SnapshotGrabber()
grabber.start(CAMERA_IP)

# ========= HEURÍSTICA FOGO =========
def hsv_fire_mask(frame_bgr: np.ndarray) -> np.ndarray:
    hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
    return cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))

def boxes_from_mask(mask_bin: np.ndarray, min_area: int = MIN_BLOB_AREA) -> List[List[int]]:
    k = np.ones((KERNEL_SZ, KERNEL_SZ), np.uint8)
    m = cv2.morphologyEx(mask_bin, cv2.MORPH_OPEN, k, 1)
    m = cv2.morphologyEx(m, cv2.MORPH_DILATE, k, 1)
    cnts, _ = cv2.findContours(m, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    out = []
    for c in cnts:
        x,y,w,h = cv2.boundingRect(c)
        if w*h >= min_area:
            out.append([int(x), int(y), int(w), int(h)])
    return out

class FireDetector:
    def __init__(self, src: SnapshotGrabber):
        self.src = src
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._ema = 0.0
        self._score_raw = 0.0
        self._is_fire = False
        self._boxes: List[List[int]] = []
        self._last_ts = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._frame_wh: Optional[Tuple[int,int]] = None

    def start(self):
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)
        self._thread = None

    def _run(self):
        min_interval = 1.0 / 8.0
        while not self._stop.is_set():
            t0 = time.time()
            jpeg = self.src.get_latest_jpeg()
            if jpeg is None:
                time.sleep(0.02); continue
            frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
            if frame is None:
                time.sleep(0.01); continue
            H, W = frame.shape[:2]
            self._frame_wh = (W, H)
            mask = hsv_fire_mask(frame)
            v_mean = float(np.mean(cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)[...,2])) / 255.0
            ratio = float(np.count_nonzero(mask))/float(mask.size)
            score_raw = min(1.0, ratio*4.0 + v_mean*0.1)
            ema = score_raw if self._ema==0.0 else EMA_ALPHA*score_raw + (1.0-EMA_ALPHA)*self._ema
            boxes = boxes_from_mask(mask)
            if   ema >= HYST_HIGH: is_fire = True
            elif ema <= HYST_LOW : is_fire = False
            else: is_fire = self._is_fire
            with self._lock:
                self._ema = ema
                self._score_raw = score_raw
                self._is_fire = is_fire
                self._boxes = boxes if is_fire else []
                self._last_ts = int(time.time()*1000)
                self._frames += 1
                now = time.time()
                if now - self._last_fps_tick >= 1.0:
                    self._fps = self._frames / (now - self._last_fps_tick)
                    self._frames = 0
                    self._last_fps_tick = now
            elapsed = time.time() - t0
            if elapsed < min_interval:
                time.sleep(min_interval - elapsed)

    def get(self) -> Dict[str, Any]:
        with self._lock:
            return {
                "ok": True,
                "isFire": bool(self._is_fire),
                "score": round(float(self._ema), 3),
                "score_raw": round(float(self._score_raw), 3),
                "score_ema": round(float(self._ema), 3),
                "boxes": list(self._boxes),
                "ts": int(self._last_ts),
                "fps_det": round(float(self._fps), 2),
                "frame_wh": list(self._frame_wh) if self._frame_wh else None
            }

det = FireDetector(grabber); det.start()

# ========= ENDPOINTS =========
@app.get("/healthz")
def healthz():
    s = grabber.status()
    return {"ok": True, "camera_ip": s.get("ip"), "fps_in": s.get("fps_in"),
            "hasFrame": s.get("hasFrame"), "age_ms": s.get("age_ms"), "last_err": s.get("last_err")}

@app.get("/status")
def status():
    s = grabber.status(); d = det.get()
    return {"ok": True, "camera_ip": s["ip"], **s, **d}

@app.post("/config")
def set_config(cfg: ConfigIn):
    global CAMERA_IP
    CAMERA_IP = cfg.camera_ip
    grabber.start(CAMERA_IP)
    return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
    b = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS) or placeholder_jpeg("NO LIVE FRAME")
    headers = {
        "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
        "Pragma": "no-cache",
        "Expires": "0",
        "Content-Type": "image/jpeg"
    }
    return Response(content=b, headers=headers, media_type="image/jpeg")

@app.get("/frame.jpg")
def frame_jpg():
    b = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS) or placeholder_jpeg("NO LIVE FRAME")
    headers = {
        "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
        "Pragma": "no-cache",
        "Expires": "0",
        "Content-Type": "image/jpeg"
    }
    return Response(content=b, headers=headers, media_type="image/jpeg")

@app.get("/detect")
def detect():
    res = det.get()
    if res.get("ts", 0) and (int(time.time()*1000) - res["ts"] <= MAX_RESULT_AGE_MS):
        return res
    jpeg = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS)
    if jpeg is None:
        return {"ok": False, "error": "no recent frame"}
    frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
    if frame is None:
        return {"ok": False, "error": "decode failed"}
    H, W = frame.shape[:2]
    mask = hsv_fire_mask(frame)
    v_mean = float(np.mean(cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)[...,2])) / 255.0
    ratio = float(np.count_nonzero(mask))/float(mask.size)
    score = min(1.0, ratio*4.0 + v_mean*0.1)
    is_fire = bool(score >= HYST_HIGH)
    return {"ok": True, "isFire": is_fire, "score": round(score,3), "score_raw": round(score,3),
            "score_ema": round(score,3), "boxes": [], "ts": int(time.time()*1000), "frame_wh": [W,H], "fallback": True}
