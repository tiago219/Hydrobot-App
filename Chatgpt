CameraScreen.tsx

import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
} from "react-native";

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#ffffff" };

// ajuste estes padr√µes se quiser
const DEFAULT_IP = "192.168.4.1";            // ESP32-CAM (AP)
const DEFAULT_SERVER = "http://192.168.4.2:8000"; // Servidor IA (PC no mesmo AP)

export default function CameraScreen() {
  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");
  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // detec√ß√£o
  const [detectOn, setDetectOn] = useState<boolean>(false);
  const [isFire, setIsFire] = useState<boolean>(false);
  const [fireScore, setFireScore] = useState<number>(0);

  // ‚Äúv√≠deo‚Äù por snapshots do servidor
  const [frameUri, setFrameUri] = useState<string>("");

  // joystick (UI)
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // URLs do ESP
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  // consulta /status do ESP
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl, { method: "GET" });
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }

  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText("Erro ao alternar LED.");
    }
  }

  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText("Erro ao alternar bomba.");
    }
  }

  // ping peri√≥dico de status do ESP
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // ===== V√≠deo por snapshots do servidor =====
  useEffect(() => {
    let stop = false;
    const tick = () => {
      if (stop) return;
      // cache-buster (?ts=) para evitar cache da Image
      setFrameUri(`${server}/snapshot?ts=${Date.now()}`);
      setTimeout(tick, 250); // ~4 fps; ajuste conforme sua m√°quina/rede
    };
    tick();
    return () => {
      stop = true;
    };
  }, [server]);

  // polling de /detect do servidor de IA
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;
    const loop = async () => {
      try {
        const r = await fetch(`${server}/detect`, { method: "GET" });
        const j = await r.json();
        if (!stop && j && j.ok) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
        }
      } finally {
        if (!stop) setTimeout(loop, 500); // ~2 Hz
      }
    };
    loop();
    return () => {
      stop = true;
    };
  }, [detectOn, server]);

  // joystick (UI)
  const RADIUS = 64;
  const KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS;
        let ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny }); // y positivo para cima
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const knobLeft = joy.x * RADIUS;
  const knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="192.168.4.1"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor IA + Detectar */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>Servidor:</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder="http://192.168.4.2:8000"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? "Detectando" : "Detectar"}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>
            {isFire ? `üî• FOGO ‚Ä¢ score ${fireScore.toFixed(2)}` : `Sem fogo ‚Ä¢ score ${fireScore.toFixed(2)}`}
          </Text>
        </View>
      )}

      {/* ‚ÄúV√≠deo‚Äù via snapshots do servidor */}
      <Image
        source={{ uri: frameUri }}
        style={styles.video}
        resizeMode="contain"
        onError={() => {
          // feedback visual simples; mant√©m o polling at√© voltar
          setStatusText("Sem v√≠deo (snapshot). Verifique o servidor /snapshot.");
        }}
      />

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: knobLeft }, { translateY: knobTop }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: PALETTE.bg,
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
    minWidth: 110,
  },
  btn: {
    backgroundColor: "#2b48ff",
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  // v√≠deo por snapshots
  video: { flex: 1, backgroundColor: "black", width: "100%" },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(43,72,255,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});









server_heuristic.py

# server_heuristic.py
# FastAPI + OpenCV ‚Äî N√ÉO mant√©m o /stream do ESP aberto.
# Em cada chamada a /snapshot ou /detect, abre o stream, l√™ 1 frame e fecha imediatamente.
import cv2, time, numpy as np
from typing import Optional, List, Tuple
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

CAMERA_IP = "192.168.4.1"
STREAM_URL_FMT = "http://{}:81/stream"
SCORE_THRESHOLD = 0.60
OPEN_TIMEOUT_S = 3.0          # tempo m√°ximo tentando abrir stream
READ_TIMEOUT_S = 1.0          # tempo m√°ximo tentando ler um frame ap√≥s abrir
JPEG_QUALITY = 85

app = FastAPI(title="HydroBot Fire (Heuristic, on-demand)", version="0.2.0")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"]
)

class ConfigIn(BaseModel):
    camera_ip: str

def open_and_read_one(ip: str) -> Optional[np.ndarray]:
    """
    Abre o stream MJPEG do ESP, tenta ler 1 frame e fecha.
    Retorna BGR np.ndarray ou None se falhar.
    """
    url = STREAM_URL_FMT.format(ip)
    t0 = time.time()
    cap = None
    try:
        # Tenta abrir por at√© OPEN_TIMEOUT_S
        while time.time() - t0 < OPEN_TIMEOUT_S:
            cap = cv2.VideoCapture(url)
            # alguns backends ignoram CAP_PROP_BUFFERSIZE, mas n√£o atrapalha
            cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
            if cap.isOpened():
                break
            cap.release()
            cap = None
            time.sleep(0.15)
        if cap is None or not cap.isOpened():
            return None

        # Tenta ler 1 frame por at√© READ_TIMEOUT_S
        t1 = time.time()
        while time.time() - t1 < READ_TIMEOUT_S:
            ok, frame = cap.read()
            if ok and frame is not None:
                return frame
            time.sleep(0.01)
        return None
    finally:
        if cap is not None:
            cap.release()

def fire_score(frame: np.ndarray) -> float:
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    # janela laranja/amarela t√≠pica de chama; ajuste se necess√°rio
    mask = cv2.inRange(hsv, (5, 80, 120), (40, 255, 255))
    ratio = float(np.count_nonzero(mask)) / float(mask.size)
    v_mean = float(np.mean(hsv[..., 2])) / 255.0
    return min(1.0, ratio * 4.0 + v_mean * 0.2)

def fire_boxes(frame: np.ndarray) -> List[List[int]]:
    h, w = frame.shape[:2]
    scl = min(640, w)
    rs = cv2.resize(frame, (scl, int(h * scl / w)))
    hsv = cv2.cvtColor(rs, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, (5, 80, 120), (40, 255, 255))
    k = np.ones((5, 5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, k, 1)
    mask = cv2.morphologyEx(mask, cv2.MORPH_DILATE, k, 1)
    cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    rx = w / float(scl)
    ry = h / float(rs.shape[0])
    boxes: List[List[int]] = []
    for c in cnts:
        x, y, bw, bh = cv2.boundingRect(c)
        if bw * bh < 600:
            continue
        boxes.append([int(x * rx), int(y * ry), int(bw * rx), int(bh * ry)])
    return boxes

@app.get("/status")
def status():
    # N√ÉO abre stream aqui para n√£o competir com o app.
    return {
        "ok": True,
        "camera_ip": CAMERA_IP,
        "model": "heuristic_on_demand",
        "note": "This server opens the ESP stream only per-request (snapshot/detect) and releases immediately.",
        "ts": int(time.time() * 1000),
    }

@app.post("/config")
def set_config(cfg: ConfigIn):
    global CAMERA_IP
    CAMERA_IP = cfg.camera_ip
    return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
    f = open_and_read_one(CAMERA_IP)
    if f is None:
        return {"ok": False, "error": "no frame (ESP busy or unreachable)"}
    ok, buf = cv2.imencode(".jpg", f, [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY])
    if not ok:
        return {"ok": False, "error": "encode failed"}
    return Response(content=buf.tobytes(), media_type="image/jpeg")

@app.get("/detect")
def detect():
    f = open_and_read_one(CAMERA_IP)
    if f is None:
        return {"ok": False, "error": "no frame (ESP busy or unreachable)"}
    s = fire_score(f)
    is_fire = bool(s >= SCORE_THRESHOLD)
    return {
        "ok": True,
        "isFire": is_fire,
        "score": round(float(s), 3),
        "boxes": (fire_boxes(f) if is_fire else []),
        "threshold": SCORE_THRESHOLD,
        "ts": int(time.time() * 1000),
    }
