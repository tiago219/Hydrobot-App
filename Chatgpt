
// ---------- DETECÇÃO DE FOGO + DISCADOR ----------
const fireDetected = simulateFire || hud.fogoE || hud.fogoM || hud.fogoD;

useEffect(() => {
  const openDialer = async () => {
    try {
      if (Platform.OS === "android" && (Linking as any).sendIntent) {
        // Garante ACTION_DIAL com URI tel: — abre o discador com número já digitado
        await (Linking as any).sendIntent("android.intent.action.DIAL", [
          { key: "data", value: "tel:123456" },
        ]);
      } else {
        // iOS (ou Android fallback)
        await Linking.openURL("tel:123456");
      }
    } catch {}
  };

  if (fireDetected && !dialGuardRef.current) {
    dialGuardRef.current = true;
    openDialer();
  }
  if (!fireDetected) {
    dialGuardRef.current = false;
  }
}, [fireDetected]);



















Perfeito — adicionei (1) discagem automática para 123456 quando houver detecção de fogo e (2) um modo de simulação de fogo na própria tela da câmera, além de (3) subir um pouco o controle de movimento.


Abaixo vai o CameraScreen.tsx completo já com tudo integrado. Depois disso, troque apenas 1 linha no seu styles.controlPad (marquei no final) para subir o D-Pad.



src/screens/CameraScreen.tsx (substitua inteiro)


import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet, Image,
  AppState, AppStateStatus, Platform, NativeSyntheticEvent, ImageErrorEventData,
  Animated, Linking
} from "react-native";
import { WebView } from "react-native-webview";
import type { WebViewErrorEvent, WebViewHttpErrorEvent } from "react-native-webview/lib/WebViewTypes";
import { useFocusEffect, useNavigation } from "@react-navigation/native";
import { StatusBar } from "expo-status-bar";
import { useI18n } from "../i18n";

type Mode = "mjpeg" | "snapshot";
type Hud = {
  nivelAguaPct: number;
  fogoE: boolean;
  fogoM: boolean;
  fogoD: boolean;
  modo: "AUTO" | "APP";
  vel: number;
};

const PALETTE = {
  bg: "#0a0a0f",
  bgLight: "#12121a",
  card: "#1a1a24",
  border: "#2a2a3a",
  red: "#ff4444",
  redDark: "#cc0000",
  white: "#f5f5f5",
  sub: "#a0a0b0",
  green: "#00ff88",
  danger: "#ff3333",
  blue: "#4488ff",
};

const LOGO = require("../../assets/logo.png");

export default function CameraScreen() {
  const navigation = useNavigation<any>();
  const { t } = useI18n();
  const [ip, setIp] = useState<string>("192.168.3.3");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [statusText, setStatusText] = useState<string>("—");
  const [err, setErr] = useState<string>("");
  const [showSettings, setShowSettings] = useState<boolean>(false);

  const [hud, setHud] = useState<Hud>({ 
    nivelAguaPct: 0, 
    fogoE: false, 
    fogoM: false, 
    fogoD: false, 
    modo: "AUTO",
    vel: 60 
  });

  const [velocidade, setVelocidade] = useState<number>(60);
  const [snapUri, setSnapUri] = useState<string>("");
  const [simulateFire, setSimulateFire] = useState<boolean>(false);

  const timerRef = useRef<number | null>(null);
  const appState = useRef(AppState.currentState);
  const dialGuardRef = useRef(false); // evita múltiplos disparos da discagem

  const settingsAnim = useRef(new Animated.Value(0)).current;
  const pulseAnim = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    Animated.loop(
      Animated.sequence([
        Animated.timing(pulseAnim, { toValue: 1.15, duration: 1000, useNativeDriver: true }),
        Animated.timing(pulseAnim, { toValue: 1, duration: 1000, useNativeDriver: true }),
      ])
    ).start();
  }, []);

  useEffect(() => {
    Animated.timing(settingsAnim, {
      toValue: showSettings ? 1 : 0,
      duration: 300,
      useNativeDriver: true,
    }).start();
  }, [showSettings]);

  const base80 = useMemo(() => `http://${ip}`, [ip]);
  const base81 = useMemo(() => `http://${ip}:81`, [ip]);
  const statusUrl   = useMemo(() => `${base80}/status`, [base80]);
  const snapshotUrl = useMemo(() => `${base80}/capture`, [base80]);
  const streamUrl   = useMemo(() => `${base81}/stream`, [base81]);
  const cmdUrl      = useMemo(() => `${base80}/cmd`, [base80]);
  const pumpUrl     = useMemo(() => `${base80}/pump`, [base80]);
  const hudUrl      = useMemo(() => `${base80}/hud`, [base80]);
  const velUrl      = useMemo(() => `${base80}/vel`, [base80]);

  useFocusEffect(useCallback(() => {
    const parent = navigation.getParent?.();
    parent?.setOptions({ tabBarStyle: { display: "none" } });
    return () => parent?.setOptions({ tabBarStyle: undefined });
  }, [navigation]));

  const clearTimer = useCallback(() => {
    if (timerRef.current !== null) { 
      clearInterval(timerRef.current); 
      timerRef.current = null; 
    }
  }, []);

  const startSnapshot = useCallback(() => {
    clearTimer();
    timerRef.current = setInterval(() => 
      setSnapUri(`${snapshotUrl}?ts=${Date.now()}`), 125
    ) as unknown as number;
  }, [snapshotUrl, clearTimer]);

  useEffect(() => {
    const sub = AppState.addEventListener("change", (next: AppStateStatus) => {
      if (appState.current.match(/inactive|background/) && next === "active" && mode === "snapshot") {
        startSnapshot();
      }
      if (next.match(/inactive|background/)) clearTimer();
      appState.current = next;
    });
    return () => { sub.remove(); clearTimer(); };
  }, [mode, startSnapshot, clearTimer]);

  useEffect(() => {
    setErr("");
    if (mode === "snapshot") startSnapshot(); 
    else clearTimer();
    return () => clearTimer();
  }, [mode, startSnapshot, clearTimer]);

  const checkStatus = useCallback(async () => {
    try {
      const r = await fetch(statusUrl);
      await r.text();
      setStatusText(t.camera.connected);
      setErr("");
    } catch (e) {
      const er = e as Error;
      setStatusText(t.camera.disconnected);
      setErr(er?.message ?? String(e));
    }
  }, [statusUrl, t.camera.connected, t.camera.disconnected]);

  useEffect(() => { 
    if (ip) checkStatus(); 
  }, [ip, checkStatus]);

  const onWvError = useCallback((e: WebViewErrorEvent) => 
    setErr(`WebView: ${e.nativeEvent.description}`), []);
  const onWvHttpError = useCallback((e: WebViewHttpErrorEvent) => 
    setErr(`HTTP ${e.nativeEvent.statusCode}`), []);
  const onImgError = useCallback((e: NativeSyntheticEvent<ImageErrorEventData>) => 
    setErr(`Snapshot: ${e.nativeEvent.error}`), []);

  useEffect(() => {
    let stop = false;
    const tick = async () => {
      try {
        const r = await fetch(hudUrl, { cache: "no-store" });
        if (!r.ok) throw new Error(`HUD HTTP ${r.status}`);
        const j = await r.json();
        if (!stop) {
          const newHud: Hud = {
            nivelAguaPct: Number(j.nivelAguaPct ?? 0),
            fogoE: !!j.fogoE,
            fogoM: !!j.fogoM,
            fogoD: !!j.fogoD,
            modo: j.modo === 1 || j.modo === "APP" ? "APP" : "AUTO",
            vel: Number(j.vel ?? 60),
          };
          setHud(newHud);
          setVelocidade(newHud.vel);
        }
      } catch (e) {}
      if (!stop) setTimeout(tick, 300);
    };
    tick();
    return () => { stop = true; };
  }, [hudUrl]);

  const sendCmd = useCallback(async (c: "FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP", ms: number = 220) => {
    const url = c === "STOP" ? `${cmdUrl}?c=STOP` : `${cmdUrl}?c=${c}&ms=${ms}`;
    try { await fetch(url); } catch {}
  }, [cmdUrl]);

  const togglePump = useCallback(async (on: boolean) => {
    try { await fetch(`${pumpUrl}?on=${on ? 1 : 0}`); } catch {}
  }, [pumpUrl]);

  const setVel = useCallback(async (v: number) => {
    const vel = Math.max(20, Math.min(100, v));
    setVelocidade(vel);
    try { await fetch(`${velUrl}?v=${vel}`); } catch {}
  }, [velUrl]);

  // HTML para o stream MJPEG
  const mjpegHtml = useMemo(
    () => `
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"/>
    <style>
      html, body { margin:0; padding:0; background:#000; }
      img {
        position: fixed; inset: 0;
        width: 100vw; height: 100vh;
        object-fit: contain; background:#000;
      }
    </style>
  </head>
  <body><img src="${streamUrl}" /></body>
</html>`.trim(),
    [streamUrl]
  );

  // ---------- DETECÇÃO DE FOGO + DISCADOR ----------
  const fireDetected = simulateFire || hud.fogoE || hud.fogoM || hud.fogoD;

  useEffect(() => {
    if (fireDetected && !dialGuardRef.current) {
      dialGuardRef.current = true;
      // Abre o discador com o número preenchido (Android/iOS)
      Linking.openURL("tel:123456").catch(() => {});
    }
    if (!fireDetected) {
      // volta a permitir um novo disparo quando o fogo some / simulação desliga
      dialGuardRef.current = false;
    }
  }, [fireDetected]);

  const StatusIndicator = () => {
    const isConnected = statusText === t.camera.connected;
    return (
      <View style={styles.statusRow}>
        <Animated.View 
          style={[
            styles.statusDot, 
            { 
              backgroundColor: isConnected ? PALETTE.green : PALETTE.danger,
              transform: [{ scale: isConnected ? pulseAnim : 1 }]
            }
          ]} 
        />
        <Text style={[styles.statusText, { color: isConnected ? PALETTE.green : PALETTE.danger }]}>
          {statusText}
        </Text>
      </View>
    );
  };

  const FireBadge = ({ label, active }: { label: string; active: boolean }) => (
    <View style={[styles.fireBadge, active && styles.fireBadgeActive]}>
      <View style={[styles.fireDot, { backgroundColor: active ? PALETTE.danger : PALETTE.sub }]} />
      <Text style={[styles.fireLabel, { color: active ? PALETTE.white : PALETTE.sub }]}>
        {label}
      </Text>
    </View>
  );

  return (
    <View style={styles.root}>
      <StatusBar hidden />

      {/* Viewer */}
      <View style={styles.viewer}>
        {mode === "mjpeg" ? (
          <WebView
            originWhitelist={['*']}
            source={{ html: mjpegHtml }}
            style={StyleSheet.absoluteFill}
            allowsInlineMediaPlayback
            mediaPlaybackRequiresUserAction={false}
            onError={onWvError}
            onHttpError={onWvHttpError}
          />
        ) : (
          <Image
            source={{ uri: snapUri || `${snapshotUrl}?ts=${Date.now()}` }}
            style={StyleSheet.absoluteFill}
            resizeMode="contain"
            onError={onImgError}
          />
        )}
        <View style={styles.viewerOverlay} />
      </View>

      {/* Top Bar */}
      <View style={styles.topBar}>
        <View style={styles.topLeft}>
          <Pressable style={styles.backBtn} onPress={() => navigation.goBack()}>
            <Text style={styles.backBtnText}>←</Text>
          </Pressable>
          <Image source={LOGO} style={styles.topLogo} resizeMode="contain" />
          <View>
            <Text style={styles.topTitle}>{t.camera.title}</Text>
            <StatusIndicator />
          </View>
        </View>
        <View style={styles.topRight}>
          <View style={[styles.modeBadge, hud.modo === "APP" && styles.modeBadgeActive]}>
            <Text style={[styles.modeText, hud.modo === "APP" && styles.modeTextActive]}>
              {hud.modo}
            </Text>
          </View>
          <Pressable style={styles.settingsBtn} onPress={() => setShowSettings(!showSettings)}>
            <Text style={styles.settingsBtnText}>⚙</Text>
          </Pressable>
        </View>
      </View>

      {/* Settings Panel */}
      <Animated.View 
        style={[
          styles.settingsPanel,
          {
            opacity: settingsAnim,
            transform: [{ translateY: settingsAnim.interpolate({
              inputRange: [0, 1],
              outputRange: [-20, 0]
            })}],
            pointerEvents: showSettings ? 'auto' : 'none'
          }
        ]}
      >
        <View style={styles.settingsContent}>
          <View style={styles.settingsHeader}>
            <Text style={styles.settingsTitle}>{t.camera.settings}</Text>
            <Pressable onPress={() => setShowSettings(false)} style={styles.closeBtn}>
              <Text style={styles.closeBtnText}>×</Text>
            </Pressable>
          </View>
          
          <Text style={styles.settingsLabel}>{t.camera.videoMode}</Text>
          <View style={styles.modeToggle}>
            <Pressable 
              style={[styles.modeOption, mode === "mjpeg" && styles.modeOptionActive]}
              onPress={() => setMode("mjpeg")}
            >
              <Text style={[styles.modeOptionText, mode === "mjpeg" && styles.modeOptionTextActive]}>
                MJPEG
              </Text>
            </Pressable>
            <Pressable 
              style={[styles.modeOption, mode === "snapshot" && styles.modeOptionActive]}
              onPress={() => setMode("snapshot")}
            >
              <Text style={[styles.modeOptionText, mode === "snapshot" && styles.modeOptionTextActive]}>
                Snapshot
              </Text>
            </Pressable>
          </View>

          <Text style={styles.settingsLabel}>{t.camera.ipAddress}</Text>
          <View style={styles.ipRow}>
            <TextInput
              style={styles.ipInput}
              value={ip}
              onChangeText={setIp}
              placeholder="192.168.3.3"
              placeholderTextColor={PALETTE.sub}
              autoCapitalize="none"
              autoCorrect={false}
              keyboardType={Platform.OS === "android" ? "numeric" : "numbers-and-punctuation"}
            />
            <Pressable style={styles.testBtn} onPress={checkStatus}>
              <Text style={styles.testBtnText}>{t.camera.testButton}</Text>
            </Pressable>
          </View>
          {!!err && <Text style={styles.errorText} numberOfLines={2}>{err}</Text>}
        </View>
      </Animated.View>

      {/* Control Pad */}
      <View style={styles.controlPad}>
        <View style={styles.dpadContainer}>
          <View style={styles.dpadRow}>
            <Pressable style={[styles.dpadBtn, styles.dpadBtnSide]} onPress={() => sendCmd("LEFT", 180)}>
              <Text style={styles.dpadIcon}>◀</Text>
            </Pressable>
            <Pressable style={[styles.dpadBtn, styles.dpadBtnMain]} onPress={() => sendCmd("FWD", 260)}>
              <Text style={styles.dpadIcon}>▲</Text>
            </Pressable>
            <Pressable style={[styles.dpadBtn, styles.dpadBtnSide]} onPress={() => sendCmd("RIGHT", 180)}>
              <Text style={styles.dpadIcon}>▶</Text>
            </Pressable>
          </View>
          <View style={styles.dpadRow}>
            <Pressable style={[styles.dpadBtn, styles.dpadBtnStop]} onPress={() => sendCmd("STOP")}>
              <Text style={[styles.dpadIcon, { fontSize: 18 }]}>■</Text>
            </Pressable>
            <Pressable style={[styles.dpadBtn, styles.dpadBtnMain]} onPress={() => sendCmd("BACK", 240)}>
              <Text style={styles.dpadIcon}>▼</Text>
            </Pressable>
          </View>
        </View>
      </View>

      {/* Right Panel */}
      <View style={styles.rightPanel}>
        {/* Velocidade */}
        <View style={styles.infoCard}>
          <Text style={styles.cardTitle}>{t.camera.speed}</Text>
          <Text style={styles.velDisplay}>{velocidade}%</Text>
          <View style={styles.velControls}>
            <Pressable style={styles.velBtn} onPress={() => setVel(velocidade - 10)}>
              <Text style={styles.velBtnText}>−</Text>
            </Pressable>
            <View style={styles.velBarContainer}>
              <View style={[styles.velBarFill, { width: `${velocidade}%` }]} />
            </View>
            <Pressable style={styles.velBtn} onPress={() => setVel(velocidade + 10)}>
              <Text style={styles.velBtnText}>+</Text>
            </Pressable>
          </View>
          <View style={styles.velPresets}>
            {[30, 60, 100].map(v => (
              <Pressable key={v} style={styles.velPreset} onPress={() => setVel(v)}>
                <Text style={styles.velPresetText}>{v}%</Text>
              </Pressable>
            ))}
          </View>
        </View>

        {/* Bomba */}
        <View style={styles.infoCard}>
          <Text style={styles.cardTitle}>{t.camera.pump}</Text>
          <Pressable style={styles.pumpBtn} onPress={() => togglePump(true)}>
            <Text style={styles.pumpBtnText}>{t.camera.pumpOn}</Text>
          </Pressable>
          <Pressable style={[styles.pumpBtn, styles.pumpBtnOff]} onPress={() => togglePump(false)}>
            <Text style={styles.pumpBtnText}>{t.camera.pumpOff}</Text>
          </Pressable>
        </View>

        {/* Sensores */}
        <View style={styles.infoCard}>
          <Text style={styles.cardTitle}>{t.camera.sensors}</Text>
          <View style={styles.fireGrid}>
            <FireBadge label={t.camera.left} active={hud.fogoE} />
            <FireBadge label={t.camera.middle} active={hud.fogoM} />
            <FireBadge label={t.camera.right} active={hud.fogoD} />
          </View>
        </View>

        {/* Água */}
        <View style={styles.infoCard}>
          <Text style={styles.cardTitle}>{t.camera.water}</Text>
          <Text style={styles.waterLevel}>{hud.nivelAguaPct}%</Text>
          <View style={styles.waterBar}>
            <View style={[styles.waterBarFill, { 
              width: `${Math.max(0, Math.min(100, hud.nivelAguaPct))}%`,
              backgroundColor: hud.nivelAguaPct > 40 ? PALETTE.green : 
                               hud.nivelAguaPct > 20 ? "#ffbb33" : PALETTE.danger
            }]} />
          </View>
        </View>

        {/* --- NOVO: Teste / Simulação de Fogo --- */}
        <View style={styles.infoCard}>
          <Text style={styles.cardTitle}>Teste</Text>
          <Pressable
            style={[
              styles.simBtn,
              simulateFire ? styles.simBtnOn : styles.simBtnOff
            ]}
            onPress={() => setSimulateFire(s => !s)}
          >
            <Text style={styles.simBtnText}>
              {simulateFire ? "Simulação de Fogo: ATIVA" : "Simular Fogo"}
            </Text>
          </Pressable>
          {simulateFire && (
            <Text style={{ color: PALETTE.danger, fontSize: 12, marginTop: 6, fontWeight: "700" }}>
              Discador será aberto automaticamente.
            </Text>
          )}
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: PALETTE.bg },
  viewer: { ...StyleSheet.absoluteFillObject, backgroundColor: "#000" },
  viewerOverlay: { 
    ...StyleSheet.absoluteFillObject, 
    backgroundColor: "rgba(0,0,0,0.1)",
    pointerEvents: "none"
  },

  // Top Bar
  topBar: {
    position: "absolute", top: 0, left: 0, right: 0,
    flexDirection: "row", justifyContent: "space-between", alignItems: "center",
    paddingHorizontal: 16, paddingTop: 50, paddingBottom: 14,
    backgroundColor: "rgba(10,10,15,0.96)",
    borderBottomWidth: 1, borderBottomColor: PALETTE.border,
    shadowColor: "#000", shadowOpacity: 0.5, shadowRadius: 10, elevation: 10,
  },
  topLeft: { flexDirection: "row", alignItems: "center", gap: 12 },
  backBtn: {
    width: 36, height: 36, borderRadius: 18,
    backgroundColor: PALETTE.card, alignItems: "center", justifyContent: "center",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  backBtnText: { color: PALETTE.white, fontSize: 24, fontWeight: "800" },
  topLogo: { width: 32, height: 32 },
  topTitle: { color: PALETTE.white, fontSize: 19, fontWeight: "800", letterSpacing: 0.5 },
  statusRow: { flexDirection: "row", alignItems: "center", gap: 6, marginTop: 2 },
  statusDot: { width: 7, height: 7, borderRadius: 4 },
  statusText: { fontSize: 11, fontWeight: "600" },
  topRight: { flexDirection: "row", gap: 8, alignItems: "center" },
  modeBadge: {
    paddingHorizontal: 11, paddingVertical: 6, borderRadius: 20,
    backgroundColor: PALETTE.card, borderWidth: 1, borderColor: PALETTE.border,
  },
  modeBadgeActive: { backgroundColor: PALETTE.red, borderColor: PALETTE.red },
  modeText: { color: PALETTE.sub, fontSize: 11, fontWeight: "700" },
  modeTextActive: { color: PALETTE.white },
  settingsBtn: {
    width: 36, height: 36, borderRadius: 18,
    backgroundColor: PALETTE.card, alignItems: "center", justifyContent: "center",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  settingsBtnText: { fontSize: 16 },

  // Settings Panel
  settingsPanel: {
    position: "absolute", top: 110, left: 16, right: 16,
    backgroundColor: PALETTE.card, borderRadius: 16, borderWidth: 1, borderColor: PALETTE.border,
    shadowColor: "#000", shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.4, shadowRadius: 12,
    elevation: 10,
  },
  settingsContent: { padding: 16 },
  settingsHeader: { flexDirection: "row", justifyContent: "space-between", alignItems: "center", marginBottom: 14 },
  settingsTitle: { color: PALETTE.white, fontSize: 18, fontWeight: "800" },
  closeBtn: { width: 28, height: 28, alignItems: "center", justifyContent: "center" },
  closeBtnText: { color: PALETTE.sub, fontSize: 32, fontWeight: "300" },
  settingsLabel: { color: PALETTE.sub, fontSize: 12, fontWeight: "600", marginBottom: 8, marginTop: 10 },
  modeToggle: { flexDirection: "row", gap: 8 },
  modeOption: {
    flex: 1, paddingVertical: 10, borderRadius: 10,
    backgroundColor: PALETTE.bgLight, borderWidth: 1, borderColor: PALETTE.border,
    alignItems: "center",
  },
  modeOptionActive: { backgroundColor: PALETTE.red, borderColor: PALETTE.red },
  modeOptionText: { color: PALETTE.sub, fontWeight: "700", fontSize: 13 },
  modeOptionTextActive: { color: PALETTE.white },
  ipRow: { flexDirection: "row", gap: 8 },
  ipInput: {
    flex: 1, backgroundColor: PALETTE.bgLight, borderWidth: 1, borderColor: PALETTE.border,
    borderRadius: 10, paddingHorizontal: 12, paddingVertical: 10,
    color: PALETTE.white, fontSize: 14,
  },
  testBtn: {
    paddingHorizontal: 16, paddingVertical: 10, borderRadius: 10,
    backgroundColor: PALETTE.blue, alignItems: "center", justifyContent: "center",
  },
  testBtnText: { color: PALETTE.white, fontWeight: "700", fontSize: 13 },
  errorText: { color: PALETTE.danger, fontSize: 11, marginTop: 8 },

  // Control Pad (SUBI UM POUCO — bottom: 16 -> 56)
  controlPad: { position: "absolute", left: 16, bottom: 56 },
  dpadContainer: { gap: 8 },
  dpadRow: { flexDirection: "row", gap: 8, justifyContent: "center" },
  dpadBtn: {
    width: 60, height: 60, borderRadius: 14,
    alignItems: "center", justifyContent: "center",
    borderWidth: 2,
    shadowColor: "#000", shadowOpacity: 0.4, shadowRadius: 8, elevation: 6,
  },
  dpadBtnMain: {
    backgroundColor: PALETTE.red, borderColor: PALETTE.redDark,
    shadowColor: PALETTE.red,
  },
  dpadBtnSide: {
    backgroundColor: "rgba(255,68,68,0.25)", borderColor: PALETTE.red,
  },
  dpadBtnStop: {
    backgroundColor: "rgba(204,0,0,0.35)", borderColor: PALETTE.redDark,
  },
  dpadIcon: { color: PALETTE.white, fontSize: 24, fontWeight: "800" },

  // Right Panel
  rightPanel: { position: "absolute", right: 16, top: 120, width: 200, gap: 10 },
  infoCard: {
    backgroundColor: "rgba(26,26,36,0.96)", borderRadius: 14,
    padding: 12, borderWidth: 1, borderColor: PALETTE.border,
    shadowColor: "#000", shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.4, shadowRadius: 6,
    elevation: 6,
  },
  cardTitle: { color: PALETTE.white, fontSize: 12, fontWeight: "800", marginBottom: 8, letterSpacing: 0.5 },

  // Velocidade
  velDisplay: { color: PALETTE.white, fontSize: 26, fontWeight: "800", textAlign: "center", marginBottom: 6 },
  velControls: { flexDirection: "row", alignItems: "center", gap: 8 },
  velBtn: {
    width: 30, height: 30, borderRadius: 8,
    backgroundColor: PALETTE.red, alignItems: "center", justifyContent: "center",
  },
  velBtnText: { color: PALETTE.white, fontSize: 18, fontWeight: "800" },
  velBarContainer: {
    flex: 1, height: 11, borderRadius: 6,
    backgroundColor: PALETTE.bgLight, overflow: "hidden",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  velBarFill: { height: "100%", backgroundColor: PALETTE.red },
  velPresets: { flexDirection: "row", gap: 6, marginTop: 8 },
  velPreset: {
    flex: 1, paddingVertical: 6, borderRadius: 8,
    backgroundColor: PALETTE.bgLight, borderWidth: 1, borderColor: PALETTE.border,
    alignItems: "center",
  },
  velPresetText: { color: PALETTE.white, fontSize: 11, fontWeight: "700" },

  // Bomba
  pumpBtn: {
    backgroundColor: PALETTE.green, borderRadius: 10, paddingVertical: 9,
    alignItems: "center", marginBottom: 6,
  },
  pumpBtnOff: { backgroundColor: PALETTE.danger },
  pumpBtnText: { color: PALETTE.white, fontWeight: "800", fontSize: 12 },

  // Sensores
  fireGrid: { flexDirection: "row", gap: 6, flexWrap: "wrap" },
  fireBadge: {
    flexDirection: "row", alignItems: "center", gap: 5,
    paddingHorizontal: 9, paddingVertical: 5, borderRadius: 20,
    backgroundColor: PALETTE.bgLight, borderWidth: 1, borderColor: PALETTE.border,
  },
  fireBadgeActive: {
    backgroundColor: "rgba(255,51,51,0.2)", borderColor: PALETTE.danger,
  },
  fireDot: { width: 5, height: 5, borderRadius: 3 },
  fireLabel: { fontSize: 10, fontWeight: "700", color: PALETTE.sub },

  // Água
  waterLevel: { color: PALETTE.white, fontSize: 28, fontWeight: "800", textAlign: "center", marginBottom: 6 },
  waterBar: {
    height: 12, borderRadius: 6, backgroundColor: PALETTE.bgLight,
    overflow: "hidden", borderWidth: 1, borderColor: PALETTE.border,
  },
  waterBarFill: { height: "100%" },

  // Simulação
  simBtn: {
    borderRadius: 10,
    paddingVertical: 10,
    alignItems: "center",
    borderWidth: 1,
  },
  simBtnOn: {
    backgroundColor: "rgba(255,51,51,0.18)",
    borderColor: PALETTE.danger,
  },
  simBtnOff: {
    backgroundColor: PALETTE.bgLight,
    borderColor: PALETTE.border,
  },
  simBtnText: { color: PALETTE.white, fontWeight: "800", fontSize: 12 },
});




Ajuste no posicionamento do controle (já aplicado acima)


No seu original estava:


controlPad: { position: "absolute", left: 16, bottom: 16 },



Eu subi um pouco para:


controlPad: { position: "absolute", left: 16, bottom: 56 },





Se quiser mais alto/baixo, altere o valor de bottom.





Observações rápidas




Discagem: usar Linking.openURL("tel:123456") abre o discador com o número preenchido (sem precisar de permissão). Em iOS, tel: também funciona; não usei telprompt: para evitar inconsistências.


Anti-spam: o dialGuardRef garante que o discador seja aberto uma vez por evento de fogo (real ou simulado). Quando o fogo some (ou você desliga a simulação), ele “reseta”.


Simulação: o cartão “Teste” no painel da direita tem o botão Simular Fogo que ativa/desativa a simulação e aciona o discador como se os sensores tivessem detectado.




Quer que eu coloque essa simulação também em um atalho no topo (ex.: um botão 🔥 na Top Bar)?























//App.tsx
import React from "react";
import { NavigationContainer, DefaultTheme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";
import { LogBox } from "react-native";

import { I18nProvider } from "./src/i18n";
import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";

LogBox.ignoreLogs(["useInsertionEffect must not schedule updates"]);

const Tab = createBottomTabNavigator();

const theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: "#0b0b0f",
    card: "#0b0b0f",
    text: "#e5e7eb",
    border: "#25273a",
    primary: "#e6403a",
  },
};

export default function App() {
  return (
    <I18nProvider>
      <NavigationContainer theme={theme}>
        <Tab.Navigator
          screenOptions={({ route }) => ({
            headerShown: false,
            tabBarStyle: { backgroundColor: "#0b0b0f", borderTopColor: "#25273a" },
            tabBarActiveTintColor: "#e6403a",
            tabBarInactiveTintColor: "#9aa0a6",
            tabBarIcon: ({ color, size }) => {
              const name =
                route.name === "Início" ? "home" :
                route.name === "Câmera" ? "videocam" : "ellipse";
              return <Ionicons name={name as any} size={size} color={color} />;
            },
          })}
        >
          <Tab.Screen name="Início" component={HomeScreen} />
          <Tab.Screen
            name="Câmera"
            component={CameraScreen}
            options={{
              headerShown: false,
              tabBarStyle: { display: "none" },
            }}
          />
        </Tab.Navigator>
      </NavigationContainer>
    </I18nProvider>
  );
}








//HomeScreen.tsx
import React, { useEffect, useRef, useState } from "react";
import { View, Text, StyleSheet, Image, Pressable, Animated, Modal } from "react-native";
import { useNavigation } from "@react-navigation/native";
import { useI18n, Language } from "../i18n";

const PALETTE = {
  bg: "#0a0a0f",
  bgLight: "#12121a",
  card: "#1a1a24",
  border: "#2a2a3a",
  red: "#ff4444",
  redDark: "#cc0000",
  white: "#f5f5f5",
  sub: "#a0a0b0",
  green: "#00ff88",
  blue: "#4488ff",
};

const LANGUAGES: { code: Language; name: string; flag: string }[] = [
  { code: 'pt', name: 'Português', flag: '🇧🇷' },
  { code: 'en', name: 'English', flag: '🇺🇸' },
  { code: 'es', name: 'Español', flag: '🇪🇸' },
];

export default function HomeScreen() {
  const nav = useNavigation<any>();
  const { language, setLanguage, t } = useI18n();
  const [showLangModal, setShowLangModal] = useState(false);
  const [expandedCard, setExpandedCard] = useState<string | null>(null);

  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(30)).current;
  const pulseAnim = useRef(new Animated.Value(1)).current;
  const modalAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 800,
        useNativeDriver: true,
      }),
      Animated.timing(slideAnim, {
        toValue: 0,
        duration: 600,
        useNativeDriver: true,
      }),
    ]).start();

    Animated.loop(
      Animated.sequence([
        Animated.timing(pulseAnim, {
          toValue: 1.05,
          duration: 2000,
          useNativeDriver: true,
        }),
        Animated.timing(pulseAnim, {
          toValue: 1,
          duration: 2000,
          useNativeDriver: true,
        }),
      ])
    ).start();
  }, []);

  useEffect(() => {
    Animated.spring(modalAnim, {
      toValue: showLangModal ? 1 : 0,
      useNativeDriver: true,
      tension: 50,
      friction: 8,
    }).start();
  }, [showLangModal]);

  const FeatureCard = ({
    id,
    icon,
    title,
    description,
    expanded,
  }: {
    id: string;
    icon: string;
    title: string;
    description: string;
    expanded: string;
  }) => {
    const isExpanded = expandedCard === id;
    const heightAnim = useRef(new Animated.Value(0)).current;

    useEffect(() => {
      Animated.spring(heightAnim, {
        toValue: isExpanded ? 1 : 0,
        useNativeDriver: false,
        tension: 50,
        friction: 8,
      }).start();
    }, [isExpanded]);

    return (
      <Pressable
        style={[styles.featureCard, isExpanded && styles.featureCardExpanded]}
        onPress={() => setExpandedCard(isExpanded ? null : id)}
      >
        <View style={styles.featureIcon}>
          <Text style={styles.featureIconText}>{icon}</Text>
        </View>
        <View style={styles.featureContent}>
          <View style={styles.featureHeader}>
            <Text style={styles.featureTitle}>{title}</Text>
            <Text style={[styles.expandIcon, isExpanded && styles.expandIconRotated]}>
              ▼
            </Text>
          </View>
          <Text style={styles.featureDesc}>{description}</Text>
          {isExpanded && (
            <Animated.View
              style={[
                styles.expandedContent,
                {
                  opacity: heightAnim,
                  maxHeight: heightAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0, 300],
                  }),
                },
              ]}
            >
              <View style={styles.divider} />
              <Text style={styles.expandedText}>{expanded}</Text>
            </Animated.View>
          )}
        </View>
      </Pressable>
    );
  };

  const handleLanguageSelect = (lang: Language) => {
    setLanguage(lang);
    setShowLangModal(false);
  };

  const currentLang = LANGUAGES.find(l => l.code === language)!;

  return (
    <View style={styles.container}>
      <View style={styles.bgLayer1} />
      <View style={styles.bgLayer2} />

      <Pressable 
        style={styles.langButton}
        onPress={() => setShowLangModal(true)}
      >
        <Text style={styles.langFlag}>{currentLang.flag}</Text>
        <Text style={styles.langCode}>{currentLang.code.toUpperCase()}</Text>
      </Pressable>

      <Animated.View
        style={[
          styles.content,
          {
            opacity: fadeAnim,
            transform: [{ translateY: slideAnim }],
          },
        ]}
      >
        <View style={styles.logoSection}>
          <Animated.View style={{ transform: [{ scale: pulseAnim }] }}>
            <View style={styles.logoContainer}>
              <Image
                source={require("../../assets/logo.png")}
                style={styles.logo}
                resizeMode="contain"
              />
              <View style={styles.logoBg} />
            </View>
          </Animated.View>

          <Text style={styles.title}>{t.home.title}</Text>
          <View style={styles.subtitleContainer}>
            <View style={styles.statusDot} />
            <Text style={styles.subtitle}>{t.home.subtitle}</Text>
          </View>
        </View>

        <View style={styles.featuresSection}>
          <Text style={styles.sectionTitle}>{t.home.resourcesTitle}</Text>
          <FeatureCard
            id="camera"
            icon="📹"
            title={t.home.features.camera.title}
            description={t.home.features.camera.desc}
            expanded={t.home.features.camera.expanded}
          />
          <FeatureCard
            id="control"
            icon="🎮"
            title={t.home.features.control.title}
            description={t.home.features.control.desc}
            expanded={t.home.features.control.expanded}
          />
          <FeatureCard
            id="fire"
            icon="🔥"
            title={t.home.features.fire.title}
            description={t.home.features.fire.desc}
            expanded={t.home.features.fire.expanded}
          />
          <FeatureCard
            id="pump"
            icon="💧"
            title={t.home.features.pump.title}
            description={t.home.features.pump.desc}
            expanded={t.home.features.pump.expanded}
          />
        </View>

        <Pressable
          style={({ pressed }) => [
            styles.ctaButton,
            pressed && styles.ctaButtonPressed,
          ]}
          onPress={() => nav.navigate("Câmera")}
        >
          <Text style={styles.ctaText}>{t.home.startButton}</Text>
        </Pressable>

        <View style={styles.footer}>
          <View style={styles.footerDivider} />
          <Text style={styles.footerText}>{t.home.footer}</Text>
        </View>
      </Animated.View>

      <Modal
        visible={showLangModal}
        transparent
        animationType="fade"
        onRequestClose={() => setShowLangModal(false)}
      >
        <Pressable 
          style={styles.modalOverlay}
          onPress={() => setShowLangModal(false)}
        >
          <Animated.View
            style={[
              styles.modalContent,
              {
                opacity: modalAnim,
                transform: [
                  {
                    scale: modalAnim.interpolate({
                      inputRange: [0, 1],
                      outputRange: [0.9, 1],
                    }),
                  },
                ],
              },
            ]}
          >
            <Text style={styles.modalTitle}>🌍 Select Language</Text>
            <View style={styles.langList}>
              {LANGUAGES.map((lang) => (
                <Pressable
                  key={lang.code}
                  style={[
                    styles.langOption,
                    language === lang.code && styles.langOptionActive,
                  ]}
                  onPress={() => handleLanguageSelect(lang.code)}
                >
                  <Text style={styles.langOptionFlag}>{lang.flag}</Text>
                  <Text
                    style={[
                      styles.langOptionName,
                      language === lang.code && styles.langOptionNameActive,
                    ]}
                  >
                    {lang.name}
                  </Text>
                  {language === lang.code && (
                    <Text style={styles.langCheckmark}>✓</Text>
                  )}
                </Pressable>
              ))}
            </View>
          </Animated.View>
        </Pressable>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: PALETTE.bg,
  },
  bgLayer1: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: PALETTE.bg,
  },
  bgLayer2: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: PALETTE.red,
    opacity: 0.05,
  },
  langButton: {
    position: 'absolute',
    top: 50,
    right: 24,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: PALETTE.card,
    borderRadius: 20,
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
    gap: 6,
    zIndex: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },
  langFlag: {
    fontSize: 18,
  },
  langCode: {
    color: PALETTE.white,
    fontSize: 13,
    fontWeight: '700',
  },
  content: {
    flex: 1,
    paddingHorizontal: 24,
    paddingTop: 60,
    paddingBottom: 40,
  },
  logoSection: {
    alignItems: "center",
    marginBottom: 32,
  },
  logoContainer: {
    width: 140,
    height: 140,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 20,
  },
  logo: {
    width: 120,
    height: 120,
    zIndex: 2,
  },
  logoBg: {
    position: "absolute",
    width: 140,
    height: 140,
    borderRadius: 70,
    backgroundColor: PALETTE.red,
    opacity: 0.15,
    zIndex: 1,
  },
  title: {
    color: PALETTE.white,
    fontSize: 38,
    fontWeight: "900",
    letterSpacing: 1.5,
    textShadowColor: "rgba(255, 68, 68, 0.6)",
    textShadowOffset: { width: 0, height: 2 },
    textShadowRadius: 8,
    marginBottom: 8,
  },
  subtitleContainer: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  statusDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: PALETTE.green,
  },
  subtitle: {
    color: PALETTE.sub,
    fontSize: 15,
    fontWeight: "600",
  },
  featuresSection: {
    flex: 1,
    gap: 12,
  },
  sectionTitle: {
    color: PALETTE.white,
    fontSize: 20,
    fontWeight: "800",
    marginBottom: 8,
    paddingLeft: 4,
  },
  featureCard: {
    flexDirection: "row",
    backgroundColor: PALETTE.card,
    borderRadius: 16,
    padding: 16,
    borderLeftWidth: 4,
    borderLeftColor: PALETTE.red,
    shadowColor: "#ff4444",
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.25,
    shadowRadius: 6,
    elevation: 4,
  },
  featureCardExpanded: {
    shadowOpacity: 0.4,
    shadowRadius: 10,
    elevation: 8,
    borderLeftWidth: 6,
  },
  featureIcon: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: "rgba(255, 68, 68, 0.15)",
    alignItems: "center",
    justifyContent: "center",
    marginRight: 16,
  },
  featureIconText: {
    fontSize: 24,
  },
  featureContent: {
    flex: 1,
  },
  featureHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 4,
  },
  featureTitle: {
    color: PALETTE.white,
    fontSize: 16,
    fontWeight: "800",
  },
  expandIcon: {
    color: PALETTE.sub,
    fontSize: 12,
    fontWeight: "800",
  },
  expandIconRotated: {
    transform: [{ rotate: "180deg" }],
    color: PALETTE.red,
  },
  featureDesc: {
    color: PALETTE.sub,
    fontSize: 14,
    lineHeight: 20,
  },
  expandedContent: {
    overflow: "hidden",
  },
  divider: {
    height: 1,
    backgroundColor: PALETTE.border,
    marginVertical: 12,
  },
  expandedText: {
    color: PALETTE.white,
    fontSize: 13,
    lineHeight: 20,
    opacity: 0.9,
  },
  ctaButton: {
    borderRadius: 16,
    marginTop: 28,
    paddingVertical: 18,
    backgroundColor: PALETTE.red,
    shadowColor: PALETTE.red,
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.6,
    shadowRadius: 16,
    elevation: 10,
    alignItems: "center",
  },
  ctaButtonPressed: {
    opacity: 0.9,
    transform: [{ scale: 0.98 }],
  },
  ctaText: {
    color: PALETTE.white,
    fontSize: 19,
    fontWeight: "900",
    letterSpacing: 1,
  },
  footer: {
    alignItems: "center",
    marginTop: 40,
    gap: 16,
  },
  footerDivider: {
    width: 70,
    height: 3,
    borderRadius: 2,
    backgroundColor: PALETTE.border,
  },
  footerText: {
    color: PALETTE.sub,
    fontSize: 12,
    fontWeight: "500",
    textAlign: "center",
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.85)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
  },
  modalContent: {
    backgroundColor: PALETTE.card,
    borderRadius: 24,
    padding: 24,
    width: '100%',
    maxWidth: 340,
    borderWidth: 1,
    borderColor: PALETTE.border,
    shadowColor: PALETTE.red,
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.3,
    shadowRadius: 16,
    elevation: 10,
  },
  modalTitle: {
    color: PALETTE.white,
    fontSize: 22,
    fontWeight: '900',
    marginBottom: 20,
    textAlign: 'center',
  },
  langList: {
    gap: 10,
  },
  langOption: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: PALETTE.bgLight,
    borderRadius: 14,
    padding: 16,
    borderWidth: 2,
    borderColor: PALETTE.border,
  },
  langOptionActive: {
    borderColor: PALETTE.red,
    backgroundColor: 'rgba(255, 68, 68, 0.1)',
  },
  langOptionFlag: {
    fontSize: 28,
    marginRight: 14,
  },
  langOptionName: {
    flex: 1,
    color: PALETTE.sub,
    fontSize: 17,
    fontWeight: '700',
  },
  langOptionNameActive: {
    color: PALETTE.white,
  },
  langCheckmark: {
    color: PALETTE.red,
    fontSize: 22,
    fontWeight: '900',
  },
});











//CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet, Image,
  AppState, AppStateStatus, Platform, NativeSyntheticEvent, ImageErrorEventData,
  Animated
} from "react-native";
import { WebView } from "react-native-webview";
import type { WebViewErrorEvent, WebViewHttpErrorEvent } from "react-native-webview/lib/WebViewTypes";
import { useFocusEffect, useNavigation } from "@react-navigation/native";
import { StatusBar } from "expo-status-bar";
import { useI18n } from "../i18n";

type Mode = "mjpeg" | "snapshot";
type Hud = {
  nivelAguaPct: number;
  fogoE: boolean;
  fogoM: boolean;
  fogoD: boolean;
  modo: "AUTO" | "APP";
  vel: number;
};

const PALETTE = {
  bg: "#0a0a0f",
  bgLight: "#12121a",
  card: "#1a1a24",
  border: "#2a2a3a",
  red: "#ff4444",
  redDark: "#cc0000",
  white: "#f5f5f5",
  sub: "#a0a0b0",
  green: "#00ff88",
  danger: "#ff3333",
  blue: "#4488ff",
};

const LOGO = require("../../assets/logo.png");

export default function CameraScreen() {
  const navigation = useNavigation<any>();
  const { t } = useI18n();
  const [ip, setIp] = useState<string>("192.168.3.3");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [statusText, setStatusText] = useState<string>("—");
  const [err, setErr] = useState<string>("");
  const [showSettings, setShowSettings] = useState<boolean>(false);

  const [hud, setHud] = useState<Hud>({ 
    nivelAguaPct: 0, 
    fogoE: false, 
    fogoM: false, 
    fogoD: false, 
    modo: "AUTO",
    vel: 60 
  });

  const [velocidade, setVelocidade] = useState<number>(60);
  const [snapUri, setSnapUri] = useState<string>("");
  const timerRef = useRef<number | null>(null);
  const appState = useRef(AppState.currentState);

  const settingsAnim = useRef(new Animated.Value(0)).current;
  const pulseAnim = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    Animated.loop(
      Animated.sequence([
        Animated.timing(pulseAnim, { toValue: 1.15, duration: 1000, useNativeDriver: true }),
        Animated.timing(pulseAnim, { toValue: 1, duration: 1000, useNativeDriver: true }),
      ])
    ).start();
  }, []);

  useEffect(() => {
    Animated.timing(settingsAnim, {
      toValue: showSettings ? 1 : 0,
      duration: 300,
      useNativeDriver: true,
    }).start();
  }, [showSettings]);

  const base80 = useMemo(() => `http://${ip}`, [ip]);
  const base81 = useMemo(() => `http://${ip}:81`, [ip]);
  const statusUrl   = useMemo(() => `${base80}/status`, [base80]);
  const snapshotUrl = useMemo(() => `${base80}/capture`, [base80]);
  const streamUrl   = useMemo(() => `${base81}/stream`, [base81]);
  const cmdUrl      = useMemo(() => `${base80}/cmd`, [base80]);
  const pumpUrl     = useMemo(() => `${base80}/pump`, [base80]);
  const hudUrl      = useMemo(() => `${base80}/hud`, [base80]);
  const velUrl      = useMemo(() => `${base80}/vel`, [base80]);

  useFocusEffect(useCallback(() => {
    const parent = navigation.getParent?.();
    parent?.setOptions({ tabBarStyle: { display: "none" } });
    return () => parent?.setOptions({ tabBarStyle: undefined });
  }, [navigation]));

  const clearTimer = useCallback(() => {
    if (timerRef.current !== null) { 
      clearInterval(timerRef.current); 
      timerRef.current = null; 
    }
  }, []);

  const startSnapshot = useCallback(() => {
    clearTimer();
    timerRef.current = setInterval(() => 
      setSnapUri(`${snapshotUrl}?ts=${Date.now()}`), 125
    ) as unknown as number;
  }, [snapshotUrl, clearTimer]);

  useEffect(() => {
    const sub = AppState.addEventListener("change", (next: AppStateStatus) => {
      if (appState.current.match(/inactive|background/) && next === "active" && mode === "snapshot") {
        startSnapshot();
      }
      if (next.match(/inactive|background/)) clearTimer();
      appState.current = next;
    });
    return () => { sub.remove(); clearTimer(); };
  }, [mode, startSnapshot, clearTimer]);

  useEffect(() => {
    setErr("");
    if (mode === "snapshot") startSnapshot(); 
    else clearTimer();
    return () => clearTimer();
  }, [mode, startSnapshot, clearTimer]);

  const checkStatus = useCallback(async () => {
    try {
      const r = await fetch(statusUrl);
      await r.text();
      setStatusText(t.camera.connected);
      setErr("");
    } catch (e) {
      const er = e as Error;
      setStatusText(t.camera.disconnected);
      setErr(er?.message ?? String(e));
    }
  }, [statusUrl, t.camera.connected, t.camera.disconnected]);

  useEffect(() => { 
    if (ip) checkStatus(); 
  }, [ip, checkStatus]);

  const onWvError = useCallback((e: WebViewErrorEvent) => 
    setErr(`WebView: ${e.nativeEvent.description}`), []);
  const onWvHttpError = useCallback((e: WebViewHttpErrorEvent) => 
    setErr(`HTTP ${e.nativeEvent.statusCode}`), []);
  const onImgError = useCallback((e: NativeSyntheticEvent<ImageErrorEventData>) => 
    setErr(`Snapshot: ${e.nativeEvent.error}`), []);

  useEffect(() => {
    let stop = false;
    const tick = async () => {
      try {
        const r = await fetch(hudUrl, { cache: "no-store" });
        if (!r.ok) throw new Error(`HUD HTTP ${r.status}`);
        const j = await r.json();
        if (!stop) {
          const newHud: Hud = {
            nivelAguaPct: Number(j.nivelAguaPct ?? 0),
            fogoE: !!j.fogoE,
            fogoM: !!j.fogoM,
            fogoD: !!j.fogoD,
            modo: j.modo === 1 || j.modo === "APP" ? "APP" : "AUTO",
            vel: Number(j.vel ?? 60),
          };
          setHud(newHud);
          setVelocidade(newHud.vel);
        }
      } catch (e) {}
      if (!stop) setTimeout(tick, 300);
    };
    tick();
    return () => { stop = true; };
  }, [hudUrl]);

  const sendCmd = useCallback(async (c: "FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP", ms: number = 220) => {
    const url = c === "STOP" ? `${cmdUrl}?c=STOP` : `${cmdUrl}?c=${c}&ms=${ms}`;
    try { await fetch(url); } catch {}
  }, [cmdUrl]);

  const togglePump = useCallback(async (on: boolean) => {
    try { await fetch(`${pumpUrl}?on=${on ? 1 : 0}`); } catch {}
  }, [pumpUrl]);

  const setVel = useCallback(async (v: number) => {
    const vel = Math.max(20, Math.min(100, v));
    setVelocidade(vel);
    try { await fetch(`${velUrl}?v=${vel}`); } catch {}
  }, [velUrl]);

  const mjpegHtml = useMemo(
    () => `
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"/>
    <style>
      html, body { margin:0; padding:0; background:#000; }
      img {
        position: fixed; inset: 0;
        width: 100vw; height: 100vh;
        object-fit: contain; background:#000;
      }
    </style>
  </head>
  <body><img src="${streamUrl}" /></body>
</html>`.trim(),
    [streamUrl]
  );

  const StatusIndicator = () => {
    const isConnected = statusText === t.camera.connected;
    return (
      <View style={styles.statusRow}>
        <Animated.View 
          style={[
            styles.statusDot, 
            { 
              backgroundColor: isConnected ? PALETTE.green : PALETTE.danger,
              transform: [{ scale: isConnected ? pulseAnim : 1 }]
            }
          ]} 
        />
        <Text style={[styles.statusText, { color: isConnected ? PALETTE.green : PALETTE.danger }]}>
          {statusText}
        </Text>
      </View>
    );
  };

  const FireBadge = ({ label, active }: { label: string; active: boolean }) => (
    <View style={[styles.fireBadge, active && styles.fireBadgeActive]}>
      <View style={[styles.fireDot, { backgroundColor: active ? PALETTE.danger : PALETTE.sub }]} />
      <Text style={[styles.fireLabel, { color: active ? PALETTE.white : PALETTE.sub }]}>
        {label}
      </Text>
    </View>
  );

  return (
    <View style={styles.root}>
      <StatusBar hidden />

      {/* Viewer */}
      <View style={styles.viewer}>
        {mode === "mjpeg" ? (
          <WebView
            originWhitelist={['*']}
            source={{ html: mjpegHtml }}
            style={StyleSheet.absoluteFill}
            allowsInlineMediaPlayback
            mediaPlaybackRequiresUserAction={false}
            onError={onWvError}
            onHttpError={onWvHttpError}
          />
        ) : (
          <Image
            source={{ uri: snapUri || `${snapshotUrl}?ts=${Date.now()}` }}
            style={StyleSheet.absoluteFill}
            resizeMode="contain"
            onError={onImgError}
          />
        )}
        <View style={styles.viewerOverlay} />
      </View>

      {/* Top Bar */}
      <View style={styles.topBar}>
        <View style={styles.topLeft}>
          <Pressable style={styles.backBtn} onPress={() => navigation.goBack()}>
            <Text style={styles.backBtnText}>←</Text>
          </Pressable>
          <Image source={LOGO} style={styles.topLogo} resizeMode="contain" />
          <View>
            <Text style={styles.topTitle}>{t.camera.title}</Text>
            <StatusIndicator />
          </View>
        </View>
        <View style={styles.topRight}>
          <View style={[styles.modeBadge, hud.modo === "APP" && styles.modeBadgeActive]}>
            <Text style={[styles.modeText, hud.modo === "APP" && styles.modeTextActive]}>
              {hud.modo}
            </Text>
          </View>
          <Pressable style={styles.settingsBtn} onPress={() => setShowSettings(!showSettings)}>
            <Text style={styles.settingsBtnText}>⚙</Text>
          </Pressable>
        </View>
      </View>

      {/* Settings Panel */}
      <Animated.View 
        style={[
          styles.settingsPanel,
          {
            opacity: settingsAnim,
            transform: [{ translateY: settingsAnim.interpolate({
              inputRange: [0, 1],
              outputRange: [-20, 0]
            })}],
            pointerEvents: showSettings ? 'auto' : 'none'
          }
        ]}
      >
        <View style={styles.settingsContent}>
          <View style={styles.settingsHeader}>
            <Text style={styles.settingsTitle}>{t.camera.settings}</Text>
            <Pressable onPress={() => setShowSettings(false)} style={styles.closeBtn}>
              <Text style={styles.closeBtnText}>×</Text>
            </Pressable>
          </View>
          
          <Text style={styles.settingsLabel}>{t.camera.videoMode}</Text>
          <View style={styles.modeToggle}>
            <Pressable 
              style={[styles.modeOption, mode === "mjpeg" && styles.modeOptionActive]}
              onPress={() => setMode("mjpeg")}
            >
              <Text style={[styles.modeOptionText, mode === "mjpeg" && styles.modeOptionTextActive]}>
                MJPEG
              </Text>
            </Pressable>
            <Pressable 
              style={[styles.modeOption, mode === "snapshot" && styles.modeOptionActive]}
              onPress={() => setMode("snapshot")}
            >
              <Text style={[styles.modeOptionText, mode === "snapshot" && styles.modeOptionTextActive]}>
                Snapshot
              </Text>
            </Pressable>
          </View>

          <Text style={styles.settingsLabel}>{t.camera.ipAddress}</Text>
          <View style={styles.ipRow}>
            <TextInput
              style={styles.ipInput}
              value={ip}
              onChangeText={setIp}
              placeholder="192.168.3.3"
              placeholderTextColor={PALETTE.sub}
              autoCapitalize="none"
              autoCorrect={false}
              keyboardType={Platform.OS === "android" ? "numeric" : "numbers-and-punctuation"}
            />
            <Pressable style={styles.testBtn} onPress={checkStatus}>
              <Text style={styles.testBtnText}>{t.camera.testButton}</Text>
            </Pressable>
          </View>
          {!!err && <Text style={styles.errorText} numberOfLines={2}>{err}</Text>}
        </View>
      </Animated.View>

      {/* Control Pad */}
      <View style={styles.controlPad}>
        <View style={styles.dpadContainer}>
          <View style={styles.dpadRow}>
            <Pressable style={[styles.dpadBtn, styles.dpadBtnSide]} onPress={() => sendCmd("LEFT", 180)}>
              <Text style={styles.dpadIcon}>◀</Text>
            </Pressable>
            <Pressable style={[styles.dpadBtn, styles.dpadBtnMain]} onPress={() => sendCmd("FWD", 260)}>
              <Text style={styles.dpadIcon}>▲</Text>
            </Pressable>
            <Pressable style={[styles.dpadBtn, styles.dpadBtnSide]} onPress={() => sendCmd("RIGHT", 180)}>
              <Text style={styles.dpadIcon}>▶</Text>
            </Pressable>
          </View>
          <View style={styles.dpadRow}>
            <Pressable style={[styles.dpadBtn, styles.dpadBtnStop]} onPress={() => sendCmd("STOP")}>
              <Text style={[styles.dpadIcon, { fontSize: 18 }]}>■</Text>
            </Pressable>
            <Pressable style={[styles.dpadBtn, styles.dpadBtnMain]} onPress={() => sendCmd("BACK", 240)}>
              <Text style={styles.dpadIcon}>▼</Text>
            </Pressable>
          </View>
        </View>
      </View>

      {/* Right Panel */}
      <View style={styles.rightPanel}>
        {/* Velocidade */}
        <View style={styles.infoCard}>
          <Text style={styles.cardTitle}>{t.camera.speed}</Text>
          <Text style={styles.velDisplay}>{velocidade}%</Text>
          <View style={styles.velControls}>
            <Pressable style={styles.velBtn} onPress={() => setVel(velocidade - 10)}>
              <Text style={styles.velBtnText}>−</Text>
            </Pressable>
            <View style={styles.velBarContainer}>
              <View style={[styles.velBarFill, { width: `${velocidade}%` }]} />
            </View>
            <Pressable style={styles.velBtn} onPress={() => setVel(velocidade + 10)}>
              <Text style={styles.velBtnText}>+</Text>
            </Pressable>
          </View>
          <View style={styles.velPresets}>
            {[30, 60, 100].map(v => (
              <Pressable key={v} style={styles.velPreset} onPress={() => setVel(v)}>
                <Text style={styles.velPresetText}>{v}%</Text>
              </Pressable>
            ))}
          </View>
        </View>

        {/* Bomba */}
        <View style={styles.infoCard}>
          <Text style={styles.cardTitle}>{t.camera.pump}</Text>
          <Pressable style={styles.pumpBtn} onPress={() => togglePump(true)}>
            <Text style={styles.pumpBtnText}>{t.camera.pumpOn}</Text>
          </Pressable>
          <Pressable style={[styles.pumpBtn, styles.pumpBtnOff]} onPress={() => togglePump(false)}>
            <Text style={styles.pumpBtnText}>{t.camera.pumpOff}</Text>
          </Pressable>
        </View>

        {/* Sensores */}
        <View style={styles.infoCard}>
          <Text style={styles.cardTitle}>{t.camera.sensors}</Text>
          <View style={styles.fireGrid}>
            <FireBadge label={t.camera.left} active={hud.fogoE} />
            <FireBadge label={t.camera.middle} active={hud.fogoM} />
            <FireBadge label={t.camera.right} active={hud.fogoD} />
          </View>
        </View>

        {/* Água */}
        <View style={styles.infoCard}>
          <Text style={styles.cardTitle}>{t.camera.water}</Text>
          <Text style={styles.waterLevel}>{hud.nivelAguaPct}%</Text>
          <View style={styles.waterBar}>
            <View style={[styles.waterBarFill, { 
              width: `${Math.max(0, Math.min(100, hud.nivelAguaPct))}%`,
              backgroundColor: hud.nivelAguaPct > 40 ? PALETTE.green : 
                               hud.nivelAguaPct > 20 ? "#ffbb33" : PALETTE.danger
            }]} />
          </View>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: PALETTE.bg },
  viewer: { ...StyleSheet.absoluteFillObject, backgroundColor: "#000" },
  viewerOverlay: { 
    ...StyleSheet.absoluteFillObject, 
    backgroundColor: "rgba(0,0,0,0.1)",
    pointerEvents: "none"
  },

  // Top Bar
  topBar: {
    position: "absolute", top: 0, left: 0, right: 0,
    flexDirection: "row", justifyContent: "space-between", alignItems: "center",
    paddingHorizontal: 16, paddingTop: 50, paddingBottom: 14,
    backgroundColor: "rgba(10,10,15,0.96)",
    borderBottomWidth: 1, borderBottomColor: PALETTE.border,
    shadowColor: "#000", shadowOpacity: 0.5, shadowRadius: 10, elevation: 10,
  },
  topLeft: { flexDirection: "row", alignItems: "center", gap: 12 },
  backBtn: {
    width: 36, height: 36, borderRadius: 18,
    backgroundColor: PALETTE.card, alignItems: "center", justifyContent: "center",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  backBtnText: { color: PALETTE.white, fontSize: 24, fontWeight: "800" },
  topLogo: { width: 32, height: 32 },
  topTitle: { color: PALETTE.white, fontSize: 19, fontWeight: "800", letterSpacing: 0.5 },
  statusRow: { flexDirection: "row", alignItems: "center", gap: 6, marginTop: 2 },
  statusDot: { width: 7, height: 7, borderRadius: 4 },
  statusText: { fontSize: 11, fontWeight: "600" },
  topRight: { flexDirection: "row", gap: 8, alignItems: "center" },
  modeBadge: {
    paddingHorizontal: 11, paddingVertical: 6, borderRadius: 20,
    backgroundColor: PALETTE.card, borderWidth: 1, borderColor: PALETTE.border,
  },
  modeBadgeActive: { backgroundColor: PALETTE.red, borderColor: PALETTE.red },
  modeText: { color: PALETTE.sub, fontSize: 11, fontWeight: "700" },
  modeTextActive: { color: PALETTE.white },
  settingsBtn: {
    width: 36, height: 36, borderRadius: 18,
    backgroundColor: PALETTE.card, alignItems: "center", justifyContent: "center",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  settingsBtnText: { fontSize: 16 },

  // Settings Panel
  settingsPanel: {
    position: "absolute", top: 110, left: 16, right: 16,
    backgroundColor: PALETTE.card, borderRadius: 16, borderWidth: 1, borderColor: PALETTE.border,
    shadowColor: "#000", shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.4, shadowRadius: 12,
    elevation: 10,
  },
  settingsContent: { padding: 16 },
  settingsHeader: { flexDirection: "row", justifyContent: "space-between", alignItems: "center", marginBottom: 14 },
  settingsTitle: { color: PALETTE.white, fontSize: 18, fontWeight: "800" },
  closeBtn: { width: 28, height: 28, alignItems: "center", justifyContent: "center" },
  closeBtnText: { color: PALETTE.sub, fontSize: 32, fontWeight: "300" },
  settingsLabel: { color: PALETTE.sub, fontSize: 12, fontWeight: "600", marginBottom: 8, marginTop: 10 },
  modeToggle: { flexDirection: "row", gap: 8 },
  modeOption: {
    flex: 1, paddingVertical: 10, borderRadius: 10,
    backgroundColor: PALETTE.bgLight, borderWidth: 1, borderColor: PALETTE.border,
    alignItems: "center",
  },
  modeOptionActive: { backgroundColor: PALETTE.red, borderColor: PALETTE.red },
  modeOptionText: { color: PALETTE.sub, fontWeight: "700", fontSize: 13 },
  modeOptionTextActive: { color: PALETTE.white },
  ipRow: { flexDirection: "row", gap: 8 },
  ipInput: {
    flex: 1, backgroundColor: PALETTE.bgLight, borderWidth: 1, borderColor: PALETTE.border,
    borderRadius: 10, paddingHorizontal: 12, paddingVertical: 10,
    color: PALETTE.white, fontSize: 14,
  },
  testBtn: {
    paddingHorizontal: 16, paddingVertical: 10, borderRadius: 10,
    backgroundColor: PALETTE.blue, alignItems: "center", justifyContent: "center",
  },
  testBtnText: { color: PALETTE.white, fontWeight: "700", fontSize: 13 },
  errorText: { color: PALETTE.danger, fontSize: 11, marginTop: 8 },

  // Control Pad
  controlPad: { position: "absolute", left: 16, bottom: 16 },
  dpadContainer: { gap: 8 },
  dpadRow: { flexDirection: "row", gap: 8, justifyContent: "center" },
  dpadBtn: {
    width: 60, height: 60, borderRadius: 14,
    alignItems: "center", justifyContent: "center",
    borderWidth: 2,
    shadowColor: "#000", shadowOpacity: 0.4, shadowRadius: 8, elevation: 6,
  },
  dpadBtnMain: {
    backgroundColor: PALETTE.red, borderColor: PALETTE.redDark,
    shadowColor: PALETTE.red,
  },
  dpadBtnSide: {
    backgroundColor: "rgba(255,68,68,0.25)", borderColor: PALETTE.red,
  },
  dpadBtnStop: {
    backgroundColor: "rgba(204,0,0,0.35)", borderColor: PALETTE.redDark,
  },
  dpadIcon: { color: PALETTE.white, fontSize: 24, fontWeight: "800" },

  // Right Panel
  rightPanel: { position: "absolute", right: 16, top: 120, width: 200, gap: 10 },
  infoCard: {
    backgroundColor: "rgba(26,26,36,0.96)", borderRadius: 14,
    padding: 12, borderWidth: 1, borderColor: PALETTE.border,
    shadowColor: "#000", shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.4, shadowRadius: 6,
    elevation: 6,
  },
  cardTitle: { color: PALETTE.white, fontSize: 12, fontWeight: "800", marginBottom: 8, letterSpacing: 0.5 },

  // Velocidade
  velDisplay: { color: PALETTE.white, fontSize: 26, fontWeight: "800", textAlign: "center", marginBottom: 6 },
  velControls: { flexDirection: "row", alignItems: "center", gap: 8 },
  velBtn: {
    width: 30, height: 30, borderRadius: 8,
    backgroundColor: PALETTE.red, alignItems: "center", justifyContent: "center",
  },
  velBtnText: { color: PALETTE.white, fontSize: 18, fontWeight: "800" },
  velBarContainer: {
    flex: 1, height: 11, borderRadius: 6,
    backgroundColor: PALETTE.bgLight, overflow: "hidden",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  velBarFill: { height: "100%", backgroundColor: PALETTE.red },
  velPresets: { flexDirection: "row", gap: 6, marginTop: 8 },
  velPreset: {
    flex: 1, paddingVertical: 6, borderRadius: 8,
    backgroundColor: PALETTE.bgLight, borderWidth: 1, borderColor: PALETTE.border,
    alignItems: "center",
  },
  velPresetText: { color: PALETTE.white, fontSize: 11, fontWeight: "700" },

  // Bomba
  pumpBtn: {
    backgroundColor: PALETTE.green, borderRadius: 10, paddingVertical: 9,
    alignItems: "center", marginBottom: 6,
  },
  pumpBtnOff: { backgroundColor: PALETTE.danger },
  pumpBtnText: { color: PALETTE.white, fontWeight: "800", fontSize: 12 },

  // Sensores
  fireGrid: { flexDirection: "row", gap: 6, flexWrap: "wrap" },
  fireBadge: {
    flexDirection: "row", alignItems: "center", gap: 5,
    paddingHorizontal: 9, paddingVertical: 5, borderRadius: 20,
    backgroundColor: PALETTE.bgLight, borderWidth: 1, borderColor: PALETTE.border,
  },
  fireBadgeActive: {
    backgroundColor: "rgba(255,51,51,0.2)", borderColor: PALETTE.danger,
  },
  fireDot: { width: 5, height: 5, borderRadius: 3 },
  fireLabel: { fontSize: 10, fontWeight: "700" },

  // Água
  waterLevel: { color: PALETTE.white, fontSize: 28, fontWeight: "800", textAlign: "center", marginBottom: 6 },
  waterBar: {
    height: 12, borderRadius: 6, backgroundColor: PALETTE.bgLight,
    overflow: "hidden", borderWidth: 1, borderColor: PALETTE.border,
  },
  waterBarFill: { height: "100%" },
});










Faça com que o dispositivo automaticamente vá para o telefone com o numero 123456 discado caso fogo seja detectado. Além disso, faça uma opção para simular a detecçao de fogo na tela Camera (para testar as funcionalidades). Também suba um pouquinho a posição do controle de movimento do carrinho.
