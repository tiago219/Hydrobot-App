
Beleza ‚Äî hasFrame:false no /healthz significa que o servidor ainda n√£o conseguiu ler o /stream do ESP. O mais comum √©:




o servidor est√° tentando hydrobot.local (mDNS) e n√£o resolve;


o ESP n√£o est√° acess√≠vel pelo IP certo;


o stream /stream n√£o est√° abrindo (rede/sub-rede diferentes ou firewall).




Fa√ßa isso, na ordem, e n√£o precisa mudar c√≥digo:


1) Confirme o IP real do ESP




No Serial Monitor do Arduino IDE aparece o IP ao conectar (‚ÄúWiFi: 192.168.x.y‚Äù).


Ou entre em http://hydrobot.local/ pelo celular/PC ‚Äî se abrir a p√°gina do ESP, copie o IP exibido.




2) Diga ao servidor qual IP usar


Abra o Swagger do FastAPI no PC onde o servidor roda:

http://SEU_SERVIDOR:8000/docs




Clique em POST /config ‚Üí Try it out ‚Üí em camera_ip coloque o IP do ESP, por ex.:

{ "camera_ip": "192.168.3.3" }





Execute ‚Üí deve retornar {ok:true, camera_ip:"192.168.3.3"}.






Alternativas se preferir linha de comando:

curl -X POST http://SEU_SERVIDOR:8000/config -H "Content-Type: application/json" -d '{"camera_ip":"192.168.3.3"}'




3) Teste direto no ESP


No mesmo PC do servidor, abra:




http://192.168.3.3/snapshot ‚Üí deve baixar uma foto.


http://192.168.3.3/stream ‚Üí deve abrir o MJPEG (p√°gina ‚Äúquebrando‚Äù com imagens trocando).




Se isso n√£o abrir, o problema √© rede (sub-redes diferentes, firewall do PC/roteador, ESP n√£o conectado ao mesmo Wi-Fi).


4) Volte ao /healthz


Abra http://SEU_SERVIDOR:8000/healthz. Se tudo ok, ver√° algo como:


{"ok":true,"camera_ip":"192.168.3.3","ip":"192.168.3.3","hasFrame":true,"age_ms":...,"fps_in":...,"last_err":null}




Se ainda ficar hasFrame:false


Cheque estes pontos r√°pidos:




mDNS n√£o funciona no seu PC/roteador ‚Üí use IP num√©rico e sempre fa√ßa o POST /config.


Firewall do servidor: permita sa√≠da HTTP (porta 80) e entrada na porta 8000 (se o app acessa de outro dispositivo).


Sub-rede: PC (servidor) e ESP precisam estar na mesma (ex.: 192.168.3.*).


ESP: confirme /stream est√° respondendo; se cair, baixe a press√£o:



no .ino, deixe FRAMESIZE_QVGA e JPEG_QUALITY 30;


aumente STREAM_MIN_DELAY_MS para 90‚Äì110 ms;


mantenha WiFi.setSleep(false);


fonte 5 V robusta.








Se quiser, me diga o IP do ESP e o IP do servidor (e se /snapshot abre direto no browser). Com isso eu te digo exatamente onde est√° o gargalo.








































Perfeito. Abaixo est√£o os tr√™s c√≥digos completos j√° ajustados para eliminar os crashes:




ESP32-CAM servindo /stream (MJPEG) com backpressure, /snapshot leve, Wi-Fi sem sleep, compress√£o mais alta, resolu√ß√£o conservadora, reinit defensivo.


Servidor FastAPI lendo /stream, guardando o √∫ltimo frame em mem√≥ria, servindo /frame.jpg e calculando score de fogo (HSV + EMA).


CameraScreen.tsx consumindo apenas o servidor (/frame.jpg + /detect), com crossfade e fallbacks suaves (sem pressionar o ESP).





1) ESP32-CAM (Arduino) ‚Äî HydroBot_ESP32CAM_Stable.ino


/*
  HydroBot - ESP32-CAM (AI Thinker) ‚Äì Perfil EST√ÅVEL (anti-crash)
  - Endpoints:
      GET  /              -> p√°gina info
      GET  /status        -> JSON (uptime, RSSI, heap, ip, √∫ltimo STATUS do Arduino)
      GET  /snapshot      -> JPEG √∫nico (usa fb direto, sem c√≥pias)
      GET  /stream        -> MJPEG stream (limite de FPS + reinit defensivo)
      POST /uart?cmd=...  -> envia comando na UART (ex: CMD:FWD:ms=400:spd=70)
      POST /led?on=0|1    -> liga/desliga flash (GPIO 4)
      POST /restart       -> reinicia
  - mDNS: http://hydrobot.local
  - CORS: *
  - UART: Serial2 (RX=15, TX=14) ‚Äî ajuste se necess√°rio
*/

#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include "esp_camera.h"
#include "soc/rtc_cntl_reg.h"
#include "esp_timer.h"

// ====== CONFIG Wi-Fi ======
const char* WIFI_SSID = "HydroBot";
const char* WIFI_PASS = "loud2025emibr";

// (Opcional) IP fixo ‚Äî comente para DHCP
//#define USE_STATIC_IP
IPAddress local_IP(192,168,0,50);
IPAddress gateway(192,168,0,1);
IPAddress subnet(255,255,255,0);
IPAddress dns1(8,8,8,8);
IPAddress dns2(1,1,1,1);

// mDNS
const char* MDNS_NAME = "hydrobot"; // http://hydrobot.local

// ====== UART p/ Arduino ======
#define UART_RX_PIN 15
#define UART_TX_PIN 14
#define UART_BAUD   115200
#define STATUS_POLL_MS 1000

// ====== CAMERA PINS (AI Thinker) ======
#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

// ====== SERVER ======
WebServer server(80);
String lastStatusLine = "";

// LED do flash
static const int FLASH_PIN = 4;

// Parametriza√ß√£o do stream
static const char* STREAM_BOUNDARY = "frame";
static const char* STREAM_CT = "multipart/x-mixed-replace; boundary=frame";
static const int  JPEG_QUALITY = 30;        // n√∫mero MAIOR = mais compress√£o (menor arquivo)
static const bool STREAM_HFLIP  = false;
static const bool STREAM_VFLIP  = false;
static const uint16_t STREAM_MIN_DELAY_MS = 70; // ~14 fps; suba p/ 90‚Äì110ms se precisar

// Watchdogs
unsigned long lastWiFiCheck  = 0;
unsigned long lastStatusPoll = 0;

// --------- Util ---------
static inline void addCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}
void handleOptions() { addCORS(); server.send(204); }

// --------- UART ---------
void initUART() {
  Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN);
}
void pollArduinoStatus() {
  static String rxBuf;
  Serial2.print("REQ:STATUS\n");
  while (Serial2.available()) {
    char c = (char)Serial2.read();
    if (c == '\n' || c == '\r') {
      if (rxBuf.length() > 0) {
        if (rxBuf.startsWith("STAT:")) lastStatusLine = rxBuf;
        rxBuf = "";
      }
    } else {
      rxBuf += c;
    }
  }
}

// --------- C√¢mera ---------
bool initCamera() {
  // evita brownout reset
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;

  // Perfil est√°vel
  config.frame_size   = FRAMESIZE_QVGA;   // 320x240 (suba gradualmente se ficar 100% est√°vel)
  config.jpeg_quality = JPEG_QUALITY;     // 30 = compress√£o forte (menor tamanho)
  config.fb_count     = 2;
#if defined(CAMERA_GRAB_LATEST)
  config.grab_mode    = CAMERA_GRAB_LATEST;
#endif

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed 0x%x\n", err);
    return false;
  }

  sensor_t* s = esp_camera_sensor_get();
  if (s) {
    s->set_hmirror  (s, STREAM_HFLIP);
    s->set_vflip    (s, STREAM_VFLIP);
    s->set_whitebal (s, 1);
    s->set_awb_gain (s, 1);
    s->set_exposure_ctrl(s, 1);
    s->set_gain_ctrl(s, 1);
    s->set_brightness(s, -1);  // reduz brilho ‚Üí menos bytes no JPEG
  }
  return true;
}

void safeReinitCamera() {
  esp_camera_deinit();
  delay(120);
  initCamera();
}

// --------- Handlers ---------
void handleRoot() {
  addCORS();
  String html = "<!doctype html><html><head><meta charset='utf-8'/>"
                "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
                "<title>HydroBot ESP32-CAM</title>"
                "<style>body{font-family:system-ui;background:#0b0b0f;color:#e5e7eb;padding:16px}"
                "a,button{background:#e6403a;color:#fff;padding:8px 12px;border:none;border-radius:8px;text-decoration:none;margin-right:8px}"
                "code{background:#121218;padding:2px 6px;border-radius:6px}</style></head><body>";
  html += "<h2>HydroBot ESP32-CAM (Est√°vel)</h2>";
  html += "<p>IP: <code>" + WiFi.localIP().toString() + "</code> | RSSI: <code>" + String(WiFi.RSSI()) + " dBm</code></p>";
  html += "<p>Heap livre: <code>" + String(ESP.getFreeHeap()) + " bytes</code> | JPEG quality: <code>" + String(JPEG_QUALITY) + "</code></p>";
  html += "<p><a href='/snapshot'>/snapshot</a> <a href='/stream'>/stream</a> <a href='/status'>/status</a></p>";
  html += "<p>mDNS: <code>http://" + String(MDNS_NAME) + ".local</code></p>";
  html += "<p>√öltimo STATUS Arduino: <code>" + (lastStatusLine.length()? lastStatusLine : "(ainda n√£o)") + "</code></p>";
  html += "</body></html>";
  server.send(200, "text/html", html);
}

void handleStatus() {
  addCORS();
  String json = "{";
  json += "\"ip\":\"" + WiFi.localIP().toString() + "\",";
  json += "\"rssi\":" + String(WiFi.RSSI()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"uptime_ms\":" + String(millis()) + ",";
  json += "\"jpeg_quality\":" + String(JPEG_QUALITY) + ",";
  json += "\"arduino_status\":\"" + lastStatusLine + "\"";
  json += "}";
  server.send(200, "application/json", json);
}

void handleSnapshot() {
  addCORS();
  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb) { server.send(503, "text/plain", "Camera capture failed"); return; }

  server.sendHeader("Content-Type", "image/jpeg");
  server.sendHeader("Content-Disposition", "inline; filename=capture.jpg");
  server.sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  server.send_P(200, "image/jpeg", (const char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

void handleStream() {
  WiFiClient client = server.client();

  client.println("HTTP/1.1 200 OK");
  client.println("Content-Type: multipart/x-mixed-replace; boundary=frame");
  client.println("Access-Control-Allow-Origin: *");
  client.println("Cache-Control: no-cache, no-store, must-revalidate");
  client.println("Pragma: no-cache");
  client.println();

  uint8_t failStreak = 0;

  while (client.connected()) {
    camera_fb_t* fb = esp_camera_fb_get();
    if (!fb) {
      failStreak++;
      if (failStreak >= 5) { safeReinitCamera(); failStreak = 0; }
      delay(40);
      continue;
    }
    failStreak = 0;

    client.println("--frame");
    client.println("Content-Type: image/jpeg");
    client.print("Content-Length: ");
    client.println(fb->len);
    client.println();
    client.write(fb->buf, fb->len);
    client.println();

    esp_camera_fb_return(fb);

    delay(STREAM_MIN_DELAY_MS); // limita FPS ‚Üí menos calor/mem√≥ria
    if (!client.connected()) break;
    yield();
  }
}

void handleUART() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  String cmd = server.arg("cmd");
  if (!cmd.length()) { server.send(400, "application/json", "{\"error\":\"use /uart?cmd=...\"}"); return; }
  if (!cmd.endsWith("\n")) cmd += "\n";
  Serial2.print(cmd);
  server.send(200, "application/json", "{\"ok\":true}");
}

void handleLED() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  int on = server.arg("on").toInt();
  digitalWrite(FLASH_PIN, on ? HIGH : LOW);
  server.send(200, "application/json", String("{\"on\":") + (on? "true":"false") + "}");
}

void handleRestart() {
  addCORS();
  server.send(200, "application/json", "{\"restarting\":true}");
  delay(300);
  ESP.restart();
}

// --------- Wi-Fi ---------
void connectWiFi() {
#ifdef USE_STATIC_IP
  WiFi.config(local_IP, gateway, subnet, dns1, dns2);
#endif
  WiFi.mode(WIFI_STA);
  WiFi.setSleep(false); // MUITO IMPORTANTE p/ stream est√°vel
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 15000) {
    delay(250);
  }
}

void setupServer() {
  server.on("/",       HTTP_GET,     handleRoot);
  server.on("/status", HTTP_GET,     handleStatus);
  server.on("/snapshot", HTTP_GET,   handleSnapshot);
  server.on("/stream", HTTP_GET,     handleStream);
  server.on("/uart",   HTTP_POST,    handleUART);
  server.on("/led",    HTTP_POST,    handleLED);
  server.on("/restart",HTTP_POST,    handleRestart);

  server.on("/uart",   HTTP_OPTIONS, handleOptions);
  server.on("/led",    HTTP_OPTIONS, handleOptions);
  server.on("/restart",HTTP_OPTIONS, handleOptions);

  server.onNotFound([](){
    addCORS();
    server.send(404, "application/json", "{\"error\":\"not found\"}");
  });

  server.begin();
}

// --------- Setup / Loop ---------
void setup() {
  Serial.begin(115200);
  delay(200);

  pinMode(FLASH_PIN, OUTPUT);
  digitalWrite(FLASH_PIN, LOW); // evite picos

  initUART();

  if (!initCamera()) {
    Serial.println("Falha c√¢mera ‚Äì tentando novamente...");
    delay(1000);
    if (!initCamera()) { Serial.println("Falha cr√≠tica na c√¢mera"); }
  } else {
    Serial.println("C√¢mera OK");
  }

  connectWiFi();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("WiFi: " + WiFi.localIP().toString());
    if (MDNS.begin(MDNS_NAME)) {
      MDNS.addService("http", "tcp", 80);
      Serial.println("mDNS: http://" + String(MDNS_NAME) + ".local");
    }
  } else {
    Serial.println("WiFi FAIL");
  }

  setupServer();
  Serial.println("HTTP server OK");
}

void loop() {
  server.handleClient();

  if (millis() - lastWiFiCheck > 3000) {
    lastWiFiCheck = millis();
    if (WiFi.status() != WL_CONNECTED) {
      connectWiFi();
    }
  }
  if (millis() - lastStatusPoll > STATUS_POLL_MS) {
    lastStatusPoll = millis();
    pollArduinoStatus();
  }
}





Notas r√°pidas




Comece com QVGA + jpeg_quality=30. Se ficar 100% est√°vel, suba para HVGA e depois VGA, ajustando STREAM_MIN_DELAY_MS p/ 80‚Äì110 ms se necess√°rio.


Mantenha WiFi.setSleep(false), LED off, fonte 5 V est√°vel (‚â•2 A).







2) Servidor (FastAPI) ‚Äî server_heuristic.py


#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HydroBot Server (EST√ÅVEL) ‚Äì L√™ /stream (MJPEG) do ESP32-CAM, guarda o √∫ltimo frame,
serve /frame.jpg e calcula score simples de fogo (HSV + EMA).

Rodar:
  uvicorn server_heuristic:app --host 0.0.0.0 --port 8000
Deps:
  pip install fastapi uvicorn requests opencv-python numpy pydantic
"""

import time
import threading
from typing import Optional, Dict, Any
import re

import requests
import cv2
import numpy as np
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ========= CONFIG =========
CAMERA_IP = "hydrobot.local"
STREAM_URL_FMT = "http://{}/stream"
CONNECT_TIMEOUT = 3.0
READ_TIMEOUT = 10.0
MAX_FRAME_AGE_MS = 10_000
MAX_RESULT_AGE_MS = 800
JPEG_QUALITY = 85

# Fire (HSV simples)
HSV_LOW = (8, 70, 120)
HSV_HIGH = (40, 255, 255)
EMA_ALPHA = 0.3
FIRE_THRESHOLD = 0.15

BOUNDARY_RE = re.compile(br'--[^\r\n]+')
REQ_HEADERS = {"Connection": "keep-alive", "User-Agent": "HydroBot-Grabber/3.0"}

# ========= FASTAPI =========
app = FastAPI(title="HydroBot Server (Stable)", version="4.0")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True,
                   allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
  camera_ip: str

def placeholder_jpeg(msg: str = "NO FRAME") -> bytes:
  img = np.zeros((240, 320, 3), dtype=np.uint8)
  img[:, :] = (50, 50, 150)
  cv2.putText(img, msg, (38, 130), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
  cv2.putText(img, time.strftime("%H:%M:%S"), (38, 180), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
  ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY])
  return buf.tobytes()

# ========= MJPEG Stream Grabber =========
class StreamGrabber:
  def __init__(self, ip: str):
    self.ip = ip
    self._stop = threading.Event()
    self._lock = threading.Lock()
    self._last_jpeg: Optional[bytes] = None
    self._last_ts = 0
    self._fps_in = 0.0
    self._frames = 0
    self._tick = time.time()
    self._last_err: Optional[str] = None

  def start(self):
    self._stop.clear()
    t = threading.Thread(target=self._run, daemon=True)
    t.start()

  def stop(self):
    self._stop.set()

  def _run(self):
    while not self._stop.is_set():
      url = STREAM_URL_FMT.format(self.ip)
      buf = b""
      try:
        with requests.get(url, stream=True, timeout=(CONNECT_TIMEOUT, READ_TIMEOUT), headers=REQ_HEADERS) as r:
          r.raise_for_status()
          for chunk in r.iter_content(chunk_size=4096):
            if self._stop.is_set():
              break
            if not chunk:
              continue
            buf += chunk

            # procurar boundaries e extrair o pen√∫ltimo part (frame completo)
            m = BOUNDARY_RE.search(buf)
            if not m:
              if len(buf) > 2_000_000:
                buf = buf[-200_000:]
              continue

            parts = BOUNDARY_RE.split(buf)
            if len(parts) >= 2:
              frame_blob = parts[-2]
              buf = parts[-1]

              header_end = frame_blob.find(b"\r\n\r\n")
              if header_end == -1:
                continue
              body = frame_blob[header_end+4:]

              if body.startswith(b"\xff\xd8") and body.endswith(b"\xff\xd9"):
                with self._lock:
                  self._last_jpeg = body
                  self._last_ts = int(time.time()*1000)
                  self._last_err = None
                  self._frames += 1
                  now = time.time()
                  if now - self._tick >= 1.0:
                    self._fps_in = self._frames / (now - self._tick)
                    self._frames = 0
                    self._tick = now

      except Exception as e:
        with self._lock:
          self._last_err = str(e)
        time.sleep(0.8)  # backoff curto e reconecta

  def get_latest(self, max_age_ms=MAX_FRAME_AGE_MS) -> Optional[bytes]:
    with self._lock:
      if not self._last_jpeg:
        return None
      if int(time.time()*1000) - self._last_ts > max_age_ms:
        return None
      return self._last_jpeg

  def status(self) -> Dict[str, Any]:
    with self._lock:
      age = int(time.time()*1000) - self._last_ts if self._last_ts else None
      return {
        "ip": self.ip,
        "hasFrame": self._last_jpeg is not None,
        "age_ms": age,
        "fps_in": round(self._fps_in, 2),
        "last_err": self._last_err
      }

grabber = StreamGrabber(CAMERA_IP)
grabber.start()

# ========= Fire Detection =========
def simple_fire_score(frame_bgr: np.ndarray) -> float:
  try:
    hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))
    fire_ratio = float(np.count_nonzero(mask)) / float(mask.size)
    v_mean = float(np.mean(hsv[:, :, 2])) / 255.0
    score = min(1.0, fire_ratio * 4.0 + v_mean * 0.1)
    return float(score)
  except Exception:
    return 0.0

class FireDetector:
  def __init__(self, src: StreamGrabber):
    self.src = src
    self._lock = threading.Lock()
    self._stop = threading.Event()
    self._thr: Optional[threading.Thread] = None

    self._ema = 0.0
    self._raw = 0.0
    self._is_fire = False
    self._ts = 0
    self._fps = 0.0
    self._frames = 0
    self._tick = time.time()
    self._wh: Optional[tuple] = None

  def start(self):
    self._stop.clear()
    self._thr = threading.Thread(target=self._run, daemon=True)
    self._thr.start()

  def stop(self):
    self._stop.set()
    if self._thr and self._thr.is_alive():
      self._thr.join(timeout=1.0)

  def _run(self):
    interval = 1.0 / 5.0
    while not self._stop.is_set():
      t0 = time.time()
      jpeg = self.src.get_latest()
      if jpeg is None:
        time.sleep(0.1)
        continue
      try:
        frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
        if frame is None:
          time.sleep(0.05)
          continue
        H, W = frame.shape[:2]
        score = simple_fire_score(frame)
        ema = score if self._ema == 0.0 else EMA_ALPHA*score + (1.0-EMA_ALPHA)*self._ema
        is_fire = (ema >= FIRE_THRESHOLD)
        with self._lock:
          self._raw = score
          self._ema = ema
          self._is_fire = is_fire
          self._ts = int(time.time()*1000)
          self._wh = (W, H)
          self._frames += 1
          now = time.time()
          if now - self._tick >= 1.0:
            self._fps = self._frames / (now - self._tick)
            self._frames = 0
            self._tick = now
      except Exception:
        pass
      dt = time.time() - t0
      time.sleep(max(0.0, interval - dt))

  def get(self) -> Dict[str, Any]:
    with self._lock:
      return {
        "ok": True,
        "isFire": bool(self._is_fire),
        "score": round(float(self._ema), 3),
        "score_raw": round(float(self._raw), 3),
        "ts": int(self._ts),
        "fps_det": round(float(self._fps), 2),
        "frame_wh": list(self._wh) if self._wh else None
      }

detector = FireDetector(grabber)
detector.start()

# ========= Endpoints =========
@app.get("/healthz")
def healthz():
  s = grabber.status()
  return {"ok": True, "camera_ip": s.get("ip"), **s}

@app.get("/status")
def status():
  s = grabber.status()
  d = detector.get()
  return {"ok": True, "camera_ip": s.get("ip"), **s, **d}

@app.post("/config")
def set_config(cfg: ConfigIn):
  global CAMERA_IP, grabber, detector
  CAMERA_IP = cfg.camera_ip
  # reinicia o grabber
  grabber.stop()
  grabber = StreamGrabber(CAMERA_IP)
  grabber.start()
  # detector continua usando o mesmo objeto? recria para limpar estado
  detector.stop()
  detector = FireDetector(grabber)
  detector.start()
  return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
  b = grabber.get_latest() or placeholder_jpeg("NO FRAME")
  headers = {
    "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
    "Pragma": "no-cache",
    "Expires": "0",
    "Content-Type": "image/jpeg"
  }
  return Response(content=b, headers=headers, media_type="image/jpeg")

@app.get("/frame.jpg")
def frame_jpg():
  return snapshot()

@app.get("/detect")
def detect():
  res = detector.get()
  if res.get("ts", 0) and (int(time.time()*1000) - int(res["ts"]) <= MAX_RESULT_AGE_MS):
    return res
  # fallback r√°pido
  jpeg = grabber.get_latest()
  if jpeg is None:
    return {"ok": False, "error": "no recent frame"}
  frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
  if frame is None:
    return {"ok": False, "error": "decode failed"}
  score = simple_fire_score(frame)
  is_fire = (score >= FIRE_THRESHOLD)
  H, W = frame.shape[:2]
  return {
    "ok": True,
    "isFire": bool(is_fire),
    "score": round(float(score), 3),
    "score_raw": round(float(score), 3),
    "ts": int(time.time()*1000),
    "frame_wh": [W, H],
    "fallback": True
  }

if __name__ == "__main__":
  import uvicorn
  print("HydroBot Server (Stable) ‚Äî lendo /stream")
  print(f"Camera IP: {CAMERA_IP}")
  uvicorn.run(app, host="0.0.0.0", port=8000)




3) React Native ‚Äî CameraScreen.tsx (simplificado, consumindo o servidor)


// HydroBotApp2/src/screens/CameraScreen.tsx
// Vers√£o est√°vel: usa apenas o servidor (/frame.jpg e /detect). Sem ‚Äúsnapshot direto no ESP‚Äù.

import { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet,
  PanResponder, GestureResponderEvent, PanResponderGestureState,
  Image, Animated
} from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: { heroSubtitle:"Monitoramento e Controle", espIp:"ESP:", pumpOn:"BOMBA ON", pumpOff:"BOMBA OFF",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Aguardando servidor‚Ä¶", statusFail:"Falha ao conectar. Confira o Wi-Fi/IP.",
        noVideo:"Sem v√≠deo. Verifique o servidor.", fireOn:(s:number)=>`üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sem fogo ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sincronizado",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  en: { heroSubtitle:"Monitoring & Control", espIp:"ESP:", pumpOn:"PUMP ON", pumpOff:"PUMP OFF",
        server:"Server:", detecting:"Detecting‚Ä¶", waiting:"Waiting for server‚Ä¶", statusFail:"Failed to connect. Check Wi-Fi/IP.",
        noVideo:"No video. Check server.", fireOn:(s:number)=>`üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`No fire ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sync OK",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  es: { heroSubtitle:"Monitoreo y Control", espIp:"ESP:", pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Esperando servidor‚Ä¶", statusFail:"Error de conexi√≥n. Revisa Wi-Fi/IP.",
        noVideo:"Sin v√≠deo. Revisa el servidor.", fireOn:(s:number)=>`üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sin fuego ‚Ä¢ score ${s.toFixed(2)}`, synced:"Sincronizado con servidor",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
};

const DEFAULT_IP = "hydrobot.local";
const DEFAULT_SERVER = "http://192.168.0.100:8000";
const appLogo = require("../../assets/logo.png");

/* ---------- UI ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown,
}: { currentUri: string; nextUri: string; onNextLoadStart: () => void; onNextShown: (ok: boolean) => void; }) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={() => { onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- Screen ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [statusText, setStatusText] = useState(T.waiting);
  const [pumpOn, setPumpOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);
  const failCountRef = useRef(0);

  const clean = (s:string)=>s.replace(/\/+$/,"");
  const healthUrl   = useMemo(()=>`${clean(server)}/healthz`,[server]);
  const detectUrl   = useMemo(()=>`${clean(server)}/detect`,[server]);
  const frameUrl    = useMemo(()=>`${clean(server)}/frame.jpg`,[server]);
  const configUrl   = useMemo(()=>`${clean(server)}/config`,[server]);
  const uartPost    = useMemo(()=> (cmd:string)=>`http://${ip}/uart?cmd=${encodeURIComponent(cmd)}`, [ip]);
  const ledPost     = useMemo(()=> (on:boolean)=>`http://${ip}/led?on=${on?1:0}`, [ip]);

  // Sincroniza IP da c√¢mera no servidor (para o grabber do /stream)
  useEffect(()=>{
    let aborted=false;
    (async()=>{
      try{
        const r=await fetch(configUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({camera_ip:ip})});
        const j=await r.json();
        if(!aborted && j?.ok) setStatusText(`${T.synced} (${j.camera_ip})`);
      }catch{ if(!aborted) setStatusText(T.statusFail); }
    })();
    return()=>{aborted=true};
  },[ip, configUrl, T]);

  // Health do servidor
  useEffect(()=>{
    let stop=false, backoff=600;
    const poll=async()=>{
      if(stop) return;
      try{
        const r=await fetch(healthUrl); const j=await r.json();
        if(j?.ok){ setStatusText(`Server OK ‚Ä¢ fps_in:${j.fps_in||0} ‚Ä¢ hasFrame:${j.hasFrame||false}`); }
        else setStatusText(T.waiting);
      }catch{ setStatusText(T.waiting); }
      setTimeout(poll, backoff);
      backoff=Math.min(backoff*1.4, 5000);
    };
    poll(); return()=>{stop=true};
  },[healthUrl, T]);

  // Loop de frames: SEM snapshot direto no ESP ‚Äî s√≥ /frame.jpg do servidor
  useEffect(()=>{
    let stop=false, interval=220;
    setCurrentFrameUri(`${frameUrl}?ts=${Date.now()}`);
    const tick=()=>{
      if(stop) return;
      try{
        if(!loadingNextRef.current){
          setNextFrameUri(`${frameUrl}?ts=${Date.now()}`);
        }
        interval=220;
      }catch{
        interval=Math.min(interval*1.6, 1500);
      }
      setTimeout(tick, interval);
    };
    tick();
    return()=>{stop=true};
  },[frameUrl]);

  const onNextLoadStart = ()=>{ loadingNextRef.current=true; };
  const onNextShown = (ok:boolean)=>{
    if(ok){
      failCountRef.current = 0;
      if(nextFrameUri) setCurrentFrameUri(nextFrameUri);
    }else{
      failCountRef.current += 1;
    }
    loadingNextRef.current=false;
  };

  // DETECT loop (score simplificado)
  useEffect(()=>{
    let stop=false, interval=350;
    const loop=async()=>{
      if(stop) return;
      try{
        const r=await fetch(detectUrl);
        const j=await r.json();
        if(j && j.ok!==false){
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score||0));
          interval=350;
        }
      }catch{
        setIsFire(false); setFireScore(0);
        interval=Math.min(interval*1.5, 2000);
      }finally{ setTimeout(loop, interval); }
    };
    loop(); return()=>{stop=true};
  },[detectUrl]);

  // UART + LED (direto no ESP)
  async function sendUART(cmd: string) {
    try {
      const res = await fetch(uartPost(cmd), { method: "POST" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return true;
    } catch {
      setStatusText(T.statusFail);
      return false;
    }
  }
  async function togglePump(){
    const target = !pumpOn;
    const ok = await sendUART(`CMD:PUMP:${target ? "1" : "0"}`);
    if (ok) setPumpOn(target);
  }
  async function led(on:boolean){
    try{
      const res = await fetch(ledPost(on), { method: "POST" });
      const txt = await res.text();
      setStatusText(`${on?T.ledOn:T.ledOff} ‚Ä¢ ${res.status} ${txt||""}`);
    }catch{ setStatusText(T.statusFail); }
  }

  // Joystick (pulsos discretos)
  const RADIUS=64;
  const [joy, setJoy] = useState({x:0, y:0});
  const [dragging, setDragging] = useState(false);
  const pan = useRef(PanResponder.create({
    onStartShouldSetPanResponder:()=>true,
    onMoveShouldSetPanResponder:()=>true,
    onPanResponderGrant:()=>{ setDragging(true); },
    onPanResponderMove:(_e:GestureResponderEvent,g:PanResponderGestureState)=>{
      let nx=g.dx/RADIUS, ny=g.dy/RADIUS; const len=Math.hypot(nx,ny); if(len>1){ nx/=len; ny/=len; }
      setJoy({x:nx, y:-ny});
    },
    onPanResponderRelease:()=>{ setJoy({x:0,y:0}); setDragging(false); },
    onPanResponderTerminate:()=>{ setJoy({x:0,y:0}); setDragging(false); },
  })).current;

  const lastSendRef = useRef(0);
  const lastDirRef  = useRef<string>("STOP");
  const vecToDir=(x:number,y:number):"FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP"=>{
    const mag=Math.hypot(x,y); if(mag<0.2) return "STOP";
    const deg=(Math.atan2(y,x)*180)/Math.PI;
    if(deg>-45&&deg<=45) return "RIGHT";
    if(deg>45&&deg<=135) return "FWD";
    if(deg<=-45&&deg>-135) return "BACK";
    return "LEFT";
  };

  useEffect(()=>{
    let cancelled=false;
    const tick=async()=>{
      if(cancelled) return;
      const now=Date.now();
      if(now-lastSendRef.current<120){ setTimeout(tick,20); return; }
      lastSendRef.current=now;

      const {x,y}=joy;
      const mag=Math.hypot(x,y);
      const dir=vecToDir(x,y);

      if(dir!==lastDirRef.current){
        if(dir==="STOP"){ await sendUART("CMD:STOP"); }
        else{
          const ms=140+Math.round(260*Math.min(1,mag));
          const spd=50+Math.round(50*Math.min(1,mag));
          await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
        }
        lastDirRef.current=dir;
      }else if(dir!=="STOP"){
        const ms=120+Math.round(200*Math.min(1,mag));
        const spd=50+Math.round(50*Math.min(1,mag));
        await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
      }
      setTimeout(tick,120);
    };
    tick(); return()=>{cancelled=true};
  },[joy, ip]);

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder={T.placeholderIp} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={styles.input} />
        <Text style={styles.label}>{T.server}</Text>
        <TextInput value={server} onChangeText={setServer} placeholder={T.placeholderServer} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={[styles.input,{minWidth:220}]} />

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn?styles.btnOn:styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn?T.pumpOn:T.pumpOff}</Text>
        </Pressable>
        <Pressable onPress={()=>led(true)} style={[styles.btn, {backgroundColor:"#2563eb"}]}>
          <Text style={styles.btnText}>{T.ledOn}</Text>
        </Pressable>
        <Pressable onPress={()=>led(false)} style={[styles.btn, {backgroundColor:"#374151"}]}>
          <Text style={styles.btnText}>{T.ledOff}</Text>
        </Pressable>
      </View>

      <View style={[styles.statusRow,{paddingTop:4,paddingBottom:8}]}>
        <Text numberOfLines={2} style={styles.status}>{statusText}</Text>
        <View style={[styles.badge,{backgroundColor: "#065f46"}]}>
          <Text style={{ color:"#fff", fontWeight:"800" }}>{isFire ? T.detecting : T.waiting}</Text>
        </View>
      </View>

      <View style={[styles.fireBanner, isFire?styles.fireOn:styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      <View style={{ flex:1 }}>
        <CrossfadeImage
          currentUri={currentFrameUri}
          nextUri={nextFrameUri}
          onNextLoadStart={()=>{ loadingNextRef.current=true; }}
          onNextShown={(ok)=>{ if(ok && nextFrameUri) setCurrentFrameUri(nextFrameUri); loadingNextRef.current=false; }}
        />
      </View>

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap,{width:64*2+24,height:64*2+24}]}
              {...(pan.panHandlers as any)}>
          <View style={[styles.joyBase,{width:64*2,height:64*2,borderRadius:64}]} />
          <View style={[styles.joyKnob,{width:22*2,height:22*2,borderRadius:22,
                        transform:[{translateX:joy.x*64},{translateY:-joy.y*64}], opacity: dragging?1:0.9}]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", flexWrap:"wrap",
           paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:120 },
  btn:{ backgroundColor:PALETTE.accent, paddingHorizontal:10, paddingVertical:10, borderRadius:10 },
  btnOn:{ backgroundColor:"#17a34a" }, btnOff:{ backgroundColor:"#374151" },
  btnText:{ color:"white", fontWeight:"600" },

  statusRow:{ flexDirection:"row", alignItems:"center", paddingHorizontal:12, paddingVertical:8, gap:8,
              backgroundColor:"#0f1322", borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  badge:{ paddingHorizontal:10, paddingVertical:6, borderRadius:8, borderWidth:1, borderColor:PALETTE.border },
  status:{ color:"#cbd5ff", flex:1, fontSize:12 },

  fireBanner:{ alignItems:"center", justifyContent:"center", paddingVertical:6 },
  fireOn:{ backgroundColor:"#8b0000" }, fireOff:{ backgroundColor:"#223" },
  fireText:{ color:"white", fontWeight:"800" },

  joyWrap:{ position:"absolute", bottom:24, left:24, alignItems:"center", justifyContent:"center" },
  joyBase:{ position:"absolute", backgroundColor:"rgba(255,255,255,0.08)", borderWidth:2, borderColor:"rgba(255,255,255,0.14)" },
  joyKnob:{ position:"absolute", backgroundColor:"rgba(230,64,58,0.9)", borderWidth:2, borderColor:"rgba(255,255,255,0.85)" },
  joyText:{ position:"absolute", bottom:-22, color:"#cbd5ff", fontSize:12 },
});




Checklist r√°pido de integra√ß√£o




Flash o ESP com o .ino acima (board ‚ÄúAI Thinker ESP32-CAM‚Äù).


Confirme no Serial Monitor: IP, ‚ÄúHTTP server OK‚Äù.


No PC/servidor: uvicorn server_heuristic:app --host 0.0.0.0 --port 8000.


Teste no navegador:



http://SEU_SERVIDOR:8000/healthz ‚Üí hasFrame=true ap√≥s alguns segundos.


http://SEU_SERVIDOR:8000/frame.jpg ‚Üí deve mostrar o √∫ltimo frame.






No app, em Servidor, coloque http://SEU_SERVIDOR:8000. Em ESP, deixe hydrobot.local (ou IP da c√¢mera).


A tela deve atualizar fluida; se ainda cair em cena ‚Äúrica‚Äù, aumente STREAM_MIN_DELAY_MS (ESP) para 90‚Äì110ms ou suba jpeg_quality (ex.: 32) e mantenha QVGA/HVGA.




Se quiser, me manda o c√≥digo que ‚Äúfuncionava bem‚Äù para eu cruzar e manter qualquer ajuste fino que voc√™ curtiu (pins, timers, etc.).


















































// CameraScreen.tsx - Vers√£o Simplificada (apenas score de fogo)
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet,
  PanResponder, GestureResponderEvent, PanResponderGestureState,
  Image, Animated, LayoutChangeEvent,
} from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: { heroSubtitle:"Monitoramento e Controle", espIp:"ESP:", pumpOn:"BOMBA ON", pumpOff:"BOMBA OFF",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Aguardando servidor‚Ä¶", statusFail:"Falha ao conectar. Confira o Wi-Fi/IP.",
        noVideo:"Sem v√≠deo (snapshot). Verifique o servidor.", fireOn:(s:number)=>`üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sem fogo ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sincronizado",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  en: { heroSubtitle:"Monitoring & Control", espIp:"ESP:", pumpOn:"PUMP ON", pumpOff:"PUMP OFF",
        server:"Server:", detecting:"Detecting‚Ä¶", waiting:"Waiting for server‚Ä¶", statusFail:"Failed to connect. Check Wi-Fi/IP.",
        noVideo:"No video (snapshot). Check server.", fireOn:(s:number)=>`üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`No fire ‚Ä¢ score ${s.toFixed(2)}`, synced:"Server sync OK",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  es: { heroSubtitle:"Monitoreo y Control", espIp:"ESP:", pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.",
        server:"Servidor:", detecting:"Detectando‚Ä¶", waiting:"Esperando servidor‚Ä¶", statusFail:"Error de conexi√≥n. Revisa Wi-Fi/IP.",
        noVideo:"Sin v√≠deo (snapshot). Revisa el servidor.", fireOn:(s:number)=>`üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sin fuego ‚Ä¢ score ${s.toFixed(2)}`, synced:"Sincronizado con servidor",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
};

const DEFAULT_IP = "hydrobot.local";
const DEFAULT_SERVER = "http://192.168.0.100:8000";

const appLogo = require("../../assets/logo.png");

/* ---------------------- UI AUX ---------------------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown,
}: { currentUri: string; nextUri: string; onNextLoadStart: () => void; onNextShown: (ok: boolean) => void; }) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={() => { onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------------------- SCREEN ---------------------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [statusText, setStatusText] = useState(T.waiting);
  const [pumpOn, setPumpOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  const [useDirectSnapshot, setUseDirectSnapshot] = useState(false);
  const failCountRef = useRef(0);

  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const clean = (s:string)=>s.replace(/\/+$/,"");

  // Server endpoints
  const healthUrl     = useMemo(()=>`${clean(server)}/healthz`,[server]);
  const detectUrl     = useMemo(()=>`${clean(server)}/detect`,[server]);
  const snapshotSrv   = useMemo(()=>`${clean(server)}/snapshot`,[server]);
  const snapshotSrvAlt= useMemo(()=>`${clean(server)}/frame.jpg`,[server]);
  const configUrl     = useMemo(()=>`${clean(server)}/config`,[server]);

  // ESP endpoints
  const snapshotEsp   = useMemo(()=> `http://${ip}/snapshot`, [ip]);
  const uartPost      = useMemo(()=> (cmd:string)=>`http://${ip}/uart?cmd=${encodeURIComponent(cmd)}`, [ip]);
  const ledPost       = useMemo(()=> (on:boolean)=>`http://${ip}/led?on=${on?1:0}`, [ip]);

  // Sincroniza IP da c√¢mera no server
  useEffect(()=>{
    let aborted=false;
    (async()=>{
      try{
        const r=await fetch(configUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({camera_ip:ip})});
        const j=await r.json();
        if(!aborted && j?.ok) setStatusText(`${T.synced} (${j.camera_ip})`);
      }catch{ if(!aborted) setStatusText(T.statusFail); }
    })();
    return()=>{aborted=true};
  },[ip, configUrl, T]);

  // Health do servidor
  useEffect(()=>{
    let stop=false, backoff=500;
    const poll=async()=>{
      if(stop) return;
      try{
        const r=await fetch(healthUrl); const j=await r.json();
        if(j?.ok){ setStatusText(`Server OK ‚Ä¢ fps_in:${j.fps_in || 0} ‚Ä¢ hasFrame:${j.hasFrame || false}`); return; }
      }catch{}
      setStatusText(T.waiting);
      setTimeout(poll, backoff); backoff=Math.min(backoff*1.6, 5000);
    };
    poll(); return()=>{stop=true};
  },[healthUrl, T]);

  // SNAPSHOT loop com fallback server->ESP
  useEffect(()=>{
    let stop=false, interval=200; // Intervalo mais conservador
    const pickBase = ()=>{
      if (useDirectSnapshot) return snapshotEsp;
      return failCountRef.current >= 2 ? snapshotSrvAlt : snapshotSrv;
    };

    setCurrentFrameUri(`${pickBase()}?ts=${Date.now()}`);
    const tick=()=>{
      if(stop) return;
      try{
        if(!loadingNextRef.current){
          const base = pickBase();
          setNextFrameUri(`${base}?ts=${Date.now()}`);
        }
        interval=200;
      }catch{
        interval=Math.min(interval*1.7, 1500);
      }
      setTimeout(tick, interval);
    };
    tick();
    return()=>{stop=true};
  },[snapshotSrv, snapshotSrvAlt, snapshotEsp, useDirectSnapshot]);

  const onNextLoadStart = ()=>{ loadingNextRef.current=true; };
  const onNextShown = (ok:boolean)=>{
    if(ok){
      failCountRef.current = 0;
      if(useDirectSnapshot){ setUseDirectSnapshot(false); }
      if(nextFrameUri) setCurrentFrameUri(nextFrameUri);
    }else{
      failCountRef.current += 1;
      if(!useDirectSnapshot && failCountRef.current >= 3){
        setUseDirectSnapshot(true);
        failCountRef.current = 0;
      }
    }
    loadingNextRef.current=false;
  };

  // DETECT loop - SIMPLIFICADO (apenas score)
  useEffect(()=>{
    let stop=false, interval=300;
    const loop=async()=>{
      if(stop) return;
      try{
        const r=await fetch(detectUrl); 
        const j=await r.json();
        if(j && j.ok!==false){
          setIsFire(!!j.isFire); 
          setFireScore(Number(j.score||0));
          interval=300;
        }
      }catch{
        setIsFire(false); 
        setFireScore(0); 
        interval=Math.min(interval*1.5,2000);
      }finally{ 
        setTimeout(loop, interval); 
      }
    };
    loop(); return()=>{stop=true};
  },[detectUrl]);

  // ------- COMANDOS (UART + LED) -------
  async function sendUART(cmd: string) {
    try {
      const res = await fetch(uartPost(cmd), { method: "POST" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return true;
    } catch {
      setStatusText(T.statusFail);
      return false;
    }
  }

  async function togglePump(){
    const target = !pumpOn;
    const ok = await sendUART(`CMD:PUMP:${target ? "1" : "0"}`);
    if (ok) setPumpOn(target);
  }

  async function led(on:boolean){
    try{
      const res = await fetch(ledPost(on), { method: "POST" });
      const txt = await res.text();
      setStatusText(`${on?T.ledOn:T.ledOff} ‚Ä¢ ${res.status} ${txt||""}`);
    }catch{
      setStatusText(T.statusFail);
    }
  }

  // Joystick: envia PULSOS discretos por UART
  const RADIUS=64;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder:()=>true,
      onMoveShouldSetPanResponder:()=>true,
      onPanResponderGrant:()=>{ setDragging(true); },
      onPanResponderMove:(_e:GestureResponderEvent,g:PanResponderGestureState)=>{
        let nx=g.dx/RADIUS, ny=g.dy/RADIUS;
        const len=Math.hypot(nx,ny); if(len>1){ nx/=len; ny/=len; }
        setJoy({x:nx, y:-ny});
      },
      onPanResponderRelease:()=>{ setJoy({x:0,y:0}); setDragging(false); },
      onPanResponderTerminate:()=>{ setJoy({x:0,y:0}); setDragging(false); },
    })
  ).current;

  const lastSendRef = useRef(0);
  const lastDirRef  = useRef<string>("STOP");

  const vecToDir=(x:number,y:number):"FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP"=>{
    const mag=Math.hypot(x,y); if(mag<0.2) return "STOP";
    const deg=(Math.atan2(y,x)*180)/Math.PI;
    if(deg>-45&&deg<=45) return "RIGHT";
    if(deg>45&&deg<=135) return "FWD";
    if(deg<=-45&&deg>-135) return "BACK";
    return "LEFT";
  };

  useEffect(()=>{
    let cancelled=false;
    const tick=async()=>{
      if(cancelled) return;
      const now=Date.now();
      if(now-lastSendRef.current<120){ setTimeout(tick,20); return; }
      lastSendRef.current=now;

      const {x,y}=joy;
      const mag=Math.hypot(x,y);
      const dir=vecToDir(x,y);

      if(dir!==lastDirRef.current){
        if(dir==="STOP"){
          await sendUART("CMD:STOP");
        }else{
          const ms=140+Math.round(260*Math.min(1,mag));
          const spd=50+Math.round(50*Math.min(1,mag));
          await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
        }
        lastDirRef.current=dir;
      }else if(dir!=="STOP"){
        const ms=120+Math.round(200*Math.min(1,mag));
        const spd=50+Math.round(50*Math.min(1,mag));
        await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
      }

      setTimeout(tick,120);
    };
    tick(); return()=>{cancelled=true};
  },[joy, ip]);

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder={T.placeholderIp} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={styles.input} />
        <Text style={styles.label}>{T.server}</Text>
        <TextInput value={server} onChangeText={setServer} placeholder={T.placeholderServer} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={[styles.input,{minWidth:220}]} />

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn?styles.btnOn:styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn?T.pumpOn:T.pumpOff}</Text>
        </Pressable>
        <Pressable onPress={()=>led(true)} style={[styles.btn, {backgroundColor:"#2563eb"}]}>
          <Text style={styles.btnText}>{T.ledOn}</Text>
        </Pressable>
        <Pressable onPress={()=>led(false)} style={[styles.btn, {backgroundColor:"#374151"}]}>
          <Text style={styles.btnText}>{T.ledOff}</Text>
        </Pressable>
      </View>

      <View style={[styles.statusRow,{paddingTop:4,paddingBottom:8}]}>
        <Text numberOfLines={2} style={styles.status}>{statusText} {useDirectSnapshot ? "‚Ä¢ (snapshot direto)" : ""}</Text>
        <View style={[styles.badge,{backgroundColor: "#065f46"}]}>
          <Text style={{ color:"#fff", fontWeight:"800" }}>{isFire ? T.detecting : T.waiting}</Text>
        </View>
      </View>

      <View style={[styles.fireBanner, isFire?styles.fireOn:styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      {/* Video simples - sem overlay de boxes */}
      <View style={{ flex:1 }}>
        <CrossfadeImage 
          currentUri={currentFrameUri} 
          nextUri={nextFrameUri}
          onNextLoadStart={onNextLoadStart}
          onNextShown={onNextShown}
        />
      </View>

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap,{width:64*2+24,height:64*2+24}]}
              {...(pan.panHandlers as any)}>
          <View style={[styles.joyBase,{width:64*2,height:64*2,borderRadius:64}]} />
          <View style={[styles.joyKnob,{width:22*2,height:22*2,borderRadius:22,
                        transform:[{translateX:joy.x*64},{translateY:-joy.y*64}], opacity: dragging?1:0.9}]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", flexWrap:"wrap",
           paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:120 },
  btn:{ backgroundColor:PALETTE.accent, paddingHorizontal:10, paddingVertical:10, borderRadius:10 },
  btnOn:{ backgroundColor:"#17a34a" }, btnOff:{ backgroundColor:"#374151" },
  btnText:{ color:"white", fontWeight:"600" },

  statusRow:{ flexDirection:"row", alignItems:"center", paddingHorizontal:12, paddingVertical:8, gap:8,
              backgroundColor:"#0f1322", borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  badge:{ paddingHorizontal:10, paddingVertical:6, borderRadius:8, borderWidth:1, borderColor:PALETTE.border },
  status:{ color:"#cbd5ff", flex:1, fontSize:12 },

  fireBanner:{ alignItems:"center", justifyContent:"center", paddingVertical:6 },
  fireOn:{ backgroundColor:"#8b0000" }, fireOff:{ backgroundColor:"#223" },
  fireText:{ color:"white", fontWeight:"800" },

  joyWrap:{ position:"absolute", bottom:24, left:24, alignItems:"center", justifyContent:"center" },
  joyBase:{ position:"absolute", backgroundColor:"rgba(255,255,255,0.08)", borderWidth:2, borderColor:"rgba(255,255,255,0.14)" },
  joyKnob:{ position:"absolute", backgroundColor:"rgba(230,64,58,0.9)", borderWidth:2, borderColor:"rgba(255,255,255,0.85)" },
  joyText:{ position:"absolute", bottom:-22, color:"#cbd5ff", fontSize:12 },
});










# FastAPI proxy + heur√≠stica de fogo SIMPLES para ESP32-CAM

import time
import threading
from typing import Optional, Dict, Any

import cv2
import numpy as np
import requests
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ========= CONFIG SIMPLES =========
CAMERA_IP = "hydrobot.local"
SNAPSHOT_URL_FMT = "http://{}/snapshot"
CONNECT_TIMEOUT = 3.0
READ_TIMEOUT = 10.0
POLL_FPS_TARGET = 6.0
MAX_FRAME_AGE_MS = 10000
MAX_RESULT_AGE_MS = 1000
JPEG_QUALITY = 85

# Heur√≠stica simples de fogo - APENAS SCORE
HSV_LOW = (8, 70, 120)
HSV_HIGH = (40, 255, 255)
EMA_ALPHA = 0.3
FIRE_THRESHOLD = 0.15  # threshold √∫nico simples

REQUEST_HEADERS = {
    "Connection": "keep-alive",
    "User-Agent": "HydroBot-Simple/1.0",
    "Cache-Control": "no-cache",
}

def is_jpeg_bytes(b: bytes) -> bool:
    return len(b) > 4 and b[0] == 0xFF and b[1] == 0xD8

# ========= FASTAPI =========
app = FastAPI(title="HydroBot Server (Simple)", version="3.0")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True,
                   allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
    camera_ip: str

# ========= PLACEHOLDER =========
def placeholder_jpeg(msg: str = "NO FRAME") -> bytes:
    img = np.zeros((240, 320, 3), dtype=np.uint8)
    img[:, :] = (50, 50, 150)
    cv2.putText(img, msg, (50, 130), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
    cv2.putText(img, time.strftime("%H:%M:%S"), (50, 180), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
    ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY])
    return buf.tobytes()

# ========= SNAPSHOT GRABBER SIMPLES =========
class SimpleGrabber:
    def __init__(self):
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._ip = CAMERA_IP
        self._last_jpeg: Optional[bytes] = None
        self._last_ts_ms: int = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._session = requests.Session()
        self._last_err: Optional[str] = None

    def start(self, ip: Optional[str] = None):
        if ip:
            self._ip = ip
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)

    def _fetch_once(self) -> Optional[bytes]:
        try:
            u = f"{SNAPSHOT_URL_FMT.format(self._ip)}?ts={int(time.time()*1000)}"
            r = self._session.get(u, timeout=(CONNECT_TIMEOUT, READ_TIMEOUT), headers=REQUEST_HEADERS)
            
            if r.status_code == 200 and len(r.content) > 0:
                if is_jpeg_bytes(r.content):
                    return r.content
        except Exception as e:
            print(f"Fetch error: {e}")
        return None

    def _run(self):
        interval = 1.0 / POLL_FPS_TARGET
        
        while not self._stop.is_set():
            t0 = time.time()
            
            try:
                jpeg = self._fetch_once()
                if jpeg:
                    with self._lock:
                        self._last_jpeg = jpeg
                        self._last_ts_ms = int(time.time() * 1000)
                        self._last_err = None
                    
                    self._frames += 1
                    now = time.time()
                    if now - self._last_fps_tick >= 1.0:
                        self._fps = self._frames / (now - self._last_fps_tick)
                        self._frames = 0
                        self._last_fps_tick = now
                else:
                    with self._lock:
                        self._last_err = "Failed to fetch frame"
                        
            except Exception as e:
                with self._lock:
                    self._last_err = str(e)

            elapsed = time.time() - t0
            sleep_time = max(0.0, interval - elapsed)
            if not self._stop.is_set():
                time.sleep(sleep_time)

    def get_latest_jpeg(self, max_age_ms=MAX_FRAME_AGE_MS) -> Optional[bytes]:
        with self._lock:
            if self._last_jpeg is None:
                return None
            if int(time.time()*1000) - self._last_ts_ms > max_age_ms:
                return None
            return self._last_jpeg

    def status(self) -> Dict[str, Any]:
        with self._lock:
            age = int(time.time()*1000) - self._last_ts_ms if self._last_ts_ms else None
            return {
                "ip": self._ip,
                "hasFrame": self._last_jpeg is not None,
                "age_ms": age,
                "fps_in": round(self._fps, 2),
                "last_err": self._last_err
            }

grabber = SimpleGrabber()
grabber.start(CAMERA_IP)

# ========= DETEC√á√ÉO SIMPLES =========
def simple_fire_score(frame_bgr: np.ndarray) -> float:
    """Calcula score simples de fogo (0.0 a 1.0)"""
    try:
        hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
        mask = cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))
        
        # Propor√ß√£o de pixels "fogo"
        fire_pixels = np.count_nonzero(mask)
        total_pixels = mask.size
        fire_ratio = fire_pixels / total_pixels
        
        # Brilho m√©dio do canal V
        v_mean = np.mean(hsv[:,:,2]) / 255.0
        
        # Score combinado simples
        score = min(1.0, fire_ratio * 4.0 + v_mean * 0.1)
        return score
        
    except Exception as e:
        print(f"Fire detection error: {e}")
        return 0.0

class SimpleFireDetector:
    def __init__(self, src: SimpleGrabber):
        self.src = src
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        
        self._ema_score = 0.0
        self._raw_score = 0.0
        self._is_fire = False
        self._last_ts = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._frame_wh: Optional[tuple] = None

    def start(self):
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)

    def _run(self):
        interval = 1.0 / 5.0  # 5 FPS para detec√ß√£o
        
        while not self._stop.is_set():
            t0 = time.time()
            
            jpeg = self.src.get_latest_jpeg()
            if jpeg is None:
                time.sleep(0.1)
                continue
                
            try:
                frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
                if frame is None:
                    continue
                
                H, W = frame.shape[:2]
                self._frame_wh = (W, H)
                
                # Calcula score simples
                raw_score = simple_fire_score(frame)
                
                # EMA suavizado
                if self._ema_score == 0.0:
                    ema_score = raw_score
                else:
                    ema_score = EMA_ALPHA * raw_score + (1.0 - EMA_ALPHA) * self._ema_score
                
                # Detec√ß√£o simples
                is_fire = ema_score >= FIRE_THRESHOLD
                
                with self._lock:
                    self._raw_score = raw_score
                    self._ema_score = ema_score
                    self._is_fire = is_fire
                    self._last_ts = int(time.time() * 1000)
                    
                    # FPS
                    self._frames += 1
                    now = time.time()
                    if now - self._last_fps_tick >= 1.0:
                        self._fps = self._frames / (now - self._last_fps_tick)
                        self._frames = 0
                        self._last_fps_tick = now
                        
            except Exception as e:
                print(f"Detection error: {e}")
                continue
            
            elapsed = time.time() - t0
            sleep_time = max(0.0, interval - elapsed)
            if not self._stop.is_set():
                time.sleep(sleep_time)

    def get(self) -> Dict[str, Any]:
        with self._lock:
            return {
                "ok": True,
                "isFire": bool(self._is_fire),
                "score": round(float(self._ema_score), 3),
                "score_raw": round(float(self._raw_score), 3),
                "ts": int(self._last_ts),
                "fps_det": round(float(self._fps), 2),
                "frame_wh": list(self._frame_wh) if self._frame_wh else None
            }

detector = SimpleFireDetector(grabber)
detector.start()

# ========= ENDPOINTS =========
@app.get("/healthz")
def healthz():
    s = grabber.status()
    return {
        "ok": True,
        "camera_ip": s.get("ip"),
        "fps_in": s.get("fps_in"),
        "hasFrame": s.get("hasFrame"),
        "age_ms": s.get("age_ms"),
        "last_err": s.get("last_err")
    }

@app.get("/status")
def status():
    s = grabber.status()
    d = detector.get()
    return {"ok": True, "camera_ip": s["ip"], **s, **d}

@app.post("/config")
def set_config(cfg: ConfigIn):
    global CAMERA_IP
    CAMERA_IP = cfg.camera_ip
    grabber.start(CAMERA_IP)
    return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
    b = grabber.get_latest_jpeg() or placeholder_jpeg("NO RECENT FRAME")
    headers = {
        "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
        "Pragma": "no-cache",
        "Expires": "0",
        "Content-Type": "image/jpeg"
    }
    return Response(content=b, headers=headers, media_type="image/jpeg")

@app.get("/frame.jpg")
def frame_jpg():
    """Endpoint alternativo para snapshot"""
    return snapshot()

@app.get("/detect")
def detect():
    res = detector.get()
    
    # Se resultado √© recente, retorna
    if res.get("ts", 0) and (int(time.time()*1000) - res["ts"] <= MAX_RESULT_AGE_MS):
        return res
    
    # Sen√£o, faz detec√ß√£o r√°pida
    jpeg = grabber.get_latest_jpeg()
    if jpeg is None:
        return {"ok": False, "error": "no recent frame"}
    
    try:
        frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
        if frame is None:
            return {"ok": False, "error": "decode failed"}
        
        H, W = frame.shape[:2]
        score = simple_fire_score(frame)
        is_fire = score >= FIRE_THRESHOLD
        
        return {
            "ok": True,a
            "isFire": is_fire,
            "score": round(score, 3),
            "score_raw": round(score, 3),
            "ts": int(time.time()*1000),
            "frame_wh": [W, H],
            "fallback": True
        }
        
    except Exception as e:
        return {"ok": False, "error": f"detection failed: {str(e)}"}

if __name__ == "__main__":
    import uvicorn
    print("Iniciando HydroBot Server (vers√£o simplificada)...")
    print(f"Camera IP: {CAMERA_IP}")
    print(f"FPS alvo: {POLL_FPS_TARGET}")
    print(f"Fire threshold: {FIRE_THRESHOLD}")
    uvicorn.run(app, host="0.0.0.0", port=8000)












/*
  HydroBot - ESP32-CAM em modo STA (vers√£o simplificada)
  - Endpoints:
      GET  /              -> p√°gina info r√°pida
      GET  /status        -> JSON (uptime, RSSI, heap, ip, √∫ltimo STATUS do Arduino)
      GET  /snapshot      -> JPEG √∫nico
      GET  /stream        -> MJPEG stream
      POST /uart?cmd=...  -> envia comando na UART para o Arduino (ex: CMD:FWD:ms=400:spd=70)
      POST /led?on=0|1    -> liga/desliga flash (GPIO 4)
      POST /restart       -> reinicia ESP
  - mDNS: http://hydrobot.local
  - CORS: Access-Control-Allow-Origin: *
  - UART: Serial2 (pinos configur√°veis abaixo). ESP requisita "REQ:STATUS\n" periodicamente e armazena √∫ltima linha "STAT:...".
*/

#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include "esp_timer.h"
#include "img_converters.h"
#include "esp_camera.h"
#include "fb_gfx.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ====== CONFIG ======
const char* WIFI_SSID   = "HydroBot";
const char* WIFI_PASS   = "loud2025emibr";

// (Opcional) IP fixo ‚Äì deixe comentado se preferir DHCP
//#define USE_STATIC_IP
IPAddress local_IP(192,168,0,50);
IPAddress gateway(192,168,0,1);
IPAddress subnet(255,255,255,0);
IPAddress dns1(8,8,8,8);
IPAddress dns2(1,1,1,1);

// mDNS
const char* MDNS_NAME = "hydrobot"; // http://hydrobot.local

// UART com Arduino (ajuste conforme seu fio)
// Recomenda-se ESP32-CAM: RX=15, TX=14 (costuma estar dispon√≠vel nesse m√≥dulo)
#define UART_RX_PIN 15
#define UART_TX_PIN 14
#define UART_BAUD   115200

// Requisi√ß√£o peri√≥dica ao Arduino
#define STATUS_POLL_MS  1000

// Camera: selecione pinos do modelo AI Thinker
#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

// ====== FIM CONFIG ======

// Servidor HTTP
WebServer server(80);

// Buffer do √∫ltimo STATUS do Arduino
String lastStatusLine = "";

// Controle de LED do flash (AI Thinker usa GPIO 4 pra l√¢mpada)
static const int FLASH_PIN = 4;

// Controle de stream - CONFIGURA√á√ïES FIXAS SIMPLES
static const char* STREAM_BOUNDARY = "frame";
static const char* STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" "frame";
static const int JPEG_QUALITY = 25;    // QUALIDADE BAIXA FIXA para estabilidade
static const bool STREAM_HFLIP = false; 
static const bool STREAM_VFLIP = false; 

// Watchdog / reconex√£o
unsigned long lastWiFiCheck = 0;
unsigned long lastStatusPoll = 0;

// ---------- Util ----------
void addCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}
void handleOptions() {
  addCORS();
  server.send(204);
}

// ---------- UART ----------
void initUART() {
  Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN);
}
void pollArduinoStatus() {
  static String rxBuf;
  // Solicita status
  Serial2.print("REQ:STATUS\n");
  // L√™ o que chegou desde a √∫ltima chamada
  while (Serial2.available()) {
    char c = (char)Serial2.read();
    if (c == '\n' || c == '\r') {
      if (rxBuf.length() > 0) {
        // Guarda √∫ltima linha completa
        if (rxBuf.startsWith("STAT:")) {
          lastStatusLine = rxBuf;
        }
        rxBuf = "";
      }
    } else {
      rxBuf += c;
    }
  }
}

// ---------- C√¢mera SIMPLIFICADA ----------
bool initCamera() {
  // Evitar brownout reset
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;

  // CONFIGURA√á√ÉO SIMPLES E EST√ÅVEL
  config.frame_size   = FRAMESIZE_VGA;      // VGA padr√£o
  config.jpeg_quality = JPEG_QUALITY;      // Qualidade baixa fixa
  config.fb_count     = 2;                 // 2 buffers simples
  
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x\n", err);
    return false;
  }

  // Configura√ß√µes b√°sicas do sensor
  sensor_t * s = esp_camera_sensor_get();
  if (s) {
    s->set_vflip(s, STREAM_VFLIP);
    s->set_hmirror(s, STREAM_HFLIP);
    // Configura√ß√µes simples - sem adapta√ß√£o
    s->set_whitebal(s, 1);       // white balance autom√°tico
    s->set_awb_gain(s, 1);       // AWB gain autom√°tico
    s->set_exposure_ctrl(s, 1);  // controle de exposi√ß√£o autom√°tico
    s->set_gain_ctrl(s, 1);      // controle de ganho autom√°tico
  }

  return true;
}

// ---------- Handlers HTTP ----------
void handleRoot() {
  addCORS();
  String html = "<!doctype html><html><head><meta charset='utf-8'/>"
                "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
                "<title>HydroBot ESP32-CAM</title>"
                "<style>body{font-family:system-ui;background:#0b0b0f;color:#e5e7eb;padding:16px}"
                "a,button{background:#e6403a;color:#fff;padding:8px 12px;border:none;border-radius:8px;text-decoration:none;margin-right:8px}"
                "code{background:#121218;padding:2px 6px;border-radius:6px}</style></head><body>";
  html += "<h2>HydroBot ESP32-CAM (Simplificado)</h2>";
  html += "<p>IP: <code>" + WiFi.localIP().toString() + "</code> | RSSI: <code>" + String(WiFi.RSSI()) + " dBm</code></p>";
  html += "<p>Heap livre: <code>" + String(ESP.getFreeHeap()) + " bytes</code> | Qualidade JPEG: <code>" + String(JPEG_QUALITY) + "</code></p>";
  html += "<p><a href='/snapshot'>/snapshot</a> <a href='/stream'>/stream</a> <a href='/status'>/status</a></p>";
  html += "<p>mDNS: <code>http://" + String(MDNS_NAME) + ".local</code></p>";
  html += "<p>√öltimo STATUS Arduino: <code>" + (lastStatusLine.length() ? lastStatusLine : "(ainda n√£o)") + "</code></p>";
  html += "</body></html>";
  server.send(200, "text/html", html);
}

void handleStatus() {
  addCORS();
  // Monta JSON simples
  String json = "{";
  json += "\"ip\":\"" + WiFi.localIP().toString() + "\",";
  json += "\"rssi\":" + String(WiFi.RSSI()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"uptime_ms\":" + String(millis()) + ",";
  json += "\"jpeg_quality\":" + String(JPEG_QUALITY) + ",";
  // Se quiser, parse do lastStatusLine -> chave:valor
  json += "\"arduino_status\":\"" + lastStatusLine + "\"";
  json += "}";
  server.send(200, "application/json", json);
}

void handleSnapshot() {
  addCORS();
  
  camera_fb_t * fb = esp_camera_fb_get();
  
  if (!fb) {
    Serial.println("Camera capture failed");
    server.send(503, "text/plain", "Camera capture failed");
    return;
  }
  
  server.sendHeader("Content-Type", "image/jpeg");
  server.sendHeader("Content-Disposition", "inline; filename=capture.jpg");
  server.sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  
  server.send_P(200, "image/jpeg", (const char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

void handleStream() {
  WiFiClient client = server.client();
  
  // Cabe√ßalhos do stream
  client.println("HTTP/1.1 200 OK");
  client.println("Content-Type: " + String(STREAM_CONTENT_TYPE));
  client.println("Access-Control-Allow-Origin: *");
  client.println("Cache-Control: no-cache, no-store, must-revalidate");
  client.println("Pragma: no-cache");
  client.println();

  while (client.connected()) {
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) {
      delay(100);
      continue;
    }

    client.println("--" + String(STREAM_BOUNDARY));
    client.println("Content-Type: image/jpeg");
    client.println("Content-Length: " + String(fb->len));
    client.println();
    client.write(fb->buf, fb->len);
    client.println();
    
    esp_camera_fb_return(fb);

    // Delay fixo simples
    delay(50);
  }
}

void handleUART() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  String cmd = server.arg("cmd");
  if (!cmd.length()) {
    server.send(400, "application/json", "{\"error\":\"use /uart?cmd=...\"}");
    return;
  }
  // Garante terminador de linha
  if (!cmd.endsWith("\n")) cmd += "\n";
  Serial2.print(cmd);
  server.send(200, "application/json", "{\"ok\":true}");
}

void handleLED() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  int on = server.arg("on").toInt();
  digitalWrite(FLASH_PIN, on ? HIGH : LOW);
  server.send(200, "application/json", String("{\"on\":") + (on? "true":"false") + "}");
}

void handleRestart() {
  addCORS();
  server.send(200, "application/json", "{\"restarting\":true}");
  delay(300);
  ESP.restart();
}

// ---------- Wi-Fi ----------
void connectWiFi() {
#ifdef USE_STATIC_IP
  WiFi.config(local_IP, gateway, subnet, dns1, dns2);
#endif
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);

  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 15000) {
    delay(250);
  }
}

void setupServer() {
  // Rotas
  server.on("/", HTTP_GET, handleRoot);
  server.on("/status", HTTP_GET, handleStatus);
  server.on("/snapshot", HTTP_GET, handleSnapshot);
  server.on("/stream", HTTP_GET, handleStream);
  server.on("/uart", HTTP_POST, handleUART);
  server.on("/led", HTTP_POST, handleLED);
  server.on("/restart", HTTP_POST, handleRestart);

  // CORS preflight
  server.onNotFound([](){
    addCORS();
    server.send(404, "application/json", "{\"error\":\"not found\"}");
  });
  server.on("/uart", HTTP_OPTIONS, handleOptions);
  server.on("/led", HTTP_OPTIONS, handleOptions);
  server.on("/restart", HTTP_OPTIONS, handleOptions);

  server.begin();
}

// ---------- setup / loop ----------
void setup() {
  // Logs seriais (opcional). Evite compartilhar TX0/RX0 com Arduino se usar USB.
  Serial.begin(115200);
  delay(200);

  pinMode(FLASH_PIN, OUTPUT);
  digitalWrite(FLASH_PIN, LOW);

  // UART secund√°ria com Arduino
  initUART();

  // C√¢mera
  if (!initCamera()) {
    Serial.println("Falha na inicializa√ß√£o da c√¢mera, tentando novamente...");
    delay(1000);
    if (!initCamera()) {
      Serial.println("Falha cr√≠tica na c√¢mera");
    }
  } else {
    Serial.println("C√¢mera inicializada com sucesso");
  }

  // Wi-Fi
  connectWiFi();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("WiFi conectado: " + WiFi.localIP().toString());
  } else {
    Serial.println("Falha na conex√£o WiFi");
  }

  // mDNS
  if (WiFi.status() == WL_CONNECTED) {
    if (MDNS.begin(MDNS_NAME)) {
      MDNS.addService("http", "tcp", 80);
      Serial.println("mDNS iniciado: http://" + String(MDNS_NAME) + ".local");
    }
  }

  // HTTP
  setupServer();
  Serial.println("Servidor HTTP iniciado");
}

void loop() {
  server.handleClient();

  // Watch Wi-Fi & reconectar
  if (millis() - lastWiFiCheck > 3000) {
    lastWiFiCheck = millis();
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("WiFi desconectado, tentando reconectar...");
      connectWiFi();
    }
  }

  // Poll do STATUS no Arduino
  if (millis() - lastStatusPoll > STATUS_POLL_MS) {
    lastStatusPoll = millis();
    pollArduinoStatus();
  }
}
