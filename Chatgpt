App.tsx

import React from "react";
import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";
import { LogBox } from "react-native";
LogBox.ignoreLogs(["useInsertionEffect must not schedule updates"]);

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";
import DashboardScreen from "./src/screens/DashboardScreen";
import SettingsScreen from "./src/screens/SettingsScreen";

import { LanguageProvider, useLanguage } from "./src/context/LanguageContext";

export type TabParamList = {
  Home: undefined;
  Camera: undefined;
  Dashboard: undefined;
  Settings: undefined;
};

const Tab = createBottomTabNavigator<TabParamList>();

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
};

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

// Traduções simples
const labels = {
  pt: { home: "Início", camera: "Câmera", dashboard: "Dashboard", settings: "Ajustes" },
  en: { home: "Home", camera: "Camera", dashboard: "Dashboard", settings: "Settings" },
  es: { home: "Inicio", camera: "Cámara", dashboard: "Panel", settings: "Ajustes" },
};

function AppNavigator() {
  const { lang } = useLanguage();
  const L = labels[lang];

  return (
    <NavigationContainer theme={DarkThemeHB}>
      {/* key={lang} força o TabNavigator a reconfigurar rótulos/títulos ao mudar o idioma */}
      <Tab.Navigator
        key={lang}
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
              
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen
          name="Home"
          component={HomeScreen}
          // options como FUNÇÃO, para recomputar com L atualizado
          options={() => ({ title: L.home, tabBarLabel: L.home })}
        />
        <Tab.Screen
          name="Camera"
          component={CameraScreen}
          options={() => ({ title: L.camera, tabBarLabel: L.camera })}
        />
        <Tab.Screen
          name="Dashboard"
          component={DashboardScreen}
          options={() => ({ title: L.dashboard, tabBarLabel: L.dashboard })}
        />
        <Tab.Screen
          name="Settings"
          component={SettingsScreen}
          options={() => ({ title: L.settings, tabBarLabel: L.settings })}
        />
      </Tab.Navigator>
    </NavigationContainer>
  );
}

export default function App() {
  return (
    <LanguageProvider>
      <AppNavigator />
    </LanguageProvider>
  );
}











// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { View, Text, TextInput, Pressable, StyleSheet, Image, AppState, AppStateStatus } from "react-native";
import { WebView } from "react-native-webview";

type Mode = "mjpeg" | "snapshot";

const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", accent: "#e6403a", text: "#e5e7eb" };

// Utilitário de timeout para fetch
async function fetchWithTimeout(url: string, ms = 2000) {
  const ctrl = new AbortController();
  const to = setTimeout(() => ctrl.abort(), ms);
  try {
    const r = await fetch(url, { method: "GET", signal: ctrl.signal });
    return r;
  } finally {
    clearTimeout(to);
  }
}

export default function CameraScreen() {
  const [ip, setIp] = useState("192.168.4.1"); // coloque o IP do seu ESP
  const [status, setStatus] = useState("Aguardando IP");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [streamURL, setStreamURL] = useState<string>("");
  const [snapshotURL, setSnapshotURL] = useState<string>("");
  const [snapTick, setSnapTick] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  const snapTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const appState = useRef<AppStateStatus>(AppState.currentState);

  // Candidatos típicos do firmware “teste esp32”
  const streamCandidates = useMemo(() => {
    const base = (ip || "").trim();
    if (!base) return [];
    return [
      `http://${base}:81/stream`,   // padrão do exemplo oficial
      `http://${base}/stream`,      // alguns firmwares servem na 80
      `http://${base}:80/stream`,
      `http://${base}:81/mjpeg`,    // variações
      `http://${base}/mjpeg`,
    ];
  }, [ip]);

  const snapshotCandidates = useMemo(() => {
    const base = (ip || "").trim();
    if (!base) return [];
    return [
      `http://${base}/capture`,     // padrão do exemplo oficial
      `http://${base}/snapshot`,
      `http://${base}:81/capture`,
      `http://${base}:81/snapshot`,
      `http://${base}:80/capture`,
      `http://${base}:80/snapshot`,
    ];
  }, [ip]);

  // Loop do snapshot (fallback)
  const startSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) return;
    snapTimerRef.current = setInterval(() => setSnapTick((t) => (t + 1) % 1_000_000), 200); // ~5 fps estável
  }, []);
  const stopSnapshotLoop = useCallback(() => {
    if (!snapTimerRef.current) return;
    clearInterval(snapTimerRef.current);
    snapTimerRef.current = null;
  }, []);
  useEffect(() => {
    if (mode === "snapshot" && snapshotURL) startSnapshotLoop();
    else stopSnapshotLoop();
    return stopSnapshotLoop;
  }, [mode, snapshotURL, startSnapshotLoop, stopSnapshotLoop]);

  // Pausar ao ir para background
  useEffect(() => {
    const sub = AppState.addEventListener("change", (next) => {
      const prev = appState.current;
      appState.current = next;
      if (prev.match(/active/) && next.match(/inactive|background/)) {
        stopSnapshotLoop();
        setIsRunning(false);
      } else if (prev.match(/inactive|background/) && next === "active") {
        if (mode === "snapshot" && snapshotURL) startSnapshotLoop();
        if (streamURL || snapshotURL) setIsRunning(true);
      }
    });
    return () => sub.remove();
  }, [mode, snapshotURL, streamURL, startSnapshotLoop, stopSnapshotLoop]);

  // Teste/auto-detecção
  const testConnection = useCallback(async () => {
    const target = (ip || "").trim();
    if (!target) {
      setStatus("Informe o IP do ESP");
      return;
    }
    setStatus("Testando...");
    setIsRunning(false);
    stopSnapshotLoop();
    setStreamURL("");
    setSnapshotURL("");

    // 1) Tentar candidatos de MJPEG
    for (const u of streamCandidates) {
      try {
        const r = await fetchWithTimeout(u, 2000);
        if (r.ok) {
          setStreamURL(u);
          setMode("mjpeg");
          setStatus(`Conectado (MJPEG): ${u}`);
          setIsRunning(true);
          return;
        }
      } catch {}
    }

    // 2) Fallback: tentar snapshot
    for (const u of snapshotCandidates) {
      try {
        const r = await fetchWithTimeout(u, 2000);
        if (r.ok) {
          setSnapshotURL(u);
          setMode("snapshot");
          setStatus(`Conectado (Snapshot): ${u}`);
          setIsRunning(true);
          startSnapshotLoop();
          return;
        }
      } catch {}
    }

    setStatus("Falha ao conectar — verifique IP, porta 81/80 e rotas (/stream ou /capture).");
    setIsRunning(false);
  }, [ip, streamCandidates, snapshotCandidates, startSnapshotLoop, stopSnapshotLoop]);

  // HTML que carrega o MJPEG com auto-reconnect
  const mjpegHTML = useMemo(() => {
    if (!streamURL) return "";
    return `
      <!doctype html>
      <html><head><meta name="viewport" content="width=device-width, initial-scale=1"/>
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;overflow:hidden;}
        #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;}
        img{max-width:100vw;max-height:100vh;object-fit:contain;}
        #badge{position:fixed;left:8px;bottom:8px;padding:4px 8px;border-radius:8px;
               background:#121218;color:#e5e7eb;font-family:system-ui,Arial,sans-serif;font-size:12px;opacity:.7}
      </style></head>
      <body>
        <div id="wrap"><img id="mjpeg" src="${streamURL}"/></div>
        <div id="badge">${streamURL}</div>
        <script>
          const img = document.getElementById('mjpeg');
          let backoff=800;
          img.addEventListener('error',()=>{
            setTimeout(()=>{ img.src='${streamURL}?_='+Date.now(); }, backoff);
            backoff = Math.min(backoff*2, 4000);
          });
        </script>
      </body></html>
    `.trim();
  }, [streamURL]);

  const snapshotURI = useMemo(
    () => (snapshotURL ? `${snapshotURL}?_=${snapTick}` : ""),
    [snapshotURL, snapTick]
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>ESP32-CAM Viewer</Text>

      <View style={styles.row}>
        <Text style={styles.label}>ESP IP</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="ex.: 192.168.3.3"
          placeholderTextColor="#6b7280"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
        />
        <Pressable style={styles.button} onPress={testConnection}>
          <Text style={styles.buttonText}>Testar</Text>
        </Pressable>
      </View>

      <Text style={styles.status}>Status: {status} {isRunning ? " | OK" : ""}</Text>

      <View style={styles.viewer}>
        {isRunning ? (
          mode === "mjpeg" && streamURL ? (
            <WebView
              originWhitelist={["*"]}
              source={{ html: mjpegHTML, baseUrl: streamURL }}
              javaScriptEnabled
              domStorageEnabled
              allowsInlineMediaPlayback
              mediaPlaybackRequiresUserAction={false}
              allowsFullscreenVideo={false}
              mixedContentMode="always"                         // Android: libera HTTP claro
              androidHardwareAccelerationEnabled
              setSupportMultipleWindows={false}
              onError={() => {
                // se falhar, tenta cair automaticamente para snapshot candidates
                setStatus("MJPEG falhou — alternando para Snapshot...");
                setMode("snapshot");
                // escolhe o melhor snapshot disponível já conhecido ou o primeiro candidato
                setSnapshotURL((prev) => prev || snapshotCandidates[0] || "");
                startSnapshotLoop();
              }}
              style={styles.webview}
            />
          ) : (
            <Image
              source={{ uri: snapshotURI }}
              resizeMode="contain"
              style={styles.image}
              onError={() => setStatus("Erro no snapshot — verifique /capture ou /snapshot")}
            />
          )
        ) : (
          <View style={styles.placeholder}>
            <Text style={{ color: PALETTE.text, opacity: 0.7, textAlign: "center" }}>
              Informe o IP e toque em “Testar”. A tela tenta automaticamente
              <Text> :81/stream → /stream → /capture.</Text>
            </Text>
          </View>
        )}
      </View>

      {isRunning ? (
        <View style={styles.footerRow}>
          <Pressable
            style={[styles.smallBtn, mode === "mjpeg" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("mjpeg"); setStatus("Tentando MJPEG /stream..."); }}
          >
            <Text style={styles.smallBtnText}>Usar MJPEG</Text>
          </Pressable>
          <Pressable
            style={[styles.smallBtn, mode === "snapshot" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("snapshot"); setStatus("Usando Snapshot (/capture)"); }}
          >
            <Text style={styles.smallBtnText}>Usar Snapshot</Text>
          </Pressable>
        </View>
      ) : null}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, gap: 12 },
  title: { color: PALETTE.text, fontSize: 20, fontWeight: "700" },
  row: { flexDirection: "row", alignItems: "center", gap: 8 },
  label: { color: PALETTE.text },
  input: {
    flex: 1, backgroundColor: PALETTE.card, color: PALETTE.text,
    borderWidth: 1, borderColor: PALETTE.border, borderRadius: 10,
    paddingHorizontal: 10, paddingVertical: 8,
  },
  button: { backgroundColor: PALETTE.accent, paddingHorizontal: 14, paddingVertical: 10, borderRadius: 10 },
  buttonText: { color: "#fff", fontWeight: "700" },
  status: { color: PALETTE.text, opacity: 0.9 },
  viewer: {
    flex: 1, backgroundColor: "#000", borderRadius: 12, overflow: "hidden",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  webview: { flex: 1, backgroundColor: "#000" },
  image: { width: "100%", height: "100%" },
  placeholder: { flex: 1, alignItems: "center", justifyContent: "center", padding: 24 },
  footerRow: { flexDirection: "row", gap: 10, justifyContent: "center" },
  smallBtn: {
    paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1,
    borderColor: PALETTE.border, backgroundColor: PALETTE.card,
  },
  smallBtnActive: { borderColor: PALETTE.accent },
  smallBtnText: { color: PALETTE.text, fontWeight: "600" },
});










HomeScreen.tsx

import { View, Text, StyleSheet, Pressable, Dimensions, Image } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { BottomTabNavigationProp } from "@react-navigation/bottom-tabs";
import type { TabParamList } from "../../App";
import { useLanguage } from "../context/LanguageContext";

type Nav = BottomTabNavigationProp<TabParamList>;
const W = Dimensions.get("window").width;
const CARD = W / 2 - 28;

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
  textSoft: "#E6E6E6",
};

const texts = {
  pt: { title: "HydroBot", sub: "Monitoramento e Controle", cam: "Câmera", dash: "Dashboard", hint: "Use o rodapé para navegar entre as seções" },
  en: { title: "HydroBot", sub: "Monitoring & Control", cam: "Camera", dash: "Dashboard", hint: "Use the footer to navigate" },
  es: { title: "HydroBot", sub: "Monitoreo y Control", cam: "Cámara", dash: "Panel", hint: "Usa el pie para navegar" },
};

export default function HomeScreen() {
  const navigation = useNavigation<Nav>();
  const { lang } = useLanguage();
  const T = texts[lang];

  const tiles = [
    { key: "Camera" as const, label: T.cam, icon: "videocam" as const, color: PALETTE.red },
    { key: "Dashboard" as const, label: T.dash, icon: "pulse" as const, color: PALETTE.redSoft },
  ];

  return (
    <View style={styles.container}>
      <View style={styles.hero}>
        <Image source={require("../../assets/logo.png")} style={styles.logo} resizeMode="contain" />
        <Text style={styles.title}>{T.title}</Text>
        <Text style={styles.sub}>{T.sub}</Text>
      </View>

      <View style={styles.grid}>
        {tiles.map((t) => (
          <Pressable
            key={t.key}
            onPress={() => navigation.navigate(t.key)}
            style={({ pressed }) => [
              styles.tile,
              { width: CARD, height: CARD, borderColor: t.color },
              pressed && { transform: [{ scale: 0.98 }] },
            ]}
          >
            <View style={[styles.tileInner, { backgroundColor: t.color }]}>
              <Ionicons name={t.icon} size={42} color={PALETTE.white} />
            </View>
            <Text style={styles.tileLabel}>{t.label}</Text>
          </Pressable>
        ))}
      </View>

      <Text style={styles.hint}>{T.hint}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 18 },
  hero: { alignItems: "center", marginTop: 6, marginBottom: 16 },
  logo: { width: 120, height: 120, marginBottom: 6 },
  title: { color: PALETTE.white, fontSize: 24, fontWeight: "800" },
  sub: { color: PALETTE.textSoft, fontSize: 12 },
  grid: { flexDirection: "row", flexWrap: "wrap", justifyContent: "space-between", rowGap: 16 },
  tile: { borderRadius: 18, borderWidth: 2, backgroundColor: PALETTE.card, overflow: "hidden" },
  tileInner: { flex: 1, alignItems: "center", justifyContent: "center" },
  tileLabel: { position: "absolute", bottom: 8, width: "100%", textAlign: "center", color: PALETTE.white, fontWeight: "700", fontSize: 16 },
  hint: { textAlign: "center", color: "#9c9c9c", marginTop: 12, fontSize: 12 },
});
