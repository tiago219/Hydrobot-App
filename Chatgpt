
// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  Image,
  AppState,
  AppStateStatus,
} from "react-native";
import { WebView } from "react-native-webview";

type Mode = "mjpeg" | "snapshot";

const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", accent: "#e6403a", text: "#e5e7eb" };

export default function CameraScreen() {
  const [ip, setIp] = useState<string>("192.168.4.1"); // ajuste para seu IP (ou mDNS se usar proxy)
  const [testedIp, setTestedIp] = useState<string>(""); // IP efetivo em uso na visualização
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [status, setStatus] = useState<string>("Aguardando IP");
  const [snapTick, setSnapTick] = useState<number>(0);
  const [isRunning, setIsRunning] = useState<boolean>(false);
  const snapTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const appState = useRef<AppStateStatus>(AppState.currentState);

  const streamURL = useMemo(() => (testedIp ? `http://${testedIp}/stream` : ""), [testedIp]);
  const snapshotURL = useMemo(
    () => (testedIp ? `http://${testedIp}/snapshot?_=${snapTick}` : ""),
    [testedIp, snapTick]
  );
  const healthURL = useMemo(() => (testedIp ? `http://${testedIp}/status` : ""), [testedIp]);

  // ---- Controle do modo snapshot (polling) ----
  const startSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) return;
    snapTimerRef.current = setInterval(() => setSnapTick((t) => (t + 1) % 1_000_000), 150); // ~6-7 FPS
  }, []);

  const stopSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) {
      clearInterval(snapTimerRef.current);
      snapTimerRef.current = null;
    }
  }, []);

  useEffect(() => {
    if (mode === "snapshot" && testedIp) {
      startSnapshotLoop();
    } else {
      stopSnapshotLoop();
    }
    return stopSnapshotLoop;
  }, [mode, testedIp, startSnapshotLoop, stopSnapshotLoop]);

  // Pausar quando app em background (evita consumo)
  useEffect(() => {
    const sub = AppState.addEventListener("change", (nextState) => {
      const prev = appState.current;
      appState.current = nextState;
      if (prev.match(/active/) && nextState.match(/inactive|background/)) {
        stopSnapshotLoop();
        setIsRunning(false);
      } else if (prev.match(/inactive|background/) && nextState === "active") {
        if (mode === "snapshot" && testedIp) startSnapshotLoop();
        if (testedIp) setIsRunning(true);
      }
    });
    return () => sub.remove();
  }, [mode, testedIp, startSnapshotLoop, stopSnapshotLoop]);

  // ---- Teste de conexão e fallback automático ----
  const testConnection = useCallback(async () => {
    const target = (ip || "").trim();
    if (!target) {
      setStatus("Informe o IP do ESP");
      return;
    }
    setStatus("Testando conexão...");
    setIsRunning(false);
    stopSnapshotLoop();

    // 1) Tenta um GET rápido no /status (se existir)
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/status`, { signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("mjpeg");
        setStatus("Conectado (tentando MJPEG)...");
        setIsRunning(true);
        return;
      }
    } catch (_) {
      // segue para checar /stream e /snapshot
    }

    // 2) Checa se /stream responde pelo menos com headers
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/stream`, { method: "GET", signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("mjpeg");
        setStatus("Conectado (MJPEG)...");
        setIsRunning(true);
        return;
      }
    } catch (_) {
      // segue
    }

    // 3) Fallback: tenta /snapshot
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/snapshot`, { method: "GET", signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("snapshot");
        setStatus("Conectado (Snapshot contínuo)...");
        setIsRunning(true);
        startSnapshotLoop();
        return;
      }
    } catch (_) {
      // segue
    }

    setStatus("Falha ao conectar. Verifique IP/rede/firmware.");
    setIsRunning(false);
  }, [ip, startSnapshotLoop, stopSnapshotLoop]);

  // ---- UI MJPEG via WebView (funciona bem no Android) ----
  const mjpegHTML = useMemo(() => {
    if (!streamURL) return "";
    // HTML simples que carrega o MJPEG e tenta auto-reconectar em caso de erro
    return `
      <!doctype html>
      <html><head><meta name="viewport" content="width=device-width, initial-scale=1" />
      <style>
        html,body{margin:0;padding:0;background:#0b0b0f;height:100%;overflow:hidden;}
        #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;}
        img{max-width:100vw;max-height:100vh;object-fit:contain;}
        #badge{position:fixed;left:8px;bottom:8px;padding:4px 8px;border-radius:8px;
               background:#121218;color:#e5e7eb;font-family:system-ui,Arial,sans-serif;font-size:12px;opacity:.7}
      </style></head>
      <body>
        <div id="wrap">
          <img id="mjpeg" src="${streamURL}" />
        </div>
        <div id="badge">Stream: ${streamURL}</div>
        <script>
          const img = document.getElementById('mjpeg');
          let retryMs = 1000;
          img.addEventListener('error', () => {
            setTimeout(() => {
              img.src = '${streamURL}' + '?_=' + Date.now();
            }, retryMs);
            retryMs = Math.min(retryMs * 2, 5000);
          });
        </script>
      </body></html>
    `.trim();
  }, [streamURL]);

  // ---- Render ----
  return (
    <View style={styles.container}>
      <Text style={styles.title}>ESP32-CAM Viewer</Text>

      <View style={styles.row}>
        <Text style={styles.label}>ESP IP</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="ex.: 192.168.4.1"
          placeholderTextColor="#6b7280"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
        />
        <Pressable style={styles.button} onPress={testConnection}>
          <Text style={styles.buttonText}>Testar</Text>
        </Pressable>
      </View>

      <Text style={styles.status}>
        Status: {status} {testedIp ? `| IP: ${testedIp}` : ""}
        {testedIp ? ` | Modo: ${mode}` : ""}
      </Text>

      <View style={styles.viewer}>
        {testedIp && isRunning ? (
          mode === "mjpeg" ? (
            <WebView
              originWhitelist={["*"]}
              source={{ html: mjpegHTML, baseUrl: `http://${testedIp}` }}
              javaScriptEnabled
              domStorageEnabled
              allowsInlineMediaPlayback
              allowsFullscreenVideo={false}
              mediaPlaybackRequiresUserAction={false}
              onError={() => {
                // Cai para snapshot se o WebView reportar erro
                setMode("snapshot");
                setStatus("MJPEG falhou — alternando para Snapshot...");
              }}
              style={styles.webview}
            />
          ) : (
            <Image
              source={{ uri: snapshotURL }}
              resizeMode="contain"
              style={styles.image}
              onError={() => setStatus("Erro no snapshot — checar conexão")}
            />
          )
        ) : (
          <View style={styles.placeholder}>
            <Text style={{ color: PALETTE.text, opacity: 0.7, textAlign: "center" }}>
              Informe o IP e toque em “Testar” para iniciar o vídeo.
            </Text>
          </View>
        )}
      </View>

      {testedIp ? (
        <View style={styles.footerRow}>
          <Pressable
            style={[styles.smallBtn, mode === "mjpeg" ? styles.smallBtnActive : null]}
            onPress={() => {
              setMode("mjpeg");
              setStatus("Tentando MJPEG /stream...");
            }}
          >
            <Text style={styles.smallBtnText}>Usar MJPEG</Text>
          </Pressable>
          <Pressable
            style={[styles.smallBtn, mode === "snapshot" ? styles.smallBtnActive : null]}
            onPress={() => {
              setMode("snapshot");
              setStatus("Usando /snapshot contínuo...");
            }}
          >
            <Text style={styles.smallBtnText}>Usar Snapshot</Text>
          </Pressable>
        </View>
      ) : null}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, gap: 12 },
  title: { color: PALETTE.text, fontSize: 20, fontWeight: "700" },
  row: { flexDirection: "row", alignItems: "center", gap: 8 },
  label: { color: PALETTE.text },
  input: {
    flex: 1,
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderWidth: 1,
    borderColor: PALETTE.border,
    borderRadius: 10,
    paddingHorizontal: 10,
    paddingVertical: 8,
  },
  button: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 10,
  },
  buttonText: { color: "#fff", fontWeight: "700" },
  status: { color: PALETTE.text, opacity: 0.9 },
  viewer: {
    flex: 1,
    backgroundColor: "#000",
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  webview: { flex: 1, backgroundColor: "#000" },
  image: { width: "100%", height: "100%" },
  placeholder: { flex: 1, alignItems: "center", justifyContent: "center", padding: 24 },
  footerRow: { flexDirection: "row", gap: 10, justifyContent: "center" },
  smallBtn: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: PALETTE.card,
  },
  smallBtnActive: { borderColor: PALETTE.accent },
  smallBtnText: { color: PALETTE.text, fontWeight: "600" },
});
















Perfeito — abaixo está a CameraScreen.tsx já adaptada para funcionar com o firmware padrão do ESP32-CAM (que expõe /jpg ou /stream no exemplo oficial, e alguns forks usam /snapshot ou /capture).

O componente tenta automaticamente /snapshot → /jpg → /capture até encontrar um que responda, e mantém polling leve com troca suave de frames (crossfade). É 100% compatível com Expo Go, sem precisar de WebView.




Basta substituir o arquivo HydroBotApp2/src/screens/CameraScreen.tsx pelo código completo a seguir.




// HydroBotApp2/src/screens/CameraScreen.tsx
// Expo Go friendly — snapshot polling com auto-fallback de endpoint (/snapshot → /jpg → /capture)

import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet, Image, Animated, AppState,
} from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: {
    heroSubtitle: "Visualização da Câmera (snapshot)",
    espIp: "Host/IP do ESP:",
    placeholderIp: "192.168.0.50",
    start: "Iniciar",
    stop: "Parar",
    statusIdle: "Pronto",
    statusResolving: "Detectando endpoint…",
    statusRunning: (ms:number)=>`Coletando snapshots… ${ms} ms`,
    statusErr: "Erro ao carregar imagem. Verifique IP e Wi-Fi.",
    endpoint: (p:string)=>`Endpoint: ${p}`,
  },
  en: {
    heroSubtitle: "Camera Viewer (snapshot)",
    espIp: "ESP Host/IP:",
    placeholderIp: "192.168.0.50",
    start: "Start",
    stop: "Stop",
    statusIdle: "Ready",
    statusResolving: "Detecting endpoint…",
    statusRunning: (ms:number)=>`Fetching snapshots… ${ms} ms`,
    statusErr: "Failed to load image. Check IP & Wi-Fi.",
    endpoint: (p:string)=>`Endpoint: ${p}`,
  },
  es: {
    heroSubtitle: "Visor de Cámara (snapshot)",
    espIp: "Host/IP del ESP:",
    placeholderIp: "192.168.0.50",
    start: "Iniciar",
    stop: "Parar",
    statusIdle: "Listo",
    statusResolving: "Detectando endpoint…",
    statusRunning: (ms:number)=>`Obteniendo snapshots… ${ms} ms`,
    statusErr: "Error al cargar imagen. Verifica IP y Wi-Fi.",
    endpoint: (p:string)=>`Endpoint: ${p}`,
  },
};

const DEFAULT_HOST = "192.168.0.50"; // use o IP numérico do seu ESP
const CANDIDATE_PATHS = ["/snapshot", "/jpg", "/capture"]; // tentativas em ordem
const appLogo = require("../../assets/logo.png");

/* ---------- Header ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ---------- Crossfade de imagens ---------- */
function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown
}: {
  currentUri: string; nextUri: string;
  onNextLoadStart: () => void; onNextShown: (ok: boolean) => void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastRef.current) return;
    lastRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={() => { onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- Tela principal ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [host, setHost] = useState(DEFAULT_HOST);
  const [running, setRunning] = useState(false);
  const [hadError, setHadError] = useState(false);
  const [intervalMs, setIntervalMs] = useState(550);
  const [endpointPath, setEndpointPath] = useState<string | null>(null);
  const [resolving, setResolving] = useState(false);

  const [currentUri, setCurrentUri] = useState("");
  const [nextUri, setNextUri] = useState("");
  const loadingNext = useRef(false);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  const pathIndexRef = useRef(0);
  const stablePathRef = useRef<string | null>(null);
  const consecutiveFailsRef = useRef(0);

  const cleanHost = (s:string)=> s.replace(/^https?:\/\//,"").replace(/\/+$/,"");
  const baseUrl = useMemo(()=> `http://${cleanHost(host)}`, [host]);

  const makeUrl = (path:string)=> `${baseUrl}${path}?t=${Date.now()}`;

  const pickNextCandidate = () => {
    pathIndexRef.current = (pathIndexRef.current + 1) % CANDIDATE_PATHS.length;
    const p = CANDIDATE_PATHS[pathIndexRef.current];
    setEndpointPath(p);
    return p;
  };

  const resolveEndpointIfNeeded = () => {
    if (stablePathRef.current) { setEndpointPath(stablePathRef.current); return; }
    setResolving(true);
    // estratégia: começamos do índice atual; ao primeiro sucesso de imagem, fixamos
    const p = CANDIDATE_PATHS[pathIndexRef.current];
    setEndpointPath(p);
  };

  const schedule = () => {
    if (!running) return;
    timerRef.current = setTimeout(() => {
      if (!loadingNext.current && endpointPath) {
        setNextUri(makeUrl(endpointPath));
      }
      schedule();
    }, intervalMs);
  };

  const start = () => {
    if (timerRef.current) clearTimeout(timerRef.current);
    setRunning(true);
    setHadError(false);
    consecutiveFailsRef.current = 0;
    stablePathRef.current = null;
    resolveEndpointIfNeeded();
    if (endpointPath) setCurrentUri(makeUrl(endpointPath));
    schedule();
  };

  const stop = () => {
    setRunning(false);
    if (timerRef.current) clearTimeout(timerRef.current);
    timerRef.current = null;
  };

  // pausa automática em background
  useEffect(() => {
    const sub = AppState.addEventListener("change", (s) => {
      if (s !== "active") stop();
    });
    return () => sub.remove();
  }, []);

  // limpa timer ao desmontar
  useEffect(()=>()=>{ if(timerRef.current) clearTimeout(timerRef.current); },[]);

  // se mudar host/intervalo, reinicia polling (se estiver rodando)
  useEffect(() => {
    if (running) { stop(); start(); }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [intervalMs, host]);

  // quando endpointPath muda (ex: fallback), atualiza frame inicial
  useEffect(() => {
    if (running && endpointPath) {
      setCurrentUri(makeUrl(endpointPath));
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [endpointPath]);

  const onNextLoadStart = ()=>{ loadingNext.current = true; };

  const onNextShown = (ok:boolean)=>{
    loadingNext.current = false;
    if (ok) {
      setHadError(false);
      setResolving(false);
      consecutiveFailsRef.current = 0;
      if (!stablePathRef.current && endpointPath) {
        // fixamos o endpoint que funcionou
        stablePathRef.current = endpointPath;
      }
      if (nextUri) setCurrentUri(nextUri);
    } else {
      setHadError(true);
      consecutiveFailsRef.current += 1;

      // Se falhar algumas vezes seguidas, tenta próximo endpoint
      if (consecutiveFailsRef.current >= 2) {
        const next = pickNextCandidate();
        consecutiveFailsRef.current = 0;
        stablePathRef.current = null; // “desfixa” para poder testar
        // força tentativa imediata no novo path
        setCurrentUri(""); // remove frame atual para evitar “imagem congelada”
        setNextUri(makeUrl(next));
        setResolving(true);
      }
    }
  };

  const statusText = !running
    ? T.statusIdle
    : (hadError
      ? T.statusErr
      : (resolving ? T.statusResolving : T.statusRunning(intervalMs)));

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={host}
          onChangeText={(v)=>{ setHost(v); setEndpointPath(null); stablePathRef.current=null; }}
          placeholder={T.placeholderIp}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        {!running ? (
          <Pressable onPress={start} style={[styles.btn, { backgroundColor: "#16a34a" }]}>
            <Text style={styles.btnText}>{T.start}</Text>
          </Pressable>
        ) : (
          <Pressable onPress={stop} style={[styles.btn, { backgroundColor: "#dc2626" }]}>
            <Text style={styles.btnText}>{T.stop}</Text>
          </Pressable>
        )}
      </View>

      <View style={styles.statusRow}>
        <Text style={styles.statusText}>{statusText}</Text>
        {!!(endpointPath) && (
          <Text style={[styles.statusText, { marginTop: 4, opacity: 0.8 }]}>
            {T.endpoint(endpointPath)}
          </Text>
        )}
      </View>

      {/* Controles simples de intervalo */}
      <View style={[styles.sliderRow, {flexDirection:"row", alignItems:"center", gap:8}]}>
        <Text style={styles.sliderLabel}>Intervalo: {intervalMs} ms</Text>
        <Pressable
          onPress={() => setIntervalMs(ms => Math.max(350, ms - 50))}
          style={[styles.btn, { backgroundColor: "#374151", paddingHorizontal:12, paddingVertical:8 }]}
        >
          <Text style={styles.btnText}>-50</Text>
        </Pressable>
        <Pressable
          onPress={() => setIntervalMs(ms => Math.min(1200, ms + 50))}
          style={[styles.btn, { backgroundColor: "#374151", paddingHorizontal:12, paddingVertical:8 }]}
        >
          <Text style={styles.btnText}>+50</Text>
        </Pressable>
      </View>

      <View style={{ flex:1 }}>
        <CrossfadeImage
          currentUri={currentUri}
          nextUri={nextUri}
          onNextLoadStart={onNextLoadStart}
          onNextShown={onNextShown}
        />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", flexWrap:"wrap",
           paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:150, flexGrow:1 },
  btn:{ paddingHorizontal:12, paddingVertical:10, borderRadius:10 },
  btnText:{ color:"white", fontWeight:"700" },

  statusRow:{ paddingHorizontal:12, paddingVertical:6, backgroundColor:"#0f1322",
              borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  statusText:{ color:"#cbd5ff", fontSize:12 },

  sliderRow:{ paddingHorizontal:12, paddingVertical:8, backgroundColor:"#0f1322",
              borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  sliderLabel:{ color:"#d1d5db", marginBottom:4 },
});



O que mudou e por quê (rápido):




Auto-fallback entre "/snapshot", "/jpg" e "/capture": evita “No live frame” quando o firmware usa um nome diferente.


Fixação do endpoint após o primeiro sucesso: reduz tentativas e melhora a estabilidade.


Reconexão leve: a cada 2 falhas seguidas, troca para o próximo endpoint.


Cache-busting por ?t=Date.now(): impede cache do Android.


Polling ajustável (350–1200 ms): dá espaço para placas instáveis sem afogar a rede.






Dica: com seu firmware acima (webserver padrão), o caminho mais comum é http://<IP>/jpg. No app, basta digitar o IP numérico (sem http://) e tocar Iniciar.









































#include "esp_camera.h"
#include <WiFi.h>

// ===========================
// Select camera model in board_config.h
// ===========================
#include "board_config.h"

// ===========================
// Enter your WiFi credentials
// ===========================
const char *ssid = "HydroBot";
const char *password = "loud2025emibr";

void startCameraServer();
void setupLedFlash();

void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println();

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.frame_size = FRAMESIZE_UXGA;
  config.pixel_format = PIXFORMAT_JPEG;  // for streaming
  //config.pixel_format = PIXFORMAT_RGB565; // for face detection/recognition
  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
  config.fb_location = CAMERA_FB_IN_PSRAM;
  config.jpeg_quality = 12;
  config.fb_count = 1;

  // if PSRAM IC present, init with UXGA resolution and higher JPEG quality
  //                      for larger pre-allocated frame buffer.
  if (config.pixel_format == PIXFORMAT_JPEG) {
    if (psramFound()) {
      config.jpeg_quality = 10;
      config.fb_count = 2;
      config.grab_mode = CAMERA_GRAB_LATEST;
    } else {
      // Limit the frame size when PSRAM is not available
      config.frame_size = FRAMESIZE_SVGA;
      config.fb_location = CAMERA_FB_IN_DRAM;
    }
  } else {
    // Best option for face detection/recognition
    config.frame_size = FRAMESIZE_240X240;
#if CONFIG_IDF_TARGET_ESP32S3
    config.fb_count = 2;
#endif
  }

#if defined(CAMERA_MODEL_ESP_EYE)
  pinMode(13, INPUT_PULLUP);
  pinMode(14, INPUT_PULLUP);
#endif

  // camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }

  sensor_t *s = esp_camera_sensor_get();
  // initial sensors are flipped vertically and colors are a bit saturated
  if (s->id.PID == OV3660_PID) {
    s->set_vflip(s, 1);        // flip it back
    s->set_brightness(s, 1);   // up the brightness just a bit
    s->set_saturation(s, -2);  // lower the saturation
  }
  // drop down frame size for higher initial frame rate
  if (config.pixel_format == PIXFORMAT_JPEG) {
    s->set_framesize(s, FRAMESIZE_QVGA);
  }

#if defined(CAMERA_MODEL_M5STACK_WIDE) || defined(CAMERA_MODEL_M5STACK_ESP32CAM)
  s->set_vflip(s, 1);
  s->set_hmirror(s, 1);
#endif

#if defined(CAMERA_MODEL_ESP32S3_EYE)
  s->set_vflip(s, 1);
#endif

// Setup LED FLash if LED pin is defined in camera_pins.h
#if defined(LED_GPIO_NUM)
  setupLedFlash();
#endif

  WiFi.begin(ssid, password);
  WiFi.setSleep(false);

  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("WiFi connected");

  startCameraServer();

  Serial.print("Camera Ready! Use 'http://");
  Serial.print(WiFi.localIP());
  Serial.println("' to connect");
}

void loop() {
  // Do nothing. Everything is done in another task by the web server
  delay(10000);
}









// HydroBotApp2/src/screens/CameraScreen.tsx
// Expo Go friendly: renderiza /snapshot por polling (sem SDK/HTTPS/WebView)

import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet, Image, Animated, AppState
} from "react-native";

import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: {
    heroSubtitle: "Visualização da Câmera (snapshot)",
    espIp: "Host/IP do ESP:",
    placeholderIp: "192.168.0.50",
    start: "Iniciar",
    stop: "Parar",
    statusIdle: "Pronto",
    statusRunning: (ms:number)=>`Coletando snapshots… ${ms} ms`,
    statusErr: "Erro ao carregar imagem. Verifique IP e Wi-Fi."
  },
  en: {
    heroSubtitle: "Camera Viewer (snapshot)",
    espIp: "ESP Host/IP:",
    placeholderIp: "192.168.0.50",
    start: "Start",
    stop: "Stop",
    statusIdle: "Ready",
    statusRunning: (ms:number)=>`Fetching snapshots… ${ms} ms`,
    statusErr: "Failed to load image. Check IP & Wi-Fi."
  },
  es: {
    heroSubtitle: "Visor de Cámara (snapshot)",
    espIp: "Host/IP del ESP:",
    placeholderIp: "192.168.0.50",
    start: "Iniciar",
    stop: "Parar",
    statusIdle: "Listo",
    statusRunning: (ms:number)=>`Obteniendo snapshots… ${ms} ms`,
    statusErr: "Error al cargar imagen. Verifica IP y Wi-Fi."
  },
};

const DEFAULT_HOST = "192.168.0.50"; // coloque o IP do seu ESP (numérico funciona melhor no Android)
const appLogo = require("../../assets/logo.png");

function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown
}: {
  currentUri: string; nextUri: string;
  onNextLoadStart: () => void; onNextShown: (ok: boolean) => void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastRef.current) return;
    lastRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={() => { onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [host, setHost] = useState(DEFAULT_HOST);
  const [running, setRunning] = useState(false);
  const [hadError, setHadError] = useState(false);
  const [intervalMs, setIntervalMs] = useState(600); // ajuste fino no slider (400–900 ms)

  const [currentUri, setCurrentUri] = useState("");
  const [nextUri, setNextUri] = useState("");
  const loadingNext = useRef(false);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  const clean = (s:string)=> s.replace(/\/+$/,"");
  const snapshotUrl = useMemo(()=> `http://${clean(host)}/snapshot`, [host]);

  const schedule = () => {
    if (!running) return;
    timerRef.current = setTimeout(() => {
      if (!loadingNext.current) {
        setNextUri(`${snapshotUrl}?t=${Date.now()}`); // cache-busting
      }
      schedule();
    }, intervalMs);
  };

  const start = () => {
    if (timerRef.current) clearTimeout(timerRef.current);
    setRunning(true);
    setHadError(false);
    setCurrentUri(`${snapshotUrl}?t=${Date.now()}`);
    schedule();
  };

  const stop = () => {
    setRunning(false);
    if (timerRef.current) clearTimeout(timerRef.current);
    timerRef.current = null;
  };

  // pausa automática quando app vai para background
  useEffect(() => {
    const sub = AppState.addEventListener("change", (s) => {
      if (s !== "active") stop();
    });
    return () => sub.remove();
  }, []);

  // limpa timer ao desmontar
  useEffect(()=>()=>{ if(timerRef.current) clearTimeout(timerRef.current); },[]);

  // se mudar o intervalo durante execução, reprograma
  useEffect(() => {
    if (running) { stop(); start(); }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [intervalMs, host]);

  const onNextLoadStart = ()=>{ loadingNext.current = true; };
  const onNextShown = (ok:boolean)=>{
    loadingNext.current = false;
    if (ok) {
      setHadError(false);
      if (nextUri) setCurrentUri(nextUri);
    } else {
      setHadError(true);
    }
  };

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={host}
          onChangeText={setHost}
          placeholder={T.placeholderIp}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        {!running ? (
          <Pressable onPress={start} style={[styles.btn, { backgroundColor: "#16a34a" }]}>
            <Text style={styles.btnText}>{T.start}</Text>
          </Pressable>
        ) : (
          <Pressable onPress={stop} style={[styles.btn, { backgroundColor: "#dc2626" }]}>
            <Text style={styles.btnText}>{T.stop}</Text>
          </Pressable>
        )}
      </View>

      <View style={styles.statusRow}>
        <Text style={styles.statusText}>
          {!running ? T.statusIdle : (hadError ? T.statusErr : T.statusRunning(intervalMs))}
        </Text>
      </View>

      {/* Controles simples de intervalo */}
<View style={[styles.sliderRow, {flexDirection:"row", alignItems:"center", gap:8}]}>
  <Text style={styles.sliderLabel}>Intervalo: {intervalMs} ms</Text>
  <Pressable
    onPress={() => setIntervalMs(ms => Math.max(400, ms - 50))}
    style={[styles.btn, { backgroundColor: "#374151", paddingHorizontal:12, paddingVertical:8 }]}
  >
    <Text style={styles.btnText}>-50</Text>
  </Pressable>
  <Pressable
    onPress={() => setIntervalMs(ms => Math.min(900, ms + 50))}
    style={[styles.btn, { backgroundColor: "#374151", paddingHorizontal:12, paddingVertical:8 }]}
  >
    <Text style={styles.btnText}>+50</Text>
  </Pressable>
</View>


      <View style={{ flex:1 }}>
        <CrossfadeImage
          currentUri={currentUri}
          nextUri={nextUri}
          onNextLoadStart={onNextLoadStart}
          onNextShown={onNextShown}
        />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", flexWrap:"wrap",
           paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:150, flexGrow:1 },
  btn:{ paddingHorizontal:12, paddingVertical:10, borderRadius:10 },
  btnText:{ color:"white", fontWeight:"700" },

  statusRow:{ paddingHorizontal:12, paddingVertical:6, backgroundColor:"#0f1322",
              borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  statusText:{ color:"#cbd5ff", fontSize:12 },

  sliderRow:{ paddingHorizontal:12, paddingVertical:8, backgroundColor:"#0f1322",
              borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  sliderLabel:{ color:"#d1d5db", marginBottom:4 },
});
