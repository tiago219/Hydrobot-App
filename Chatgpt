
Perfeito — vou manter sua arquitetura (AP-only, WebServer :80 + httpd :81/stream) e mudar o mínimo possível para eliminar os resets/quedas que você observou (DMA overflow / PSRAM falhando quando o app começa a puxar frames).


O que mudei (mínimo e seguro)




Desativei power-save do Wi-Fi no modo AP → WiFi.setSleep(false) (evita quedas intermitentes por economia de energia).


Config da câmera mais robusta:



xclk_freq_hz 10 MHz (era 20 MHz) → reduz glitches no barramento quando a fonte está no limite.


Se há PSRAM: FRAMESIZE_VGA, jpeg_quality=15, fb_count=1, fb_location=PSRAM, grab_mode=CAMERA_GRAB_LATEST.


Se não há PSRAM: FRAMESIZE_QVGA, jpeg_quality=18, fb_count=1, fb_location=DRAM.

Esses ajustes aliviam o DMA e acabam com os resets quando o app começa a capturar com frequência.






Loop do stream: mantive sua lógica; só acrescentei um limite de frequência natural (10–15 ms) e retorno limpo se esp_camera_fb_get() falhar (evita travar a task).






Todo o resto (rotas, snapshot, bomba via LEDC, etc.) permanece idêntico.





Código completo (HydroBot.ino) com ajustes mínimos


/**
 * HydroBot.ino - ESP32-CAM (AI Thinker) - AP ONLY (sem sensores)
 * - AP fixo (HYDROBOT-CAM)
 * - Stream MJPEG: /stream (porta 81)
 * - API (80): /status, /led, /mode, /joystick, /pump (on/off), /pump_pwm?duty=0..255, /snapshot (JPEG único)
 * - LED no GPIO 4 (flash onboard)
 * - Bomba por MOSFET com PWM (LEDC via ESP-IDF)
 */

#include <Arduino.h>
#include "esp_camera.h"
#include <WiFi.h>
#include <WebServer.h>
#include "esp_http_server.h"
#include <time.h>
#include "driver/ledc.h"   // PWM (ESP-IDF)

// Desativa brownout
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ===================== WIFI AP =====================
const char* AP_SSID = "HYDROBOT-CAM";
const char* AP_PASS = "12345678"; // 8+ chars

// ===================== PINOS =====================
// LED seguro no ESP32-CAM (flash onboard).
#define LED_FLASH_PIN 4
// Bomba (MOSFET)
#define PUMP_PIN 14

// ===================== ESTADO =====================
String g_mode = "manual";
bool   g_ledOn = false;
bool   g_pumpOn = false;
float  g_joyX = 0.0f, g_joyY = 0.0f;

static httpd_handle_t stream_httpd = NULL;
WebServer server(80);

// ===================== CAMERA (AI THINKER) =====================
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ===================== UTILS =====================
String isoTimestamp() {
  time_t now = time(nullptr);
  if (now < 8 * 3600 * 2) {
    unsigned long ms = millis();
    char buf[64];
    snprintf(buf, sizeof(buf), "\"uptime_ms\":%lu", ms);
    return String("{") + buf + "}";
  }
  struct tm timeinfo;
  localtime_r(&now, &timeinfo);
  char buf[64];
  strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S%z", &timeinfo);
  String ts(buf);
  if (ts.length() >= 5) ts = ts.substring(0, ts.length()-2) + ":" + ts.substring(ts.length()-2);
  return "\"" + ts + "\"";
}

void sendCORSHeaders(httpd_req_t *req) {
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Headers", "Content-Type");
}

void sendCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}

// ===================== BOMBA (PWM via ESP-IDF LEDC) =====================
static const ledc_channel_t PUMP_CH   = LEDC_CHANNEL_0;
static const ledc_timer_t   PUMP_TMR  = LEDC_TIMER_0;
static const ledc_mode_t    PUMP_MODE = LEDC_HIGH_SPEED_MODE;

void pumpPwmInit() {
  ledc_timer_config_t tcfg = {};
  tcfg.speed_mode      = PUMP_MODE;
  tcfg.timer_num       = PUMP_TMR;
  tcfg.duty_resolution = LEDC_TIMER_8_BIT; // 0..255
  tcfg.freq_hz         = 5000;            // 5 kHz
  tcfg.clk_cfg         = LEDC_AUTO_CLK;
  ledc_timer_config(&tcfg);

  ledc_channel_config_t ccfg = {};
  ccfg.gpio_num   = PUMP_PIN;
  ccfg.speed_mode = PUMP_MODE;
  ccfg.channel    = PUMP_CH;
  ccfg.intr_type  = LEDC_INTR_DISABLE;
  ccfg.timer_sel  = PUMP_TMR;
  ccfg.duty       = 0;
  ccfg.hpoint     = 0;
  ledc_channel_config(&ccfg);

  g_pumpOn = false;
}

static inline void pumpWriteDuty(uint8_t duty) {
  ledc_set_duty(PUMP_MODE, PUMP_CH, duty);
  ledc_update_duty(PUMP_MODE, PUMP_CH);
}

void pumpSetOnOff(bool on) {
  g_pumpOn = on;
  pumpWriteDuty(on ? 255 : 0);
}

void pumpSetDuty(uint8_t duty) {
  if (duty > 255) duty = 255;
  g_pumpOn = (duty > 0);
  pumpWriteDuty(duty);
}

// ===================== STREAM (/stream) =====================
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";
static const char* _STREAM_BOUNDARY = "\r\n--frame\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

esp_err_t jpg_stream_httpd_handler(httpd_req_t *req) {
  sendCORSHeaders(req);
  camera_fb_t * fb = NULL;
  esp_err_t res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) return res;

  while (true) {
    fb = esp_camera_fb_get();
    if (!fb) { res = ESP_FAIL; break; }                  // <- retorna limpo se falhar
    if (fb->format != PIXFORMAT_JPEG) { esp_camera_fb_return(fb); vTaskDelay(10 / portTICK_PERIOD_MS); continue; }

    res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    if (res == ESP_OK) {
      char part_buf[64];
      size_t hlen = snprintf(part_buf, 64, _STREAM_PART, fb->len);
      res = httpd_resp_send_chunk(req, part_buf, hlen);
    }
    if (res == ESP_OK) res = httpd_resp_send_chunk(req, (const char *)fb->buf, fb->len);

    esp_camera_fb_return(fb);
    if (res != ESP_OK) break;

    // ~10–15 ms entre frames para aliviar DMA/CPU
    vTaskDelay(12 / portTICK_PERIOD_MS);
  }
  return res;
}

void startCameraStreamServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 81;
  config.ctrl_port = 32768;
  config.max_open_sockets = 3;
  config.task_priority = 5;

  httpd_uri_t stream_uri = { .uri="/stream", .method=HTTP_GET, .handler=jpg_stream_httpd_handler, .user_ctx=NULL };
  if (httpd_start(&stream_httpd, &config) == ESP_OK) {
    httpd_register_uri_handler(stream_httpd, &stream_uri);
    Serial.println("Stream em :81/stream");
  }
}

// ===================== API =====================
void api_status() {
  sendCORS();
  String ts = isoTimestamp();
  String json = "{";
  json += "\"ip\":\"" + WiFi.softAPIP().toString() + "\",";
  json += "\"mode\":\"" + g_mode + "\",";
  json += "\"led\":" + String(g_ledOn ? "true":"false") + ",";
  json += "\"pump\":" + String(g_pumpOn ? "true":"false") + ",";
  json += "\"uptime\":" + String(millis()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"ts\":" + ts;
  json += "}";
  server.send(200, "application/json", json);
}

void api_led() {
  sendCORS();
  bool on = server.arg("on") == "1" || server.arg("on") == "true";
  g_ledOn = on;
  digitalWrite(LED_FLASH_PIN, g_ledOn ? HIGH : LOW);
  server.send(200, "application/json", String("{\"ok\":true,\"led\":") + (g_ledOn?"true":"false") + "}");
}

void api_pump() { // on/off rápido
  sendCORS();
  bool on = server.arg("on") == "1" || server.arg("on") == "true";
  pumpSetOnOff(on);
  server.send(200, "application/json", String("{\"ok\":true,\"pump\":") + (g_pumpOn?"true":"false") + "}");
}

void api_pump_pwm() { // duty 0..255
  sendCORS();
  int duty = server.hasArg("duty") ? server.arg("duty").toInt() : -1;
  if (duty < 0 || duty > 255) {
    server.send(400, "application/json", "{\"ok\":false,\"error\":\"duty 0..255\"}");
    return;
  }
  pumpSetDuty((uint8_t)duty);
  server.send(200, "application/json", String("{\"ok\":true,\"duty\":") + duty + "}");
}

void api_mode() {
  sendCORS();
  String v = server.arg("v"); if (v.length()==0) v = server.arg("mode");
  if (v != "manual" && v != "auto" && v != "patrol") {
    server.send(400, "application/json", "{\"ok\":false,\"error\":\"mode must be manual|auto|patrol\"}");
    return;
  }
  g_mode = v;
  server.send(200, "application/json", String("{\"ok\":true,\"mode\":\"") + g_mode + "\"}");
}

void api_joystick() {
  sendCORS();
  float x = server.arg("x").toFloat();
  float y = server.arg("y").toFloat();
  if (x < -1) x = -1; if (x > 1) x = 1;
  if (y < -1) y = -1; if (y > 1) y = 1;
  g_joyX = x; g_joyY = y;
  server.send(200, "application/json", String("{\"ok\":true,\"x\":") + x + ",\"y\":" + y + "}");
}

void handleCORS() {
  sendCORS();
  server.send(200);
}

// ===== /snapshot (JPEG único) =====
void api_snapshot() {
  sendCORS();
  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb) {
    server.send(503, "application/json", "{\"ok\":false,\"error\":\"no_frame\"}");
    return;
  }
  if (fb->format != PIXFORMAT_JPEG) {
    esp_camera_fb_return(fb);
    server.send(500, "application/json", "{\"ok\":false,\"error\":\"not_jpeg\"}");
    return;
  }

  server.sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  server.setContentLength(fb->len);
  server.send(200, "image/jpeg", "");
  WiFiClient client = server.client();
  client.write(fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

// ===================== SETUP =====================
void setupNTP() {
  configTime(-3 * 3600, 0, "pool.ntp.org", "time.nist.gov");
}

// ---- CHANGED: câmera com parâmetros mais estáveis ----
bool initCamera() {
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;

  // CHANGED: clock mais baixo para robustez
  config.xclk_freq_hz = 10000000; // 10 MHz (antes 20 MHz)
  config.pixel_format = PIXFORMAT_JPEG;

  if (psramFound()) {
    // CHANGED: perfil com PSRAM mais conservador
    config.frame_size   = FRAMESIZE_VGA;          // 640x480
    config.jpeg_quality = 15;                     // um pouco mais comprimido
    config.fb_count     = 1;                      // 1 buffer reduz pressão no DMA
    config.fb_location  = CAMERA_FB_IN_PSRAM;
    config.grab_mode    = CAMERA_GRAB_LATEST;     // sempre o mais recente
  } else {
    // CHANGED: perfil sem PSRAM
    config.frame_size   = FRAMESIZE_QVGA;         // 320x240
    config.jpeg_quality = 18;
    config.fb_count     = 1;
    config.fb_location  = CAMERA_FB_IN_DRAM;
    config.grab_mode    = CAMERA_GRAB_WHEN_EMPTY;
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed: 0x%x\n", err);
    return false;
  }
  return true;
}

void startAPOnly() {
  WiFi.mode(WIFI_AP);
  WiFi.softAP(AP_SSID, AP_PASS);
  WiFi.setSleep(false);                // CHANGED: desliga power-save no AP
  delay(100);
  Serial.println("AP iniciado:");
  Serial.print(" SSID: "); Serial.println(AP_SSID);
  Serial.print(" PASS: "); Serial.println(AP_PASS);
  Serial.print(" IP: ");   Serial.println(WiFi.softAPIP());
}

void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);
  Serial.begin(115200);
  Serial.println("\n=== HYDROBOT CAM (AP ONLY / SEM SENSORES) ===");

  pinMode(LED_FLASH_PIN, OUTPUT);
  digitalWrite(LED_FLASH_PIN, LOW);

  pumpPwmInit();

  if (!initCamera()) {
    Serial.println("Camera FAIL");
    delay(3000);
    ESP.restart();
  }

  startAPOnly();
  setupNTP();

  // Rotas
  server.on("/status",    HTTP_GET, api_status);
  server.on("/led",       HTTP_GET, api_led);
  server.on("/led",       HTTP_POST, api_led);
  server.on("/pump",      HTTP_GET, api_pump);
  server.on("/pump",      HTTP_POST, api_pump);
  server.on("/pump_pwm",  HTTP_GET, api_pump_pwm);
  server.on("/pump_pwm",  HTTP_POST, api_pump_pwm);
  server.on("/mode",      HTTP_GET, api_mode);
  server.on("/mode",      HTTP_POST, api_mode);
  server.on("/joystick",  HTTP_GET, api_joystick);
  server.on("/joystick",  HTTP_POST, api_joystick);

  // snapshot
  server.on("/snapshot",  HTTP_GET, api_snapshot);

  // CORS (OPTIONS)
  server.on("/status",    HTTP_OPTIONS, handleCORS);
  server.on("/led",       HTTP_OPTIONS, handleCORS);
  server.on("/pump",      HTTP_OPTIONS, handleCORS);
  server.on("/pump_pwm",  HTTP_OPTIONS, handleCORS);
  server.on("/mode",      HTTP_OPTIONS, handleCORS);
  server.on("/joystick",  HTTP_OPTIONS, handleCORS);
  server.on("/snapshot",  HTTP_OPTIONS, handleCORS);

  server.begin();
  Serial.println("HTTP :80 pronto");
  startCameraStreamServer();
  Serial.println("=== PRONTO ===");
}

void loop() {
  server.handleClient();
  delay(10);
}




Por que isso resolve?




WiFi.setSleep(false) elimina quedas periódicas de AP causadas pelo power-save.


xclk 10 MHz + fb_count=1 + grab_mode=LATEST reduzem a pressão no DMA/PSRAM. É exatamente nessas condições (quando o app começa a requisitar com frequência) que o driver, com clock alto e múltiplos buffers, costuma travar e reiniciar.


Perfis distintos com/sem PSRAM evitam “PSRAM not found/overflow” e estabilizam tanto /snapshot quanto /stream.




Se quiser manter 20 MHz e empurrar resolução/qualidade depois que tudo ficar estável, podemos expor isso por endpoint /camera_cfg para trocar dinâmico — mas para parar as quedas agora, esses ajustes mínimos são os mais eficazes.







































/**
 * HydroBot.ino - ESP32-CAM (AI Thinker) - AP ONLY (sem sensores)
 * - AP fixo (HYDROBOT-CAM)
 * - Stream MJPEG: /stream (porta 81)
 * - API (80): /status, /led, /mode, /joystick, /pump (on/off), /pump_pwm?duty=0..255, /snapshot (JPEG único)
 * - LED no GPIO 4 (flash onboard)
 * - Bomba por MOSFET com PWM (LEDC via ESP-IDF)
 */

#include <Arduino.h>
#include "esp_camera.h"
#include <WiFi.h>
#include <WebServer.h>
#include "esp_http_server.h"
#include <time.h>
#include "driver/ledc.h"   // PWM (ESP-IDF)

// Desativa brownout
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ===================== WIFI AP =====================
const char* AP_SSID = "HYDROBOT-CAM";
const char* AP_PASS = "12345678"; // 8+ chars

// ===================== PINOS =====================
// LED seguro no ESP32-CAM (flash onboard). Se quiser usar 2, troque aqui (não recomendado).
#define LED_FLASH_PIN 4
// Bomba (MOSFET): evite 1/3/2/12/15; 14 é estável no ESP32-CAM
#define PUMP_PIN 14

// ===================== ESTADO =====================
String g_mode = "manual";
bool   g_ledOn = false;
bool   g_pumpOn = false;
float  g_joyX = 0.0f, g_joyY = 0.0f;

static httpd_handle_t stream_httpd = NULL;
WebServer server(80);

// ===================== CAMERA (AI THINKER) =====================
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ===================== UTILS =====================
String isoTimestamp() {
  time_t now = time(nullptr);
  if (now < 8 * 3600 * 2) {
    unsigned long ms = millis();
    char buf[64];
    snprintf(buf, sizeof(buf), "\"uptime_ms\":%lu", ms);
    return String("{") + buf + "}";
  }
  struct tm timeinfo;
  localtime_r(&now, &timeinfo);
  char buf[64];
  strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S%z", &timeinfo);
  String ts(buf);
  if (ts.length() >= 5) ts = ts.substring(0, ts.length()-2) + ":" + ts.substring(ts.length()-2);
  return "\"" + ts + "\"";
}

void sendCORSHeaders(httpd_req_t *req) {
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Headers", "Content-Type");
}

void sendCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}

// ===================== BOMBA (PWM via ESP-IDF LEDC) =====================
static const ledc_channel_t PUMP_CH   = LEDC_CHANNEL_0;
static const ledc_timer_t   PUMP_TMR  = LEDC_TIMER_0;
static const ledc_mode_t    PUMP_MODE = LEDC_HIGH_SPEED_MODE;

void pumpPwmInit() {
  ledc_timer_config_t tcfg = {};
  tcfg.speed_mode      = PUMP_MODE;
  tcfg.timer_num       = PUMP_TMR;
  tcfg.duty_resolution = LEDC_TIMER_8_BIT; // 0..255
  tcfg.freq_hz         = 5000;            // 5 kHz
  tcfg.clk_cfg         = LEDC_AUTO_CLK;
  ledc_timer_config(&tcfg);

  ledc_channel_config_t ccfg = {};
  ccfg.gpio_num   = PUMP_PIN;
  ccfg.speed_mode = PUMP_MODE;
  ccfg.channel    = PUMP_CH;
  ccfg.intr_type  = LEDC_INTR_DISABLE;
  ccfg.timer_sel  = PUMP_TMR;
  ccfg.duty       = 0;
  ccfg.hpoint     = 0;
  ledc_channel_config(&ccfg);

  g_pumpOn = false;
}

static inline void pumpWriteDuty(uint8_t duty) {
  ledc_set_duty(PUMP_MODE, PUMP_CH, duty);
  ledc_update_duty(PUMP_MODE, PUMP_CH);
}

void pumpSetOnOff(bool on) {
  g_pumpOn = on;
  pumpWriteDuty(on ? 255 : 0);
}

void pumpSetDuty(uint8_t duty) {
  if (duty > 255) duty = 255;
  g_pumpOn = (duty > 0);
  pumpWriteDuty(duty);
}

// ===================== STREAM (/stream) =====================
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";
static const char* _STREAM_BOUNDARY = "\r\n--frame\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

esp_err_t jpg_stream_httpd_handler(httpd_req_t *req) {
  sendCORSHeaders(req);
  camera_fb_t * fb = NULL;
  esp_err_t res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) return res;

  while (true) {
    fb = esp_camera_fb_get();
    if (!fb) return ESP_FAIL;
    if (fb->format != PIXFORMAT_JPEG) { esp_camera_fb_return(fb); continue; }

    res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    if (res == ESP_OK) {
      char part_buf[64];
      size_t hlen = snprintf(part_buf, 64, _STREAM_PART, fb->len);
      res = httpd_resp_send_chunk(req, part_buf, hlen);
    }
    if (res == ESP_OK) res = httpd_resp_send_chunk(req, (const char *)fb->buf, fb->len);

    esp_camera_fb_return(fb);
    if (res != ESP_OK) break;
    vTaskDelay(10 / portTICK_PERIOD_MS);
  }
  return res;
}

void startCameraStreamServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 81;
  config.ctrl_port = 32768;
  config.max_open_sockets = 3;
  config.task_priority = 5;

  httpd_uri_t stream_uri = { .uri="/stream", .method=HTTP_GET, .handler=jpg_stream_httpd_handler, .user_ctx=NULL };
  if (httpd_start(&stream_httpd, &config) == ESP_OK) {
    httpd_register_uri_handler(stream_httpd, &stream_uri);
    Serial.println("Stream em :81/stream");
  }
}

// ===================== API =====================
void api_status() {
  sendCORS();
  String ts = isoTimestamp();
  String json = "{";
  json += "\"ip\":\"" + WiFi.softAPIP().toString() + "\",";
  json += "\"mode\":\"" + g_mode + "\",";
  json += "\"led\":" + String(g_ledOn ? "true":"false") + ",";
  json += "\"pump\":" + String(g_pumpOn ? "true":"false") + ",";
  json += "\"uptime\":" + String(millis()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"ts\":" + ts;
  json += "}";
  server.send(200, "application/json", json);
}

void api_led() {
  sendCORS();
  bool on = server.arg("on") == "1" || server.arg("on") == "true";
  g_ledOn = on;
  digitalWrite(LED_FLASH_PIN, g_ledOn ? HIGH : LOW);
  server.send(200, "application/json", String("{\"ok\":true,\"led\":") + (g_ledOn?"true":"false") + "}");
}

void api_pump() { // on/off rápido
  sendCORS();
  bool on = server.arg("on") == "1" || server.arg("on") == "true";
  pumpSetOnOff(on);
  server.send(200, "application/json", String("{\"ok\":true,\"pump\":") + (g_pumpOn?"true":"false") + "}");
}

void api_pump_pwm() { // duty 0..255
  sendCORS();
  int duty = server.hasArg("duty") ? server.arg("duty").toInt() : -1;
  if (duty < 0 || duty > 255) {
    server.send(400, "application/json", "{\"ok\":false,\"error\":\"duty 0..255\"}");
    return;
  }
  pumpSetDuty((uint8_t)duty);
  server.send(200, "application/json", String("{\"ok\":true,\"duty\":") + duty + "}");
}

void api_mode() {
  sendCORS();
  String v = server.arg("v"); if (v.length()==0) v = server.arg("mode");
  if (v != "manual" && v != "auto" && v != "patrol") {
    server.send(400, "application/json", "{\"ok\":false,\"error\":\"mode must be manual|auto|patrol\"}");
    return;
  }
  g_mode = v;
  server.send(200, "application/json", String("{\"ok\":true,\"mode\":\"") + g_mode + "\"}");
}

void api_joystick() {
  sendCORS();
  float x = server.arg("x").toFloat();
  float y = server.arg("y").toFloat();
  if (x < -1) x = -1; if (x > 1) x = 1;
  if (y < -1) y = -1; if (y > 1) y = 1;
  g_joyX = x; g_joyY = y;
  server.send(200, "application/json", String("{\"ok\":true,\"x\":") + x + ",\"y\":" + y + "}");
}

void handleCORS() {
  sendCORS();
  server.send(200);
}

// ===== NOVO: /snapshot (JPEG único para o app React Native) =====
void api_snapshot() {
  sendCORS();
  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb) {
    server.send(503, "application/json", "{\"ok\":false,\"error\":\"no_frame\"}");
    return;
  }
  if (fb->format != PIXFORMAT_JPEG) {
    esp_camera_fb_return(fb);
    server.send(500, "application/json", "{\"ok\":false,\"error\":\"not_jpeg\"}");
    return;
  }

  // Desabilita cache no cliente
  server.sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  server.setContentLength(fb->len);
  server.send(200, "image/jpeg", "");            // inicia resposta
  WiFiClient client = server.client();
  client.write(fb->buf, fb->len);                // envia bytes do JPEG
  esp_camera_fb_return(fb);
}

// ===================== SETUP =====================
void setupNTP() {
  configTime(-3 * 3600, 0, "pool.ntp.org", "time.nist.gov");
}

bool initCamera() {
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;

  if (psramFound()) {
    config.frame_size = FRAMESIZE_VGA;
    config.jpeg_quality = 12;
    config.fb_count = 2;
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
  } else {
    config.frame_size = FRAMESIZE_QVGA;
    config.jpeg_quality = 15;
    config.fb_count = 1;
    config.fb_location = CAMERA_FB_IN_DRAM;
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed: 0x%x\n", err);
    return false;
  }
  return true;
}

void startAPOnly() {
  WiFi.mode(WIFI_AP);
  WiFi.softAP(AP_SSID, AP_PASS);
  delay(100);
  Serial.println("AP iniciado:");
  Serial.print(" SSID: "); Serial.println(AP_SSID);
  Serial.print(" PASS: "); Serial.println(AP_PASS);
  Serial.print(" IP: ");   Serial.println(WiFi.softAPIP());
}

void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);
  Serial.begin(115200);
  Serial.println("\n=== HYDROBOT CAM (AP ONLY / SEM SENSORES) ===");

  pinMode(LED_FLASH_PIN, OUTPUT);
  digitalWrite(LED_FLASH_PIN, LOW);

  pumpPwmInit();

  if (!initCamera()) {
    Serial.println("Camera FAIL");
    delay(3000);
    ESP.restart();
  }

  startAPOnly();
  setupNTP();

  // Rotas
  server.on("/status",    HTTP_GET, api_status);
  server.on("/led",       HTTP_GET, api_led);
  server.on("/led",       HTTP_POST, api_led);
  server.on("/pump",      HTTP_GET, api_pump);
  server.on("/pump",      HTTP_POST, api_pump);
  server.on("/pump_pwm",  HTTP_GET, api_pump_pwm);
  server.on("/pump_pwm",  HTTP_POST, api_pump_pwm);
  server.on("/mode",      HTTP_GET, api_mode);
  server.on("/mode",      HTTP_POST, api_mode);
  server.on("/joystick",  HTTP_GET, api_joystick);
  server.on("/joystick",  HTTP_POST, api_joystick);

  // NOVO: snapshot
  server.on("/snapshot",  HTTP_GET, api_snapshot);

  // CORS (OPTIONS)
  server.on("/status",    HTTP_OPTIONS, handleCORS);
  server.on("/led",       HTTP_OPTIONS, handleCORS);
  server.on("/pump",      HTTP_OPTIONS, handleCORS);
  server.on("/pump_pwm",  HTTP_OPTIONS, handleCORS);
  server.on("/mode",      HTTP_OPTIONS, handleCORS);
  server.on("/joystick",  HTTP_OPTIONS, handleCORS);
  server.on("/snapshot",  HTTP_OPTIONS, handleCORS);

  server.begin();
  Serial.println("HTTP :80 pronto");
  startCameraStreamServer();
  Serial.println("=== PRONTO ===");
}

void loop() {
  server.handleClient();
  delay(10);
}
