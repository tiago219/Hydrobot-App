

// ====== HydroBot – AUTO (delta analógico) + botão alterna MODO_APP/MODO_AUTO (SEM SERVO) ======
#include <Arduino.h>

/* ---------------- PINOS ---------------- */
// Motores (ponte H)
#define IN1 8
#define IN2 9
#define IN3 10
#define IN4 11

// Sensores KY-026 (digitais)
#define SENSOR_FOGO_ESQ_D 4   // LOW = fogo
#define SENSOR_FOGO_MEIO_D 5
#define SENSOR_FOGO_DIR_D 6

// Sensores KY-026 (analógicos)
#define SENSOR_FOGO_ESQ  A2
#define SENSOR_FOGO_MEIO A1
#define SENSOR_FOGO_DIR  A0

// Bomba / Nível de água / LED
#define BOMBA_PIN      13          // rele/driver da bomba
#define NIVEL_AGUA_PIN A3          // sensor nível (0-1023)
#define LED_NIVEL      12          // LED indicador de água (pino comum, sem PWM no UNO)
#define BOTAO          7           // alterna modo APP/AUTO (com PULLUP)

/* ---------------- PARÂMETROS ---------------- */
// Detecção por delta: base - leitura
static const int DIFERENCA_FOGO  = 150;   // aciona
static const int DIFERENCA_CLEAR = 100;   // limpa (histerese)

static const uint8_t  CONFIRM_READS = 3;
static const uint8_t  CONFIRM_MIN   = 2;
static const uint16_t CONFIRM_SPACING_MS = 15;

static const uint16_t FIRE_HOLD_MS = 250;

static const uint16_t TEMPO_CALIBRACAO_MS = 3000; // 3 s
static const uint8_t  RECALIB_EVERY_CONFIRMED = 5;

static const uint8_t  VEL_PERC = 60;
static const uint16_t T_FWD_MS  = 210;
static const uint16_t T_TURN_MS = 150;
static const uint16_t T_BACK_MS = 260; // reserva

/* ---------------- ESTADO ---------------- */
enum Modo : uint8_t { MODO_APP = 0, MODO_AUTO = 1 };
enum Dir  : uint8_t { DIR_STOP=0, DIR_FWD, DIR_BACK, DIR_LEFT, DIR_RIGHT };

struct State {
  // modo
  Modo modo = MODO_AUTO;

  // calibração analógica
  int baseEsq=0, baseMeio=0, baseDir=0;
  bool calibrado=false;

  // água/LED/bomba
  uint8_t nivelAguaPct=0;
  bool bombaOn=false;
  unsigned long ledTick=0;
  bool ledState=false;

  // fogo confirmado
  bool fogoConfirmado=false;
  unsigned long fogoHoldUntil=0;
  uint16_t eventosConfirmados=0;

  // movimento watchdog
  Dir currentDir=DIR_STOP;
  bool motionActive=false;
  unsigned long motionEndMs=0;
  unsigned long lastMoveCmdAt=0;

  // botão (debounce + toggle)
  bool lastBtn=HIGH;
  unsigned long lastBtnChange=0;
} G;

/* ---------------- PROTÓTIPOS ---------------- */
void motorsStop(); void motorsFwd(); void motorsBack(); void motorsLeftTurn(); void motorsRightTurn();
void setMotion(Dir d, uint16_t ms);
void pwmSoftware(void (*mov)(), int velPerc, int duracaoMs);

void pumpWrite(bool on);
uint8_t waterPercent();
void updateWaterLED(uint8_t pct);

void calibrarSensores();
static inline void leituraDelta(int &dE,int &dM,int &dD, int &side);
bool detectarFogoConfirmado(int &sideOut);
bool isClearNow();

void handleAuto();
void handleApp(); // “manual/app”: aqui só gerencia água/LED e espera comandos pela Serial

void processSerialFromESP();

/* ---------------- IMPLEMENTAÇÃO ---------------- */
// Motores
void motorsStop(){ digitalWrite(IN1,LOW);digitalWrite(IN2,LOW);digitalWrite(IN3,LOW);digitalWrite(IN4,LOW); G.currentDir=DIR_STOP; }
void motorsFwd(){  digitalWrite(IN1,HIGH);digitalWrite(IN2,LOW);digitalWrite(IN3,HIGH);digitalWrite(IN4,LOW);  G.currentDir=DIR_FWD; }
void motorsBack(){ digitalWrite(IN1,LOW); digitalWrite(IN2,HIGH);digitalWrite(IN3,LOW); digitalWrite(IN4,HIGH); G.currentDir=DIR_BACK; }
void motorsLeftTurn(){  digitalWrite(IN1,HIGH);digitalWrite(IN2,LOW); digitalWrite(IN3,LOW); digitalWrite(IN4,HIGH); G.currentDir=DIR_LEFT; }
void motorsRightTurn(){ digitalWrite(IN1,LOW); digitalWrite(IN2,HIGH);digitalWrite(IN3,HIGH);digitalWrite(IN4,LOW);  G.currentDir=DIR_RIGHT; }

void setMotion(Dir d, uint16_t ms){
  if (ms==0 || d==DIR_STOP){ motorsStop(); G.motionActive=false; return; }
  switch(d){ case DIR_FWD: motorsFwd(); break; case DIR_BACK: motorsBack(); break;
             case DIR_LEFT: motorsLeftTurn(); break; case DIR_RIGHT: motorsRightTurn(); break; default: motorsStop(); }
  G.motionActive=true; G.motionEndMs=millis()+ms; G.lastMoveCmdAt=millis();
}

// PWM por software para passos curtos
void pwmSoftware(void (*movimento)(), int vel, int duracao){
  unsigned long inicio = millis();
  const int ciclo = 10;               // 10 ms
  const int onMs = (ciclo * vel) / 100;
  const int offMs = ciclo - onMs;
  while ((int)(millis()-inicio) < duracao){
    movimento(); delay(onMs);
    if (vel < 100 && offMs>0){ motorsStop(); delay(offMs); }
  }
}

// Água / LED / Bomba
void pumpWrite(bool on){ G.bombaOn=on; digitalWrite(BOMBA_PIN, on?HIGH:LOW); }
uint8_t waterPercent(){ int raw=analogRead(NIVEL_AGUA_PIN); int pct=map(raw,0,1023,0,100); return (uint8_t)constrain(pct,0,100); }

// LED de nível por FASES (sem PWM de pino):
// >=60%: LED apagado
// 40-59%: LED aceso fixo
// 20-39%: pisca lento (800 ms)
// 10-19%: pisca médio (400 ms)
// <10%:  pisca rápido (200 ms)
void updateWaterLED(uint8_t pct){
  unsigned long now = millis();

  if (pct >= 60){
    if (G.ledState){ G.ledState=false; digitalWrite(LED_NIVEL, LOW); }
    return;
  }

  if (pct >= 40){
    if (!G.ledState){ G.ledState=true; digitalWrite(LED_NIVEL, HIGH); }
    return;
  }

  uint16_t periodo = (pct >= 20) ? 800 : (pct >= 10 ? 400 : 200);
  if (now - G.ledTick >= periodo){
    G.ledTick = now;
    G.ledState = !G.ledState;
    digitalWrite(LED_NIVEL, G.ledState ? HIGH : LOW);
  }
}

// Calibração
void calibrarSensores(){
  unsigned long t0=millis();
  long sE=0,sM=0,sD=0; int n=0;
  while (millis()-t0 < TEMPO_CALIBRACAO_MS){
    sE+=analogRead(SENSOR_FOGO_ESQ);
    sM+=analogRead(SENSOR_FOGO_MEIO);
    sD+=analogRead(SENSOR_FOGO_DIR);
    n++; delay(100);
  }
  if (n==0) n=1;
  G.baseEsq = sE/n; G.baseMeio = sM/n; G.baseDir = sD/n;
  G.calibrado=true;
  Serial.print(F("[CALIB] E="));Serial.print(G.baseEsq);
  Serial.print(F(" M="));Serial.print(G.baseMeio);
  Serial.print(F(" D="));Serial.println(G.baseDir);
}

static inline void leituraDelta(int &dE,int &dM,int &dD, int &side){
  int aE=analogRead(SENSOR_FOGO_ESQ);
  int aM=analogRead(SENSOR_FOGO_MEIO);
  int aD=analogRead(SENSOR_FOGO_DIR);
  dE = G.baseEsq - aE; dM = G.baseMeio - aM; dD = G.baseDir - aD;
  int md=dM; side=0; if (dE>md){ md=dE; side=-1; } if (dD>md){ md=dD; side=+1; }
}

bool detectarFogoConfirmado(int &sideOut){
  uint8_t hits=0;
  int bestDelta=-32768; int sideBest=0;
  for (uint8_t i=0;i<CONFIRM_READS;i++){
    int dE,dM,dD,side; leituraDelta(dE,dM,dD,side);
    bool fogo = (dE>DIFERENCA_FOGO) || (dM>DIFERENCA_FOGO) || (dD>DIFERENCA_FOGO);
    if (fogo) hits++;
    int strongest = dM; if (dE>strongest) strongest=dE; if (dD>strongest) strongest=dD;
    if (strongest>bestDelta){ bestDelta=strongest; sideBest=side; }
    delay(CONFIRM_SPACING_MS);
  }
  sideOut = sideBest;
  return (hits>=CONFIRM_MIN);
}

bool isClearNow(){
  int dE,dM,dD,sideDummy; leituraDelta(dE,dM,dD,sideDummy);
  return (dE<DIFERENCA_CLEAR) && (dM<DIFERENCA_CLEAR) && (dD<DIFERENCA_CLEAR);
}

// ===================== LÓGICA AUTO (SEM SERVO) =====================
void handleAuto(){
  if (!G.calibrado){ calibrarSensores(); return; }

  // nível/LED/bomba
  G.nivelAguaPct = waterPercent();
  updateWaterLED(G.nivelAguaPct);
  if (G.nivelAguaPct<=10) pumpWrite(false);

  int side=0;
  bool fireNow = detectarFogoConfirmado(side);

  unsigned long now=millis();
  if (fireNow){
    G.fogoConfirmado = true;
    G.fogoHoldUntil = now + FIRE_HOLD_MS;

    if (G.nivelAguaPct>10) pumpWrite(true); else pumpWrite(false);

    // “vira” para o lado do maior delta e avança curto
    if (side<0){ // fogo mais à esquerda -> vira esquerda, depois avança
      pwmSoftware([](){ motorsLeftTurn(); }, VEL_PERC, T_TURN_MS);
      pwmSoftware([](){ motorsFwd();      }, VEL_PERC, T_FWD_MS);
    } else if (side>0){
      pwmSoftware([](){ motorsRightTurn(); }, VEL_PERC, T_TURN_MS);
      pwmSoftware([](){ motorsFwd();       }, VEL_PERC, T_FWD_MS);
    } else {
      pwmSoftware([](){ motorsFwd(); }, VEL_PERC, T_FWD_MS);
    }

    static bool lastHadFire=false;
    if (!lastHadFire && G.fogoConfirmado){
      G.eventosConfirmados++;
      if (G.eventosConfirmados % RECALIB_EVERY_CONFIRMED == 0){
        Serial.println(F("[AUTO] Recalibrando por contagem de eventos..."));
        calibrarSensores();
      }
    }
    lastHadFire = true;
  } else {
    if (G.fogoConfirmado && now > G.fogoHoldUntil){
      if (isClearNow()){ G.fogoConfirmado=false; }
    }

    if (!G.fogoConfirmado){
      pumpWrite(false);
      motorsStop();
    }
  }
}

// ===================== MODO “APP” (controle externo) =====================
// Aqui apenas mantém leitura de água/LED/bomba. Os comandos de movimento/bomba
// podem chegar pela Serial (vindo do ESP32-CAM). Exemplos aceitos:
//   CMD:FWD:ms=300
//   CMD:BACK:ms=250
//   CMD:LEFT:ms=180
//   CMD:RIGHT:ms=180
//   CMD:STOP
//   CMD:PUMP:on
//   CMD:PUMP:off
void handleApp(){
  G.nivelAguaPct = waterPercent();
  updateWaterLED(G.nivelAguaPct);
  processSerialFromESP();
}

void applyTimedMove(const String& dir, uint16_t ms){
  if (dir=="FWD")      pwmSoftware([](){ motorsFwd(); }, VEL_PERC, ms);
  else if (dir=="BACK")  pwmSoftware([](){ motorsBack(); }, VEL_PERC, ms);
  else if (dir=="LEFT")  pwmSoftware([](){ motorsLeftTurn(); }, VEL_PERC, ms);
  else if (dir=="RIGHT") pwmSoftware([](){ motorsRightTurn(); }, VEL_PERC, ms);
  else motorsStop();
}

void processSerialFromESP(){
  static String buf;
  while (Serial.available()){
    char c = (char)Serial.read();
    if (c=='\n' || c=='\r'){
      if (buf.length()){
        // parse simples
        if (buf.startsWith("CMD:")){
          if (buf.indexOf("STOP")>0){ motorsStop(); }
          else if (buf.indexOf("PUMP:on")>0){ if (G.nivelAguaPct>10) pumpWrite(true); }
          else if (buf.indexOf("PUMP:off")>0){ pumpWrite(false); }
          else {
            // CMD:FWD:ms=300
            int p1 = buf.indexOf(':',4);
            int p2 = buf.indexOf(":ms=");
            if (p1>0){
              String d = buf.substring(4, p1);
              uint16_t ms = 200;
              if (p2>0){ ms = (uint16_t)buf.substring(p2+4).toInt(); }
              applyTimedMove(d, ms);
            }
          }
        }
        buf = "";
      }
    } else {
      if (buf.length() < 64) buf += c;
    }
  }
}

/* ===================== SETUP / LOOP ===================== */
void setup(){
  Serial.begin(115200);   // UART para falar com ESP32-CAM (ou PC durante testes)

  pinMode(IN1,OUTPUT); pinMode(IN2,OUTPUT); pinMode(IN3,OUTPUT); pinMode(IN4,OUTPUT);
  pinMode(BOMBA_PIN,OUTPUT); pumpWrite(false);

  pinMode(LED_NIVEL,OUTPUT); digitalWrite(LED_NIVEL, LOW);

  pinMode(SENSOR_FOGO_ESQ_D,INPUT);
  pinMode(SENSOR_FOGO_MEIO_D,INPUT);
  pinMode(SENSOR_FOGO_DIR_D,INPUT);

  pinMode(BOTAO,INPUT_PULLUP);

  motorsStop();
  Serial.println(F("HydroBot pronto. Inicia em MODO_AUTO e calibra ao entrar."));
  G.modo = MODO_AUTO;
}

void loop(){
  // watchdog de movimento (segurança)
  if (G.motionActive && (long)(millis()-G.motionEndMs)>=0){ motorsStop(); G.motionActive=false; }
  if ((millis()-G.lastMoveCmdAt)>1000 && G.currentDir!=DIR_STOP){ motorsStop(); G.motionActive=false; }

  // BOTÃO no D7 alterna modos (debounce)
  bool btn = digitalRead(BOTAO); // HIGH = solto (pullup)
  unsigned long now = millis();
  if (btn != G.lastBtn && (now - G.lastBtnChange) > 50){
    G.lastBtn = btn;
    G.lastBtnChange = now;
    if (btn == LOW){ // clique
      G.modo = (G.modo==MODO_AUTO) ? MODO_APP : MODO_AUTO;
      Serial.print(F("[MODO] ")); Serial.println(G.modo==MODO_AUTO ? "AUTO" : "APP");
      if (G.modo==MODO_AUTO){ G.calibrado=false; } // força recalibrar ao voltar p/ AUTO
      motorsStop();
      pumpWrite(false);
    }
  }

  // executa modo
  if (G.modo==MODO_AUTO) handleAuto();
  else handleApp();
}
