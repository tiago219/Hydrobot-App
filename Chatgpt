Aqui est√° o DashboardScreen.tsx completo, com o visual ‚Äúvermelhinho‚Äù para combinar com as outras telas e com a logo no topo (usando o caminho correto ../../assets/logo.png). Mantive todas as fun√ß√µes (expandir card, baixar, compartilhar, limpar, excluir).


// HydroBotApp2/src/screens/DashboardScreen.tsx
import { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Image,
  Pressable,
  Alert,
  TextInput,
  Modal,
  TouchableOpacity,
  SafeAreaView,
  Share,
} from "react-native";
import * as FileSystem from "expo-file-system";
import * as MediaLibrary from "expo-media-library";
import {
  getEvents,
  saveEventFromServer,
  deleteEvent,
  clearAllEvents,
  FireEvent,
} from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ============ TEMA ‚Äúvermelhinho‚Äù para combinar com as outras telas ============ */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#151318",
  card2: "#111015",
  border: "#2b2230",
  text: "#f1f5f9",
  sub: "#cbd5e1",
  accent: "#E6403A", // vermelho HB
  danger: "#ef4444",
  row: "#1a1418",
  chip: "#20171b",
  chipText: "#ffb3ad",
};

/* ================== TEXTOS ================== */
const texts = {
  pt: {
    title: "Dashboard",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar agora",
    saving: "Salvando...",
    empty1: "Sem eventos ainda.",
    empty2:
      "Quando o detector sinalizar fogo, capturaremos o snapshot automaticamente.\nVoc√™ tamb√©m pode tocar ‚ÄúRegistrar agora‚Äù.",
    fire: "Detec√ß√£o de fogo",
    clear: "Limpar",
    confirmClearTitle: "Limpar tudo",
    confirmClearBody: "Isso apagar√° todos os eventos e imagens. Continuar?",
    cancel: "Cancelar",
    delete: "Excluir",
    confirmDeleteTitle: "Excluir registro",
    confirmDeleteBody: "Deseja excluir este evento?",
    fail: "Falha ao salvar",
    failBody: "Verifique o servidor /snapshot e a rede.",
    details: "Detalhes",
    share: "Compartilhar",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Baixar",
    downloadedTo: (p: string) => `Imagem salva em:\n${p}`,
    savedToGallery: "Imagem salva na galeria üì∏",
    heroSubtitle: "Monitoramento e Controle",
  },
  en: {
    title: "Dashboard",
    server: "Server:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Save now",
    saving: "Saving...",
    empty1: "No events yet.",
    empty2:
      "When fire is detected, a snapshot is captured automatically.\nYou can also tap ‚ÄúSave now‚Äù.",
    fire: "Fire detection",
    clear: "Clear",
    confirmClearTitle: "Clear all",
    confirmClearBody: "This will delete all events and images. Continue?",
    cancel: "Cancel",
    delete: "Delete",
    confirmDeleteTitle: "Delete entry",
    confirmDeleteBody: "Do you want to delete this event?",
    fail: "Failed to save",
    failBody: "Check the /snapshot endpoint and network.",
    details: "Details",
    share: "Share",
    show: "Show",
    hide: "Hide",
    download: "Download",
    downloadedTo: (p: string) => `Image saved to:\n${p}`,
    savedToGallery: "Image saved to gallery üì∏",
    heroSubtitle: "Monitoring & Control",
  },
  es: {
    title: "Panel",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar ahora",
    saving: "Guardando...",
    empty1: "Sin eventos a√∫n.",
    empty2:
      "Cuando se detecte fuego, se capturar√° una imagen autom√°ticamente.\nTambi√©n puedes tocar ‚ÄúRegistrar ahora‚Äù.",
    fire: "Detecci√≥n de fuego",
    clear: "Limpiar",
    confirmClearTitle: "Limpiar todo",
    confirmClearBody: "Esto borrar√° todos los eventos e im√°genes. ¬øContinuar?",
    cancel: "Cancelar",
    delete: "Eliminar",
    confirmDeleteTitle: "Eliminar registro",
    confirmDeleteBody: "¬øDeseas eliminar este evento?",
    fail: "Error al guardar",
    failBody: "Revisa /snapshot y la red.",
    details: "Detalles",
    share: "Compartir",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Descargar",
    downloadedTo: (p: string) => `Imagen guardada en:\n${p}`,
    savedToGallery: "Imagen guardada en la galer√≠a üì∏",
    heroSubtitle: "Monitoreo y Control",
  },
};

const DEFAULT_SERVER = "http://192.168.4.2:8000";

/* ===== Logo (caminho correto partindo de src/screens) ===== */
const appLogo = require("../../assets/logo.png");

/* ===== Hero com logo ===== */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ===== Tipos ===== */
type EventWithMeta = FireEvent & { meta?: any };

/* =============================================================================
   COMPONENTE
============================================================================= */
export default function DashboardScreen() {
  const { lang } = useLanguage();
  const T = texts[lang];

  const [server, setServer] = useState<string>(DEFAULT_SERVER);
  const [items, setItems] = useState<EventWithMeta[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [preview, setPreview] = useState<EventWithMeta | null>(null);
  const [busy, setBusy] = useState(false);
  const [expanded, setExpanded] = useState<Set<string>>(new Set());

  async function load() {
    setRefreshing(true);
    try {
      const list = (await getEvents()) as EventWithMeta[];
      setItems(list);
    } finally {
      setRefreshing(false);
    }
  }
  useEffect(() => {
    load();
  }, []);

  async function handleRegisterNow() {
    try {
      setBusy(true);
      const ev = (await saveEventFromServer(server)) as EventWithMeta;
      setItems((prev) => [ev, ...prev]);
    } catch {
      Alert.alert(T.fail, T.failBody);
    } finally {
      setBusy(false);
    }
  }

  function confirmDelete(ev: EventWithMeta) {
    Alert.alert(T.confirmDeleteTitle, T.confirmDeleteBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.delete,
        style: "destructive",
        onPress: async () => {
          await deleteEvent(ev.id);
          setItems((prev) => prev.filter((x) => x.id !== ev.id));
          setExpanded((s) => {
            const n = new Set(s);
            n.delete(ev.id);
            return n;
          });
        },
      },
    ]);
  }

  function confirmClearAll() {
    Alert.alert(T.confirmClearTitle, T.confirmClearBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.clear,
        style: "destructive",
        onPress: async () => {
          await clearAllEvents();
          setItems([]);
          setExpanded(new Set());
        },
      },
    ]);
  }

  function toggleExpand(item: EventWithMeta) {
    setExpanded((prev) => {
      const n = new Set(prev);
      if (n.has(item.id)) n.delete(item.id);
      else n.add(item.id);
      return n;
    });
  }

  async function downloadImage(uri: string, id: string) {
    try {
      const filename = `${id}.jpg`;
      const dest = FileSystem.documentDirectory + filename;

      let localPath = dest;

      if (uri.startsWith("file://")) {
        await FileSystem.copyAsync({ from: uri, to: dest });
      } else {
        const res = await FileSystem.downloadAsync(uri, dest);
        localPath = res.uri;
      }

      try {
        const perm = await MediaLibrary.requestPermissionsAsync();
        if (perm.granted) {
          const asset = await MediaLibrary.createAssetAsync(localPath);
          const albumName = "HydroBot";
          let album = await MediaLibrary.getAlbumAsync(albumName);
          if (!album) {
            album = await MediaLibrary.createAlbumAsync(albumName, asset, false);
          } else {
            await MediaLibrary.addAssetsToAlbumAsync([asset], album, false);
          }
          Alert.alert("OK", T.savedToGallery);
          return;
        }
      } catch {}

      Alert.alert("OK", T.downloadedTo(localPath));
    } catch {
      Alert.alert("Erro", "Falha ao baixar imagem");
    }
  }

  const renderItem = ({ item }: { item: EventWithMeta }) => {
    const dateStr = new Date(item.ts).toLocaleString();
    const isOpen = expanded.has(item.id);

    return (
      <View style={styles.cardWrap}>
        {/* Cabe√ßalho */}
        <Pressable onPress={() => toggleExpand(item)} style={styles.cardHeader}>
          <Image source={{ uri: item.imageUri }} style={styles.thumb} />
          <View style={{ flex: 1 }}>
            <Text style={styles.title}>{T.fire}</Text>
            <Text style={styles.time}>{dateStr}</Text>
          </View>

          <View style={{ alignItems: "flex-end", gap: 8 }}>
            <Pressable
              onPress={() => toggleExpand(item)}
              style={[styles.expandBtn, isOpen && styles.expandBtnOn]}
            >
              <Text style={styles.expandTxt}>
                {isOpen ? "‚ñæ " + T.hide : "‚ñ∏ " + T.show}
              </Text>
            </Pressable>
            <Pressable onPress={() => confirmDelete(item)} style={styles.trashBtn}>
              <Text style={styles.trashTxt}>{T.delete}</Text>
            </Pressable>
          </View>
        </Pressable>

        {/* Painel expandido */}
        {isOpen && (
          <View style={styles.expandPanel}>
            <Pressable onPress={() => setPreview(item)} style={styles.bigImageWrap}>
              <Image source={{ uri: item.imageUri }} style={styles.bigImage} resizeMode="contain" />
            </Pressable>

            <View style={styles.detailsBox}>
              <Text style={styles.detailsTitle}>{T.details}</Text>
              <Text style={styles.timeBig}>{dateStr}</Text>
            </View>

            <View style={styles.actionsRow}>
              <Pressable
                style={[styles.actionBtn, { backgroundColor: PALETTE.accent }]}
                onPress={() => downloadImage(item.imageUri, item.id)}
              >
                <Text style={[styles.actionTxt, { color: "white" }]}>‚¨á {T.download}</Text>
              </Pressable>

              <Pressable
                style={[styles.actionBtn, { backgroundColor: "#3a2e33" }]}
                onPress={() =>
                  Share.share({
                    url: item.imageUri,
                    message: `${T.fire} ‚Ä¢ ${dateStr}`,
                  })
                }
              >
                <Text style={[styles.actionTxt, { color: "#fff" }]}>{T.share}</Text>
              </Pressable>
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      {/* HERO com logo */}
      <AppHero subtitle={T.heroSubtitle} />

      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.headerTitle}>{T.title}</Text>
        <Pressable onPress={confirmClearAll} style={styles.clearAllBtn}>
          <Text style={styles.clearAllTxt}>{T.clear}</Text>
        </Pressable>
      </View>

      {/* Linha do servidor + Registrar */}
      <View style={styles.row}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholder}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable
          onPress={handleRegisterNow}
          style={[styles.btn, busy && { opacity: 0.6 }]}
          disabled={busy}
        >
          <Text style={styles.btnTxt}>{busy ? T.saving : T.btnSave}</Text>
        </Pressable>
      </View>

      {/* Lista */}
      <FlatList
        data={items}
        keyExtractor={(it) => it.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={load}
        contentContainerStyle={items.length === 0 && { flex: 1, justifyContent: "center" }}
        ListEmptyComponent={
          <View style={{ alignItems: "center", paddingHorizontal: 16 }}>
            <Text style={{ color: PALETTE.sub, textAlign: "center" }}>{T.empty1}</Text>
            <Text style={{ color: PALETTE.sub, marginTop: 4, textAlign: "center" }}>{T.empty2}</Text>
          </View>
        }
      />

      {/* Modal zoom */}
      <Modal visible={!!preview} transparent animationType="fade" onRequestClose={() => setPreview(null)}>
        <View style={styles.modalBg}>
          <TouchableOpacity style={styles.modalBg} activeOpacity={1} onPress={() => setPreview(null)}>
            {preview && <Image source={{ uri: preview.imageUri }} style={styles.fullImg} resizeMode="contain" />}
          </TouchableOpacity>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

/* =========================
   ESTILOS
========================= */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  /* HERO */
  hero: {
    alignItems: "center",
    paddingTop: 18,
    paddingBottom: 8,
  },
  heroLogo: { width: 84, height: 84, resizeMode: "contain", marginBottom: 6 },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#e2e8f0", marginTop: 2 },

  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: "#1b1416",
  },
  headerTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700", flex: 1 },
  clearAllBtn: {
    paddingHorizontal: 10,
    paddingVertical: 8,
    backgroundColor: "#3a2a2d",
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#5a3a3f",
  },
  clearAllTxt: { color: "#ffd4cf", fontWeight: "800" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: "#161015",
  },
  label: { color: "#f3b7b1", fontSize: 12, fontWeight: "700" },
  input: {
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderRadius: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: "#3b2930",
    minWidth: 140,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 12,
  },
  btnTxt: { color: "white", fontWeight: "800" },

  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 12,
    marginTop: 12,
    borderRadius: 14,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#35252b",
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: {
    width: 86,
    height: 56,
    backgroundColor: "#000",
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#2b1f23",
  },
  title: { color: "#ffe2df", fontSize: 14, fontWeight: "800" },
  time: { color: "#eab7b1", fontSize: 12, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2b1f23",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#3b262b",
  },
  expandBtnOn: { backgroundColor: "#3b262b" },
  expandTxt: { color: "#ffd4cf", fontWeight: "800", fontSize: 12 },

  trashBtn: {
    backgroundColor: "#2a1e22",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#4b2f35",
  },
  trashTxt: { color: "#ffb4ad", fontWeight: "800", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#3b2930",
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 230 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#3b2930",
    backgroundColor: "#1b1416",
  },
  detailsTitle: { color: "#ffb3ad", fontWeight: "900", marginBottom: 6 },
  timeBig: { color: "#ffe2df", fontSize: 14, fontWeight: "700" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "900" },

  modalBg: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.92)",
    alignItems: "center",
    justifyContent: "center",
  },
  fullImg: { width: "100%", height: "100%" },
});



Se quiser, deixo o Settings e a C√¢mera com exatamente o mesmo ‚Äúhero‚Äù e tons para tudo ficar 100% consistente.












































Aqui est√° o DashboardScreen.tsx completo, com o visual ‚Äúvermelhinho‚Äù para combinar com as outras telas e com a logo no topo (usando o caminho correto ../../assets/logo.png). Mantive todas as fun√ß√µes (expandir card, baixar, compartilhar, limpar, excluir).


// HydroBotApp2/src/screens/DashboardScreen.tsx
import { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Image,
  Pressable,
  Alert,
  TextInput,
  Modal,
  TouchableOpacity,
  SafeAreaView,
  Share,
} from "react-native";
import * as FileSystem from "expo-file-system";
import * as MediaLibrary from "expo-media-library";
import {
  getEvents,
  saveEventFromServer,
  deleteEvent,
  clearAllEvents,
  FireEvent,
} from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ============ TEMA ‚Äúvermelhinho‚Äù para combinar com as outras telas ============ */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#151318",
  card2: "#111015",
  border: "#2b2230",
  text: "#f1f5f9",
  sub: "#cbd5e1",
  accent: "#E6403A", // vermelho HB
  danger: "#ef4444",
  row: "#1a1418",
  chip: "#20171b",
  chipText: "#ffb3ad",
};

/* ================== TEXTOS ================== */
const texts = {
  pt: {
    title: "Dashboard",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar agora",
    saving: "Salvando...",
    empty1: "Sem eventos ainda.",
    empty2:
      "Quando o detector sinalizar fogo, capturaremos o snapshot automaticamente.\nVoc√™ tamb√©m pode tocar ‚ÄúRegistrar agora‚Äù.",
    fire: "Detec√ß√£o de fogo",
    clear: "Limpar",
    confirmClearTitle: "Limpar tudo",
    confirmClearBody: "Isso apagar√° todos os eventos e imagens. Continuar?",
    cancel: "Cancelar",
    delete: "Excluir",
    confirmDeleteTitle: "Excluir registro",
    confirmDeleteBody: "Deseja excluir este evento?",
    fail: "Falha ao salvar",
    failBody: "Verifique o servidor /snapshot e a rede.",
    details: "Detalhes",
    share: "Compartilhar",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Baixar",
    downloadedTo: (p: string) => `Imagem salva em:\n${p}`,
    savedToGallery: "Imagem salva na galeria üì∏",
    heroSubtitle: "Monitoramento e Controle",
  },
  en: {
    title: "Dashboard",
    server: "Server:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Save now",
    saving: "Saving...",
    empty1: "No events yet.",
    empty2:
      "When fire is detected, a snapshot is captured automatically.\nYou can also tap ‚ÄúSave now‚Äù.",
    fire: "Fire detection",
    clear: "Clear",
    confirmClearTitle: "Clear all",
    confirmClearBody: "This will delete all events and images. Continue?",
    cancel: "Cancel",
    delete: "Delete",
    confirmDeleteTitle: "Delete entry",
    confirmDeleteBody: "Do you want to delete this event?",
    fail: "Failed to save",
    failBody: "Check the /snapshot endpoint and network.",
    details: "Details",
    share: "Share",
    show: "Show",
    hide: "Hide",
    download: "Download",
    downloadedTo: (p: string) => `Image saved to:\n${p}`,
    savedToGallery: "Image saved to gallery üì∏",
    heroSubtitle: "Monitoring & Control",
  },
  es: {
    title: "Panel",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar ahora",
    saving: "Guardando...",
    empty1: "Sin eventos a√∫n.",
    empty2:
      "Cuando se detecte fuego, se capturar√° una imagen autom√°ticamente.\nTambi√©n puedes tocar ‚ÄúRegistrar ahora‚Äù.",
    fire: "Detecci√≥n de fuego",
    clear: "Limpiar",
    confirmClearTitle: "Limpiar todo",
    confirmClearBody: "Esto borrar√° todos los eventos e im√°genes. ¬øContinuar?",
    cancel: "Cancelar",
    delete: "Eliminar",
    confirmDeleteTitle: "Eliminar registro",
    confirmDeleteBody: "¬øDeseas eliminar este evento?",
    fail: "Error al guardar",
    failBody: "Revisa /snapshot y la red.",
    details: "Detalles",
    share: "Compartir",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Descargar",
    downloadedTo: (p: string) => `Imagen guardada en:\n${p}`,
    savedToGallery: "Imagen guardada en la galer√≠a üì∏",
    heroSubtitle: "Monitoreo y Control",
  },
};

const DEFAULT_SERVER = "http://192.168.4.2:8000";

/* ===== Logo (caminho correto partindo de src/screens) ===== */
const appLogo = require("../../assets/logo.png");

/* ===== Hero com logo ===== */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ===== Tipos ===== */
type EventWithMeta = FireEvent & { meta?: any };

/* =============================================================================
   COMPONENTE
============================================================================= */
export default function DashboardScreen() {
  const { lang } = useLanguage();
  const T = texts[lang];

  const [server, setServer] = useState<string>(DEFAULT_SERVER);
  const [items, setItems] = useState<EventWithMeta[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [preview, setPreview] = useState<EventWithMeta | null>(null);
  const [busy, setBusy] = useState(false);
  const [expanded, setExpanded] = useState<Set<string>>(new Set());

  async function load() {
    setRefreshing(true);
    try {
      const list = (await getEvents()) as EventWithMeta[];
      setItems(list);
    } finally {
      setRefreshing(false);
    }
  }
  useEffect(() => {
    load();
  }, []);

  async function handleRegisterNow() {
    try {
      setBusy(true);
      const ev = (await saveEventFromServer(server)) as EventWithMeta;
      setItems((prev) => [ev, ...prev]);
    } catch {
      Alert.alert(T.fail, T.failBody);
    } finally {
      setBusy(false);
    }
  }

  function confirmDelete(ev: EventWithMeta) {
    Alert.alert(T.confirmDeleteTitle, T.confirmDeleteBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.delete,
        style: "destructive",
        onPress: async () => {
          await deleteEvent(ev.id);
          setItems((prev) => prev.filter((x) => x.id !== ev.id));
          setExpanded((s) => {
            const n = new Set(s);
            n.delete(ev.id);
            return n;
          });
        },
      },
    ]);
  }

  function confirmClearAll() {
    Alert.alert(T.confirmClearTitle, T.confirmClearBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.clear,
        style: "destructive",
        onPress: async () => {
          await clearAllEvents();
          setItems([]);
          setExpanded(new Set());
        },
      },
    ]);
  }

  function toggleExpand(item: EventWithMeta) {
    setExpanded((prev) => {
      const n = new Set(prev);
      if (n.has(item.id)) n.delete(item.id);
      else n.add(item.id);
      return n;
    });
  }

  async function downloadImage(uri: string, id: string) {
    try {
      const filename = `${id}.jpg`;
      const dest = FileSystem.documentDirectory + filename;

      let localPath = dest;

      if (uri.startsWith("file://")) {
        await FileSystem.copyAsync({ from: uri, to: dest });
      } else {
        const res = await FileSystem.downloadAsync(uri, dest);
        localPath = res.uri;
      }

      try {
        const perm = await MediaLibrary.requestPermissionsAsync();
        if (perm.granted) {
          const asset = await MediaLibrary.createAssetAsync(localPath);
          const albumName = "HydroBot";
          let album = await MediaLibrary.getAlbumAsync(albumName);
          if (!album) {
            album = await MediaLibrary.createAlbumAsync(albumName, asset, false);
          } else {
            await MediaLibrary.addAssetsToAlbumAsync([asset], album, false);
          }
          Alert.alert("OK", T.savedToGallery);
          return;
        }
      } catch {}

      Alert.alert("OK", T.downloadedTo(localPath));
    } catch {
      Alert.alert("Erro", "Falha ao baixar imagem");
    }
  }

  const renderItem = ({ item }: { item: EventWithMeta }) => {
    const dateStr = new Date(item.ts).toLocaleString();
    const isOpen = expanded.has(item.id);

    return (
      <View style={styles.cardWrap}>
        {/* Cabe√ßalho */}
        <Pressable onPress={() => toggleExpand(item)} style={styles.cardHeader}>
          <Image source={{ uri: item.imageUri }} style={styles.thumb} />
          <View style={{ flex: 1 }}>
            <Text style={styles.title}>{T.fire}</Text>
            <Text style={styles.time}>{dateStr}</Text>
          </View>

          <View style={{ alignItems: "flex-end", gap: 8 }}>
            <Pressable
              onPress={() => toggleExpand(item)}
              style={[styles.expandBtn, isOpen && styles.expandBtnOn]}
            >
              <Text style={styles.expandTxt}>
                {isOpen ? "‚ñæ " + T.hide : "‚ñ∏ " + T.show}
              </Text>
            </Pressable>
            <Pressable onPress={() => confirmDelete(item)} style={styles.trashBtn}>
              <Text style={styles.trashTxt}>{T.delete}</Text>
            </Pressable>
          </View>
        </Pressable>

        {/* Painel expandido */}
        {isOpen && (
          <View style={styles.expandPanel}>
            <Pressable onPress={() => setPreview(item)} style={styles.bigImageWrap}>
              <Image source={{ uri: item.imageUri }} style={styles.bigImage} resizeMode="contain" />
            </Pressable>

            <View style={styles.detailsBox}>
              <Text style={styles.detailsTitle}>{T.details}</Text>
              <Text style={styles.timeBig}>{dateStr}</Text>
            </View>

            <View style={styles.actionsRow}>
              <Pressable
                style={[styles.actionBtn, { backgroundColor: PALETTE.accent }]}
                onPress={() => downloadImage(item.imageUri, item.id)}
              >
                <Text style={[styles.actionTxt, { color: "white" }]}>‚¨á {T.download}</Text>
              </Pressable>

              <Pressable
                style={[styles.actionBtn, { backgroundColor: "#3a2e33" }]}
                onPress={() =>
                  Share.share({
                    url: item.imageUri,
                    message: `${T.fire} ‚Ä¢ ${dateStr}`,
                  })
                }
              >
                <Text style={[styles.actionTxt, { color: "#fff" }]}>{T.share}</Text>
              </Pressable>
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      {/* HERO com logo */}
      <AppHero subtitle={T.heroSubtitle} />

      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.headerTitle}>{T.title}</Text>
        <Pressable onPress={confirmClearAll} style={styles.clearAllBtn}>
          <Text style={styles.clearAllTxt}>{T.clear}</Text>
        </Pressable>
      </View>

      {/* Linha do servidor + Registrar */}
      <View style={styles.row}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholder}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable
          onPress={handleRegisterNow}
          style={[styles.btn, busy && { opacity: 0.6 }]}
          disabled={busy}
        >
          <Text style={styles.btnTxt}>{busy ? T.saving : T.btnSave}</Text>
        </Pressable>
      </View>

      {/* Lista */}
      <FlatList
        data={items}
        keyExtractor={(it) => it.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={load}
        contentContainerStyle={items.length === 0 && { flex: 1, justifyContent: "center" }}
        ListEmptyComponent={
          <View style={{ alignItems: "center", paddingHorizontal: 16 }}>
            <Text style={{ color: PALETTE.sub, textAlign: "center" }}>{T.empty1}</Text>
            <Text style={{ color: PALETTE.sub, marginTop: 4, textAlign: "center" }}>{T.empty2}</Text>
          </View>
        }
      />

      {/* Modal zoom */}
      <Modal visible={!!preview} transparent animationType="fade" onRequestClose={() => setPreview(null)}>
        <View style={styles.modalBg}>
          <TouchableOpacity style={styles.modalBg} activeOpacity={1} onPress={() => setPreview(null)}>
            {preview && <Image source={{ uri: preview.imageUri }} style={styles.fullImg} resizeMode="contain" />}
          </TouchableOpacity>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

/* =========================
   ESTILOS
========================= */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  /* HERO */
  hero: {
    alignItems: "center",
    paddingTop: 18,
    paddingBottom: 8,
  },
  heroLogo: { width: 84, height: 84, resizeMode: "contain", marginBottom: 6 },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#e2e8f0", marginTop: 2 },

  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: "#1b1416",
  },
  headerTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700", flex: 1 },
  clearAllBtn: {
    paddingHorizontal: 10,
    paddingVertical: 8,
    backgroundColor: "#3a2a2d",
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#5a3a3f",
  },
  clearAllTxt: { color: "#ffd4cf", fontWeight: "800" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: "#161015",
  },
  label: { color: "#f3b7b1", fontSize: 12, fontWeight: "700" },
  input: {
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderRadius: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: "#3b2930",
    minWidth: 140,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 12,
  },
  btnTxt: { color: "white", fontWeight: "800" },

  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 12,
    marginTop: 12,
    borderRadius: 14,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#35252b",
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: {
    width: 86,
    height: 56,
    backgroundColor: "#000",
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#2b1f23",
  },
  title: { color: "#ffe2df", fontSize: 14, fontWeight: "800" },
  time: { color: "#eab7b1", fontSize: 12, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2b1f23",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#3b262b",
  },
  expandBtnOn: { backgroundColor: "#3b262b" },
  expandTxt: { color: "#ffd4cf", fontWeight: "800", fontSize: 12 },

  trashBtn: {
    backgroundColor: "#2a1e22",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#4b2f35",
  },
  trashTxt: { color: "#ffb4ad", fontWeight: "800", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#3b2930",
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 230 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#3b2930",
    backgroundColor: "#1b1416",
  },
  detailsTitle: { color: "#ffb3ad", fontWeight: "900", marginBottom: 6 },
  timeBig: { color: "#ffe2df", fontSize: 14, fontWeight: "700" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "900" },

  modalBg: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.92)",
    alignItems: "center",
    justifyContent: "center",
  },
  fullImg: { width: "100%", height: "100%" },
});



Se quiser, deixo o Settings e a C√¢mera com exatamente o mesmo ‚Äúhero‚Äù e tons para tudo ficar 100% consistente.




































































































perfeito ‚Äî deixei a C√¢mera no modo que voc√™ pediu:




Detec√ß√£o sempre ativa (sem bot√£o).


Snapshot (fallback) como vis√£o padr√£o (sem op√ß√£o de trocar para stream).


Removi o bot√£o ‚ÄúBoxes‚Äù (o mini-preview do servidor). O overlay de caixas na pr√≥pria imagem continua funcionando.


Barra do servidor simplificada (mostra ‚ÄúDetectando‚Ä¶‚Äù quando ativo).




Cole isso em HydroBotApp2/src/screens/CameraScreen.tsx:


// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
  Animated,
  LayoutChangeEvent,
} from "react-native";
import { WebView } from "react-native-webview";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ---------- PALETA ---------- */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#121218",
  border: "#25273a",
  accent: "#e6403a",
  text: "#e5e7eb",
};

/* ---------- TEXTOS ---------- */
const textsByLang = {
  pt: {
    heroSubtitle: "Monitoramento e Controle",
    espIp: "ESP IP:",
    test: "Testar",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "BOMBA ON",
    pumpOff: "BOMBA OFF",
    server: "Servidor:",
    detecting: "Detectando‚Ä¶",
    saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi/IP.",
    noVideo: "Sem v√≠deo (snapshot). Verifique o servidor.",
    fireOn: (s: number) => `üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sem fogo ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento salvo em ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    persons: "Pessoas",
    animals: "Animais",
    backend: "Modelo",
  },
  en: {
    heroSubtitle: "Monitoring & Control",
    espIp: "ESP IP:",
    test: "Test",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "PUMP ON",
    pumpOff: "PUMP OFF",
    server: "Server:",
    detecting: "Detecting‚Ä¶",
    saving: "Saving...",
    statusFail: "Failed to connect. Check Wi-Fi/IP.",
    noVideo: "No video (snapshot). Check the server.",
    fireOn: (s: number) => `üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `No fire ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Event saved at ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    persons: "People",
    animals: "Animals",
    backend: "Model",
  },
  es: {
    heroSubtitle: "Monitoreo y Control",
    espIp: "ESP IP:",
    test: "Probar",
    ledOn: "LED ENC.",
    ledOff: "LED APAG.",
    pumpOn: "BOMBA ENC.",
    pumpOff: "BOMBA APAG.",
    server: "Servidor:",
    detecting: "Detectando‚Ä¶",
    saving: "Guardando...",
    statusFail: "Error de conexi√≥n. Revisa Wi-Fi/IP.",
    noVideo: "Sin v√≠deo (snapshot). Revisa el servidor.",
    fireOn: (s: number) => `üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sin fuego ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento guardado a las ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    persons: "Personas",
    animals: "Animales",
    backend: "Modelo",
  },
};

const DEFAULT_IP = "192.168.4.1";
const DEFAULT_SERVER = "http://192.168.4.2:8000";

// caminho correto da logo a partir de src/screens
const appLogo = require("../../assets/logo.png");

/* ---------- HERO ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ---------- STREAM (mantido para poss√≠vel uso futuro) ---------- */
function LiveMJPEG({ ip }: { ip: string }) {
  const html = `
    <html><head><meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;}
        .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;}
        img{max-width:100%;max-height:100%;object-fit:contain;background:#000;}
      </style>
    </head>
    <body><div class="wrap"><img src="http://${ip}:81/stream"/></div></body></html>
  `.trim();

  return (
    <WebView
      originWhitelist={["*"]}
      source={{ html }}
      javaScriptEnabled
      allowsInlineMediaPlayback
      mediaPlaybackRequiresUserAction={false}
      automaticallyAdjustContentInsets={false}
      style={{ flex: 1, backgroundColor: "black" }}
    />
  );
}

/* ---------- SNAPSHOT com crossfade ---------- */
function CrossfadeImage({
  currentUri,
  nextUri,
  onNextLoadStart,
  onNextShown,
}: {
  currentUri: string;
  nextUri: string;
  onNextLoadStart: () => void;
  onNextShown: () => void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}

      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={onNextShown}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown();
                fade.setValue(0);
                setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- OVERLAY DE CAIXAS ---------- */
type BoxType = "fire" | "person" | "animal";
type SrcBox = { x: number; y: number; w: number; h: number; type: BoxType; conf?: number };

function BoxesOverlay({
  frameWH,
  containerWH,
  boxes,
}: {
  frameWH: { w: number; h: number } | null;
  containerWH: { w: number; h: number } | null;
  boxes: SrcBox[];
}) {
  if (!frameWH || !containerWH || frameWH.w <= 0 || frameWH.h <= 0 || containerWH.w <= 0 || containerWH.h <= 0) {
    return null;
  }
  const scale = Math.min(containerWH.w / frameWH.w, containerWH.h / frameWH.h);
  const dispW = frameWH.w * scale;
  const dispH = frameWH.h * scale;
  const offsetX = (containerWH.w - dispW) / 2;
  const offsetY = (containerWH.h - dispH) / 2;

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position: "absolute", left: offsetX, top: offsetY, width: dispW, height: dispH }}>
        {boxes.map((b, i) => {
          const left = b.x * scale;
          const top = b.y * scale;
          const width = b.w * scale;
          const height = b.h * scale;

          let borderColor = "#ff3b30"; // fire
          if (b.type === "person") borderColor = "#00e5ff";
          else if (b.type === "animal") borderColor = "#7CFC00";

          return (
            <View
              key={`${i}-${b.type}`}
              style={{ position: "absolute", left, top, width, height, borderWidth: 3, borderColor, borderRadius: 6 }}
            >
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  top: -18,
                  paddingHorizontal: 6,
                  paddingVertical: 2,
                  borderRadius: 4,
                  backgroundColor: borderColor,
                }}
              >
                <Text style={{ color: "#000", fontWeight: "800", fontSize: 10 }}>
                  {b.type.toUpperCase()}
                  {typeof b.conf === "number" ? ` ${b.conf.toFixed(2)}` : ""}
                </Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- TELA PRINCIPAL ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados do ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState("‚Äî");
  const [ledOn, setLedOn] = useState(false);
  const [pumpOn, setPumpOn] = useState(false);

  // detec√ß√£o (sempre ativa)
  const [detectOn] = useState(true);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  // pessoas/animais
  const [people, setPeople] = useState(0);
  const [animals, setAnimals] = useState(0);
  const [backend, setBackend] = useState<string>("‚Äî");
  const [confMax, setConfMax] = useState<number>(0);

  // caixas + dimens√µes para overlay
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{ w: number; h: number } | null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{ w: number; h: number } | null>(null);

  // registro autom√°tico
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef(0);
  const wasFireRef = useRef(false);
  const SAVE_COOLDOWN_MS = 5000;

  // vis√£o: sempre SNAPSHOT fallback (sem bot√£o para trocar)
  const [useStream] = useState(false);
  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  // joystick (UI)
  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // helpers URL
  const cleanServer = (s: string) => s.replace(/\/+$/, "");
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  /* ===== ESP STATUS ===== */
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl);
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(`OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`);
    } catch {
      setStatusText(T.statusFail);
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  /* ===== SNAPSHOT fallback (25 fps alvo) ===== */
  useEffect(() => {
    let stop = false;
    const FPS_INTERVAL = 40; // ~25 fps

    setCurrentFrameUri(`${cleanServer(server)}/snapshot?ts=${Date.now()}`);

    const tick = () => {
      if (stop) return;
      if (!loadingNextRef.current) {
        const url = `${cleanServer(server)}/snapshot?ts=${Date.now()}`;
        setNextFrameUri(url);
      }
      setTimeout(tick, FPS_INTERVAL);
    };
    tick();

    return () => {
      stop = true;
    };
  }, [server]);

  function onNextLoadStart() {
    loadingNextRef.current = true;
  }
  function onNextShown() {
    if (nextFrameUri) setCurrentFrameUri(nextFrameUri);
    loadingNextRef.current = false;
  }

  /* ===== LOOP DE DETEC√á√ÉO + CAIXAS ===== */
  useEffect(() => {
    let stop = false;

    const loop = async () => {
      try {
        const r = await fetch(`${cleanServer(server)}/detect`);
        const j = await r.json();

        if (!stop && j && j.ok !== false) {
          // fogo
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));

          // frame size (se servidor expor; opcional)
          const wh =
            Array.isArray(j.frame_wh) && j.frame_wh.length === 2
              ? { w: Number(j.frame_wh[0]) || 0, h: Number(j.frame_wh[1]) || 0 }
              : null;
          if (wh && wh.w > 0 && wh.h > 0) setFrameWH(wh);

          // objetos e est√°veis
          const o = j.objects || {};
          const objs = o.objects || [];
          const peopleStable =
            typeof o.n_person_stable === "number"
              ? o.n_person_stable
              : typeof o.n_person === "number"
              ? o.n_person
              : objs.some((x: any) => String(x.label).toLowerCase() === "person")
              ? 1
              : 0;
          const animalsStable =
            typeof o.n_animals_stable === "number"
              ? o.n_animals_stable
              : typeof o.n_animals === "number"
              ? o.n_animals
              : objs.some((x: any) => String(x.label).toLowerCase() !== "person")
              ? 1
              : 0;

          setPeople(peopleStable);
          setAnimals(animalsStable);
          setBackend(o.backend || "‚Äî");
          setConfMax(Number(o.conf_max || 0));

          // montar caixas
          const boxes: SrcBox[] = [];

          if (j.isFire && Array.isArray(j.boxes)) {
            for (const b of j.boxes) {
              if (!Array.isArray(b) || b.length < 4) continue;
              const [x, y, w, h] = b.map((n: any) => Number(n) || 0);
              boxes.push({ x, y, w, h, type: "fire" });
            }
          }
          for (const it of objs) {
            if (!it || !Array.isArray(it.box) || it.box.length < 4) continue;
            const [x, y, w, h] = it.box.map((n: any) => Number(n) || 0);
            const label = String(it.label || "").toLowerCase();
            const conf = typeof it.conf === "number" ? it.conf : undefined;
            if (label === "person") boxes.push({ x, y, w, h, type: "person", conf });
            else boxes.push({ x, y, w, h, type: "animal", conf });
          }
          setOverlayBoxes(boxes);
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
          setPeople(0);
          setAnimals(0);
          setOverlayBoxes([]);
        }
      } finally {
        if (!stop) setTimeout(loop, 180); // ~5-6Hz
      }
    };
    loop();

    return () => {
      stop = true;
    };
  }, [server]);

  /* ===== Registro autom√°tico ===== */
  useEffect(() => {
    const rising = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;

    if (rising && cooldownOk && !saving) {
      (async () => {
        try {
          setSaving(true);
          await saveEventFromServer(server);
          lastSaveRef.current = Date.now();
          setStatusText(T.eventSavedAt(new Date(lastSaveRef.current).toLocaleString()));
        } catch {
          setStatusText(T.noVideo);
        } finally {
          setSaving(false);
        }
      })();
    }
    wasFireRef.current = isFire;
  }, [isFire, server, saving, T]);

  /* ===== Joystick ===== */
  const RADIUS = 64,
    KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS,
          ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny });
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  /* ===== Medidas do container do v√≠deo ===== */
  function onVideoLayout(e: LayoutChangeEvent) {
    const { width, height } = e.nativeEvent.layout;
    setVideoContainerWH({ w: width, h: height });
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder={T.placeholderIp}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : T.test}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? T.ledOn : T.ledOff}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? T.pumpOn : T.pumpOff}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor + indicador (sem bot√µes de detectar/stream/boxes) */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholderServer}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <View style={[styles.badge]}>
          <Text style={{ color: "#fff", fontWeight: "800" }}>{T.detecting}</Text>
        </View>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Banner de fogo */}
      <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      {/* Banner de pessoas/animais + backend */}
      <View style={[styles.statusRow, { justifyContent: "space-between" }]}>
        <Text style={styles.statChip}>
          {T.persons}: <Text style={styles.statNumber}>{people}</Text>
        </Text>
        <Text style={styles.statChip}>
          {T.animals}: <Text style={styles.statNumber}>{animals}</Text>
        </Text>
        <Text style={styles.modelChip}>
          {T.backend}: {backend} ‚Ä¢ conf_max {confMax.toFixed(2)}
        </Text>
      </View>

      {/* V√≠deo (sempre snapshot) + Overlay */}
      <View style={{ flex: 1 }} onLayout={onVideoLayout}>
        <CrossfadeImage
          currentUri={currentFrameUri}
          nextUri={nextFrameUri}
          onNextLoadStart={onNextLoadStart}
          onNextShown={onNextShown}
        />

        {overlayBoxes.length > 0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: 64 * 2 + 24, height: 64 * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: 64 * 2, height: 64 * 2, borderRadius: 64 }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: 22 * 2,
                height: 22 * 2,
                borderRadius: 22,
                transform: [{ translateX: joy.x * 64 }, { translateY: -joy.y * 64 }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

/* ---------- ESTILOS ---------- */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  // HERO
  hero: { alignItems: "center", paddingTop: 12, paddingBottom: 6 },
  heroLogo: { width: 80, height: 80, marginBottom: 6, resizeMode: "contain" },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 2 },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: "#0b0d14",
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 110,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1322",
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  badge: {
    backgroundColor: "#1f2937",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  statChip: { color: "#dbeafe", fontSize: 14, fontWeight: "600" },
  statNumber: { color: "#fff" },
  modelChip: { marginLeft: "auto", color: "#9fb0ff", fontSize: 12 },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: {
    position: "absolute",
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.14)",
  },
  joyKnob: {
    position: "absolute",
    backgroundColor: "rgba(230,64,58,0.9)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.85)",
  },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});



se quiser tamb√©m sumo com os bot√µes de LED/BOMBA e deixo s√≥ o v√≠deo + overlay üòâ




























































const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
  },
  headerTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700", flex: 1 },
  clearAllBtn: {
    paddingHorizontal: 10,
    paddingVertical: 8,
    backgroundColor: PALETTE.danger,
    borderRadius: 8,
  },
  clearAllTxt: { color: "white", fontWeight: "700" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.row,
  },
  label: { color: PALETTE.sub, fontSize: 12 },
  input: {
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 140,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnTxt: { color: "white", fontWeight: "700" },

  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 10,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: { width: 84, height: 56, backgroundColor: "#000", borderRadius: 8 },
  title: { color: PALETTE.text, fontSize: 14, fontWeight: "700" },
  time: { color: PALETTE.sub, fontSize: 12, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2a2f3d",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  expandBtnOn: { backgroundColor: "#1d2435" },
  expandTxt: { color: "#cbd5ff", fontWeight: "700", fontSize: 12 },

  trashBtn: {
    backgroundColor: "#333",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  trashTxt: { color: "#fca5a5", fontWeight: "700", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 10,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 220 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#0c1020",
  },
  detailsTitle: { color: PALETTE.chipText, fontWeight: "800", marginBottom: 6 },
  timeBig: { color: PALETTE.text, fontSize: 14, fontWeight: "600" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 10,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "800" },

  modalBg: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.92)",
    alignItems: "center",
    justifyContent: "center",
  },
  fullImg: { width: "100%", height: "100%" },

  // ======= QUICK ACTION STYLES =======
  quickRow: {
    flexDirection: "row",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 12,
    backgroundColor: PALETTE.row,
  },
  quickBtn: {
    flex: 1,
    backgroundColor: "#141622",
    borderRadius: 16,
    paddingVertical: 18,
    paddingHorizontal: 12,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  quickIcon: {
    fontSize: 22,
    marginBottom: 8,
    color: "#fff",
    opacity: 0.9,
  },
  quickLabel: {
    color: "#fff",
    fontWeight: "800",
    fontSize: 13,
    textAlign: "center",
  },
});














// HydroBotApp2/src/screens/DashboardScreen.tsx
import { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Image,
  Pressable,
  Alert,
  TextInput,
  Modal,
  TouchableOpacity,
  SafeAreaView,
  Share,
} from "react-native";
import * as FileSystem from "expo-file-system";
import * as MediaLibrary from "expo-media-library";
import {
  getEvents,
  saveEventFromServer,
  deleteEvent,
  clearAllEvents,
  FireEvent,
} from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = {
  bg: "#0a0a0a",
  card: "#121212",
  card2: "#0e0e10",
  border: "#232323",
  text: "#e5e7eb",
  sub: "#9ca3af",
  accent: "#2b48ff",
  danger: "#ef4444",
  row: "#0f1730",
  chip: "#182033",
  chipText: "#b7c6ff",
};

const texts = {
  pt: {
    title: "Dashboard",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar agora",
    saving: "Salvando...",
    empty1: "Sem eventos ainda.",
    empty2:
      "Quando o detector sinalizar fogo, capturaremos o snapshot automaticamente.\nVoc√™ tamb√©m pode tocar ‚ÄúRegistrar agora‚Äù.",
    fire: "Detec√ß√£o de fogo",
    clear: "Limpar",
    confirmClearTitle: "Limpar tudo",
    confirmClearBody: "Isso apagar√° todos os eventos e imagens. Continuar?",
    cancel: "Cancelar",
    delete: "Excluir",
    confirmDeleteTitle: "Excluir registro",
    confirmDeleteBody: "Deseja excluir este evento?",
    fail: "Falha ao salvar",
    failBody: "Verifique o servidor /snapshot e a rede.",
    details: "Detalhes",
    share: "Compartilhar",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Baixar",
    downloadedTo: (p: string) => `Imagem salva em:\n${p}`,
    savedToGallery: "Imagem salva na galeria üì∏",
  },
  en: {
    title: "Dashboard",
    server: "Server:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Save now",
    saving: "Saving...",
    empty1: "No events yet.",
    empty2:
      "When fire is detected, a snapshot is captured automatically.\nYou can also tap ‚ÄúSave now‚Äù.",
    fire: "Fire detection",
    clear: "Clear",
    confirmClearTitle: "Clear all",
    confirmClearBody: "This will delete all events and images. Continue?",
    cancel: "Cancel",
    delete: "Delete",
    confirmDeleteTitle: "Delete entry",
    confirmDeleteBody: "Do you want to delete this event?",
    fail: "Failed to save",
    failBody: "Check the /snapshot endpoint and network.",
    details: "Details",
    share: "Share",
    show: "Show",
    hide: "Hide",
    download: "Download",
    downloadedTo: (p: string) => `Image saved to:\n${p}`,
    savedToGallery: "Image saved to gallery üì∏",
  },
  es: {
    title: "Panel",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar ahora",
    saving: "Guardando...",
    empty1: "Sin eventos a√∫n.",
    empty2:
      "Cuando se detecte fuego, se capturar√° una imagen autom√°ticamente.\nTambi√©n puedes tocar ‚ÄúRegistrar ahora‚Äù.",
    fire: "Detecci√≥n de fuego",
    clear: "Limpiar",
    confirmClearTitle: "Limpiar todo",
    confirmClearBody: "Esto borrar√° todos los eventos e im√°genes. ¬øContinuar?",
    cancel: "Cancelar",
    delete: "Eliminar",
    confirmDeleteTitle: "Eliminar registro",
    confirmDeleteBody: "¬øDeseas eliminar este evento?",
    fail: "Error al guardar",
    failBody: "Revisa /snapshot y la red.",
    details: "Detalles",
    share: "Compartir",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Descargar",
    downloadedTo: (p: string) => `Imagen guardada en:\n${p}`,
    savedToGallery: "Imagen guardada en la galer√≠a üì∏",
  },
};

const DEFAULT_SERVER = "http://192.168.4.2:8000";
type EventWithMeta = FireEvent & { meta?: any };

export default function DashboardScreen() {
  const { lang } = useLanguage();
  const T = texts[lang];

  const [server, setServer] = useState<string>(DEFAULT_SERVER);
  const [items, setItems] = useState<EventWithMeta[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [preview, setPreview] = useState<EventWithMeta | null>(null);
  const [busy, setBusy] = useState(false);
  const [expanded, setExpanded] = useState<Set<string>>(new Set());

  async function load() {
    setRefreshing(true);
    try {
      const list = (await getEvents()) as EventWithMeta[];
      setItems(list);
    } finally {
      setRefreshing(false);
    }
  }
  useEffect(() => {
    load();
  }, []);

  async function handleRegisterNow() {
    try {
      setBusy(true);
      const ev = (await saveEventFromServer(server)) as EventWithMeta;
      setItems((prev) => [ev, ...prev]);
    } catch {
      Alert.alert(T.fail, T.failBody);
    } finally {
      setBusy(false);
    }
  }

  function confirmDelete(ev: EventWithMeta) {
    Alert.alert(T.confirmDeleteTitle, T.confirmDeleteBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.delete,
        style: "destructive",
        onPress: async () => {
          await deleteEvent(ev.id);
          setItems((prev) => prev.filter((x) => x.id !== ev.id));
          setExpanded((s) => {
            const n = new Set(s);
            n.delete(ev.id);
            return n;
          });
        },
      },
    ]);
  }

  function confirmClearAll() {
    Alert.alert(T.confirmClearTitle, T.confirmClearBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.clear,
        style: "destructive",
        onPress: async () => {
          await clearAllEvents();
          setItems([]);
          setExpanded(new Set());
        },
      },
    ]);
  }

  function toggleExpand(item: EventWithMeta) {
    setExpanded((prev) => {
      const n = new Set(prev);
      if (n.has(item.id)) n.delete(item.id);
      else n.add(item.id);
      return n;
    });
  }

  async function downloadImage(uri: string, id: string) {
    try {
      const filename = `${id}.jpg`;
      const dest = FileSystem.documentDirectory + filename;

      let localPath = dest;

      if (uri.startsWith("file://")) {
        await FileSystem.copyAsync({ from: uri, to: dest });
      } else {
        const res = await FileSystem.downloadAsync(uri, dest);
        localPath = res.uri;
      }

      try {
        const perm = await MediaLibrary.requestPermissionsAsync();
        if (perm.granted) {
          const asset = await MediaLibrary.createAssetAsync(localPath);
          const albumName = "HydroBot";
          let album = await MediaLibrary.getAlbumAsync(albumName);
          if (!album) {
            album = await MediaLibrary.createAlbumAsync(albumName, asset, false);
          } else {
            await MediaLibrary.addAssetsToAlbumAsync([asset], album, false);
          }
          Alert.alert("OK", T.savedToGallery);
          return;
        }
      } catch {}

      Alert.alert("OK", T.downloadedTo(localPath));
    } catch {
      Alert.alert("Erro", "Falha ao baixar imagem");
    }
  }

  const renderItem = ({ item }: { item: EventWithMeta }) => {
    const dateStr = new Date(item.ts).toLocaleString();
    const isOpen = expanded.has(item.id);

    return (
      <View style={styles.cardWrap}>
        <Pressable onPress={() => toggleExpand(item)} style={styles.cardHeader}>
          <Image source={{ uri: item.imageUri }} style={styles.thumb} />
          <View style={{ flex: 1 }}>
            <Text style={styles.title}>{T.fire}</Text>
            <Text style={styles.time}>{dateStr}</Text>
          </View>
          <View style={{ alignItems: "flex-end", gap: 8 }}>
            <Pressable
              onPress={() => toggleExpand(item)}
              style={[styles.expandBtn, isOpen && styles.expandBtnOn]}
            >
              <Text style={styles.expandTxt}>
                {isOpen ? "‚ñæ " + T.hide : "‚ñ∏ " + T.show}
              </Text>
            </Pressable>
            <Pressable onPress={() => confirmDelete(item)} style={styles.trashBtn}>
              <Text style={styles.trashTxt}>{T.delete}</Text>
            </Pressable>
          </View>
        </Pressable>

        {isOpen && (
          <View style={styles.expandPanel}>
            <Pressable
              onPress={() => setPreview(item)}
              style={styles.bigImageWrap}
            >
              <Image
                source={{ uri: item.imageUri }}
                style={styles.bigImage}
                resizeMode="contain"
              />
            </Pressable>

            <View style={styles.detailsBox}>
              <Text style={styles.detailsTitle}>{T.details}</Text>
              <Text style={styles.timeBig}>{dateStr}</Text>
            </View>

            <View style={styles.actionsRow}>
              <Pressable
                style={[styles.actionBtn, { backgroundColor: PALETTE.accent }]}
                onPress={() => downloadImage(item.imageUri, item.id)}
              >
                <Text style={[styles.actionTxt, { color: "white" }]}>
                  ‚¨á {T.download}
                </Text>
              </Pressable>

              <Pressable
                style={[styles.actionBtn, { backgroundColor: "#444" }]}
                onPress={() =>
                  Share.share({
                    url: item.imageUri,
                    message: `${T.fire} ‚Ä¢ ${dateStr}`,
                  })
                }
              >
                <Text style={[styles.actionTxt, { color: "#fff" }]}>{T.share}</Text>
              </Pressable>
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.headerTitle}>{T.title}</Text>
        <Pressable onPress={confirmClearAll} style={styles.clearAllBtn}>
          <Text style={styles.clearAllTxt}>{T.clear}</Text>
        </Pressable>
      </View>

      <View style={styles.row}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholder}
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable
          onPress={handleRegisterNow}
          style={[styles.btn, busy && { opacity: 0.6 }]}
          disabled={busy}
        >
          <Text style={styles.btnTxt}>{busy ? T.saving : T.btnSave}</Text>
        </Pressable>
      </View>

      <FlatList
        data={items}
        keyExtractor={(it) => it.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={load}
        contentContainerStyle={
          items.length === 0 && { flex: 1, justifyContent: "center" }
        }
        ListEmptyComponent={
          <View style={{ alignItems: "center", paddingHorizontal: 16 }}>
            <Text style={{ color: PALETTE.sub, textAlign: "center" }}>
              {T.empty1}
            </Text>
            <Text
              style={{
                color: PALETTE.sub,
                marginTop: 4,
                textAlign: "center",
              }}
            >
              {T.empty2}
            </Text>
          </View>
        }
      />

      <Modal
        visible={!!preview}
        transparent
        animationType="fade"
        onRequestClose={() => setPreview(null)}
      >
        <View style={styles.modalBg}>
          <TouchableOpacity
            style={styles.modalBg}
            activeOpacity={1}
            onPress={() => setPreview(null)}
          >
            {preview && (
              <Image
                source={{ uri: preview.imageUri }}
                style={styles.fullImg}
                resizeMode="contain"
              />
            )}
          </TouchableOpacity>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
  },
  headerTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700", flex: 1 },
  clearAllBtn: {
    paddingHorizontal: 10,
    paddingVertical: 8,
    backgroundColor: PALETTE.danger,
    borderRadius: 8,
  },
  clearAllTxt: { color: "white", fontWeight: "700" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.row,
  },
  label: { color: PALETTE.sub, fontSize: 12 },
  input: {
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 140,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnTxt: { color: "white", fontWeight: "700" },

  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 10,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: { width: 84, height: 56, backgroundColor: "#000", borderRadius: 8 },
  title: { color: PALETTE.text, fontSize: 14, fontWeight: "700" },
  time: { color: PALETTE.sub, fontSize: 12, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2a2f3d",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  expandBtnOn: { backgroundColor: "#1d2435" },
  expandTxt: { color: "#cbd5ff", fontWeight: "700", fontSize: 12 },

  trashBtn: {
    backgroundColor: "#333",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  trashTxt: { color: "#fca5a5", fontWeight: "700", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 10,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 220 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#0c1020",
  },
  detailsTitle: { color: PALETTE.chipText, fontWeight: "800", marginBottom: 6 },
  timeBig: { color: PALETTE.text, fontSize: 14, fontWeight: "600" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 10,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "800" },

  modalBg: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.92)",
    alignItems: "center",
    justifyContent: "center",
  },
  fullImg: { width: "100%", height: "100%" },

  // ======= QUICK ACTION STYLES =======
  quickRow: {
    flexDirection: "row",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 12,
    backgroundColor: PALETTE.row,
  },
  quickBtn: {
    flex: 1,
    backgroundColor: "#141622",
    borderRadius: 16



































































































// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
  Animated,
  LayoutChangeEvent,
} from "react-native";
import { WebView } from "react-native-webview";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ---------- PALETA ---------- */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#121218",
  border: "#25273a",
  accent: "#e6403a",
  text: "#e5e7eb",
};

/* ---------- TEXTOS ---------- */
const textsByLang = {
  pt: {
    heroSubtitle: "Monitoramento e Controle",
    espIp: "ESP IP:",
    test: "Testar",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "BOMBA ON",
    pumpOff: "BOMBA OFF",
    server: "Servidor:",
    detect: "Detectar",
    detecting: "Detectando",
    saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi/IP.",
    noVideo: "Sem v√≠deo (snapshot). Verifique o servidor.",
    fireOn: (s: number) => `üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sem fogo ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento salvo em ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "Vis√£o:",
    stream: "STREAM (r√°pido)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "Pessoas",
    animals: "Animais",
    boxes: "Caixas",
    backend: "Modelo",
  },
  en: {
    heroSubtitle: "Monitoring & Control",
    espIp: "ESP IP:",
    test: "Test",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "PUMP ON",
    pumpOff: "PUMP OFF",
    server: "Server:",
    detect: "Detect",
    detecting: "Detecting",
    saving: "Saving...",
    statusFail: "Failed to connect. Check Wi-Fi/IP.",
    noVideo: "No video (snapshot). Check the server.",
    fireOn: (s: number) => `üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `No fire ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Event saved at ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "View:",
    stream: "STREAM (fast)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "People",
    animals: "Animals",
    boxes: "Boxes",
    backend: "Model",
  },
  es: {
    heroSubtitle: "Monitoreo y Control",
    espIp: "ESP IP:",
    test: "Probar",
    ledOn: "LED ENC.",
    ledOff: "LED APAG.",
    pumpOn: "BOMBA ENC.",
    pumpOff: "BOMBA APAG.",
    server: "Servidor:",
    detect: "Detectar",
    detecting: "Detectando",
    saving: "Guardando...",
    statusFail: "Error de conexi√≥n. Revisa Wi-Fi/IP.",
    noVideo: "Sin v√≠deo (snapshot). Revisa el servidor.",
    fireOn: (s: number) => `üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sin fuego ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento guardado a las ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "Vista:",
    stream: "STREAM (r√°pido)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "Personas",
    animals: "Animales",
    boxes: "Cajas",
    backend: "Modelo",
  },
};

const DEFAULT_IP = "192.168.4.1";
const DEFAULT_SERVER = "http://192.168.4.2:8000";

/* ---------- HERO ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={require("../assets/logo.png")} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ---------- STREAM (>=20 FPS) ---------- */
function LiveMJPEG({ ip }: { ip: string }) {
  const html = `
    <html><head><meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;}
        .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;}
        img{max-width:100%;max-height:100%;object-fit:contain;background:#000;}
      </style>
    </head>
    <body><div class="wrap"><img src="http://${ip}:81/stream"/></div></body></html>
  `.trim();

  return (
    <WebView
      originWhitelist={["*"]}
      source={{ html }}
      javaScriptEnabled
      allowsInlineMediaPlayback
      mediaPlaybackRequiresUserAction={false}
      automaticallyAdjustContentInsets={false}
      style={{ flex: 1, backgroundColor: "black" }}
    />
  );
}

/* ---------- SNAPSHOT com crossfade ---------- */
function CrossfadeImage({
  currentUri,
  nextUri,
  onNextLoadStart,
  onNextShown,
}: {
  currentUri: string;
  nextUri: string;
  onNextLoadStart: () => void;
  onNextShown: () => void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}

      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={onNextShown}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown();
                fade.setValue(0);
                setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- OVERLAY DE CAIXAS ---------- */
type BoxType = "fire" | "person" | "animal";
type SrcBox = { x: number; y: number; w: number; h: number; type: BoxType; conf?: number };

function BoxesOverlay({
  frameWH,
  containerWH,
  boxes,
}: {
  frameWH: { w: number; h: number } | null;
  containerWH: { w: number; h: number } | null;
  boxes: SrcBox[];
}) {
  if (!frameWH || !containerWH || frameWH.w <= 0 || frameWH.h <= 0 || containerWH.w <= 0 || containerWH.h <= 0) {
    return null;
  }
  // simula object-fit: contain
  const scale = Math.min(containerWH.w / frameWH.w, containerWH.h / frameWH.h);
  const dispW = frameWH.w * scale;
  const dispH = frameWH.h * scale;
  const offsetX = (containerWH.w - dispW) / 2;
  const offsetY = (containerWH.h - dispH) / 2;

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position: "absolute", left: offsetX, top: offsetY, width: dispW, height: dispH }}>
        {boxes.map((b, i) => {
          const left = b.x * scale;
          const top = b.y * scale;
          const width = b.w * scale;
          const height = b.h * scale;

          let borderColor = "#ff3b30"; // fire
          if (b.type === "person") borderColor = "#00e5ff";
          else if (b.type === "animal") borderColor = "#7CFC00";

          return (
            <View
              key={`${i}-${b.type}`}
              style={{ position: "absolute", left, top, width, height, borderWidth: 3, borderColor, borderRadius: 6 }}
            >
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  top: -18,
                  paddingHorizontal: 6,
                  paddingVertical: 2,
                  borderRadius: 4,
                  backgroundColor: borderColor,
                }}
              >
                <Text style={{ color: "#000", fontWeight: "800", fontSize: 10 }}>
                  {b.type.toUpperCase()}
                  {typeof b.conf === "number" ? ` ${b.conf.toFixed(2)}` : ""}
                </Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- TELA PRINCIPAL ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados do ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState("‚Äî");
  const [ledOn, setLedOn] = useState(false);
  const [pumpOn, setPumpOn] = useState(false);

  // detec√ß√£o
  const [detectOn, setDetectOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  // pessoas/animais
  const [people, setPeople] = useState(0);
  const [animals, setAnimals] = useState(0);
  const [backend, setBackend] = useState<string>("‚Äî");
  const [confMax, setConfMax] = useState<number>(0);

  // caixas + dimens√µes para overlay
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{ w: number; h: number } | null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{ w: number; h: number } | null>(null);

  // mini preview de caixas
  const [showBoxes, setShowBoxes] = useState(false);
  const [boxesUri, setBoxesUri] = useState("");

  // registro autom√°tico
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef(0);
  const wasFireRef = useRef(false);
  const SAVE_COOLDOWN_MS = 5000;

  // v√≠deo
  const [useStream, setUseStream] = useState(true);
  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  // joystick (UI)
  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // helpers URL
  const cleanServer = (s: string) => s.replace(/\/+$/, "");
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  /* ===== ESP STATUS ===== */
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl);
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(`OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`);
    } catch {
      setStatusText(T.statusFail);
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  /* ===== SNAPSHOT fallback (25 fps alvo) ===== */
  useEffect(() => {
    if (useStream) return;
    let stop = false;
    const FPS_INTERVAL = 40; // ~25 fps

    setCurrentFrameUri(`${cleanServer(server)}/snapshot?ts=${Date.now()}`);

    const tick = () => {
      if (stop) return;
      if (!loadingNextRef.current) {
        const url = `${cleanServer(server)}/snapshot?ts=${Date.now()}`;
        setNextFrameUri(url);
      }
      setTimeout(tick, FPS_INTERVAL);
    };
    tick();

    return () => {
      stop = true;
    };
  }, [server, useStream]);

  function onNextLoadStart() {
    loadingNextRef.current = true;
  }
  function onNextShown() {
    if (nextFrameUri) setCurrentFrameUri(nextFrameUri);
    loadingNextRef.current = false;
  }

  /* ===== LOOP DE DETEC√á√ÉO + CAIXAS ===== */
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;

    const loop = async () => {
      try {
        const r = await fetch(`${cleanServer(server)}/detect`);
        const j = await r.json();

        if (!stop && j && j.ok !== false) {
          // fogo
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));

          // frame size (se servidor expor; opcional)
          const wh = Array.isArray(j.frame_wh) && j.frame_wh.length === 2
            ? { w: Number(j.frame_wh[0]) || 0, h: Number(j.frame_wh[1]) || 0 }
            : null;
          if (wh && wh.w > 0 && wh.h > 0) setFrameWH(wh);

          // objetos e est√°veis
          const o = j.objects || {};
          const objs = o.objects || [];
          const peopleStable =
            typeof o.n_person_stable === "number"
              ? o.n_person_stable
              : typeof o.n_person === "number"
              ? o.n_person
              : objs.some((x: any) => String(x.label).toLowerCase() === "person")
              ? 1
              : 0;
          const animalsStable =
            typeof o.n_animals_stable === "number"
              ? o.n_animals_stable
              : typeof o.n_animals === "number"
              ? o.n_animals
              : objs.some((x: any) => String(x.label).toLowerCase() !== "person")
              ? 1
              : 0;

          setPeople(peopleStable);
          setAnimals(animalsStable);
          setBackend(o.backend || "‚Äî");
          setConfMax(Number(o.conf_max || 0));

          // montar caixas
          const boxes: SrcBox[] = [];

          if (j.isFire && Array.isArray(j.boxes)) {
            for (const b of j.boxes) {
              if (!Array.isArray(b) || b.length < 4) continue;
              const [x, y, w, h] = b.map((n: any) => Number(n) || 0);
              boxes.push({ x, y, w, h, type: "fire" });
            }
          }
          for (const it of objs) {
            if (!it || !Array.isArray(it.box) || it.box.length < 4) continue;
            const [x, y, w, h] = it.box.map((n: any) => Number(n) || 0);
            const label = String(it.label || "").toLowerCase();
            const conf = typeof it.conf === "number" ? it.conf : undefined;
            if (label === "person") boxes.push({ x, y, w, h, type: "person", conf });
            else boxes.push({ x, y, w, h, type: "animal", conf });
          }
          setOverlayBoxes(boxes);

          if (showBoxes) {
            setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`);
          }
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
          setPeople(0);
          setAnimals(0);
          setOverlayBoxes([]);
        }
      } finally {
        if (!stop) setTimeout(loop, 180); // ~5-6Hz
      }
    };
    loop();

    return () => {
      stop = true;
    };
  }, [detectOn, server, showBoxes]);

  /* ===== Registro autom√°tico ===== */
  useEffect(() => {
    const rising = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;

    if (detectOn && rising && cooldownOk && !saving) {
      (async () => {
        try {
          setSaving(true);
          await saveEventFromServer(server);
          lastSaveRef.current = Date.now();
          setStatusText(T.eventSavedAt(new Date(lastSaveRef.current).toLocaleString()));
        } catch {
          setStatusText(T.noVideo);
        } finally {
          setSaving(false);
        }
      })();
    }
    wasFireRef.current = isFire;
  }, [detectOn, isFire, server, saving, T]);

  /* ===== Joystick ===== */
  const RADIUS = 64,
    KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS,
          ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny });
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const knobLeft = joy.x * RADIUS,
    knobTop = -joy.y * RADIUS;

  /* ===== Medidas do container do v√≠deo ===== */
  function onVideoLayout(e: LayoutChangeEvent) {
    const { width, height } = e.nativeEvent.layout;
    setVideoContainerWH({ w: width, h: height });
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder={T.placeholderIp}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : T.test}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? T.ledOn : T.ledOff}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? T.pumpOn : T.pumpOff}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor + Detectar + Seletor de vis√£o */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholderServer}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? (saving ? T.saving : T.detecting) : T.detect}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Seletor de vis√£o + toggle boxes */}
      <View style={[styles.statusRow, { gap: 6 }]}>
        <Text style={styles.label}>{T.view}</Text>
        <Pressable onPress={() => setUseStream(true)} style={[styles.btn, useStream ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{T.stream}</Text>
        </Pressable>
        <Pressable onPress={() => setUseStream(false)} style={[styles.btn, !useStream ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{T.snapshot}</Text>
        </Pressable>

        <Pressable
          onPress={() => {
            const val = !showBoxes;
            setShowBoxes(val);
            if (val) setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`);
          }}
          style={[styles.btn, showBoxes ? styles.btnOn : styles.btnOff]}
        >
          <Text style={styles.btnText}>{T.boxes}</Text>
        </Pressable>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
        </View>
      )}

      {/* Banner de pessoas/animais + backend */}
      {detectOn && (
        <View style={[styles.statusRow, { justifyContent: "space-between" }]}>
          <Text style={styles.statChip}>
            {T.persons}: <Text style={styles.statNumber}>{people}</Text>
          </Text>
          <Text style={styles.statChip}>
            {T.animals}: <Text style={styles.statNumber}>{animals}</Text>
          </Text>
          <Text style={styles.modelChip}>
            {T.backend}: {backend} ‚Ä¢ conf_max {confMax.toFixed(2)}
          </Text>
        </View>
      )}

      {/* V√≠deo + Overlay */}
      <View style={{ flex: 1 }} onLayout={onVideoLayout}>
        {useStream ? (
          <LiveMJPEG ip={ip} />
        ) : (
          <CrossfadeImage
            currentUri={currentFrameUri}
            nextUri={nextFrameUri}
            onNextLoadStart={onNextLoadStart}
            onNextShown={onNextShown}
          />
        )}

        {detectOn && overlayBoxes.length > 0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Mini preview do servidor (opcional) */}
      {detectOn && showBoxes && (
        <View style={{ height: 140, backgroundColor: "#000" }}>
          {!!boxesUri && (
            <Image
              source={{ uri: boxesUri }}
              style={{ flex: 1, width: "100%" }}
              resizeMode="contain"
              onError={() => setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`)}
            />
          )}
        </View>
      )}

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: 64 * 2 + 24, height: 64 * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: 64 * 2, height: 64 * 2, borderRadius: 64 }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: 22 * 2,
                height: 22 * 2,
                borderRadius: 22,
                transform: [{ translateX: joy.x * 64 }, { translateY: -joy.y * 64 }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

/* ---------- ESTILOS ---------- */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  // HERO
  hero: { alignItems: "center", paddingTop: 12, paddingBottom: 6 },
  heroLogo: { width: 80, height: 80, marginBottom: 6, resizeMode: "contain" },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 2 },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: "#0b0d14",
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 110,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1322",
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  statChip: { color: "#dbeafe", fontSize: 14, fontWeight: "600" },
  statNumber: { color: "#fff" },
  modelChip: { marginLeft: "auto", color: "#9fb0ff", fontSize: 12 },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: {
    position: "absolute",
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.14)",
  },
  joyKnob: {
    position: "absolute",
    backgroundColor: "rgba(230,64,58,0.9)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.85)",
  },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});








































bora deixar tudo com a carinha do ‚ÄúHome‚Äù da foto üòé

Abaixo est√£o os tr√™s arquivos completos (Dashboard, Camera e Settings) com:




Header hero igual ao da imagem (logo centralizada + ‚ÄúHydroBot‚Äù + subt√≠tulo por idioma).


Paleta e bot√µes ajustados pra combinar com os cards vermelhos do seu Home.


Nada do seu fluxo foi removido ‚Äî s√≥ reorganizei o topo visual.






A logo √© carregada de ../assets/logo.png (a partir de src/screens). Se o seu caminho for diferente, ajuste o require.





HydroBotApp2/src/screens/DashboardScreen.tsx


import { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Image,
  Pressable,
  Alert,
  TextInput,
  Modal,
  TouchableOpacity,
  SafeAreaView,
  Share,
} from "react-native";
import * as FileSystem from "expo-file-system";
import * as MediaLibrary from "expo-media-library";
import { getEvents, saveEventFromServer, deleteEvent, clearAllEvents, FireEvent } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = {
  bg: "#0b0b0f",
  card: "#121218",
  card2: "#0f1117",
  border: "#25273a",
  text: "#e5e7eb",
  sub: "#9aa4b2",
  accent: "#e6403a", // vermelho do card
  accentDark: "#c93631",
  danger: "#ef4444",
  row: "#0f1730",
  chip: "#182033",
  chipText: "#b7c6ff",
};

const texts = {
  pt: {
    heroSubtitle: "Monitoramento e Controle",
    title: "Dashboard",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar agora",
    saving: "Salvando...",
    empty1: "Sem eventos ainda.",
    empty2:
      "Quando o detector sinalizar fogo, capturaremos o snapshot automaticamente.\nVoc√™ tamb√©m pode tocar ‚ÄúRegistrar agora‚Äù.",
    fire: "Detec√ß√£o de fogo",
    clear: "Limpar",
    confirmClearTitle: "Limpar tudo",
    confirmClearBody: "Isso apagar√° todos os eventos e imagens. Continuar?",
    cancel: "Cancelar",
    delete: "Excluir",
    confirmDeleteTitle: "Excluir registro",
    confirmDeleteBody: "Deseja excluir este evento?",
    fail: "Falha ao salvar",
    failBody: "Verifique o servidor /snapshot e a rede.",
    details: "Detalhes",
    share: "Compartilhar",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Baixar",
    downloadedTo: (p: string) => `Imagem salva em:\n${p}`,
    savedToGallery: "Imagem salva na galeria üì∏",
  },
  en: {
    heroSubtitle: "Monitoring & Control",
    title: "Dashboard",
    server: "Server:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Save now",
    saving: "Saving...",
    empty1: "No events yet.",
    empty2:
      "When fire is detected, a snapshot is captured automatically.\nYou can also tap ‚ÄúSave now‚Äù.",
    fire: "Fire detection",
    clear: "Clear",
    confirmClearTitle: "Clear all",
    confirmClearBody: "This will delete all events and images. Continue?",
    cancel: "Cancel",
    delete: "Delete",
    confirmDeleteTitle: "Delete entry",
    confirmDeleteBody: "Do you want to delete this event?",
    fail: "Failed to save",
    failBody: "Check the /snapshot endpoint and network.",
    details: "Details",
    share: "Share",
    show: "Show",
    hide: "Hide",
    download: "Download",
    downloadedTo: (p: string) => `Image saved to:\n${p}`,
    savedToGallery: "Image saved to gallery üì∏",
  },
  es: {
    heroSubtitle: "Monitoreo y Control",
    title: "Panel",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar ahora",
    saving: "Guardando...",
    empty1: "Sin eventos a√∫n.",
    empty2:
      "Cuando se detecte fuego, se capturar√° una imagen autom√°ticamente.\nTambi√©n puedes tocar ‚ÄúRegistrar ahora‚Äù.",
    fire: "Detecci√≥n de fuego",
    clear: "Limpiar",
    confirmClearTitle: "Limpiar todo",
    confirmClearBody: "Esto borrar√° todos los eventos e im√°genes. ¬øContinuar?",
    cancel: "Cancelar",
    delete: "Eliminar",
    confirmDeleteTitle: "Eliminar registro",
    confirmDeleteBody: "¬øDeseas eliminar este evento?",
    fail: "Error al guardar",
    failBody: "Revisa /snapshot y la red.",
    details: "Detalles",
    share: "Compartir",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Descargar",
    downloadedTo: (p: string) => `Imagen guardada en:\n${p}`,
    savedToGallery: "Imagen guardada en la galer√≠a üì∏",
  },
};

const DEFAULT_SERVER = "http://192.168.4.2:8000";
type EventWithMeta = FireEvent & { meta?: any };

/** Header hero igual ao da tela Home */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={require("../assets/logo.png")} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

export default function DashboardScreen() {
  const { lang } = useLanguage();
  const T = texts[lang];

  const [server, setServer] = useState<string>(DEFAULT_SERVER);
  const [items, setItems] = useState<EventWithMeta[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [preview, setPreview] = useState<EventWithMeta | null>(null);
  const [busy, setBusy] = useState(false);
  const [expanded, setExpanded] = useState<Set<string>>(new Set());

  async function load() {
    setRefreshing(true);
    try {
      const list = (await getEvents()) as EventWithMeta[];
      setItems(list);
    } finally {
      setRefreshing(false);
    }
  }
  useEffect(() => {
    load();
  }, []);

  async function handleRegisterNow() {
    try {
      setBusy(true);
      const ev = (await saveEventFromServer(server)) as EventWithMeta;
      setItems((prev) => [ev, ...prev]);
    } catch {
      Alert.alert(T.fail, T.failBody);
    } finally {
      setBusy(false);
    }
  }

  function confirmDelete(ev: EventWithMeta) {
    Alert.alert(T.confirmDeleteTitle, T.confirmDeleteBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.delete,
        style: "destructive",
        onPress: async () => {
          await deleteEvent(ev.id);
          setItems((prev) => prev.filter((x) => x.id !== ev.id));
          setExpanded((s) => {
            const n = new Set(s);
            n.delete(ev.id);
            return n;
          });
        },
      },
    ]);
  }

  function confirmClearAll() {
    Alert.alert(T.confirmClearTitle, T.confirmClearBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.clear,
        style: "destructive",
        onPress: async () => {
          await clearAllEvents();
          setItems([]);
          setExpanded(new Set());
        },
      },
    ]);
  }

  function toggleExpand(item: EventWithMeta) {
    setExpanded((prev) => {
      const n = new Set(prev);
      if (n.has(item.id)) n.delete(item.id);
      else n.add(item.id);
      return n;
    });
  }

  async function downloadImage(uri: string, id: string) {
    try {
      const filename = `${id}.jpg`;
      const dest = FileSystem.documentDirectory + filename;
      let localPath = dest;

      if (uri.startsWith("file://")) {
        await FileSystem.copyAsync({ from: uri, to: dest });
      } else {
        const res = await FileSystem.downloadAsync(uri, dest);
        localPath = res.uri;
      }

      try {
        const perm = await MediaLibrary.requestPermissionsAsync();
        if (perm.granted) {
          const asset = await MediaLibrary.createAssetAsync(localPath);
          const albumName = "HydroBot";
          let album = await MediaLibrary.getAlbumAsync(albumName);
          if (!album) {
            album = await MediaLibrary.createAlbumAsync(albumName, asset, false);
          } else {
            await MediaLibrary.addAssetsToAlbumAsync([asset], album, false);
          }
          Alert.alert("OK", T.savedToGallery);
          return;
        }
      } catch {}
      Alert.alert("OK", T.downloadedTo(localPath));
    } catch {
      Alert.alert("Erro", "Falha ao baixar imagem");
    }
  }

  const renderItem = ({ item }: { item: EventWithMeta }) => {
    const dateStr = new Date(item.ts).toLocaleString();
    const isOpen = expanded.has(item.id);

    return (
      <View style={styles.cardWrap}>
        <Pressable onPress={() => toggleExpand(item)} style={styles.cardHeader}>
          <Image source={{ uri: item.imageUri }} style={styles.thumb} />
          <View style={{ flex: 1 }}>
            <Text style={styles.title}>{T.fire}</Text>
            <Text style={styles.time}>{dateStr}</Text>
            <Text style={styles.path} numberOfLines={1}>{item.imageUri}</Text>
          </View>

        <View style={{ alignItems: "flex-end", gap: 8 }}>
          <Pressable onPress={() => toggleExpand(item)} style={[styles.expandBtn, isOpen && styles.expandBtnOn]}>
            <Text style={styles.expandTxt}>{isOpen ? "‚ñæ " + T.hide : "‚ñ∏ " + T.show}</Text>
          </Pressable>
          <Pressable onPress={() => confirmDelete(item)} style={styles.trashBtn}>
            <Text style={styles.trashTxt}>{T.delete}</Text>
          </Pressable>
        </View>
        </Pressable>

        {isOpen && (
          <View style={styles.expandPanel}>
            <Pressable onPress={() => setPreview(item)} style={styles.bigImageWrap}>
              <Image source={{ uri: item.imageUri }} style={styles.bigImage} resizeMode="contain" />
            </Pressable>

            <View style={styles.detailsBox}>
              <Text style={styles.detailsTitle}>{T.details}</Text>
              <Text style={styles.timeBig}>{dateStr}</Text>
            </View>

            <View style={styles.actionsRow}>
              <Pressable
                style={[styles.actionBtn, { backgroundColor: PALETTE.accent }]}
                onPress={() => downloadImage(item.imageUri, item.id)}
              >
                <Text style={[styles.actionTxt, { color: "white" }]}>‚¨á {T.download}</Text>
              </Pressable>

              <Pressable
                style={[styles.actionBtn, { backgroundColor: "#3b3f52" }]}
                onPress={() => Share.share({ url: item.imageUri, message: `${T.fire} ‚Ä¢ ${dateStr}` })}
              >
                <Text style={[styles.actionTxt, { color: "#fff" }]}>{T.share}</Text>
              </Pressable>
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <FlatList
        data={items}
        keyExtractor={(it) => it.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={load}
        ListHeaderComponent={
          <>
            <AppHero subtitle={T.heroSubtitle} />

            {/* Barra de a√ß√µes igual ao estilo do Home (bot√µes vermelhos) */}
            <View style={styles.quickRow}>
              <View style={[styles.quickTile, { backgroundColor: PALETTE.accent }]}>
                <Text style={styles.quickLabel}>{T.server}</Text>
                <TextInput
                  value={server}
                  onChangeText={setServer}
                  placeholder={T.placeholder}
                  autoCapitalize="none"
                  autoCorrect={false}
                  placeholderTextColor="#9aa4b2"
                  style={styles.input}
                />
              </View>

              <Pressable
                onPress={handleRegisterNow}
                style={[styles.quickTile, styles.quickAction, busy && { opacity: 0.7 }]}
                disabled={busy}
              >
                <Text style={styles.quickActionIcon}>‚¨áÔ∏è</Text>
                <Text style={styles.quickActionText}>{busy ? T.saving : T.btnSave}</Text>
              </Pressable>
            </View>

            <View style={styles.sectionHeader}>
              <Text style={styles.sectionTitle}>{T.title}</Text>
              <Pressable onPress={confirmClearAll} style={styles.clearAllBtn}>
                <Text style={styles.clearAllTxt}>{T.clear}</Text>
              </Pressable>
            </View>
          </>
        }
        contentContainerStyle={items.length === 0 && { flexGrow: 1, justifyContent: "center" }}
        ListEmptyComponent={
          <View style={{ alignItems: "center", paddingHorizontal: 16 }}>
            <Text style={{ color: PALETTE.sub, textAlign: "center" }}>{T.empty1}</Text>
            <Text style={{ color: PALETTE.sub, marginTop: 4, textAlign: "center" }}>{T.empty2}</Text>
          </View>
        }
      />

      <Modal visible={!!preview} transparent animationType="fade" onRequestClose={() => setPreview(null)}>
        <View style={styles.modalBg}>
          <TouchableOpacity style={styles.modalBg} activeOpacity={1} onPress={() => setPreview(null)}>
            {preview && <Image source={{ uri: preview.imageUri }} style={styles.fullImg} resizeMode="contain" />}
          </TouchableOpacity>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  /* base */
  container: { flex: 1, backgroundColor: PALETTE.bg },

  /* HERO (logo + nome + subt√≠tulo) */
  hero: { alignItems: "center", paddingTop: 18, paddingBottom: 10 },
  heroLogo: { width: 80, height: 80, marginBottom: 8, resizeMode: "contain" },
  heroTitle: { color: "#ffffff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 4 },

  /* Action row inspirada nos cards vermelhos */
  quickRow: { flexDirection: "row", gap: 12, paddingHorizontal: 14, marginTop: 12 },
  quickTile: {
    flex: 1,
    borderRadius: 14,
    padding: 12,
    backgroundColor: PALETTE.card2,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  quickAction: { backgroundColor: PALETTE.accent },
  quickActionIcon: { fontSize: 18, textAlign: "center", marginBottom: 6, color: "#fff" },
  quickActionText: { color: "#fff", fontWeight: "800", textAlign: "center" },

  input: {
    marginTop: 6,
    backgroundColor: "#0b0d14",
    color: PALETTE.text,
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },

  sectionHeader: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    marginTop: 14,
    marginBottom: 6,
  },
  sectionTitle: { color: "#fff", fontWeight: "800", fontSize: 16, flex: 1 },

  clearAllBtn: { paddingHorizontal: 10, paddingVertical: 8, backgroundColor: PALETTE.danger, borderRadius: 8 },
  clearAllTxt: { color: "white", fontWeight: "700" },

  /* Cards de evento */
  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 10,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: { width: 84, height: 56, backgroundColor: "#000", borderRadius: 8 },
  title: { color: PALETTE.text, fontSize: 14, fontWeight: "700" },
  time: { color: PALETTE.sub, fontSize: 12, marginTop: 2 },
  path: { color: "#8b93a3", fontSize: 11, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2a2f3d",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  expandBtnOn: { backgroundColor: "#1d2435" },
  expandTxt: { color: "#cbd5ff", fontWeight: "700", fontSize: 12 },

  trashBtn: { backgroundColor: "#3a3d4d", paddingHorizontal: 10, paddingVertical: 6, borderRadius: 8 },
  trashTxt: { color: "#fca5a5", fontWeight: "700", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 10,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 220 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#0c1020",
  },
  detailsTitle: { color: PALETTE.chipText, fontWeight: "800", marginBottom: 6 },
  timeBig: { color: PALETTE.text, fontSize: 14, fontWeight: "600" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 10,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "800" },

  /* Modal zoom */
  modalBg: { flex: 1, backgroundColor: "rgba(0,0,0,0.92)", alignItems: "center", justifyContent: "center" },
  fullImg: { width: "100%", height: "100%" },
});




HydroBotApp2/src/screens/CameraScreen.tsx




Reestilizei o topo com o Hero (logo + t√≠tulo) e deixei seus controles logo abaixo, mantendo o overlay de caixas que fizemos.




import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
  Animated,
  LayoutChangeEvent,
} from "react-native";
import { WebView } from "react-native-webview";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ---------- PALETA AJUSTADA ---------- */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#121218",
  border: "#25273a",
  accent: "#e6403a",
  accentDark: "#c93631",
  text: "#e5e7eb",
};

const textsByLang = {
  pt: { heroSubtitle: "Monitoramento e Controle", /* ...restante igual... */ 
    espIp: "ESP IP:", test: "Testar", ledOn: "LED ON", ledOff: "LED OFF",
    pumpOn: "BOMBA ON", pumpOff: "BOMBA OFF", server: "Servidor:",
    detect: "Detectar", detecting: "Detectando", saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi/IP.",
    noVideo: "Sem v√≠deo (snapshot). Verifique o servidor.",
    fireOn: (s:number)=>`üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s:number)=>`Sem fogo ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt:(ts:string)=>`Evento salvo em ${ts}`,
    placeholderIp:"192.168.4.1", placeholderServer:"http://192.168.4.2:8000",
    view:"Vis√£o:", stream:"STREAM (r√°pido)", snapshot:"SNAPSHOT (fallback)",
    persons:"Pessoas", animals:"Animais", boxes:"Caixas", backend:"Modelo",
  },
  en: { heroSubtitle: "Monitoring & Control", /* ...idem... */ 
    espIp:"ESP IP:", test:"Test", ledOn:"LED ON", ledOff:"LED OFF",
    pumpOn:"PUMP ON", pumpOff:"PUMP OFF", server:"Server:", detect:"Detect",
    detecting:"Detecting", saving:"Saving...", statusFail:"Failed to connect. Check Wi-Fi/IP.",
    noVideo:"No video (snapshot). Check the server.",
    fireOn:(s:number)=>`üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`, fireOff:(s:number)=>`No fire ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt:(ts:string)=>`Event saved at ${ts}`, placeholderIp:"192.168.4.1",
    placeholderServer:"http://192.168.4.2:8000", view:"View:", stream:"STREAM (fast)",
    snapshot:"SNAPSHOT (fallback)", persons:"People", animals:"Animals", boxes:"Boxes", backend:"Model",
  },
  es: { heroSubtitle: "Monitoreo y Control", /* ...idem... */ 
    espIp:"ESP IP:", test:"Probar", ledOn:"LED ENC.", ledOff:"LED APAG.",
    pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.", server:"Servidor:", detect:"Detectar",
    detecting:"Detectando", saving:"Guardando...", statusFail:"Error de conexi√≥n. Revisa Wi-Fi/IP.",
    noVideo:"Sin v√≠deo (snapshot). Revisa el servidor.",
    fireOn:(s:number)=>`üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`, fireOff:(s:number)=>`Sin fuego ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt:(ts:string)=>`Evento guardado a las ${ts}`, placeholderIp:"192.168.4.1",
    placeholderServer:"http://192.168.4.2:8000", view:"Vista:", stream:"STREAM (r√°pido)",
    snapshot:"SNAPSHOT (fallback)", persons:"Personas", animals:"Animales", boxes:"Cajas", backend:"Modelo",
  },
};

const DEFAULT_IP = "192.168.4.1";
const DEFAULT_SERVER = "http://192.168.4.2:8000";

/* ---------- HERO ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={require("../assets/logo.png")} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ---------- STREAM ---------- */
function LiveMJPEG({ ip }: { ip: string }) {
  const html = `
  <html><head><meta name="viewport" content="width=device-width, initial-scale=1">
    <style>html,body{margin:0;background:#000;height:100%}
    .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000}
    img{max-width:100%;max-height:100%;object-fit:contain;background:#000}</style></head>
  <body><div class="wrap"><img src="http://${ip}:81/stream"/></div></body></html>`.trim();

  return (
    <WebView
      originWhitelist={["*"]}
      source={{ html }}
      style={{ flex: 1, backgroundColor: "black" }}
      javaScriptEnabled
      allowsInlineMediaPlayback
      mediaPlaybackRequiresUserAction={false}
      automaticallyAdjustContentInsets={false}
    />
  );
}

/* ---------- SNAPSHOT crossfade ---------- */
function CrossfadeImage({ currentUri, nextUri, onNextLoadStart, onNextShown }:{
  currentUri: string; nextUri: string; onNextLoadStart: ()=>void; onNextShown: ()=>void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && <Image source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={onNextShown}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- Overlay de caixas (igual j√° enviado) ---------- */
type BoxType = "fire" | "person" | "animal";
type SrcBox = { x: number; y: number; w: number; h: number; type: BoxType; conf?: number };

function BoxesOverlay({
  frameWH, containerWH, boxes,
}:{ frameWH:{w:number;h:number}|null; containerWH:{w:number;h:number}|null; boxes: SrcBox[]; }) {
  if (!frameWH || !containerWH || frameWH.w<=0 || frameWH.h<=0 || containerWH.w<=0 || containerWH.h<=0) return null;
  const scale = Math.min(containerWH.w / frameWH.w, containerWH.h / frameWH.h);
  const dispW = frameWH.w * scale, dispH = frameWH.h * scale;
  const offsetX = (containerWH.w - dispW) / 2, offsetY = (containerWH.h - dispH) / 2;

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View style={{ position:"absolute", left: offsetX, top: offsetY, width: dispW, height: dispH }}>
        {boxes.map((b, i) => {
          const left=b.x*scale, top=b.y*scale, width=b.w*scale, height=b.h*scale;
          let borderColor = "#ff3b30"; if (b.type==="person") borderColor="#00e5ff"; else if (b.type==="animal") borderColor="#7CFC00";
          return (
            <View key={`${i}-${b.type}`} style={{ position:"absolute", left, top, width, height, borderWidth:3, borderColor, borderRadius:6 }} >
              <View style={{ position:"absolute", left:0, top:-18, paddingHorizontal:6, paddingVertical:2, borderRadius:4, backgroundColor: borderColor }}>
                <Text style={{ color:"#000", fontWeight:"800", fontSize:10 }}>
                  {b.type.toUpperCase()}{typeof b.conf==="number" ? ` ${b.conf.toFixed(2)}` : ""}
                </Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- Tela principal ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  // ... (todo o seu estado/efeitos permanecem iguais) ...
  // ******* C√ìDIGO DE ESTADO / EFEITOS / JOYSTICK / DETEC√á√ÉO √â O MESMO DA SUA VERS√ÉO ATUAL *******
  // Para n√£o alongar demais, mantenha exatamente o que voc√™ j√° tem e
  // substitua apenas os estilos e o header conforme abaixo.

  // ---- daqui em diante √© id√™ntico ao seu arquivo anterior (estados, efeitos, etc.) ----
  // >> Cole aqui o restante do seu CameraScreen que voc√™ enviou por √∫ltimo <<
  // (Somente os estilos no final foram atualizados)

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      {/* ... seus controles/topbar/linhas exatamente como j√° est√£o ... */}
      {/* Mantenha o mesmo JSX ap√≥s o hero que voc√™ me enviou na √∫ltima vers√£o */}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  /* HERO */
  hero: { alignItems: "center", paddingTop: 12, paddingBottom: 6 },
  heroLogo: { width: 80, height: 80, marginBottom: 6, resizeMode: "contain" },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 2 },

  /* abaixo mantenha seus estilos anteriores, mas com a paleta nova */
  topbar: {
    flexDirection: "row", alignItems: "center",
    paddingHorizontal: 12, paddingVertical: 10, gap: 8, backgroundColor: PALETTE.card,
    borderBottomWidth: StyleSheet.hairlineWidth, borderBottomColor: PALETTE.border,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: "#0b0d14", color: "white", borderRadius: 8,
    paddingHorizontal: 10, paddingVertical: 8, borderWidth: 1, borderColor: PALETTE.border, minWidth: 110,
  },
  btn: { backgroundColor: PALETTE.accent, paddingHorizontal: 10, paddingVertical: 10, borderRadius: 10 },
  btnOn: { backgroundColor: "#17a34a" }, btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row", alignItems: "center",
    paddingHorizontal: 12, paddingVertical: 8, gap: 8, backgroundColor: "#0f1322",
    borderBottomWidth: StyleSheet.hairlineWidth, borderBottomColor: PALETTE.border,
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" }, fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  statChip: { color: "#dbeafe", fontSize: 14, fontWeight: "600" },
  statNumber: { color: "#fff" },
  modelChip: { marginLeft: "auto", color: "#9fb0ff", fontSize: 12 },

  // Joystick (sem mudan√ßas visuais maiores)
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(230,64,58,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});





No CameraScreen, cole de volta todo o seu corpo (estados/efeitos/JSX) entre o return e os estilos ‚Äî troquei s√≥ o Hero no topo e atualizei as cores nos estilos.





HydroBotApp2/src/screens/SettingsScreen.tsx


import { View, Text, StyleSheet, Pressable, Image } from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", text: "#e5e7eb", accent: "#e6403a" };

function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={require("../assets/logo.png")} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

export default function SettingsScreen() {
  const { lang, setLang } = useLanguage();
  const subtitle =
    lang === "pt" ? "Monitoramento e Controle" : lang === "es" ? "Monitoreo y Control" : "Monitoring & Control";

  return (
    <View style={styles.container}>
      <AppHero subtitle={subtitle} />

      <Text style={styles.title}>
        {lang === "pt" ? "Configura√ß√µes" : lang === "es" ? "Configuraciones" : "Settings"}
      </Text>

      <Text style={styles.label}>
        {lang === "pt" ? "Idioma do aplicativo:" : lang === "es" ? "Idioma de la aplicaci√≥n:" : "App language:"}
      </Text>

      <View style={styles.row}>
        <Pressable onPress={() => setLang("pt")} style={[styles.btn, lang === "pt" && styles.btnActive]}>
          <Text style={styles.btnText}>Portugu√™s</Text>
        </Pressable>

        <Pressable onPress={() => setLang("en")} style={[styles.btn, lang === "en" && styles.btnActive]}>
          <Text style={styles.btnText}>English</Text>
        </Pressable>

        <Pressable onPress={() => setLang("es")} style={[styles.btn, lang === "es" && styles.btnActive]}>
          <Text style={styles.btnText}>Espa√±ol</Text>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, paddingHorizontal: 16 },
  hero: { alignItems: "center", paddingTop: 18, paddingBottom: 10 },
  heroLogo: { width: 80, height: 80, marginBottom: 8, resizeMode: "contain" },
  heroTitle: { color: "#ffffff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 4 },

  title: { color: PALETTE.text, fontSize: 18, fontWeight: "800", marginBottom: 16, marginTop: 6 },
  label: { color: PALETTE.text, marginBottom: 12 },
  row: { flexDirection: "row", gap: 12 },
  btn: {
    backgroundColor: PALETTE.card,
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  btnActive: { backgroundColor: PALETTE.accent, borderColor: PALETTE.accent },
  btnText: { color: "white", fontWeight: "700" },
});




Se quiser, tamb√©m aplico os mesmos cards vermelhos na tela da C√¢mera (ex.: um ‚Äútile‚Äù para alternar Stream/Snapshot e outro para Detectar/Parar), mas mantive seu layout funcional. Curtiu o visual? Quer que eu traga os √≠cones (c√¢mera/ECG) nos tiles de a√ß√£o do Dashboard pra ficar 1:1 com a Home?





































































// HydroBotApp2/src/screens/DashboardScreen.tsx
import { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Image,
  Pressable,
  Alert,
  TextInput,
  Modal,
  TouchableOpacity,
  SafeAreaView,
  Share,
} from "react-native";
import * as FileSystem from "expo-file-system";
import * as MediaLibrary from "expo-media-library";
import { getEvents, saveEventFromServer, deleteEvent, clearAllEvents, FireEvent } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = {
  bg: "#0a0a0a",
  card: "#121212",
  card2: "#0e0e10",
  border: "#232323",
  text: "#e5e7eb",
  sub: "#9ca3af",
  accent: "#2b48ff",
  danger: "#ef4444",
  row: "#0f1730",
  chip: "#182033",
  chipText: "#b7c6ff",
};

const texts = {
  pt: {
    title: "Dashboard",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar agora",
    saving: "Salvando...",
    empty1: "Sem eventos ainda.",
    empty2:
      "Quando o detector sinalizar fogo, capturaremos o snapshot automaticamente.\nVoc√™ tamb√©m pode tocar ‚ÄúRegistrar agora‚Äù.",
    fire: "Detec√ß√£o de fogo",
    clear: "Limpar",
    confirmClearTitle: "Limpar tudo",
    confirmClearBody: "Isso apagar√° todos os eventos e imagens. Continuar?",
    cancel: "Cancelar",
    delete: "Excluir",
    confirmDeleteTitle: "Excluir registro",
    confirmDeleteBody: "Deseja excluir este evento?",
    fail: "Falha ao salvar",
    failBody: "Verifique o servidor /snapshot e a rede.",
    details: "Detalhes",
    share: "Compartilhar",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Baixar",
    downloadedTo: (p: string) => `Imagem salva em:\n${p}`,
    savedToGallery: "Imagem salva na galeria üì∏",
  },
  en: {
    title: "Dashboard",
    server: "Server:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Save now",
    saving: "Saving...",
    empty1: "No events yet.",
    empty2:
      "When fire is detected, a snapshot is captured automatically.\nYou can also tap ‚ÄúSave now‚Äù.",
    fire: "Fire detection",
    clear: "Clear",
    confirmClearTitle: "Clear all",
    confirmClearBody: "This will delete all events and images. Continue?",
    cancel: "Cancel",
    delete: "Delete",
    confirmDeleteTitle: "Delete entry",
    confirmDeleteBody: "Do you want to delete this event?",
    fail: "Failed to save",
    failBody: "Check the /snapshot endpoint and network.",
    details: "Details",
    share: "Share",
    show: "Show",
    hide: "Hide",
    download: "Download",
    downloadedTo: (p: string) => `Image saved to:\n${p}`,
    savedToGallery: "Image saved to gallery üì∏",
  },
  es: {
    title: "Panel",
    server: "Servidor:",
    placeholder: "http://192.168.4.2:8000",
    btnSave: "Registrar ahora",
    saving: "Guardando...",
    empty1: "Sin eventos a√∫n.",
    empty2:
      "Cuando se detecte fuego, se capturar√° una imagen autom√°ticamente.\nTambi√©n puedes tocar ‚ÄúRegistrar ahora‚Äù.",
    fire: "Detecci√≥n de fuego",
    clear: "Limpiar",
    confirmClearTitle: "Limpiar todo",
    confirmClearBody: "Esto borrar√° todos los eventos e im√°genes. ¬øContinuar?",
    cancel: "Cancelar",
    delete: "Eliminar",
    confirmDeleteTitle: "Eliminar registro",
    confirmDeleteBody: "¬øDeseas eliminar este evento?",
    fail: "Error al guardar",
    failBody: "Revisa /snapshot y la red.",
    details: "Detalles",
    share: "Compartir",
    show: "Mostrar",
    hide: "Ocultar",
    download: "Descargar",
    downloadedTo: (p: string) => `Imagen guardada en:\n${p}`,
    savedToGallery: "Imagen guardada en la galer√≠a üì∏",
  },
};

const DEFAULT_SERVER = "http://192.168.4.2:8000";

// Permite expandir/colapsar m√∫ltiplos cards
type EventWithMeta = FireEvent & { meta?: any };

export default function DashboardScreen() {
  const { lang } = useLanguage();
  const T = texts[lang];

  const [server, setServer] = useState<string>(DEFAULT_SERVER);
  const [items, setItems] = useState<EventWithMeta[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [preview, setPreview] = useState<EventWithMeta | null>(null);
  const [busy, setBusy] = useState(false);
  const [expanded, setExpanded] = useState<Set<string>>(new Set());

  async function load() {
    setRefreshing(true);
    try {
      const list = (await getEvents()) as EventWithMeta[];
      setItems(list);
    } finally {
      setRefreshing(false);
    }
  }
  useEffect(() => {
    load();
  }, []);

  async function handleRegisterNow() {
    try {
      setBusy(true);
      const ev = (await saveEventFromServer(server)) as EventWithMeta;
      setItems((prev) => [ev, ...prev]);
    } catch {
      Alert.alert(T.fail, T.failBody);
    } finally {
      setBusy(false);
    }
  }

  function confirmDelete(ev: EventWithMeta) {
    Alert.alert(T.confirmDeleteTitle, T.confirmDeleteBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.delete,
        style: "destructive",
        onPress: async () => {
          await deleteEvent(ev.id);
          setItems((prev) => prev.filter((x) => x.id !== ev.id));
          setExpanded((s) => {
            const n = new Set(s);
            n.delete(ev.id);
            return n;
          });
        },
      },
    ]);
  }

  function confirmClearAll() {
    Alert.alert(T.confirmClearTitle, T.confirmClearBody, [
      { text: T.cancel, style: "cancel" },
      {
        text: T.clear,
        style: "destructive",
        onPress: async () => {
          await clearAllEvents();
          setItems([]);
          setExpanded(new Set());
        },
      },
    ]);
  }

  function toggleExpand(item: EventWithMeta) {
    setExpanded((prev) => {
      const n = new Set(prev);
      if (n.has(item.id)) n.delete(item.id);
      else n.add(item.id);
      return n;
    });
  }

async function downloadImage(uri: string, id: string) {
  try {
    // Nome destino dentro da pasta do app
    const filename = `${id}.jpg`;
    const dest = FileSystem.documentDirectory + filename;

    let localPath = dest;

    if (uri.startsWith("file://")) {
      // -> imagem j√° est√° local; copie para uma pasta controlada do app
      await FileSystem.copyAsync({ from: uri, to: dest });
    } else {
      // -> origem remota http/https
      const res = await FileSystem.downloadAsync(uri, dest);
      localPath = res.uri;
    }

    // Tentar salvar na galeria (Android/iOS)
    try {
      const perm = await MediaLibrary.requestPermissionsAsync();
      if (perm.granted) {
        const asset = await MediaLibrary.createAssetAsync(localPath);
        // Cria/usa um √°lbum "HydroBot"
        const albumName = "HydroBot";
        let album = await MediaLibrary.getAlbumAsync(albumName);
        if (!album) {
          album = await MediaLibrary.createAlbumAsync(albumName, asset, false);
        } else {
          await MediaLibrary.addAssetsToAlbumAsync([asset], album, false);
        }
        Alert.alert("OK", T.savedToGallery);
        return;
      }
    } catch {
      // Se der erro com a galeria, mostramos o fallback abaixo
    }

    // Fallback: manter no app e mostrar caminho
    Alert.alert("OK", T.downloadedTo(localPath));
  } catch (e) {
    Alert.alert("Erro", "Falha ao baixar imagem");
  }
}


  const renderItem = ({ item }: { item: EventWithMeta }) => {
    const dateStr = new Date(item.ts).toLocaleString();
    const isOpen = expanded.has(item.id);

    return (
      <View style={styles.cardWrap}>
        {/* Cabe√ßalho do card */}
        <Pressable onPress={() => toggleExpand(item)} style={styles.cardHeader}>
          <Image source={{ uri: item.imageUri }} style={styles.thumb} />
          <View style={{ flex: 1 }}>
            <Text style={styles.title}>{T.fire}</Text>
            <Text style={styles.time}>{dateStr}</Text>
            <Text style={styles.path} numberOfLines={1}>
              {item.imageUri}
            </Text>
          </View>

          <View style={{ alignItems: "flex-end", gap: 8 }}>
            <Pressable onPress={() => toggleExpand(item)} style={[styles.expandBtn, isOpen && styles.expandBtnOn]}>
              <Text style={styles.expandTxt}>{isOpen ? "‚ñæ " + T.hide : "‚ñ∏ " + T.show}</Text>
            </Pressable>
            <Pressable onPress={() => confirmDelete(item)} style={styles.trashBtn}>
              <Text style={styles.trashTxt}>{T.delete}</Text>
            </Pressable>
          </View>
        </Pressable>

        {/* Painel expandido ‚Äì simples: imagem grande + hora + a√ß√µes */}
        {isOpen && (
          <View style={styles.expandPanel}>
            <Pressable onPress={() => setPreview(item)} style={styles.bigImageWrap}>
              <Image source={{ uri: item.imageUri }} style={styles.bigImage} resizeMode="contain" />
            </Pressable>

            <View style={styles.detailsBox}>
              <Text style={styles.detailsTitle}>{T.details}</Text>
              <Text style={styles.timeBig}>{dateStr}</Text>
            </View>

            <View style={styles.actionsRow}>
              <Pressable
                style={[styles.actionBtn, { backgroundColor: PALETTE.accent }]}
                onPress={() => downloadImage(item.imageUri, item.id)}
              >
                <Text style={[styles.actionTxt, { color: "white" }]}>‚¨á {T.download}</Text>
              </Pressable>

              <Pressable
                style={[styles.actionBtn, { backgroundColor: "#444" }]}
                onPress={() => Share.share({ url: item.imageUri, message: `${T.fire} ‚Ä¢ ${dateStr}` })}
              >
                <Text style={[styles.actionTxt, { color: "#fff" }]}>{T.share}</Text>
              </Pressable>
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.headerTitle}>{T.title}</Text>
        <Pressable onPress={confirmClearAll} style={styles.clearAllBtn}>
          <Text style={styles.clearAllTxt}>{T.clear}</Text>
        </Pressable>
      </View>

      {/* Linha do servidor + Registrar */}
      <View style={styles.row}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholder}
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={handleRegisterNow} style={[styles.btn, busy && { opacity: 0.6 }]} disabled={busy}>
          <Text style={styles.btnTxt}>{busy ? T.saving : T.btnSave}</Text>
        </Pressable>
      </View>

      {/* Lista */}
      <FlatList
        data={items}
        keyExtractor={(it) => it.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={load}
        contentContainerStyle={items.length === 0 && { flex: 1, justifyContent: "center" }}
        ListEmptyComponent={
          <View style={{ alignItems: "center", paddingHorizontal: 16 }}>
            <Text style={{ color: PALETTE.sub, textAlign: "center" }}>{T.empty1}</Text>
            <Text style={{ color: PALETTE.sub, marginTop: 4, textAlign: "center" }}>{T.empty2}</Text>
          </View>
        }
      />

      {/* Modal de zoom (toque na imagem grande) */}
      <Modal visible={!!preview} transparent animationType="fade" onRequestClose={() => setPreview(null)}>
        <View style={styles.modalBg}>
          <TouchableOpacity style={styles.modalBg} activeOpacity={1} onPress={() => setPreview(null)}>
            {preview && <Image source={{ uri: preview.imageUri }} style={styles.fullImg} resizeMode="contain" />}
          </TouchableOpacity>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

/* =========================
   ESTILOS
========================= */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
  },
  headerTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700", flex: 1 },
  clearAllBtn: { paddingHorizontal: 10, paddingVertical: 8, backgroundColor: PALETTE.danger, borderRadius: 8 },
  clearAllTxt: { color: "white", fontWeight: "700" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
    backgroundColor: PALETTE.row,
  },
  label: { color: PALETTE.sub, fontSize: 12 },
  input: {
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 140,
  },
  btn: { backgroundColor: PALETTE.accent, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 10 },
  btnTxt: { color: "white", fontWeight: "700" },

  /* CARD */
  cardWrap: {
    backgroundColor: PALETTE.card,
    marginHorizontal: 10,
    marginTop: 10,
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  thumb: { width: 84, height: 56, backgroundColor: "#000", borderRadius: 8 },
  title: { color: PALETTE.text, fontSize: 14, fontWeight: "700" },
  time: { color: PALETTE.sub, fontSize: 12, marginTop: 2 },
  path: { color: "#8b93a3", fontSize: 11, marginTop: 2 },

  expandBtn: {
    backgroundColor: "#2a2f3d",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  expandBtnOn: { backgroundColor: "#1d2435" },
  expandTxt: { color: "#cbd5ff", fontWeight: "700", fontSize: 12 },

  trashBtn: { backgroundColor: "#333", paddingHorizontal: 10, paddingVertical: 6, borderRadius: 8 },
  trashTxt: { color: "#fca5a5", fontWeight: "700", fontSize: 12 },

  expandPanel: {
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: PALETTE.border,
    backgroundColor: PALETTE.card2,
    paddingBottom: 12,
  },

  bigImageWrap: {
    marginHorizontal: 12,
    marginTop: 10,
    borderRadius: 10,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#000",
  },
  bigImage: { width: "100%", height: 220 },

  detailsBox: {
    marginTop: 10,
    marginHorizontal: 12,
    padding: 12,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: "#0c1020",
  },
  detailsTitle: { color: PALETTE.chipText, fontWeight: "800", marginBottom: 6 },
  timeBig: { color: PALETTE.text, fontSize: 14, fontWeight: "600" },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginHorizontal: 12,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 10,
    alignItems: "center",
    justifyContent: "center",
  },
  actionTxt: { fontWeight: "800" },

  /* Modal zoom */
  modalBg: { flex: 1, backgroundColor: "rgba(0,0,0,0.92)", alignItems: "center", justifyContent: "center" },
  fullImg: { width: "100%", height: "100%" },
});











// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
  Animated,
  LayoutChangeEvent,
} from "react-native";
import { WebView } from "react-native-webview";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  white: "#ffffff",
};

const textsByLang = {
  pt: {
    espIp: "ESP IP:",
    test: "Testar",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "BOMBA ON",
    pumpOff: "BOMBA OFF",
    server: "Servidor:",
    detect: "Detectar",
    detecting: "Detectando",
    saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi/IP.",
    noVideo: "Sem v√≠deo (snapshot). Verifique o servidor.",
    fireOn: (s: number) => `üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sem fogo ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento salvo em ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "Vis√£o:",
    stream: "STREAM (r√°pido)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "Pessoas",
    animals: "Animais",
    boxes: "Caixas",
    backend: "Modelo",
  },
  en: {
    espIp: "ESP IP:",
    test: "Test",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "PUMP ON",
    pumpOff: "PUMP OFF",
    server: "Server:",
    detect: "Detect",
    detecting: "Detecting",
    saving: "Saving...",
    statusFail: "Failed to connect. Check Wi-Fi/IP.",
    noVideo: "No video (snapshot). Check the server.",
    fireOn: (s: number) => `üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `No fire ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Event saved at ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "View:",
    stream: "STREAM (fast)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "People",
    animals: "Animals",
    boxes: "Boxes",
    backend: "Model",
  },
  es: {
    espIp: "ESP IP:",
    test: "Probar",
    ledOn: "LED ENC.",
    ledOff: "LED APAG.",
    pumpOn: "BOMBA ENC.",
    pumpOff: "BOMBA APAG.",
    server: "Servidor:",
    detect: "Detectar",
    detecting: "Detectando",
    saving: "Guardando...",
    statusFail: "Error de conexi√≥n. Revisa Wi-Fi/IP.",
    noVideo: "Sin v√≠deo (snapshot). Revisa el servidor.",
    fireOn: (s: number) => `üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sin fuego ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento guardado a las ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    view: "Vista:",
    stream: "STREAM (r√°pido)",
    snapshot: "SNAPSHOT (fallback)",
    persons: "Personas",
    animals: "Animales",
    boxes: "Cajas",
    backend: "Modelo",
  },
};

const DEFAULT_IP = "192.168.4.1";
const DEFAULT_SERVER = "http://192.168.4.2:8000";

/* ===========================
   Componentes de v√≠deo
=========================== */
function LiveMJPEG({ ip }: { ip: string }) {
  const html = `
    <html><head><meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;}
        .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;}
        img{max-width:100%;max-height:100%;object-fit:contain;background:#000;}
      </style>
    </head>
    <body>
      <div class="wrap"><img src="http://${ip}:81/stream" /></div>
    </body></html>
  `.trim();

  return (
    <WebView
      originWhitelist={["*"]}
      source={{ html }}
      javaScriptEnabled
      allowsInlineMediaPlayback
      mediaPlaybackRequiresUserAction={false}
      automaticallyAdjustContentInsets={false}
      style={{ flex: 1, backgroundColor: "black" }}
    />
  );
}

function CrossfadeImage({
  currentUri,
  nextUri,
  onNextLoadStart,
  onNextShown,
}: {
  currentUri: string;
  nextUri: string;
  onNextLoadStart: () => void;
  onNextShown: () => void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}

      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={onNextShown}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown();
                fade.setValue(0);
                setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ===========================
   Overlay de caixas
=========================== */

type BoxType = "fire" | "person" | "animal";
type SrcBox = { x: number; y: number; w: number; h: number; type: BoxType; conf?: number };

function BoxesOverlay({
  frameWH,
  containerWH,
  boxes,
}: {
  frameWH: { w: number; h: number } | null;
  containerWH: { w: number; h: number } | null;
  boxes: SrcBox[];
}) {
  if (!frameWH || !containerWH || frameWH.w <= 0 || frameWH.h <= 0 || containerWH.w <= 0 || containerWH.h <= 0) {
    return null;
  }

  // Simula object-fit: contain
  const scale = Math.min(containerWH.w / frameWH.w, containerWH.h / frameWH.h);
  const dispW = frameWH.w * scale;
  const dispH = frameWH.h * scale;
  const offsetX = (containerWH.w - dispW) / 2;
  const offsetY = (containerWH.h - dispH) / 2;

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      {/* √Årea exata onde a imagem aparece */}
      <View
        style={{
          position: "absolute",
          left: offsetX,
          top: offsetY,
          width: dispW,
          height: dispH,
        }}
      >
        {boxes.map((b, i) => {
          const left = b.x * scale;
          const top = b.y * scale;
          const width = b.w * scale;
          const height = b.h * scale;

          let borderColor = "#ff3b30"; // fire
          if (b.type === "person") borderColor = "#00e5ff";
          else if (b.type === "animal") borderColor = "#7CFC00";

          return (
            <View
              key={`${i}-${b.type}`}
              style={{
                position: "absolute",
                left,
                top,
                width,
                height,
                borderWidth: 3,
                borderColor,
                borderRadius: 6,
                backgroundColor: "transparent",
              }}
            >
              {/* Etiqueta no topo */}
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  top: -18,
                  paddingHorizontal: 6,
                  paddingVertical: 2,
                  borderRadius: 4,
                  backgroundColor: borderColor,
                }}
              >
                <Text style={{ color: "#000", fontWeight: "800", fontSize: 10 }}>
                  {b.type.toUpperCase()}
                  {typeof b.conf === "number" ? ` ${b.conf.toFixed(2)}` : ""}
                </Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados do ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState("‚Äî");
  const [ledOn, setLedOn] = useState(false);
  const [pumpOn, setPumpOn] = useState(false);

  // detec√ß√£o
  const [detectOn, setDetectOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  // pessoas/animais (usando campos est√°veis do servidor)
  const [people, setPeople] = useState(0);
  const [animals, setAnimals] = useState(0);
  const [backend, setBackend] = useState<string>("‚Äî");
  const [confMax, setConfMax] = useState<number>(0);

  // caixas para overlay
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{ w: number; h: number } | null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{ w: number; h: number } | null>(null);

  // preview de caixas
  const [showBoxes, setShowBoxes] = useState(false);
  const [boxesUri, setBoxesUri] = useState("");

  // registro autom√°tico
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef(0);
  const wasFireRef = useRef(false);
  const SAVE_COOLDOWN_MS = 5000;

  // vis√£o
  const [useStream, setUseStream] = useState(true);
  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  // joystick (UI)
  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // helpers URL
  const cleanServer = (s: string) => s.replace(/\/+$/, "");
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  /* ===== ESP STATUS ===== */
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl);
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(`OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`);
    } catch {
      setStatusText(T.statusFail);
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  /* ===== V√≠deo SNAPSHOT fallback (25 fps alvo) ===== */
  useEffect(() => {
    if (useStream) return;
    let stop = false;
    const FPS_INTERVAL = 40; // ~25 fps

    setCurrentFrameUri(`${cleanServer(server)}/snapshot?ts=${Date.now()}`);

    const tick = () => {
      if (stop) return;
      if (!loadingNextRef.current) {
        const url = `${cleanServer(server)}/snapshot?ts=${Date.now()}`;
        setNextFrameUri(url);
      }
      setTimeout(tick, FPS_INTERVAL);
    };
    tick();

    return () => {
      stop = true;
    };
  }, [server, useStream]);

  function onNextLoadStart() {
    loadingNextRef.current = true;
  }
  function onNextShown() {
    if (nextFrameUri) setCurrentFrameUri(nextFrameUri);
    loadingNextRef.current = false;
  }

  /* ===== LOOP DE DETEC√á√ÉO + CAIXAS ===== */
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;

    const loop = async () => {
      try {
        const r = await fetch(`${cleanServer(server)}/detect`);
        const j = await r.json();

        if (!stop && j && j.ok !== false) {
          // fogo
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));

          // frame size para convers√£o
          const wh = Array.isArray(j.frame_wh) && j.frame_wh.length === 2
            ? { w: Number(j.frame_wh[0]) || 0, h: Number(j.frame_wh[1]) || 0 }
            : null;
          if (wh && wh.w > 0 && wh.h > 0) setFrameWH(wh);

          // objetos (est√°veis)
          const o = j.objects || {};
          const objs = o.objects || [];
          const peopleStable =
            typeof o.n_person_stable === "number"
              ? o.n_person_stable
              : typeof o.n_person === "number"
              ? o.n_person
              : objs.filter((x: any) => x.label === "person").length > 0
              ? 1
              : 0;
          const animalsStable =
            typeof o.n_animals_stable === "number"
              ? o.n_animals_stable
              : typeof o.n_animals === "number"
              ? o.n_animals
              : objs.filter((x: any) => x.label !== "person").length > 0
              ? 1
              : 0;

          setPeople(peopleStable);
          setAnimals(animalsStable);
          setBackend(o.backend || "‚Äî");
          setConfMax(Number(o.conf_max || 0));

          // montar caixas para overlay
          const boxes: SrcBox[] = [];

          // Caixas de FOGO (j.boxes) ‚Äî aparecem apenas quando fogo final est√° ON
          if (j.isFire && Array.isArray(j.boxes)) {
            for (const b of j.boxes) {
              if (!Array.isArray(b) || b.length < 4) continue;
              const [x, y, w, h] = b.map((n: any) => Number(n) || 0);
              boxes.push({ x, y, w, h, type: "fire" });
            }
          }

          // Caixas de OBJETOS (pessoas/animais)
          for (const it of objs) {
            if (!it || !Array.isArray(it.box) || it.box.length < 4) continue;
            const [x, y, w, h] = it.box.map((n: any) => Number(n) || 0);
            const label = String(it.label || "").toLowerCase();
            const conf = typeof it.conf === "number" ? it.conf : undefined;
            if (label === "person") {
              boxes.push({ x, y, w, h, type: "person", conf });
            } else {
              // qualquer n√£o-person tratado como "animal" (COCO/MNet conjunto)
              boxes.push({ x, y, w, h, type: "animal", conf });
            }
          }

          setOverlayBoxes(boxes);

          // mini preview (opcional)
          if (showBoxes) {
            setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`);
          }
        }
      } catch {
        if (!stop) {
          setIsFire(false);
          setFireScore(0);
          setPeople(0);
          setAnimals(0);
          setOverlayBoxes([]);
        }
      } finally {
        if (!stop) setTimeout(loop, 180); // ~5-6Hz
      }
    };
    loop();

    return () => {
      stop = true;
    };
  }, [detectOn, server, showBoxes]);

  /* ===== Registro autom√°tico ===== */
  useEffect(() => {
    const rising = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;

    if (detectOn && rising && cooldownOk && !saving) {
      (async () => {
        try {
          setSaving(true);
          await saveEventFromServer(server);
          lastSaveRef.current = Date.now();
          setStatusText(T.eventSavedAt(new Date(lastSaveRef.current).toLocaleString()));
        } catch {
          setStatusText(T.noVideo);
        } finally {
          setSaving(false);
        }
      })();
    }
    wasFireRef.current = isFire;
  }, [detectOn, isFire, server, saving, T]);

  /* ===== Joystick ===== */
  const RADIUS = 64,
    KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS,
          ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny });
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const knobLeft = joy.x * RADIUS,
    knobTop = -joy.y * RADIUS;

  /* ===== Medidas do container do v√≠deo (para o overlay) ===== */
  function onVideoLayout(e: LayoutChangeEvent) {
    const { width, height } = e.nativeEvent.layout;
    setVideoContainerWH({ w: width, h: height });
  }

  return (
    <View style={styles.container}>
      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder={T.placeholderIp}
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : T.test}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? T.ledOn : T.ledOff}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? T.pumpOn : T.pumpOff}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor + Detectar + Seletor de vis√£o */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholderServer}
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? (saving ? T.saving : T.detecting) : T.detect}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Seletor de vis√£o */}
      <View style={[styles.statusRow, { gap: 6 }]}>
        <Text style={styles.label}>{T.view}</Text>
        <Pressable onPress={() => setUseStream(true)} style={[styles.btn, useStream ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{T.stream}</Text>
        </Pressable>
        <Pressable onPress={() => setUseStream(false)} style={[styles.btn, !useStream ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{T.snapshot}</Text>
        </Pressable>

        {/* toggle boxes (mini preview do servidor) */}
        <Pressable
          onPress={() => {
            const val = !showBoxes;
            setShowBoxes(val);
            if (val) setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`);
          }}
          style={[styles.btn, showBoxes ? styles.btnOn : styles.btnOff]}
        >
          <Text style={styles.btnText}>{T.boxes}</Text>
        </Pressable>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
        </View>
      )}

      {/* Banner de pessoas/animais + backend */}
      {detectOn && (
        <View style={[styles.statusRow, { justifyContent: "space-between" }]}>
          <Text style={styles.statChip}>
            {T.persons}: <Text style={styles.statNumber}>{people}</Text>
          </Text>
          <Text style={styles.statChip}>
            {T.animals}: <Text style={styles.statNumber}>{animals}</Text>
          </Text>
          <Text style={styles.modelChip}>
            {T.backend}: {backend} ‚Ä¢ conf_max {confMax.toFixed(2)}
          </Text>
        </View>
      )}

      {/* V√≠deo + Overlay */}
      <View style={{ flex: 1 }} onLayout={onVideoLayout}>
        {useStream ? (
          <LiveMJPEG ip={ip} />
        ) : (
          <CrossfadeImage
            currentUri={currentFrameUri}
            nextUri={nextFrameUri}
            onNextLoadStart={onNextLoadStart}
            onNextShown={onNextShown}
          />
        )}

        {/* Overlay das caixas (FOGO/PESSOA/ANIMAL) */}
        {detectOn && overlayBoxes.length > 0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Mini preview com caixas (opcional) */}
      {detectOn && showBoxes && (
        <View style={{ height: 140, backgroundColor: "#000" }}>
          {!!boxesUri && (
            <Image
              source={{ uri: boxesUri }}
              style={{ flex: 1, width: "100%" }}
              resizeMode="contain"
              onError={() => setBoxesUri(`${cleanServer(server)}/objects_frame?conf=0.25&ts=${Date.now()}`)}
            />
          )}
        </View>
      )}

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: knobLeft }, { translateY: knobTop }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: PALETTE.bg,
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
    minWidth: 110,
  },
  btn: {
    backgroundColor: "#2b48ff",
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  statChip: { color: "#dbeafe", fontSize: 14, fontWeight: "600" },
  statNumber: { color: "#fff" },
  modelChip: { marginLeft: "auto", color: "#9fb0ff", fontSize: 12 },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: {
    position: "absolute",
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.14)",
  },
  joyKnob: {
    position: "absolute",
    backgroundColor: "rgba(43,72,255,0.9)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.85)",
  },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});










import { View, Text, StyleSheet, Pressable } from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg: "#0a0a0a", card: "#121212", border: "#232323", text: "#e5e7eb", accent: "#2b48ff" };

export default function SettingsScreen() {
  const { lang, setLang } = useLanguage();

  return (
    <View style={styles.container}>
      <Text style={styles.title}>
        {lang === "pt" ? "Configura√ß√µes" : lang === "es" ? "Configuraciones" : "Settings"}
      </Text>

      <Text style={styles.label}>
        {lang === "pt" ? "Idioma do aplicativo:" : lang === "es" ? "Idioma de la aplicaci√≥n:" : "App language:"}
      </Text>

      <View style={styles.row}>
        <Pressable
          onPress={() => setLang("pt")}
          style={[styles.btn, lang === "pt" && styles.btnActive]}
        >
          <Text style={styles.btnText}>Portugu√™s</Text>
        </Pressable>

        <Pressable
          onPress={() => setLang("en")}
          style={[styles.btn, lang === "en" && styles.btnActive]}
        >
          <Text style={styles.btnText}>English</Text>
        </Pressable>

        <Pressable
          onPress={() => setLang("es")}
          style={[styles.btn, lang === "es" && styles.btnActive]}
        >
          <Text style={styles.btnText}>Espa√±ol</Text>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 20 },
  title: { color: PALETTE.text, fontSize: 22, fontWeight: "700", marginBottom: 20 },
  label: { color: PALETTE.text, marginBottom: 12 },
  row: { flexDirection: "row", gap: 12 },
  btn: {
    backgroundColor: PALETTE.card,
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  btnActive: { backgroundColor: PALETTE.accent, borderColor: PALETTE.accent },
  btnText: { color: "white", fontWeight: "600" },
});

