
bora deixar bonito e com a câmera GRANDONA. Abaixo estão os 3 arquivos completos: App.tsx, src/screens/HomeScreen.tsx e src/screens/CameraScreen.tsx.

Eles mantêm só Home e Câmera, colocam a logo (assets/logo.png) em ambas as telas, e deixam o MJPEG ocupando praticamente a tela toda (com proporção estável 4:3).



App.tsx


import React from "react";
import { NavigationContainer, DefaultTheme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";
import { LogBox } from "react-native";

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";

LogBox.ignoreLogs(["useInsertionEffect must not schedule updates"]);

const Tab = createBottomTabNavigator();

const theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: "#0b0b0f",
    card: "#0b0b0f",
    text: "#e5e7eb",
    border: "#25273a",
    primary: "#e6403a",
  },
};

export default function App() {
  return (
    <NavigationContainer theme={theme}>
      <Tab.Navigator
        screenOptions={({ route }) => ({
          headerShown: false,
          tabBarStyle: { backgroundColor: "#0b0b0f", borderTopColor: "#25273a" },
          tabBarActiveTintColor: "#e6403a",
          tabBarInactiveTintColor: "#9aa0a6",
          tabBarIcon: ({ color, size }) => {
            const name =
              route.name === "Início" ? "home" :
              route.name === "Câmera" ? "videocam" : "ellipse";
            return <Ionicons name={name as any} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen name="Início" component={HomeScreen} />
        <Tab.Screen name="Câmera" component={CameraScreen} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}




src/screens/HomeScreen.tsx


import React from "react";
import { View, Text, StyleSheet, Image, Pressable } from "react-native";
import { useNavigation } from "@react-navigation/native";

const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", accent: "#e6403a", text: "#e5e7eb" };

export default function HomeScreen() {
  const nav = useNavigation<any>();

  return (
    <View style={styles.container}>
      <View style={styles.logoWrap}>
        <Image source={require("../../assets/logo.png")} style={styles.logo} resizeMode="contain" />
        <Text style={styles.title}>HydroBot</Text>
        <Text style={styles.subtitle}>Monitoramento e Controle</Text>
      </View>

      <View style={styles.card}>
        <Text style={styles.cardTitle}>Bem-vindo</Text>
        <Text style={styles.cardText}>
          Toque abaixo para abrir a câmera e visualizar o stream MJPEG do ESP32-CAM.
        </Text>

        <Pressable style={styles.cta} onPress={() => nav.navigate("Câmera")}>
          <Text style={styles.ctaText}>Abrir Câmera</Text>
        </Pressable>
      </View>

      <Text style={styles.footer}>v2 • feito com ❤️</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, alignItems: "center", paddingHorizontal: 20, paddingTop: 48 },
  logoWrap: { alignItems: "center", gap: 8, marginBottom: 16 },
  logo: { width: 120, height: 120 },
  title: { color: PALETTE.text, fontSize: 28, fontWeight: "700", letterSpacing: 0.4 },
  subtitle: { color: "#9aa0a6", fontSize: 14 },
  card: { width: "100%", backgroundColor: PALETTE.card, borderColor: PALETTE.border, borderWidth: 1, borderRadius: 16, padding: 16, gap: 10 },
  cardTitle: { color: PALETTE.text, fontSize: 18, fontWeight: "700" },
  cardText: { color: "#cdd1d5", fontSize: 14, lineHeight: 20 },
  cta: { marginTop: 8, backgroundColor: PALETTE.accent, borderRadius: 12, paddingVertical: 12, alignItems: "center" },
  ctaText: { color: "white", fontWeight: "700", fontSize: 16 },
  footer: { position: "absolute", bottom: 20, color: "#6b7280", fontSize: 12 },
});




src/screens/CameraScreen.tsx




Câmera grande: o WebView fica dentro de um container com aspectRatio: 4/3 e maxHeight: '78%', ocupando praticamente a tela.

Inclui a logo no topo e mantém os botões de stream/snapshot.




import React, { useMemo, useRef, useState } from "react";
import { View, Text, TextInput, Pressable, StyleSheet, Image, Dimensions, Platform } from "react-native";
import { WebView } from "react-native-webview";

const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", accent: "#e6403a", text: "#e5e7eb" };

type Mode = "mjpeg" | "snapshot";

export default function CameraScreen() {
  const [ip, setIp] = useState("192.168.3.3");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const webRef = useRef<WebView>(null);

  const url = useMemo(() => {
    if (!ip) return "about:blank";
    return mode === "mjpeg" ? `http://${ip}:81/stream` : `http://${ip}/capture`;
  }, [ip, mode]);

  const reload = () => webRef.current?.reload();

  return (
    <View style={styles.container}>
      {/* Header com logo */}
      <View style={styles.header}>
        <Image source={require("../../assets/logo.png")} style={styles.logo} resizeMode="contain" />
        <Text style={styles.title}>Câmera</Text>
      </View>

      {/* Controles simples */}
      <View style={styles.row}>
        <Text style={styles.label}>ESP IP</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="ex: 192.168.3.3"
          placeholderTextColor="#7b7f86"
          autoCapitalize="none"
          autoCorrect={false}
          keyboardType={Platform.OS === "ios" ? "numbers-and-punctuation" : "numeric"}
          style={styles.input}
        />
        <Pressable style={styles.testBtn} onPress={reload}>
          <Text style={styles.testTxt}>Testar</Text>
        </Pressable>
      </View>

      {/* Botões de modo */}
      <View style={styles.modes}>
        <Pressable onPress={() => setMode("mjpeg")} style={[styles.modeBtn, mode === "mjpeg" && styles.modeActive]}>
          <Text style={[styles.modeTxt, mode === "mjpeg" && styles.modeTxtActive]}>MJPEG (:81/stream)</Text>
        </Pressable>
        <Pressable onPress={() => setMode("snapshot")} style={[styles.modeBtn, mode === "snapshot" && styles.modeActive]}>
          <Text style={[styles.modeTxt, mode === "snapshot" && styles.modeTxtActive]}>Snapshot (/capture)</Text>
        </Pressable>
      </View>

      {/* VIEWPORT GRANDONA */}
      <View style={styles.viewport}>
        <WebView
          ref={webRef}
          source={{ uri: url }}
          style={styles.web}
          javaScriptEnabled
          domStorageEnabled
          allowsInlineMediaPlayback
          cacheEnabled={false}
          automaticallyAdjustContentInsets={false}
          bounces={false}
          onError={() => {}}
        />
      </View>

      <Text style={styles.status}>URL: {url}</Text>
    </View>
  );
}

const { height } = Dimensions.get("window");
const VIEWPORT_MAX_H = Math.floor(height * 0.78); // ocupa ~78% da tela

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, paddingHorizontal: 16, paddingTop: 16 },
  header: { flexDirection: "row", alignItems: "center", gap: 10, marginBottom: 12 },
  logo: { width: 32, height: 32 },
  title: { color: PALETTE.text, fontSize: 20, fontWeight: "700" },

  row: { flexDirection: "row", alignItems: "center", gap: 8, marginBottom: 10 },
  label: { color: "#9aa0a6", width: 56 },
  input: { flex: 1, backgroundColor: PALETTE.card, color: PALETTE.text, borderColor: PALETTE.border, borderWidth: 1, borderRadius: 10, paddingHorizontal: 10, height: 40 },
  testBtn: { backgroundColor: PALETTE.accent, paddingHorizontal: 14, height: 40, borderRadius: 10, justifyContent: "center" },
  testTxt: { color: "white", fontWeight: "700" },

  modes: { flexDirection: "row", gap: 10, marginBottom: 10 },
  modeBtn: { paddingVertical: 8, paddingHorizontal: 12, borderRadius: 16, borderWidth: 1, borderColor: PALETTE.border, backgroundColor: PALETTE.card },
  modeActive: { backgroundColor: "#2a0f11", borderColor: "#5a1e21" },
  modeTxt: { color: "#cdd1d5", fontSize: 12 },
  modeTxtActive: { color: "#ffd9d7", fontWeight: "700" },

  // viewport grande estável (proporção 4:3)
  viewport: {
    width: "100%",
    maxHeight: VIEWPORT_MAX_H,
    aspectRatio: 4 / 3,
    backgroundColor: "black",
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
    alignSelf: "center",
  },
  web: { flex: 1, backgroundColor: "black" },

  status: { marginTop: 8, color: "#7b7f86", fontSize: 12 },
});




Notas




A câmera agora preenche o container 4:3 com até ~78% da altura da tela. Se quiser ainda maior, aumente VIEWPORT_MAX_H para 0.86 (86%).


A logo vem de assets/logo.png. Certifique-se de que o caminho é exatamente ./assets/logo.png na raiz do projeto.


Mantive o visual escuro do seu app, só refinei a Home (logo + card + CTA) para ficar limpa e parecida com o design anterior.




Se algo ainda ficar pequeno no seu tablet específico, me diga a altura/largura em pixels que você quer para o viewport e eu já mando um ajuste fino (ou coloco full-bleed com aspectRatio dinâmico).

































bora — já deixei a câmera maiorzassa (ocupando praticamente a tela toda) e alinhei o visual ao app antigo (preto, card escuro, acento vermelho, bordas finas). É só substituir os arquivos abaixo.



1) src/screens/CameraScreen.tsx (câmera maior + visual antigo)


import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet, Image,
  AppState, AppStateStatus, Platform, NativeSyntheticEvent, ImageErrorEventData
} from "react-native";
import { WebView } from "react-native-webview";
import type { WebViewErrorEvent, WebViewHttpErrorEvent } from "react-native-webview/lib/WebViewTypes";

type Mode = "mjpeg" | "snapshot";

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
  sub: "#9c9c9c",
};

export default function CameraScreen() {
  const [ip, setIp] = useState<string>("192.168.3.3"); // ajuste se quiser
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [statusText, setStatusText] = useState<string>("—");
  const [err, setErr] = useState<string>("");

  // snapshot loop
  const [snapUri, setSnapUri] = useState<string>("");
  const timerRef = useRef<number | null>(null);
  const appState = useRef(AppState.currentState);

  // endpoints padrão do firmware (CameraWebServer)
  const base80 = useMemo(() => `http://${ip}`, [ip]);
  const base81 = useMemo(() => `http://${ip}:81`, [ip]);
  const statusUrl = useMemo(() => `${base80}/status`, [base80]);
  const snapshotUrl = useMemo(() => `${base80}/capture`, [base80]);
  const streamUrl = useMemo(() => `${base81}/stream`, [base81]);

  const clearTimer = useCallback(() => {
    if (timerRef.current !== null) { clearInterval(timerRef.current); timerRef.current = null; }
  }, []);
  const startSnapshot = useCallback(() => {
    clearTimer();
    timerRef.current = setInterval(() => setSnapUri(`${snapshotUrl}?ts=${Date.now()}`), 125) as unknown as number;
  }, [snapshotUrl, clearTimer]);

  useEffect(() => {
    const sub = AppState.addEventListener("change", (next: AppStateStatus) => {
      if (appState.current.match(/inactive|background/) && next === "active" && mode === "snapshot") startSnapshot();
      if (next.match(/inactive|background/)) clearTimer();
      appState.current = next;
    });
    return () => { sub.remove(); clearTimer(); };
  }, [mode, startSnapshot, clearTimer]);

  useEffect(() => {
    setErr("");
    if (mode === "snapshot") startSnapshot(); else clearTimer();
    return () => clearTimer();
  }, [mode, startSnapshot, clearTimer]);

  const checkStatus = useCallback(async () => {
    try {
      const r = await fetch(statusUrl);
      const txt = await r.text();
      setStatusText(`OK (${txt.slice(0, 60)}${txt.length > 60 ? "..." : ""})`);
    } catch (e) {
      const er = e as Error;
      setStatusText("Falhou");
      setErr(er?.message ?? String(e));
    }
  }, [statusUrl]);

  useEffect(() => { if (ip) checkStatus(); }, [ip, checkStatus]);

  const onWvError = useCallback((e: WebViewErrorEvent) => setErr(`WebView: ${e.nativeEvent.description}`), []);
  const onWvHttpError = useCallback((e: WebViewHttpErrorEvent) => setErr(`HTTP ${e.nativeEvent.statusCode}`), []);
  const onImgError = useCallback((e: NativeSyntheticEvent<ImageErrorEventData>) => setErr(`Snapshot: ${e.nativeEvent.error}`), []);

  return (
    <View style={styles.container}>
      {/* Barra compacta (como no app antigo) */}
      <View style={styles.topBar}>
        <View style={{ flex: 1 }}>
          <Text style={styles.label}>ESP IP</Text>
          <TextInput
            style={styles.input}
            value={ip}
            onChangeText={setIp}
            placeholder="ex.: 192.168.3.3"
            placeholderTextColor={PALETTE.sub}
            autoCapitalize="none"
            autoCorrect={false}
            keyboardType={Platform.OS === "android" ? "numeric" : "numbers-and-punctuation"}
          />
        </View>

        <Pressable style={styles.btnTest} onPress={checkStatus}>
          <Text style={styles.btnTxt}>Testar</Text>
        </Pressable>
      </View>

      {/* Chips modo (linha fina, vermelho ativo) */}
      <View style={styles.modeRow}>
        <Pressable
          style={[styles.chip, mode === "mjpeg" && styles.chipActive]}
          onPress={() => setMode("mjpeg")}
        >
          <Text style={[styles.chipTxt, mode === "mjpeg" && styles.chipTxtActive]}>MJPEG (:81/stream)</Text>
        </Pressable>

        <Pressable
          style={[styles.chip, mode === "snapshot" && styles.chipActive]}
          onPress={() => setMode("snapshot")}
        >
          <Text style={[styles.chipTxt, mode === "snapshot" && styles.chipTxtActive]}>Snapshot (/capture)</Text>
        </Pressable>
      </View>

      {/* VIEWER — agora MUITO MAIOR */}
      <View style={styles.viewerCard}>
        {mode === "mjpeg" ? (
          <WebView
            source={{ uri: streamUrl }}
            style={{ width: "100%", height: "100%" }}
            allowsInlineMediaPlayback
            mediaPlaybackRequiresUserAction={false}
            allowUniversalAccessFromFileURLs
            onError={onWvError}
            onHttpError={onWvHttpError}
          />
        ) : (
          <Image
            source={{ uri: snapUri || `${snapshotUrl}?ts=${Date.now()}` }}
            style={{ width: "100%", height: "100%" }}
            resizeMode="contain"
            onError={onImgError}
          />
        )}
      </View>

      {/* Status enxuto, como no antigo */}
      <View style={styles.metaBox}>
        <Text style={styles.meta}>Status: <Text style={{ color: "#a7f3d0" }}>{statusText}</Text></Text>
        {!!err && <Text style={[styles.meta, { color: "#ff8b8b" }]}>Erro: {err}</Text>}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, paddingHorizontal: 12, paddingTop: 10 },
  topBar: { flexDirection: "row", alignItems: "flex-end", gap: 8 },
  label: { color: PALETTE.white, marginBottom: 6, fontWeight: "600" },
  input: {
    backgroundColor: PALETTE.card,
    borderWidth: 1,
    borderColor: PALETTE.border,
    borderRadius: 12,
    paddingHorizontal: 12,
    paddingVertical: 9,
    color: PALETTE.white,
  },
  btnTest: {
    backgroundColor: PALETTE.red,
    paddingHorizontal: 16,
    paddingVertical: 11,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#00000055",
  },
  btnTxt: { color: "#fff", fontWeight: "700" },

  modeRow: { flexDirection: "row", gap: 8, marginTop: 8, marginBottom: 8 },
  chip: { borderWidth: 1, borderColor: PALETTE.border, borderRadius: 999, paddingHorizontal: 12, paddingVertical: 6 },
  chipActive: { backgroundColor: PALETTE.red, borderColor: PALETTE.red },
  chipTxt: { color: PALETTE.white },
  chipTxtActive: { color: "#fff", fontWeight: "700" },

  // >>> AQUI a câmera cresce: ocupa quase toda a tela (flex: 1) e reduz as margens
  viewerCard: {
    flex: 1,
    backgroundColor: PALETTE.card,
    borderWidth: 1,
    borderColor: PALETTE.border,
    borderRadius: 12,
    overflow: "hidden",
  },

  metaBox: { paddingTop: 6 },
  meta: { color: PALETTE.sub, fontSize: 12 },
});



O que mudou




Compactei a top bar (IP + Testar).


Chips de modo com vermelho ativo igual ao antigo.


O viewer agora tem flex: 1 e fica logo abaixo dos controles, ocupando praticamente todo o espaço disponível.


Mantive as cores/bordas do app antigo.





2) (Opcional) src/screens/HomeScreen.tsx com o mesmo visual


import React from "react";
import { View, Text, StyleSheet, Pressable } from "react-native";

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  white: "#FFFFFF",
  sub: "#9c9c9c",
};

export default function HomeScreen({ navigation }: any) {
  return (
    <View style={styles.container}>
      <View style={styles.card}>
        <Text style={styles.title}>HydroBot</Text>
        <Text style={styles.sub}>Início do app</Text>

        <Pressable style={styles.btn} onPress={() => navigation.navigate("Camera")}>
          <Text style={styles.btnTxt}>Ir para Câmera</Text>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, justifyContent: "center" },
  card: {
    backgroundColor: PALETTE.card,
    borderWidth: 1,
    borderColor: PALETTE.border,
    borderRadius: 14,
    padding: 16,
    gap: 8,
  },
  title: { color: PALETTE.white, fontSize: 22, fontWeight: "700" },
  sub: { color: PALETTE.sub, marginBottom: 8 },
  btn: {
    alignSelf: "flex-start",
    backgroundColor: PALETTE.red,
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 12,
  },
  btnTxt: { color: "#fff", fontWeight: "700" },
});




Se quiser mais ainda de tela para o vídeo, posso mover os chips para dentro da top bar (em uma linha) ou colocar um botão “Expandir” para esconder toda a UI e deixar full-screen. Quer assim?



























































// App.tsx
import React from "react";
import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";

export type TabParamList = { Home: undefined; Camera: undefined };
const Tab = createBottomTabNavigator<TabParamList>();

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#FFFFFF" };

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

export default function App() {
  return (   // <-- sem quebra de linha aqui
    <NavigationContainer theme={DarkThemeHB}>
      <Tab.Navigator
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          tabBarIcon: ({ color, size }) => {
            const iconMap = { Home: "home", Camera: "videocam" } as const;
            return <Ionicons name={iconMap[route.name as keyof typeof iconMap]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} options={{ title: "Início", tabBarLabel: "Início" }} />
        <Tab.Screen name="Camera" component={CameraScreen} options={{ title: "Câmera", tabBarLabel: "Câmera" }} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}







// App.tsx
import React from "react";
import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";

export type TabParamList = { Home: undefined; Camera: undefined };
const Tab = createBottomTabNavigator<TabParamList>();

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#FFFFFF" };

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

export default function App() {
  return (   // <-- sem quebra de linha aqui
    <NavigationContainer theme={DarkThemeHB}>
      <Tab.Navigator
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          tabBarIcon: ({ color, size }) => {
            const iconMap = { Home: "home", Camera: "videocam" } as const;
            return <Ionicons name={iconMap[route.name as keyof typeof iconMap]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} options={{ title: "Início", tabBarLabel: "Início" }} />
        <Tab.Screen name="Camera" component={CameraScreen} options={{ title: "Câmera", tabBarLabel: "Câmera" }} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}


























Boa! O erro do print é exatamente do tsconfig:




Cannot find type definition file for: expo/metro-runtime




Isso acontece porque o tsconfig.json está com "types": ["expo/metro-runtime"] (ou algo parecido) e o TS não acha esses types. Em projetos Expo/React Native, você não precisa desse item.


Corrija assim




Instale os types básicos (se ainda não fez):




npm i -D typescript @types/react @types/react-native





Substitua seu tsconfig.json por este aqui (na raiz do projeto):




{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["ES2017", "DOM"],
    "module": "ESNext",
    "jsx": "react-jsx",
    "strict": true,
    "noEmit": true,
    "moduleResolution": "bundler",
    "allowJs": false,
    "isolatedModules": true,
    "skipLibCheck": true,
    "types": ["react", "react-native"]
  },
  "include": ["**/*.ts", "**/*.tsx"]
}



⚠️ Note que removi "expo/metro-runtime" da lista de types.






Reinicie o TS Server no VS Code:

Ctrl+Shift+P → “TypeScript: Restart TS server”.






Limpe o cache do Expo e rode de novo:






npx expo start -c



Se aparecer qualquer outro erro, manda o novo print/linha que ajusto na hora.


















































Isso é erro de resolução de módulo: o Metro não está achando ./src/screens/HomeScreen (e os demais). Corrige com estes passos—na ordem:


1) Verifique o caminho e o nome (case-sensitive)


O import no App.tsx é:


import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";



Então os arquivos precisam existir exatamente com estes paths e nomes:


<raiz-do-projeto>/
  App.tsx
  src/
    screens/
      HomeScreen.tsx
      CameraScreen.tsx



⚠️ O Metro é case-sensitive, mesmo no Windows. Se sua pasta estiver Screens, screen, homescreen.tsx, etc., vai falhar. Renomeie para screens e HomeScreen.tsx / CameraScreen.tsx.


2) Garanta a extensão e o export




Extensão deve ser .tsx (não .ts / .js).


Cada arquivo deve ter export default.




Conteúdo mínimo—cole exatamente:


src/screens/HomeScreen.tsx


import React from "react";
import { View, Text, StyleSheet } from "react-native";

export default function HomeScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Home Screen</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#000", alignItems: "center", justifyContent: "center" },
  text: { color: "#fff", fontSize: 20 },
});



src/screens/CameraScreen.tsx


import React from "react";
import { View, Text, StyleSheet } from "react-native";

export default function CameraScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Camera Screen</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#000", alignItems: "center", justifyContent: "center" },
  text: { color: "#fff", fontSize: 20 },
});



3) Confirme que você abriu a pasta raiz no VS Code


A raiz é a que contém App.tsx e package.json. O print mostra D:\\HydroBotApp\\AppHydroBot\\App.tsx. Abra AppHydroBot no VS Code (File → Open Folder).


4) Limpe o cache do bundler


No terminal na raiz do projeto:


npx expo start -c



5) Se ainda der o mesmo erro




Confira no Explorer se não ficou HomeScreen.tsx.txt (Windows às vezes oculta extensão).


Verifique se não há um arquivo com mesmo nome mas extensão diferente (ex.: HomeScreen.js conflitando).


No App.tsx, confira se os imports são relativos (começam com ./) e não têm espaços estranhos.




App.tsx (igual ao que te mandei, mas sem mudanças de path)


import React from "react";
import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";

export type TabParamList = { Home: undefined; Camera: undefined };
const Tab = createBottomTabNavigator<TabParamList>();

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#FFFFFF" };

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: { ...DefaultTheme.colors, background: PALETTE.bg, primary: PALETTE.red, card: PALETTE.card, text: PALETTE.white, border: PALETTE.border, notification: PALETTE.red },
};

export default function App() {
  return (
    <NavigationContainer theme={DarkThemeHB}>
      <Tab.Navigator
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          tabBarIcon: ({ color, size }) => {
            const iconMap = { Home: "home", Camera: "videocam" } as const;
            return <Ionicons name={iconMap[route.name as keyof typeof iconMap]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} options={{ title: "Início", tabBarLabel: "Início" }} />
        <Tab.Screen name="Camera" component={CameraScreen} options={{ title: "Câmera", tabBarLabel: "Câmera" }} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}



Se, depois disso, ainda acusar o mesmo caminho, me diga exatamente como está o nome das pastas/arquivos (com maiúsculas/minúsculas) que eu ajusto o import na hora.








































show! vamos reduzir ao essencial: apenas Home e Camera, mantendo o design preto + acento vermelho do app antigo. Home é a tela inicial.


Estrutura


App.tsx
src/
  screens/
    HomeScreen.tsx
    CameraScreen.tsx



Dependências (se ainda não tiver)


npx expo install @react-navigation/native @react-navigation/bottom-tabs react-native-screens react-native-safe-area-context
npx expo install @expo/vector-icons
npx expo install react-native-webview




App.tsx (tabs só com Home e Câmera)


// App.tsx
import React from "react";
import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";

export type TabParamList = { Home: undefined; Camera: undefined };
const Tab = createBottomTabNavigator<TabParamList>();

// Design do app antigo (preto + vermelho)
const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  white: "#FFFFFF",
};

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

export default function App() {
  return
  (
    <NavigationContainer theme={DarkThemeHB}>
      <Tab.Navigator
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          tabBarIcon: ({ color, size }) => {
            const iconMap = {
              Home: "home",
              Camera: "videocam",
            } as const;
            return <Ionicons name={iconMap[route.name as keyof typeof iconMap]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} options={{ title: "Início", tabBarLabel: "Início" }} />
        <Tab.Screen name="Camera" component={CameraScreen} options={{ title: "Câmera", tabBarLabel: "Câmera" }} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}




src/screens/HomeScreen.tsx (visual antigo, simples)


// src/screens/HomeScreen.tsx
import React from "react";
import { View, Text, StyleSheet, Pressable } from "react-native";

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  white: "#FFFFFF",
  sub: "#9c9c9c",
};

export default function HomeScreen({ navigation }: any) {
  return (
    <View style={styles.container}>
      <View style={styles.card}>
        <Text style={styles.title}>HydroBot</Text>
        <Text style={styles.sub}>Início do app</Text>

        <Pressable style={styles.btn} onPress={() => navigation.navigate("Camera")}>
          <Text style={styles.btnTxt}>Ir para Câmera</Text>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, justifyContent: "center" },
  card: {
    backgroundColor: PALETTE.card,
    borderWidth: 1,
    borderColor: PALETTE.border,
    borderRadius: 14,
    padding: 16,
    gap: 8,
  },
  title: { color: PALETTE.white, fontSize: 22, fontWeight: "700" },
  sub: { color: PALETTE.sub, marginBottom: 8 },
  btn: {
    alignSelf: "flex-start",
    backgroundColor: PALETTE.red,
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 12,
  },
  btnTxt: { color: "#fff", fontWeight: "700" },
});




src/screens/CameraScreen.tsx (igual a que funcionou, endpoints padrão)


// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet, Image,
  AppState, AppStateStatus, Platform, NativeSyntheticEvent, ImageErrorEventData
} from "react-native";
import { WebView } from "react-native-webview";
import type { WebViewErrorEvent, WebViewHttpErrorEvent } from "react-native-webview/lib/WebViewTypes";

type Mode = "mjpeg" | "snapshot";

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  white: "#FFFFFF",
  sub: "#9c9c9c",
};

export default function CameraScreen() {
  const [ip, setIp] = useState<string>("192.168.3.3"); // ajuste o IP
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [statusText, setStatusText] = useState<string>("—");
  const [err, setErr] = useState<string>("");

  const [snapUri, setSnapUri] = useState<string>("");
  const timerRef = useRef<number | null>(null);
  const appState = useRef(AppState.currentState);

  const base80 = useMemo(() => `http://${ip}`, [ip]);
  const base81 = useMemo(() => `http://${ip}:81`, [ip]);
  const statusUrl = useMemo(() => `${base80}/status`, [base80]);
  const snapshotUrl = useMemo(() => `${base80}/capture`, [base80]);
  const streamUrl = useMemo(() => `${base81}/stream`, [base81]);

  const clearTimer = useCallback(() => {
    if (timerRef.current !== null) { clearInterval(timerRef.current); timerRef.current = null; }
  }, []);

  const startSnapshot = useCallback(() => {
    clearTimer();
    timerRef.current = setInterval(() => setSnapUri(`${snapshotUrl}?ts=${Date.now()}`), 125) as unknown as number;
  }, [snapshotUrl, clearTimer]);

  useEffect(() => {
    const sub = AppState.addEventListener("change", (next: AppStateStatus) => {
      if (appState.current.match(/inactive|background/) && next === "active" && mode === "snapshot") startSnapshot();
      if (next.match(/inactive|background/)) clearTimer();
      appState.current = next;
    });
    return () => { sub.remove(); clearTimer(); };
  }, [mode, startSnapshot, clearTimer]);

  useEffect(() => {
    setErr("");
    if (mode === "snapshot") startSnapshot(); else clearTimer();
    return () => clearTimer();
  }, [mode, startSnapshot, clearTimer]);

  const checkStatus = useCallback(async () => {
    try {
      const r = await fetch(statusUrl);
      const txt = await r.text();
      setStatusText(`OK (${txt.slice(0, 60)}${txt.length > 60 ? "..." : ""})`);
    } catch (e) {
      const er = e as Error;
      setStatusText("Falhou");
      setErr(er?.message ?? String(e));
    }
  }, [statusUrl]);

  useEffect(() => { if (ip) checkStatus(); }, [ip, checkStatus]);

  const onWvError = useCallback((e: WebViewErrorEvent) => setErr(`WebView: ${e.nativeEvent.description}`), []);
  const onWvHttpError = useCallback((e: WebViewHttpErrorEvent) => setErr(`HTTP ${e.nativeEvent.statusCode}`), []);
  const onImgError = useCallback((e: NativeSyntheticEvent<ImageErrorEventData>) => setErr(`Snapshot: ${e.nativeEvent.error}`), []);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Câmera</Text>

      <View style={styles.row}>
        <View style={{ flex: 1 }}>
          <Text style={styles.label}>ESP IP</Text>
          <TextInput
            style={styles.input}
            value={ip}
            onChangeText={setIp}
            placeholder="ex.: 192.168.3.3"
            placeholderTextColor={PALETTE.sub}
            autoCapitalize="none"
            autoCorrect={false}
            keyboardType={Platform.OS === "android" ? "numeric" : "numbers-and-punctuation"}
          />
        </View>
        <Pressable style={styles.btn} onPress={checkStatus}>
          <Text style={styles.btnTxt}>Testar</Text>
        </Pressable>
      </View>

      <View style={[styles.row, { marginTop: 8 }]}>
        <Pressable style={[styles.chip, mode === "mjpeg" && styles.chipActive]} onPress={() => setMode("mjpeg")}>
          <Text style={[styles.chipTxt, mode === "mjpeg" && styles.chipTxtActive]}>MJPEG (:81/stream)</Text>
        </Pressable>
        <Pressable style={[styles.chip, mode === "snapshot" && styles.chipActive]} onPress={() => setMode("snapshot")}>
          <Text style={[styles.chipTxt, mode === "snapshot" && styles.chipTxtActive]}>Snapshot (/capture)</Text>
        </Pressable>
      </View>

      <View style={styles.card}>
        {mode === "mjpeg" ? (
          <WebView
            source={{ uri: streamUrl }}
            style={{ width: "100%", height: "100%" }}
            allowsInlineMediaPlayback
            mediaPlaybackRequiresUserAction={false}
            allowUniversalAccessFromFileURLs
            onError={onWvError}
            onHttpError={onWvHttpError}
          />
        ) : (
          <Image
            source={{ uri: snapUri || `${snapshotUrl}?ts=${Date.now()}` }}
            style={{ width: "100%", height: "100%" }}
            resizeMode="contain"
            onError={onImgError}
          />
        )}
      </View>

      <Text style={styles.meta}>Status: <Text style={{ color: "#a7f3d0" }}>{statusText}</Text></Text>
      {!!err && <Text style={[styles.meta, { color: "#ff8b8b" }]}>Erro: {err}</Text>}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, gap: 10 },
  title: { color: PALETTE.white, fontSize: 20, fontWeight: "700" },
  row: { flexDirection: "row", alignItems: "flex-end", gap: 8 },
  label: { color: PALETTE.white, marginBottom: 6, fontWeight: "600" },
  input: {
    backgroundColor: PALETTE.card, borderWidth: 1, borderColor: PALETTE.border,
    borderRadius: 12, paddingHorizontal: 12, paddingVertical: 10, color: PALETTE.white,
  },
  btn: { backgroundColor: PALETTE.red, paddingHorizontal: 16, paddingVertical: 10, borderRadius: 12 },
  btnTxt: { color: "#fff", fontWeight: "700" },
  chip: { borderWidth: 1, borderColor: PALETTE.border, borderRadius: 999, paddingHorizontal: 12, paddingVertical: 6 },
  chipActive: { backgroundColor: PALETTE.red, borderColor: PALETTE.red },
  chipTxt: { color: PALETTE.white },
  chipTxtActive: { color: "#fff", fontWeight: "700" },
  card: {
    flex: 1, marginTop: 8, backgroundColor: PALETTE.card,
    borderWidth: 1, borderColor: PALETTE.border, borderRadius: 12, overflow: "hidden",
  },
  meta: { color: "#bbb", fontSize: 12, marginTop: 6 },
});



Pronto: só duas telas, Home é a inicial, visual do app antigo preservado. Se quiser que eu ajuste paddings/raios/cores 1:1, manda um print do antigo que eu calibro.




























































Isso é “arquivo não encontrado” — o App.tsx está importando coisas que ainda não existem. Vamos criar os arquivos mínimos (stubs) para tudo compilar agora.


1) Estrutura de pastas


Crie estas pastas/arquivos:


src/
  screens/
    HomeScreen.tsx
    CameraScreen.tsx        // (já tem o seu; se não, use o stub abaixo)
    DashboardScreen.tsx
    SettingsScreen.tsx
  context/
    LanguageContext.tsx
  theme/
    tokens.ts



2) src/theme/tokens.ts


export const tokens = {
  color: {
    bg: "#0b0b0f",
    card: "#121218",
    border: "#25273a",
    text: "#e5e7eb",
    sub: "#9ca3af",
    accent: "#e6403a",
    success: "#10b981",
    danger: "#ef4444",
  },
  radius: { xs: 8, sm: 10, md: 12, lg: 16, xl: 20, pill: 999 },
  space: { xs: 6, sm: 8, md: 12, lg: 16, xl: 24, xxl: 32 },
  font: { regular: "System", medium: "System", bold: "System" },
  shadow: {
    card: { elevation: 3, shadowOpacity: 0.15, shadowRadius: 6, shadowOffset: { width: 0, height: 3 } },
  },
};
export type Tokens = typeof tokens;



3) src/context/LanguageContext.tsx


import React, { createContext, useContext, useMemo, useState } from "react";

type Lang = "pt" | "en" | "es";
type Ctx = { lang: Lang; setLang: (l: Lang) => void };
const LanguageCtx = createContext<Ctx | undefined>(undefined);

export function LanguageProvider({ children }: { children: React.ReactNode }) {
  const [lang, setLang] = useState<Lang>("pt");
  const value = useMemo(() => ({ lang, setLang }), [lang]);
  return <LanguageCtx.Provider value={value}>{children}</LanguageCtx.Provider>;
}

export function useLanguage() {
  const ctx = useContext(LanguageCtx);
  if (!ctx) throw new Error("useLanguage must be used inside LanguageProvider");
  return ctx;
}



4) Stubs das telas


src/screens/HomeScreen.tsx


import React from "react";
import { View, Text, StyleSheet } from "react-native";
import { tokens as t } from "../theme/tokens";

export default function HomeScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Home</Text>
      <Text style={styles.sub}>Tela inicial (placeholder)</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: t.color.bg, padding: 16 },
  title: { color: t.color.text, fontSize: 22, fontWeight: "700", marginBottom: 6 },
  sub: { color: t.color.sub },
});



src/screens/CameraScreen.tsx (se você já tem, mantenha o seu)


import React from "react";
import { View, Text, StyleSheet } from "react-native";
import { tokens as t } from "../theme/tokens";

export default function CameraScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Camera</Text>
      <Text style={styles.sub}>Substitua por sua tela da câmera que já funciona</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: t.color.bg, padding: 16 },
  title: { color: t.color.text, fontSize: 22, fontWeight: "700", marginBottom: 6 },
  sub: { color: t.color.sub },
});



src/screens/DashboardScreen.tsx


import React from "react";
import { View, Text, StyleSheet } from "react-native";
import { tokens as t } from "../theme/tokens";

export default function DashboardScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Dashboard</Text>
      <Text style={styles.sub}>Placeholder</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: t.color.bg, padding: 16 },
  title: { color: t.color.text, fontSize: 22, fontWeight: "700", marginBottom: 6 },
  sub: { color: t.color.sub },
});



src/screens/SettingsScreen.tsx


import React from "react";
import { View, Text, StyleSheet, Pressable } from "react-native";
import { tokens as t } from "../theme/tokens";
import { useLanguage } from "../context/LanguageContext";

export default function SettingsScreen() {
  const { lang, setLang } = useLanguage();
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Ajustes</Text>
      <Text style={styles.sub}>Idioma atual: {lang.toUpperCase()}</Text>

      <View style={{ flexDirection: "row", gap: 8, marginTop: 12 }}>
        {(["pt", "en", "es"] as const).map(code => (
          <Pressable
            key={code}
            onPress={() => setLang(code)}
            style={{
              paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10,
              borderWidth: 1, borderColor: t.color.border,
              backgroundColor: lang === code ? t.color.accent : "transparent",
            }}
          >
            <Text style={{ color: lang === code ? "#fff" : t.color.text, fontWeight: "700" }}>
              {code.toUpperCase()}
            </Text>
          </Pressable>
        ))}
      </View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: t.color.bg, padding: 16 },
  title: { color: t.color.text, fontSize: 22, fontWeight: "700", marginBottom: 6 },
  sub: { color: t.color.sub },
});



5) Garanta as dependências de navegação instaladas


npx expo install @react-navigation/native @react-navigation/bottom-tabs react-native-screens react-native-safe-area-context
npx expo install @expo/vector-icons



6) (Opcional) tsconfig.json saudável


Se não existir, crie na raiz:


{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["ES2017", "DOM"],
    "module": "ESNext",
    "jsx": "react-jsx",
    "strict": true,
    "noEmit": true,
    "moduleResolution": "bundler",
    "allowJs": false,
    "isolatedModules": true,
    "types": ["react", "react-native", "expo/metro-runtime"],
    "skipLibCheck": true
  },
  "include": ["**/*.ts", "**/*.tsx"]
}



7) Reinicie o bundler


npx expo start -c



Se o erro persistir, verifique:




o nome dos arquivos (ex.: HomeScreen.tsx, não .js),


os caminhos de import ("./src/screens/HomeScreen" etc.),


se você abriu no VS Code a pasta do projeto (onde está package.json).




























Aqui vai um App.tsx já alinhado com o visual (usando os tokens de tema) e mantendo sua navegação com bottom tabs, ícones do Ionicons e suporte a idiomas via LanguageProvider.




Se ainda não tem as deps de navegação:


npx expo install @react-navigation/native @react-navigation/bottom-tabs react-native-screens react-native-safe-area-context
npx expo install @expo/vector-icons





// App.tsx
import React from "react";
import { LogBox } from "react-native";
import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";
import DashboardScreen from "./src/screens/DashboardScreen";
import SettingsScreen from "./src/screens/SettingsScreen";

import { LanguageProvider, useLanguage } from "./src/context/LanguageContext";
import { tokens as t } from "./src/theme/tokens";

LogBox.ignoreLogs(["useInsertionEffect must not schedule updates"]);

export type TabParamList = {
  Home: undefined;
  Camera: undefined;
  Dashboard: undefined;
  Settings: undefined;
};

const Tab = createBottomTabNavigator<TabParamList>();

// Tema escuro baseado nos tokens
const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: t.color.bg,
    primary: t.color.accent,
    card: t.color.card,
    text: t.color.text,
    border: t.color.border,
    notification: t.color.accent,
  },
};

// Labels por idioma (simples)
const labels = {
  pt: { home: "Início", camera: "Câmera", dashboard: "Dashboard", settings: "Ajustes" },
  en: { home: "Home", camera: "Camera", dashboard: "Dashboard", settings: "Settings" },
  es: { home: "Inicio", camera: "Cámara", dashboard: "Panel", settings: "Ajustes" },
} as const;

function AppNavigator() {
  const { lang } = useLanguage();
  const L = labels[lang as keyof typeof labels] ?? labels.en;

  return (
    <NavigationContainer theme={DarkThemeHB}>
      {/* key={lang} força os rótulos a atualizarem quando o idioma muda */}
      <Tab.Navigator
        key={lang}
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: t.color.card },
          headerTintColor: t.color.text,
          tabBarStyle: { backgroundColor: t.color.bg, borderTopColor: t.color.border },
          tabBarActiveTintColor: t.color.accent,
          tabBarInactiveTintColor: t.color.sub,
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} options={() => ({ title: L.home, tabBarLabel: L.home })} />
        <Tab.Screen name="Camera" component={CameraScreen} options={() => ({ title: L.camera, tabBarLabel: L.camera })} />
        <Tab.Screen name="Dashboard" component={DashboardScreen} options={() => ({ title: L.dashboard, tabBarLabel: L.dashboard })} />
        <Tab.Screen name="Settings" component={SettingsScreen} options={() => ({ title: L.settings, tabBarLabel: L.settings })} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}

export default function App() {
  return (
    <LanguageProvider>
      <AppNavigator />
    </LanguageProvider>
  );
}



Se quiser que eu deixe os ícones, paddings e bordas idênticos ao app antigo, me manda os estilos/prints e eu ajusto os tokens (cores, radius, sombras, tipografia) para espelhar 1:1.













































import React from "react";
import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";
import { LogBox } from "react-native";
LogBox.ignoreLogs(["useInsertionEffect must not schedule updates"]);

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";
import DashboardScreen from "./src/screens/DashboardScreen";
import SettingsScreen from "./src/screens/SettingsScreen";

import { LanguageProvider, useLanguage } from "./src/context/LanguageContext";

export type TabParamList = {
  Home: undefined;
  Camera: undefined;
  Dashboard: undefined;
  Settings: undefined;
};

const Tab = createBottomTabNavigator<TabParamList>();

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
};

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

// Traduções simples
const labels = {
  pt: { home: "Início", camera: "Câmera", dashboard: "Dashboard", settings: "Ajustes" },
  en: { home: "Home", camera: "Camera", dashboard: "Dashboard", settings: "Settings" },
  es: { home: "Inicio", camera: "Cámara", dashboard: "Panel", settings: "Ajustes" },
};

function AppNavigator() {
  const { lang } = useLanguage();
  const L = labels[lang];

  return (
    <NavigationContainer theme={DarkThemeHB}>
      {/* key={lang} força o TabNavigator a reconfigurar rótulos/títulos ao mudar o idioma */}
      <Tab.Navigator
        key={lang}
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
              
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen
          name="Home"
          component={HomeScreen}
          // options como FUNÇÃO, para recomputar com L atualizado
          options={() => ({ title: L.home, tabBarLabel: L.home })}
        />
        <Tab.Screen
          name="Camera"
          component={CameraScreen}
          options={() => ({ title: L.camera, tabBarLabel: L.camera })}
        />
        <Tab.Screen
          name="Dashboard"
          component={DashboardScreen}
          options={() => ({ title: L.dashboard, tabBarLabel: L.dashboard })}
        />
        <Tab.Screen
          name="Settings"
          component={SettingsScreen}
          options={() => ({ title: L.settings, tabBarLabel: L.settings })}
        />
      </Tab.Navigator>
    </NavigationContainer>
  );
}

export default function App() {
  return (
    <LanguageProvider>
      <AppNavigator />
    </LanguageProvider>
  );
}





























massa! bora espelhar o visual do app antigo sem mexer na lógica nova.

pra agilizar, já deixei um esqueleto de tema + componentes onde a gente só “pluga” as cores/fontes/raios/sombras do seu app antigo. quando você mandar os códigos/imagens do antigo, eu só preencho os tokens — sem reescrever as telas.


o que me enviar do app antigo




colors.ts (ou onde ficavam as cores) e qualquer ThemeProvider/fonts.


1 tela que você quer copiar (JS/TSX) + styles dela.


se tiver, variáveis de spacing, radius, shadow, font family.


screenshots ajudam pra acertar microdetalhes.





1) tokens de tema (adicione em src/theme/tokens.ts)


// src/theme/tokens.ts
export const tokens = {
  color: {
    bg: "#0b0b0f",
    card: "#121218",
    border: "#25273a",
    text: "#e5e7eb",
    sub: "#9ca3af",
    accent: "#e6403a",
    success: "#10b981",
    danger: "#ef4444",
  },
  radius: {
    xs: 8,
    sm: 10,
    md: 12,
    lg: 16,
    xl: 20,
    pill: 999,
  },
  space: {
    xs: 6,
    sm: 8,
    md: 12,
    lg: 16,
    xl: 24,
    xxl: 32,
  },
  font: {
    // trocamos assim que você mandar as famílias/weights do app antigo
    regular: "System",
    medium: "System",
    bold: "System",
  },
  shadow: {
    card: { elevation: 3, shadowOpacity: 0.15, shadowRadius: 6, shadowOffset: { width: 0, height: 3 } },
  },
};
export type Tokens = typeof tokens;



2) UI base (botão, campo, cartão, header) — src/ui/index.tsx


// src/ui/index.tsx
import React, { PropsWithChildren } from "react";
import { View, Text, Pressable, TextInput, StyleSheet, ViewStyle, TextStyle, TextInputProps } from "react-native";
import { tokens as t } from "../theme/tokens";

export function Screen({ children }: PropsWithChildren) {
  return <View style={{ flex: 1, backgroundColor: t.color.bg, padding: t.space.lg }}>{children}</View>;
}

export function Header({ title, subtitle }: { title: string; subtitle?: string }) {
  return (
    <View style={{ marginBottom: t.space.lg }}>
      <Text style={{ color: t.color.text, fontSize: 22, fontWeight: "700" }}>{title}</Text>
      {!!subtitle && <Text style={{ color: t.color.sub, marginTop: 4 }}>{subtitle}</Text>}
    </View>
  );
}

export function Card({ children, style }: PropsWithChildren<{ style?: ViewStyle }>) {
  return (
    <View style={[styles.card, style]}>
      {children}
    </View>
  );
}

export function Button({
  label, onPress, variant = "primary", style, textStyle,
}: { label: string; onPress: () => void; variant?: "primary" | "ghost"; style?: ViewStyle; textStyle?: TextStyle }) {
  const bg = variant === "primary" ? t.color.accent : "transparent";
  const color = variant === "primary" ? "#fff" : t.color.text;
  return (
    <Pressable onPress={onPress} style={[styles.btn, { backgroundColor: bg, borderColor: t.color.border }, style]}>
      <Text style={[{ color, fontWeight: "700" }, textStyle]}>{label}</Text>
    </Pressable>
  );
}

export function Field({
  label, value, onChangeText, placeholder, keyboardType,
}: { label: string } & TextInputProps) {
  return (
    <View style={{ flex: 1 }}>
      <Text style={{ color: t.color.text, marginBottom: 6, fontWeight: "600" }}>{label}</Text>
      <TextInput
        style={styles.input}
        value={value}
        onChangeText={onChangeText}
        placeholder={placeholder}
        placeholderTextColor={t.color.sub}
        keyboardType={keyboardType}
        autoCapitalize="none"
        autoCorrect={false}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: t.color.card,
    borderWidth: 1,
    borderColor: t.color.border,
    borderRadius: t.radius.lg,
    overflow: "hidden",
    ...t.shadow.card,
  },
  btn: {
    paddingHorizontal: t.space.lg,
    paddingVertical: t.space.sm + 2,
    borderRadius: t.radius.md,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  input: {
    backgroundColor: t.color.card,
    borderWidth: 1,
    borderColor: t.color.border,
    borderRadius: t.radius.md,
    paddingHorizontal: t.space.md,
    paddingVertical: t.space.sm,
    color: t.color.text,
  },
});



3) CameraScreen reestilizada usando os componentes


Substitua sua tela atual por esta versão (funcionalidade idêntica; visual padronizado pelos tokens):


// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { View, Text, Image, AppState, AppStateStatus, Platform, NativeSyntheticEvent, ImageErrorEventData, StyleSheet } from "react-native";
import { WebView } from "react-native-webview";
import type { WebViewErrorEvent, WebViewHttpErrorEvent } from "react-native-webview/lib/WebViewTypes";
import { Screen, Header, Card, Button, Field } from "../ui";
import { tokens as t } from "../theme/tokens";

type Mode = "mjpeg" | "snapshot";

export default function CameraScreen() {
  const [ip, setIp] = useState("192.168.3.3");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [connected, setConnected] = useState("—");
  const [lastErr, setLastErr] = useState("");

  const [snapUri, setSnapUri] = useState("");
  const timerRef = useRef<number | null>(null);
  const appState = useRef(AppState.currentState);

  const base80 = useMemo(() => `http://${ip}`, [ip]);
  const base81 = useMemo(() => `http://${ip}:81`, [ip]);
  const statusUrl = useMemo(() => `${base80}/status`, [base80]);
  const snapshotUrl = useMemo(() => `${base80}/capture`, [base80]);
  const streamUrl = useMemo(() => `${base81}/stream`, [base81]);

  const clearTimer = useCallback(() => {
    if (timerRef.current !== null) { clearInterval(timerRef.current); timerRef.current = null; }
  }, []);
  const startSnapshotLoop = useCallback(() => {
    clearTimer();
    timerRef.current = setInterval(() => setSnapUri(`${snapshotUrl}?ts=${Date.now()}`), 125) as unknown as number;
  }, [snapshotUrl, clearTimer]);

  useEffect(() => {
    const sub = AppState.addEventListener("change", (next: AppStateStatus) => {
      if (appState.current.match(/inactive|background/) && next === "active" && mode === "snapshot") startSnapshotLoop();
      if (next.match(/inactive|background/)) clearTimer();
      appState.current = next;
    });
    return () => { sub.remove(); clearTimer(); };
  }, [mode, startSnapshotLoop, clearTimer]);

  useEffect(() => {
    setLastErr("");
    if (mode === "snapshot") startSnapshotLoop(); else clearTimer();
    return () => clearTimer();
  }, [mode, startSnapshotLoop, clearTimer]);

  const checkStatus = useCallback(async () => {
    try {
      const res = await fetch(statusUrl);
      const txt = await res.text();
      setConnected(`OK (${txt.slice(0, 60)}${txt.length > 60 ? "..." : ""})`);
    } catch (e) {
      const err = e as Error;
      setConnected("Falhou");
      setLastErr(err?.message ?? String(e));
    }
  }, [statusUrl]);

  useEffect(() => { if (ip) checkStatus(); }, [ip, checkStatus]);

  const onWvError = useCallback((e: WebViewErrorEvent) => setLastErr(`WebView: ${e.nativeEvent.description}`), []);
  const onWvHttpError = useCallback((e: WebViewHttpErrorEvent) => setLastErr(`HTTP ${e.nativeEvent.statusCode}`), []);
  const onImgError = useCallback((e: NativeSyntheticEvent<ImageErrorEventData>) => setLastErr(`Snapshot: ${e.nativeEvent.error}`), []);

  return (
    <Screen>
      <Header title="Câmera" subtitle="Visual ao estilo do app antigo (tokens prontos para ajuste)" />

      <View style={{ flexDirection: "row", gap: t.space.sm, alignItems: "flex-end" }}>
        <Field label="ESP IP" value={ip} onChangeText={setIp}
               placeholder="ex.: 192.168.3.3"
               keyboardType={Platform.OS === "android" ? "numeric" : "numbers-and-punctuation"} />
        <Button label="Testar" onPress={checkStatus} />
      </View>

      <View style={{ flexDirection: "row", gap: t.space.sm, marginTop: t.space.sm }}>
        <Button label="MJPEG" onPress={() => setMode("mjpeg")} variant={mode === "mjpeg" ? "primary" : "ghost"} />
        <Button label="Snapshot" onPress={() => setMode("snapshot")} variant={mode === "snapshot" ? "primary" : "ghost"} />
      </View>

      <Card style={{ flex: 1, marginTop: t.space.md }}>
        {mode === "mjpeg" ? (
          <WebView
            source={{ uri: streamUrl }}
            style={{ width: "100%", height: "100%" }}
            allowsInlineMediaPlayback
            mediaPlaybackRequiresUserAction={false}
            allowUniversalAccessFromFileURLs
            onError={onWvError}
            onHttpError={onWvHttpError}
          />
        ) : (
          <Image
            source={{ uri: snapUri || `${snapshotUrl}?ts=${Date.now()}` }}
            style={{ width: "100%", height: "100%" }}
            resizeMode="contain"
            onError={onImgError}
          />
        )}
      </Card>

      <View style={{ marginTop: t.space.sm }}>
        <Text style={styles.meta}>Status: <Text style={{ color: t.color.success }}>{connected}</Text></Text>
        <Text style={styles.meta}>Stream: <Text style={{ color: t.color.sub }}>{streamUrl}</Text></Text>
        <Text style={styles.meta}>Snapshot: <Text style={{ color: t.color.sub }}>{snapshotUrl}</Text></Text>
        {!!lastErr && <Text style={[styles.meta, { color: t.color.danger }]}>Erro: {lastErr}</Text>}
      </View>
    </Screen>
  );
}

const styles = StyleSheet.create({
  meta: { color: t.color.text, fontSize: 12 },
});




como vamos “copiar” o design antigo




assim que você me mandar os arquivos do tema antigo, eu só edito tokens.ts (cores, radius, shadows, tipografia) e, se precisar, ajusto o Button, Card e Field pra bater 100% com o seu visual (bordas, ícones, padding, etc.).


a CameraScreen já está usando esses componentes — então o app inteiro “troca de roupa” com pouca mudança.




manda a primeira tela/estilos do app antigo e eu já deixo os tokens idênticos 👌








































App.tsx

import React from "react";
import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";
import { LogBox } from "react-native";
LogBox.ignoreLogs(["useInsertionEffect must not schedule updates"]);

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";
import DashboardScreen from "./src/screens/DashboardScreen";
import SettingsScreen from "./src/screens/SettingsScreen";

import { LanguageProvider, useLanguage } from "./src/context/LanguageContext";

export type TabParamList = {
  Home: undefined;
  Camera: undefined;
  Dashboard: undefined;
  Settings: undefined;
};

const Tab = createBottomTabNavigator<TabParamList>();

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
};

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

// Traduções simples
const labels = {
  pt: { home: "Início", camera: "Câmera", dashboard: "Dashboard", settings: "Ajustes" },
  en: { home: "Home", camera: "Camera", dashboard: "Dashboard", settings: "Settings" },
  es: { home: "Inicio", camera: "Cámara", dashboard: "Panel", settings: "Ajustes" },
};

function AppNavigator() {
  const { lang } = useLanguage();
  const L = labels[lang];

  return (
    <NavigationContainer theme={DarkThemeHB}>
      {/* key={lang} força o TabNavigator a reconfigurar rótulos/títulos ao mudar o idioma */}
      <Tab.Navigator
        key={lang}
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
              
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen
          name="Home"
          component={HomeScreen}
          // options como FUNÇÃO, para recomputar com L atualizado
          options={() => ({ title: L.home, tabBarLabel: L.home })}
        />
        <Tab.Screen
          name="Camera"
          component={CameraScreen}
          options={() => ({ title: L.camera, tabBarLabel: L.camera })}
        />
        <Tab.Screen
          name="Dashboard"
          component={DashboardScreen}
          options={() => ({ title: L.dashboard, tabBarLabel: L.dashboard })}
        />
        <Tab.Screen
          name="Settings"
          component={SettingsScreen}
          options={() => ({ title: L.settings, tabBarLabel: L.settings })}
        />
      </Tab.Navigator>
    </NavigationContainer>
  );
}

export default function App() {
  return (
    <LanguageProvider>
      <AppNavigator />
    </LanguageProvider>
  );
}











// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { View, Text, TextInput, Pressable, StyleSheet, Image, AppState, AppStateStatus } from "react-native";
import { WebView } from "react-native-webview";

type Mode = "mjpeg" | "snapshot";

const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", accent: "#e6403a", text: "#e5e7eb" };

// Utilitário de timeout para fetch
async function fetchWithTimeout(url: string, ms = 2000) {
  const ctrl = new AbortController();
  const to = setTimeout(() => ctrl.abort(), ms);
  try {
    const r = await fetch(url, { method: "GET", signal: ctrl.signal });
    return r;
  } finally {
    clearTimeout(to);
  }
}

export default function CameraScreen() {
  const [ip, setIp] = useState("192.168.4.1"); // coloque o IP do seu ESP
  const [status, setStatus] = useState("Aguardando IP");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [streamURL, setStreamURL] = useState<string>("");
  const [snapshotURL, setSnapshotURL] = useState<string>("");
  const [snapTick, setSnapTick] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  const snapTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const appState = useRef<AppStateStatus>(AppState.currentState);

  // Candidatos típicos do firmware “teste esp32”
  const streamCandidates = useMemo(() => {
    const base = (ip || "").trim();
    if (!base) return [];
    return [
      `http://${base}:81/stream`,   // padrão do exemplo oficial
      `http://${base}/stream`,      // alguns firmwares servem na 80
      `http://${base}:80/stream`,
      `http://${base}:81/mjpeg`,    // variações
      `http://${base}/mjpeg`,
    ];
  }, [ip]);

  const snapshotCandidates = useMemo(() => {
    const base = (ip || "").trim();
    if (!base) return [];
    return [
      `http://${base}/capture`,     // padrão do exemplo oficial
      `http://${base}/snapshot`,
      `http://${base}:81/capture`,
      `http://${base}:81/snapshot`,
      `http://${base}:80/capture`,
      `http://${base}:80/snapshot`,
    ];
  }, [ip]);

  // Loop do snapshot (fallback)
  const startSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) return;
    snapTimerRef.current = setInterval(() => setSnapTick((t) => (t + 1) % 1_000_000), 200); // ~5 fps estável
  }, []);
  const stopSnapshotLoop = useCallback(() => {
    if (!snapTimerRef.current) return;
    clearInterval(snapTimerRef.current);
    snapTimerRef.current = null;
  }, []);
  useEffect(() => {
    if (mode === "snapshot" && snapshotURL) startSnapshotLoop();
    else stopSnapshotLoop();
    return stopSnapshotLoop;
  }, [mode, snapshotURL, startSnapshotLoop, stopSnapshotLoop]);

  // Pausar ao ir para background
  useEffect(() => {
    const sub = AppState.addEventListener("change", (next) => {
      const prev = appState.current;
      appState.current = next;
      if (prev.match(/active/) && next.match(/inactive|background/)) {
        stopSnapshotLoop();
        setIsRunning(false);
      } else if (prev.match(/inactive|background/) && next === "active") {
        if (mode === "snapshot" && snapshotURL) startSnapshotLoop();
        if (streamURL || snapshotURL) setIsRunning(true);
      }
    });
    return () => sub.remove();
  }, [mode, snapshotURL, streamURL, startSnapshotLoop, stopSnapshotLoop]);

  // Teste/auto-detecção
  const testConnection = useCallback(async () => {
    const target = (ip || "").trim();
    if (!target) {
      setStatus("Informe o IP do ESP");
      return;
    }
    setStatus("Testando...");
    setIsRunning(false);
    stopSnapshotLoop();
    setStreamURL("");
    setSnapshotURL("");

    // 1) Tentar candidatos de MJPEG
    for (const u of streamCandidates) {
      try {
        const r = await fetchWithTimeout(u, 2000);
        if (r.ok) {
          setStreamURL(u);
          setMode("mjpeg");
          setStatus(`Conectado (MJPEG): ${u}`);
          setIsRunning(true);
          return;
        }
      } catch {}
    }

    // 2) Fallback: tentar snapshot
    for (const u of snapshotCandidates) {
      try {
        const r = await fetchWithTimeout(u, 2000);
        if (r.ok) {
          setSnapshotURL(u);
          setMode("snapshot");
          setStatus(`Conectado (Snapshot): ${u}`);
          setIsRunning(true);
          startSnapshotLoop();
          return;
        }
      } catch {}
    }

    setStatus("Falha ao conectar — verifique IP, porta 81/80 e rotas (/stream ou /capture).");
    setIsRunning(false);
  }, [ip, streamCandidates, snapshotCandidates, startSnapshotLoop, stopSnapshotLoop]);

  // HTML que carrega o MJPEG com auto-reconnect
  const mjpegHTML = useMemo(() => {
    if (!streamURL) return "";
    return `
      <!doctype html>
      <html><head><meta name="viewport" content="width=device-width, initial-scale=1"/>
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;overflow:hidden;}
        #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;}
        img{max-width:100vw;max-height:100vh;object-fit:contain;}
        #badge{position:fixed;left:8px;bottom:8px;padding:4px 8px;border-radius:8px;
               background:#121218;color:#e5e7eb;font-family:system-ui,Arial,sans-serif;font-size:12px;opacity:.7}
      </style></head>
      <body>
        <div id="wrap"><img id="mjpeg" src="${streamURL}"/></div>
        <div id="badge">${streamURL}</div>
        <script>
          const img = document.getElementById('mjpeg');
          let backoff=800;
          img.addEventListener('error',()=>{
            setTimeout(()=>{ img.src='${streamURL}?_='+Date.now(); }, backoff);
            backoff = Math.min(backoff*2, 4000);
          });
        </script>
      </body></html>
    `.trim();
  }, [streamURL]);

  const snapshotURI = useMemo(
    () => (snapshotURL ? `${snapshotURL}?_=${snapTick}` : ""),
    [snapshotURL, snapTick]
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>ESP32-CAM Viewer</Text>

      <View style={styles.row}>
        <Text style={styles.label}>ESP IP</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="ex.: 192.168.3.3"
          placeholderTextColor="#6b7280"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
        />
        <Pressable style={styles.button} onPress={testConnection}>
          <Text style={styles.buttonText}>Testar</Text>
        </Pressable>
      </View>

      <Text style={styles.status}>Status: {status} {isRunning ? " | OK" : ""}</Text>

      <View style={styles.viewer}>
        {isRunning ? (
          mode === "mjpeg" && streamURL ? (
            <WebView
              originWhitelist={["*"]}
              source={{ html: mjpegHTML, baseUrl: streamURL }}
              javaScriptEnabled
              domStorageEnabled
              allowsInlineMediaPlayback
              mediaPlaybackRequiresUserAction={false}
              allowsFullscreenVideo={false}
              mixedContentMode="always"                         // Android: libera HTTP claro
              androidHardwareAccelerationEnabled
              setSupportMultipleWindows={false}
              onError={() => {
                // se falhar, tenta cair automaticamente para snapshot candidates
                setStatus("MJPEG falhou — alternando para Snapshot...");
                setMode("snapshot");
                // escolhe o melhor snapshot disponível já conhecido ou o primeiro candidato
                setSnapshotURL((prev) => prev || snapshotCandidates[0] || "");
                startSnapshotLoop();
              }}
              style={styles.webview}
            />
          ) : (
            <Image
              source={{ uri: snapshotURI }}
              resizeMode="contain"
              style={styles.image}
              onError={() => setStatus("Erro no snapshot — verifique /capture ou /snapshot")}
            />
          )
        ) : (
          <View style={styles.placeholder}>
            <Text style={{ color: PALETTE.text, opacity: 0.7, textAlign: "center" }}>
              Informe o IP e toque em “Testar”. A tela tenta automaticamente
              <Text> :81/stream → /stream → /capture.</Text>
            </Text>
          </View>
        )}
      </View>

      {isRunning ? (
        <View style={styles.footerRow}>
          <Pressable
            style={[styles.smallBtn, mode === "mjpeg" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("mjpeg"); setStatus("Tentando MJPEG /stream..."); }}
          >
            <Text style={styles.smallBtnText}>Usar MJPEG</Text>
          </Pressable>
          <Pressable
            style={[styles.smallBtn, mode === "snapshot" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("snapshot"); setStatus("Usando Snapshot (/capture)"); }}
          >
            <Text style={styles.smallBtnText}>Usar Snapshot</Text>
          </Pressable>
        </View>
      ) : null}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, gap: 12 },
  title: { color: PALETTE.text, fontSize: 20, fontWeight: "700" },
  row: { flexDirection: "row", alignItems: "center", gap: 8 },
  label: { color: PALETTE.text },
  input: {
    flex: 1, backgroundColor: PALETTE.card, color: PALETTE.text,
    borderWidth: 1, borderColor: PALETTE.border, borderRadius: 10,
    paddingHorizontal: 10, paddingVertical: 8,
  },
  button: { backgroundColor: PALETTE.accent, paddingHorizontal: 14, paddingVertical: 10, borderRadius: 10 },
  buttonText: { color: "#fff", fontWeight: "700" },
  status: { color: PALETTE.text, opacity: 0.9 },
  viewer: {
    flex: 1, backgroundColor: "#000", borderRadius: 12, overflow: "hidden",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  webview: { flex: 1, backgroundColor: "#000" },
  image: { width: "100%", height: "100%" },
  placeholder: { flex: 1, alignItems: "center", justifyContent: "center", padding: 24 },
  footerRow: { flexDirection: "row", gap: 10, justifyContent: "center" },
  smallBtn: {
    paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1,
    borderColor: PALETTE.border, backgroundColor: PALETTE.card,
  },
  smallBtnActive: { borderColor: PALETTE.accent },
  smallBtnText: { color: PALETTE.text, fontWeight: "600" },
});










HomeScreen.tsx

import { View, Text, StyleSheet, Pressable, Dimensions, Image } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { BottomTabNavigationProp } from "@react-navigation/bottom-tabs";
import type { TabParamList } from "../../App";
import { useLanguage } from "../context/LanguageContext";

type Nav = BottomTabNavigationProp<TabParamList>;
const W = Dimensions.get("window").width;
const CARD = W / 2 - 28;

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
  textSoft: "#E6E6E6",
};

const texts = {
  pt: { title: "HydroBot", sub: "Monitoramento e Controle", cam: "Câmera", dash: "Dashboard", hint: "Use o rodapé para navegar entre as seções" },
  en: { title: "HydroBot", sub: "Monitoring & Control", cam: "Camera", dash: "Dashboard", hint: "Use the footer to navigate" },
  es: { title: "HydroBot", sub: "Monitoreo y Control", cam: "Cámara", dash: "Panel", hint: "Usa el pie para navegar" },
};

export default function HomeScreen() {
  const navigation = useNavigation<Nav>();
  const { lang } = useLanguage();
  const T = texts[lang];

  const tiles = [
    { key: "Camera" as const, label: T.cam, icon: "videocam" as const, color: PALETTE.red },
    { key: "Dashboard" as const, label: T.dash, icon: "pulse" as const, color: PALETTE.redSoft },
  ];

  return (
    <View style={styles.container}>
      <View style={styles.hero}>
        <Image source={require("../../assets/logo.png")} style={styles.logo} resizeMode="contain" />
        <Text style={styles.title}>{T.title}</Text>
        <Text style={styles.sub}>{T.sub}</Text>
      </View>

      <View style={styles.grid}>
        {tiles.map((t) => (
          <Pressable
            key={t.key}
            onPress={() => navigation.navigate(t.key)}
            style={({ pressed }) => [
              styles.tile,
              { width: CARD, height: CARD, borderColor: t.color },
              pressed && { transform: [{ scale: 0.98 }] },
            ]}
          >
            <View style={[styles.tileInner, { backgroundColor: t.color }]}>
              <Ionicons name={t.icon} size={42} color={PALETTE.white} />
            </View>
            <Text style={styles.tileLabel}>{t.label}</Text>
          </Pressable>
        ))}
      </View>

      <Text style={styles.hint}>{T.hint}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 18 },
  hero: { alignItems: "center", marginTop: 6, marginBottom: 16 },
  logo: { width: 120, height: 120, marginBottom: 6 },
  title: { color: PALETTE.white, fontSize: 24, fontWeight: "800" },
  sub: { color: PALETTE.textSoft, fontSize: 12 },
  grid: { flexDirection: "row", flexWrap: "wrap", justifyContent: "space-between", rowGap: 16 },
  tile: { borderRadius: 18, borderWidth: 2, backgroundColor: PALETTE.card, overflow: "hidden" },
  tileInner: { flex: 1, alignItems: "center", justifyContent: "center" },
  tileLabel: { position: "absolute", bottom: 8, width: "100%", textAlign: "center", color: PALETTE.white, fontWeight: "700", fontSize: 16 },
  hint: { textAlign: "center", color: "#9c9c9c", marginTop: 12, fontSize: 12 },
});
