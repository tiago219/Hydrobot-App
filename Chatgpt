
// ================= ESP32-CAM – mantém CameraWebServer + adiciona /cmd /pump /hud =================
#include "esp_camera.h"
#include <WiFi.h>
#include "esp_http_server.h"

// ======= Modelo de câmera (ou use seu board_config.h) =======
#include "board_config.h"   // mantém sua seleção do modelo/pinos

// ======= Wi-Fi =======
const char *ssid     = "HydroBot";
const char *password = "loud2025emibr";

// ======= Declarações vindas do CameraWebServer original =======
void startCameraServer();
void setupLedFlash();

// O CameraWebServer (app_httpd.cpp) costuma expor este handle global:
extern "C" httpd_handle_t camera_httpd;   // << usamos pra registrar nossos endpoints

// ======= HUD cache (telemetria lida da Serial do Arduino) =======
static String lastHudJson = "{\"nivelAguaPct\":0,\"fogoE\":false,\"fogoM\":false,\"fogoD\":false,\"modo\":\"AUTO\"}";

// Leitura de linhas JSON da Serial (terminadas em \n)
static void poll_serial_hud() {
  static String line;
  while (Serial.available()) {
    char c = (char)Serial.read();
    if (c=='\n' || c=='\r') {
      if (line.length() > 0 && line.charAt(0) == '{') {
        lastHudJson = line;
      }
      line = "";
    } else {
      if (line.length() < 512) line += c;
    }
  }
}

// ======= Utils HTTP =======
static void set_nocache(httpd_req_t *req) {
  httpd_resp_set_hdr(req, "Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Expires", "0");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
}

// GET /hud  -> retorna o último JSON vindo do Arduino
static esp_err_t hud_handler(httpd_req_t *req) {
  set_nocache(req);
  httpd_resp_set_type(req, "application/json");
  // leitura rápida para manter fresco (não bloqueia)
  poll_serial_hud();
  return httpd_resp_send(req, lastHudJson.c_str(), HTTPD_RESP_USE_STRLEN);
}

// GET /cmd?c=FWD&ms=250   |   /cmd?c=STOP
static esp_err_t cmd_handler(httpd_req_t *req) {
  set_nocache(req);
  char q[64]; size_t qlen = httpd_req_get_url_query_len(req) + 1;
  String c = "STOP"; int ms = 200;
  if (qlen > 1 && qlen < sizeof(q)) {
    httpd_req_get_url_query_str(req, q, qlen);
    char v[16];
    if (httpd_query_key_value(q, "c", v, sizeof(v)) == ESP_OK) c = v;
    if (httpd_query_key_value(q, "ms", v, sizeof(v)) == ESP_OK) ms = atoi(v);
  }
  if (c == "STOP") Serial.println("CMD:STOP");
  else             Serial.printf("CMD:%s:ms=%d\n", c.c_str(), ms);

  httpd_resp_set_type(req, "application/json");
  return httpd_resp_send(req, "{\"ok\":true}", HTTPD_RESP_USE_STRLEN);
}

// GET /pump?on=1|0
static esp_err_t pump_handler(httpd_req_t *req) {
  set_nocache(req);
  char q[32]; size_t qlen = httpd_req_get_url_query_len(req) + 1;
  int on = 0;
  if (qlen > 1 && qlen < sizeof(q)) {
    httpd_req_get_url_query_str(req, q, qlen);
    char v[8];
    if (httpd_query_key_value(q, "on", v, sizeof(v)) == ESP_OK) on = atoi(v);
  }
  if (on) Serial.println("CMD:PUMP:on"); else Serial.println("CMD:PUMP:off");

  httpd_resp_set_type(req, "application/json");
  return httpd_resp_send(req, "{\"ok\":true}", HTTPD_RESP_USE_STRLEN);
}

// Registra endpoints no mesmo servidor (porta 80) criado por startCameraServer()
static void register_control_endpoints() {
  if (!camera_httpd) return;   // se por algum motivo não existir (fork diferente)

  httpd_uri_t hud_uri  = { .uri="/hud",  .method=HTTP_GET, .handler=hud_handler,  .user_ctx=NULL };
  httpd_uri_t cmd_uri  = { .uri="/cmd",  .method=HTTP_GET, .handler=cmd_handler,  .user_ctx=NULL };
  httpd_uri_t pump_uri = { .uri="/pump", .method=HTTP_GET, .handler=pump_handler, .user_ctx=NULL };

  httpd_register_uri_handler(camera_httpd, &hud_uri);
  httpd_register_uri_handler(camera_httpd, &cmd_uri);
  httpd_register_uri_handler(camera_httpd, &pump_uri);
}

// ===================== SETUP / LOOP =====================
void setup() {
  Serial.begin(115200);               // UART com o Arduino
  Serial.setDebugOutput(false);

  // ---------- init câmera (igual ao seu "código certo") ----------
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.frame_size   = FRAMESIZE_UXGA;
  config.pixel_format = PIXFORMAT_JPEG;  // streaming
  config.grab_mode    = CAMERA_GRAB_WHEN_EMPTY;
  config.fb_location  = CAMERA_FB_IN_PSRAM;
  config.jpeg_quality = 12;
  config.fb_count     = 1;

  if (config.pixel_format == PIXFORMAT_JPEG) {
    if (psramFound()) {
      config.jpeg_quality = 10;
      config.fb_count = 2;
      config.grab_mode = CAMERA_GRAB_LATEST;
    } else {
      config.frame_size = FRAMESIZE_SVGA;
      config.fb_location = CAMERA_FB_IN_DRAM;
    }
  } else {
    config.frame_size = FRAMESIZE_240X240;
  }

  if (esp_camera_init(&config) != ESP_OK) {
    // fallback simples, evita reboot em ambientes críticos
    config.frame_size   = FRAMESIZE_SVGA;
    config.xclk_freq_hz = 10000000;
    config.jpeg_quality = 14;
    config.fb_count     = 1;
    if (esp_camera_init(&config) != ESP_OK) {
      for(;;) delay(1000);
    }
  }

  sensor_t *s = esp_camera_sensor_get();
  if (s->id.PID == OV3660_PID) { s->set_vflip(s, 1); s->set_brightness(s, 1); s->set_saturation(s, -2); }
  if (config.pixel_format == PIXFORMAT_JPEG) s->set_framesize(s, FRAMESIZE_QVGA);  // taxa mais estável

  // ---------- Wi-Fi ----------
  WiFi.begin(ssid, password);
  WiFi.setSleep(false);
  while (WiFi.status() != WL_CONNECTED) { delay(400); }

  // ---------- servidor original ----------
  startCameraServer();

  // ---------- registrar controles no MESMO servidor ----------
  register_control_endpoints();
}

void loop() {
  // Só mantém HUD fresca; não bloqueia
  poll_serial_hud();
  delay(10);
}






















// ===================== ESP32-CAM — Camera + Controle do Carro + HUD =====================
#include "esp_camera.h"
#include <WiFi.h>
#include "esp_http_server.h"

// --------- SELECIONE SEU MODELO (ou use seu board_config.h) ---------
// Se já usa "board_config.h" no seu projeto, descomente a linha abaixo e remova o bloco de pinos.
// #include "board_config.h"

// >>> Pinos do AI Thinker (comente se usar board_config.h)
#ifndef CAMERA_MODEL_AI_THINKER
#define CAMERA_MODEL_AI_THINKER
#endif

#if defined(CAMERA_MODEL_AI_THINKER)
  #define PWDN_GPIO_NUM     32
  #define RESET_GPIO_NUM    -1
  #define XCLK_GPIO_NUM      0
  #define SIOD_GPIO_NUM     26
  #define SIOC_GPIO_NUM     27
  #define Y9_GPIO_NUM       35
  #define Y8_GPIO_NUM       34
  #define Y7_GPIO_NUM       39
  #define Y6_GPIO_NUM       36
  #define Y5_GPIO_NUM       21
  #define Y4_GPIO_NUM       19
  #define Y3_GPIO_NUM       18
  #define Y2_GPIO_NUM        5
  #define VSYNC_GPIO_NUM    25
  #define HREF_GPIO_NUM     23
  #define PCLK_GPIO_NUM     22
#endif

// ======================= WIFI =======================
const char* ssid     = "HydroBot";
const char* password = "loud2025emibr";

// =================== HTTP SERVERS ===================
static httpd_handle_t httpd_main = nullptr;

static void set_nocache(httpd_req_t *req) {
  httpd_resp_set_hdr(req, "Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Expires", "0");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
}

// ---------- HUD cache (telemetria recebida do Arduino) ----------
static String lastHudJson = "{\"nivelAguaPct\":0,\"fogoE\":false,\"fogoM\":false,\"fogoD\":false,\"modo\":\"AUTO\"}";
static unsigned long lastHudUpdateMs = 0;

// Leia continuamente a Serial e capture linhas JSON (terminadas em \n)
static void poll_serial_hud() {
  static String line;
  while (Serial.available()) {
    char c = (char)Serial.read();
    if (c == '\n' || c == '\r') {
      if (line.length() > 0 && line.charAt(0) == '{') {
        lastHudJson = line;
        lastHudUpdateMs = millis();
      }
      line = "";
    } else {
      if (line.length() < 512) line += c;
    }
  }
}

// ===================== Handlers HTTP (câmera) =====================
static esp_err_t status_handler(httpd_req_t *req) {
  set_nocache(req);
  String j = String("{\"ok\":true,\"ip\":\"") + WiFi.localIP().toString() + "\"}";
  httpd_resp_set_type(req, "application/json");
  return httpd_resp_send(req, j.c_str(), HTTPD_RESP_USE_STRLEN);
}

static esp_err_t capture_handler(httpd_req_t *req) {
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) { httpd_resp_send_500(req); return ESP_FAIL; }
  set_nocache(req);
  httpd_resp_set_type(req, "image/jpeg");
  esp_err_t res = httpd_resp_send(req, (const char *)fb->buf, fb->len);
  esp_camera_fb_return(fb);
  return res;
}

static esp_err_t stream_handler(httpd_req_t *req) {
  static const char* BOUNDARY = "--frame";
  static const char* CT = "multipart/x-mixed-replace;boundary=frame";
  set_nocache(req);
  httpd_resp_set_type(req, CT);

  while (true) {
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) break;

    char part[64];
    size_t hlen = snprintf(part, sizeof(part),
                           "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n", fb->len);

    if (httpd_resp_send_chunk(req, "\r\n--frame\r\n", 12) != ESP_OK) { esp_camera_fb_return(fb); break; }
    if (httpd_resp_send_chunk(req, part, hlen) != ESP_OK)           { esp_camera_fb_return(fb); break; }
    if (httpd_resp_send_chunk(req, (const char*)fb->buf, fb->len) != ESP_OK) { esp_camera_fb_return(fb); break; }
    esp_camera_fb_return(fb);
    if (httpd_resp_send_chunk(req, "\r\n", 2) != ESP_OK) break;
    vTaskDelay(pdMS_TO_TICKS(5));
  }
  httpd_resp_send_chunk(req, NULL, 0);
  return ESP_OK;
}

// ===================== Handlers HTTP (controle/HUD) =====================
// /hud  -> JSON mais recente vindo do Arduino
static esp_err_t hud_handler(httpd_req_t *req) {
  set_nocache(req);
  httpd_resp_set_type(req, "application/json");
  poll_serial_hud(); // garante leitura recente
  return httpd_resp_send(req, lastHudJson.c_str(), HTTPD_RESP_USE_STRLEN);
}

// /cmd?c=FWD&ms=250   ou   /cmd?c=STOP
static esp_err_t cmd_handler(httpd_req_t *req) {
  set_nocache(req);
  char q[64]; size_t qlen = httpd_req_get_url_query_len(req) + 1;
  String c = "STOP"; int ms = 200;
  if (qlen > 1 && qlen < sizeof(q)) {
    httpd_req_get_url_query_str(req, q, qlen);
    char v[16];
    if (httpd_query_key_value(q, "c", v, sizeof(v)) == ESP_OK) c = v;
    if (httpd_query_key_value(q, "ms", v, sizeof(v)) == ESP_OK) ms = atoi(v);
  }
  if (c == "STOP") Serial.println("CMD:STOP");
  else Serial.printf("CMD:%s:ms=%d\n", c.c_str(), ms);

  httpd_resp_set_type(req, "application/json");
  return httpd_resp_send(req, "{\"ok\":true}", HTTPD_RESP_USE_STRLEN);
}

// /pump?on=1|0
static esp_err_t pump_handler(httpd_req_t *req) {
  set_nocache(req);
  char q[32]; size_t qlen = httpd_req_get_url_query_len(req) + 1;
  int on = 0;
  if (qlen > 1 && qlen < sizeof(q)) {
    httpd_req_get_url_query_str(req, q, qlen);
    char v[8];
    if (httpd_query_key_value(q, "on", v, sizeof(v)) == ESP_OK) on = atoi(v);
  }
  if (on) Serial.println("CMD:PUMP:on"); else Serial.println("CMD:PUMP:off");
  httpd_resp_set_type(req, "application/json");
  return httpd_resp_send(req, "{\"ok\":true}", HTTPD_RESP_USE_STRLEN);
}

// ===================== Start server =====================
static void start_server() {
  httpd_config_t conf = HTTPD_DEFAULT_CONFIG();
  conf.server_port = 80;
  conf.max_uri_handlers = 16;
  conf.stack_size = 6144;

  if (httpd_main) httpd_stop(httpd_main);
  if (httpd_start(&httpd_main, &conf) == ESP_OK) {
    httpd_uri_t status_uri = { .uri="/status",  .method=HTTP_GET, .handler=status_handler,  .user_ctx=NULL };
    httpd_uri_t still_uri  = { .uri="/capture", .method=HTTP_GET, .handler=capture_handler, .user_ctx=NULL };
    httpd_uri_t stream_uri = { .uri="/stream",  .method=HTTP_GET, .handler=stream_handler,  .user_ctx=NULL };
    httpd_uri_t hud_uri    = { .uri="/hud",     .method=HTTP_GET, .handler=hud_handler,     .user_ctx=NULL };
    httpd_uri_t cmd_uri    = { .uri="/cmd",     .method=HTTP_GET, .handler=cmd_handler,     .user_ctx=NULL };
    httpd_uri_t pump_uri   = { .uri="/pump",    .method=HTTP_GET, .handler=pump_handler,    .user_ctx=NULL };

    httpd_register_uri_handler(httpd_main, &status_uri);
    httpd_register_uri_handler(httpd_main, &still_uri);
    httpd_register_uri_handler(httpd_main, &stream_uri);
    httpd_register_uri_handler(httpd_main, &hud_uri);
    httpd_register_uri_handler(httpd_main, &cmd_uri);
    httpd_register_uri_handler(httpd_main, &pump_uri);
  }
}

// ===================== SETUP / LOOP =====================
void setup() {
  Serial.begin(115200);   // UART para o Arduino
  Serial.setDebugOutput(true);
  delay(200);

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_QVGA;   // inicia leve; você pode subir depois
  config.jpeg_quality = 12;
  config.fb_count     = 1;
  config.grab_mode    = CAMERA_GRAB_LATEST;
  config.fb_location  = CAMERA_FB_IN_PSRAM;

  if (psramFound()) { config.jpeg_quality = 10; config.fb_count = 2; }
  else              { config.frame_size = FRAMESIZE_SVGA; config.fb_location = CAMERA_FB_IN_DRAM; }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed 0x%x\n", err);
    for(;;) delay(1000);
  }

  sensor_t *s = esp_camera_sensor_get();
  if (s->id.PID == OV3660_PID) { s->set_vflip(s, 1); s->set_brightness(s, 1); s->set_saturation(s, -2); }
  s->set_framesize(s, FRAMESIZE_QVGA);   // frame rate mais alto p/ stream

  WiFi.begin(ssid, password);
  WiFi.setSleep(false);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) { delay(400); Serial.print("."); }
  Serial.printf("\nWiFi connected: %s\n", WiFi.localIP().toString().c_str());

  start_server();
  Serial.println("HTTP server started");
  Serial.printf("Open stream: http://%s/stream\n", WiFi.localIP().toString().c_str());
}

void loop() {
  // Mantém HUD atualizada
  poll_serial_hud();
  delay(10);
}
















import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet, Image,
  AppState, AppStateStatus, Platform, NativeSyntheticEvent, ImageErrorEventData
} from "react-native";
import { WebView } from "react-native-webview";
import type { WebViewErrorEvent, WebViewHttpErrorEvent } from "react-native-webview/lib/WebViewTypes";
import { useFocusEffect, useNavigation } from "@react-navigation/native";
import { StatusBar } from "expo-status-bar";

type Mode = "mjpeg" | "snapshot";
type Hud = {
  nivelAguaPct: number;
  fogoE: boolean;
  fogoM: boolean;
  fogoD: boolean;
  modo: "AUTO" | "APP";
};

const PALETTE = {
  bg: "#0b0b0f",
  card: "#121218",
  border: "#25273a",
  red: "#E53B2F",
  white: "#E5E7EB",
  sub: "#9CA3AF",
  green: "#10b981",
  danger: "#ef4444",
};

const LOGO = require("../../assets/logo.png"); // ajuste se preciso

export default function CameraScreen() {
  const navigation = useNavigation<any>();

  const [ip, setIp] = useState<string>("192.168.3.3");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [statusText, setStatusText] = useState<string>("—");
  const [err, setErr] = useState<string>("");

  // HUD state
  const [hud, setHud] = useState<Hud>({ nivelAguaPct: 0, fogoE: false, fogoM: false, fogoD: false, modo: "AUTO" });

  // Snapshot loop
  const [snapUri, setSnapUri] = useState<string>("");
  const timerRef = useRef<number | null>(null);
  const appState = useRef(AppState.currentState);

  // Endpoints CameraWebServer + control/hud
  const base80 = useMemo(() => `http://${ip}`, [ip]);
  const base81 = useMemo(() => `http://${ip}:81`, [ip]);
  const statusUrl   = useMemo(() => `${base80}/status`, [base80]);
  const snapshotUrl = useMemo(() => `${base80}/capture`, [base80]);
  const streamUrl   = useMemo(() => `${base81}/stream`, [base81]);
  const cmdUrl      = useMemo(() => `${base80}/cmd`, [base80]);
  const pumpUrl     = useMemo(() => `${base80}/pump`, [base80]);
  const hudUrl      = useMemo(() => `${base80}/hud`, [base80]);

  // Esconde TAB BAR aqui para liberar tela total ao viewer
  useFocusEffect(useCallback(() => {
    const parent = navigation.getParent?.();
    parent?.setOptions({ tabBarStyle: { display: "none" } });
    return () => parent?.setOptions({ tabBarStyle: undefined });
  }, [navigation]));

  const clearTimer = useCallback(() => {
    if (timerRef.current !== null) { clearInterval(timerRef.current); timerRef.current = null; }
  }, []);
  const startSnapshot = useCallback(() => {
    clearTimer();
    timerRef.current = setInterval(() => setSnapUri(`${snapshotUrl}?ts=${Date.now()}`), 125) as unknown as number;
  }, [snapshotUrl, clearTimer]);

  useEffect(() => {
    const sub = AppState.addEventListener("change", (next: AppStateStatus) => {
      if (appState.current.match(/inactive|background/) && next === "active" && mode === "snapshot") startSnapshot();
      if (next.match(/inactive|background/)) clearTimer();
      appState.current = next;
    });
    return () => { sub.remove(); clearTimer(); };
  }, [mode, startSnapshot, clearTimer]);

  useEffect(() => {
    setErr("");
    if (mode === "snapshot") startSnapshot(); else clearTimer();
    return () => clearTimer();
  }, [mode, startSnapshot, clearTimer]);

  const checkStatus = useCallback(async () => {
    try {
      const r = await fetch(statusUrl);
      const txt = await r.text();
      setStatusText(`OK (${txt.slice(0, 60)}${txt.length > 60 ? "..." : ""})`);
    } catch (e) {
      const er = e as Error;
      setStatusText("Falhou");
      setErr(er?.message ?? String(e));
    }
  }, [statusUrl]);

  useEffect(() => { if (ip) checkStatus(); }, [ip, checkStatus]);

  const onWvError = useCallback((e: WebViewErrorEvent) => setErr(`WebView: ${e.nativeEvent.description}`), []);
  const onWvHttpError = useCallback((e: WebViewHttpErrorEvent) => setErr(`HTTP ${e.nativeEvent.statusCode}`), []);
  const onImgError = useCallback((e: NativeSyntheticEvent<ImageErrorEventData>) => setErr(`Snapshot: ${e.nativeEvent.error}`), []);

  // Poll HUD (a cada 300ms)
  useEffect(() => {
    let stop = false;
    const tick = async () => {
      try {
        const r = await fetch(hudUrl, { cache: "no-store" });
        if (!r.ok) throw new Error(`HUD HTTP ${r.status}`);
        const j = await r.json();
        if (!stop) setHud({
          nivelAguaPct: Number(j.nivelAguaPct ?? 0),
          fogoE: !!j.fogoE,
          fogoM: !!j.fogoM,
          fogoD: !!j.fogoD,
          modo: j.modo === 1 || j.modo === "APP" ? "APP" : "AUTO",
        });
      } catch (e) {
        // silencioso para não poluir
      }
      if (!stop) setTimeout(tick, 300);
    };
    tick();
    return () => { stop = true; };
  }, [hudUrl]);

  // Envio de comandos
  const sendCmd = useCallback(async (c: "FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP", ms: number = 220) => {
    const url = c === "STOP" ? `${cmdUrl}?c=STOP` : `${cmdUrl}?c=${c}&ms=${ms}`;
    try { await fetch(url); } catch {}
  }, [cmdUrl]);
  const togglePump = useCallback(async (on: boolean) => {
    try { await fetch(`${pumpUrl}?on=${on ? 1 : 0}`); } catch {}
  }, [pumpUrl]);

  // HTML "contain" — mostra 100% sem cortar
  const mjpegHtml = useMemo(
    () => `
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"/>
    <style>
      html, body { margin:0; padding:0; background:#000; }
      img {
        position: fixed; inset: 0;
        width: 100vw; height: 100vh;
        object-fit: contain; background:#000;
      }
    </style>
  </head>
  <body>
    <img src="${streamUrl}" />
  </body>
</html>`.trim(),
    [streamUrl]
  );

  // UI
  const fireBadge = (label: string, active: boolean) => (
    <View style={[styles.fire, { borderColor: active ? PALETTE.danger : PALETTE.border, backgroundColor: active ? "#7f1d1d" : "#00000066" }]}>
      <Text style={{ color: active ? PALETTE.white : PALETTE.sub, fontWeight: "700" }}>{label}</Text>
    </View>
  );

  return (
    <View style={styles.root}>
      <StatusBar hidden />

      {/* VIEWER em tela cheia */}
      <View style={styles.viewer}>
        {mode === "mjpeg" ? (
          <WebView
            originWhitelist={['*']}
            source={{ html: mjpegHtml }}
            style={StyleSheet.absoluteFill}
            allowsInlineMediaPlayback
            mediaPlaybackRequiresUserAction={false}
            onError={onWvError}
            onHttpError={onWvHttpError}
          />
        ) : (
          <Image
            source={{ uri: snapUri || `${snapshotUrl}?ts=${Date.now()}` }}
            style={StyleSheet.absoluteFill}
            resizeMode="contain"
            onError={onImgError}
          />
        )}
      </View>

      {/* ====== OVERLAYS ====== */}
      {/* Top: logo + chips modo + status */}
      <View style={styles.topOverlay}>
        <View style={styles.brandRow}>
          <Image source={LOGO} style={styles.logo} resizeMode="contain" />
          <Text style={styles.brand}>HydroBot</Text>
          <View style={{ flex: 1 }} />
          <View style={styles.modeRow}>
            <Pressable style={[styles.chip, mode === "mjpeg" && styles.chipActive]} onPress={() => setMode("mjpeg")}>
              <Text style={[styles.chipTxt, mode === "mjpeg" && styles.chipTxtActive]}>MJPEG</Text>
            </Pressable>
            <Pressable style={[styles.chip, mode === "snapshot" && styles.chipActive]} onPress={() => setMode("snapshot")}>
              <Text style={[styles.chipTxt, mode === "snapshot" && styles.chipTxtActive]}>Snapshot</Text>
            </Pressable>
          </View>
        </View>
        <Text style={styles.meta}>Status: <Text style={{ color: PALETTE.green }}>{statusText}</Text> • Modo robô: <Text style={{ color: PALETTE.white, fontWeight: "700" }}>{hud.modo}</Text></Text>
      </View>

      {/* Left: d-pad */}
      <View style={styles.leftOverlay}>
        <View style={styles.dpadRow}>
          <Pressable style={[styles.dbtn, styles.dbtnGhost]} onPress={() => sendCmd("LEFT", 180)}><Text style={styles.dtxt}>◀︎</Text></Pressable>
          <Pressable style={[styles.dbtn, styles.dbtnMain]} onPress={() => sendCmd("FWD", 260)}><Text style={styles.dtxt}>▲</Text></Pressable>
          <Pressable style={[styles.dbtn, styles.dbtnGhost]} onPress={() => sendCmd("RIGHT", 180)}><Text style={styles.dtxt}>▶︎</Text></Pressable>
        </View>
        <View style={[styles.dpadRow, { marginTop: 8 }]}>
          <Pressable style={[styles.dbtn, styles.dbtnWarn]} onPress={() => sendCmd("STOP")}><Text style={styles.dtxt}>■</Text></Pressable>
          <Pressable style={[styles.dbtn, styles.dbtnMain]} onPress={() => sendCmd("BACK", 240)}><Text style={styles.dtxt}>▼</Text></Pressable>
        </View>
      </View>

      {/* Right: bomba + HUD */}
      <View style={styles.rightOverlay}>
        <Pressable style={styles.pump} onPress={() => togglePump(true)}>
          <Text style={styles.pumpTxt}>Ligar Bomba</Text>
        </Pressable>
        <Pressable style={[styles.pump, { backgroundColor: "#00000055", borderColor: PALETTE.border }]} onPress={() => togglePump(false)}>
          <Text style={styles.pumpTxt}>Desligar Bomba</Text>
        </Pressable>

        <View style={styles.hudCard}>
          <Text style={styles.hudTitle}>Sensores</Text>
          <View style={styles.fireRow}>
            {fireBadge("ESQ", hud.fogoE)}
            {fireBadge("MEIO", hud.fogoM)}
            {fireBadge("DIR", hud.fogoD)}
          </View>

          <View style={{ height: 8 }} />
          <Text style={styles.hudTitle}>Nível de Água</Text>
          <View style={styles.bar}>
            <View style={[styles.barFill, { width: `${Math.max(0, Math.min(100, hud.nivelAguaPct))}%` }]} />
          </View>
          <Text style={styles.meta}>&nbsp;{hud.nivelAguaPct}%</Text>
        </View>
      </View>

      {/* Bottom: IP field */}
      <View style={styles.bottomOverlay}>
        <Text style={styles.label}>ESP IP</Text>
        <View style={{ flexDirection: "row", gap: 8 }}>
          <TextInput
            style={styles.input}
            value={ip}
            onChangeText={setIp}
            placeholder="ex.: 192.168.3.3"
            placeholderTextColor={PALETTE.sub}
            autoCapitalize="none"
            autoCorrect={false}
            keyboardType={Platform.OS === "android" ? "numeric" : "numbers-and-punctuation"}
          />
          <Pressable style={styles.btn} onPress={checkStatus}><Text style={styles.btnTxt}>Testar</Text></Pressable>
        </View>
        {!!err && <Text style={[styles.meta, { color: "#ff8b8b", marginTop: 6 }]} numberOfLines={2}>Erro: {err}</Text>}
      </View>
      {/* ====== /OVERLAYS ====== */}
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: PALETTE.bg },
  viewer: { ...StyleSheet.absoluteFillObject, backgroundColor: "#000" },

  // Top overlay
  topOverlay: {
    position: "absolute", left: 12, right: 12, top: 12,
    backgroundColor: "#00000099", borderRadius: 12, padding: 10, borderWidth: 1, borderColor: "#00000055",
  },
  brandRow: { flexDirection: "row", alignItems: "center", gap: 10 },
  logo: { width: 26, height: 26 },
  brand: { color: PALETTE.white, fontSize: 18, fontWeight: "800" },
  modeRow: { flexDirection: "row", gap: 8 },
  chip: { borderWidth: 1, borderColor: PALETTE.border, borderRadius: 999, paddingHorizontal: 10, paddingVertical: 4 },
  chipActive: { backgroundColor: PALETTE.red, borderColor: PALETTE.red },
  chipTxt: { color: PALETTE.white, fontWeight: "600", fontSize: 12 },
  chipTxtActive: { color: "#fff", fontWeight: "800" },
  meta: { color: PALETTE.sub, fontSize: 12, marginTop: 6 },

  // Left — d-pad
  leftOverlay: { position: "absolute", left: 12, bottom: 12 },
  dpadRow: { flexDirection: "row", gap: 8, justifyContent: "center" },
  dbtn: { minWidth: 56, height: 56, borderRadius: 12, alignItems: "center", justifyContent: "center", borderWidth: 1 },
  dbtnMain: { backgroundColor: PALETTE.red, borderColor: "#000" },
  dbtnGhost:{ backgroundColor: "#00000066", borderColor: PALETTE.border },
  dbtnWarn: { backgroundColor: "#7f1d1d", borderColor: "#000" },
  dtxt: { color: "#fff", fontSize: 20, fontWeight: "800" },

  // Right — bomba + HUD
  rightOverlay: { position: "absolute", right: 12, bottom: 12, alignItems: "stretch", gap: 8, width: 200 },
  pump: { backgroundColor: PALETTE.red, borderRadius: 12, paddingVertical: 10, alignItems: "center", borderWidth: 1, borderColor: "#000" },
  pumpTxt: { color: "#fff", fontWeight: "800" },

  hudCard: { backgroundColor: "#00000099", borderRadius: 12, padding: 10, borderWidth: 1, borderColor: "#00000055" },
  hudTitle: { color: PALETTE.white, fontWeight: "800", marginBottom: 6 },
  fireRow: { flexDirection: "row", gap: 8 },
  fire: { paddingHorizontal: 10, paddingVertical: 6, borderRadius: 999, borderWidth: 1 },

  bar: { height: 12, borderRadius: 999, backgroundColor: "#111", borderWidth: 1, borderColor: PALETTE.border, overflow: "hidden" },
  barFill: { height: "100%", backgroundColor: PALETTE.green },

  // Bottom — IP
  bottomOverlay: {
    position: "absolute", left: 12, right: 12, bottom: 12,
    backgroundColor: "#00000099", borderRadius: 12, padding: 10, borderWidth: 1, borderColor: "#00000055",
  },
  label: { color: PALETTE.white, marginBottom: 6, fontWeight: "600" },
  input: {
    flex: 1, backgroundColor: PALETTE.card, borderWidth: 1, borderColor: PALETTE.border,
    borderRadius: 12, paddingHorizontal: 12, paddingVertical: 9, color: PALETTE.white,
  },
  btn: { backgroundColor: PALETTE.red, paddingHorizontal: 14, paddingVertical: 11, borderRadius: 12 },
  btnTxt: { color: "#fff", fontWeight: "700" },
});









































































#include "esp_camera.h"
#include <WiFi.h>

// ===========================
// Select camera model in board_config.h
// ===========================
#include "board_config.h"

// ===========================
// Enter your WiFi credentials
// ===========================
const char *ssid = "HydroBot";
const char *password = "loud2025emibr";

void startCameraServer();
void setupLedFlash();

void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println();

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.frame_size = FRAMESIZE_UXGA;
  config.pixel_format = PIXFORMAT_JPEG;  // for streaming
  //config.pixel_format = PIXFORMAT_RGB565; // for face detection/recognition
  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
  config.fb_location = CAMERA_FB_IN_PSRAM;
  config.jpeg_quality = 12;
  config.fb_count = 1;

  // if PSRAM IC present, init with UXGA resolution and higher JPEG quality
  //                      for larger pre-allocated frame buffer.
  if (config.pixel_format == PIXFORMAT_JPEG) {
    if (psramFound()) {
      config.jpeg_quality = 10;
      config.fb_count = 2;
      config.grab_mode = CAMERA_GRAB_LATEST;
    } else {
      // Limit the frame size when PSRAM is not available
      config.frame_size = FRAMESIZE_SVGA;
      config.fb_location = CAMERA_FB_IN_DRAM;
    }
  } else {
    // Best option for face detection/recognition
    config.frame_size = FRAMESIZE_240X240;
#if CONFIG_IDF_TARGET_ESP32S3
    config.fb_count = 2;
#endif
  }

#if defined(CAMERA_MODEL_ESP_EYE)
  pinMode(13, INPUT_PULLUP);
  pinMode(14, INPUT_PULLUP);
#endif

  // camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }

  sensor_t *s = esp_camera_sensor_get();
  // initial sensors are flipped vertically and colors are a bit saturated
  if (s->id.PID == OV3660_PID) {
    s->set_vflip(s, 1);        // flip it back
    s->set_brightness(s, 1);   // up the brightness just a bit
    s->set_saturation(s, -2);  // lower the saturation
  }
  // drop down frame size for higher initial frame rate
  if (config.pixel_format == PIXFORMAT_JPEG) {
    s->set_framesize(s, FRAMESIZE_QVGA);
  }

#if defined(CAMERA_MODEL_M5STACK_WIDE) || defined(CAMERA_MODEL_M5STACK_ESP32CAM)
  s->set_vflip(s, 1);
  s->set_hmirror(s, 1);
#endif

#if defined(CAMERA_MODEL_ESP32S3_EYE)
  s->set_vflip(s, 1);
#endif

// Setup LED FLash if LED pin is defined in camera_pins.h
#if defined(LED_GPIO_NUM)
  setupLedFlash();
#endif

  WiFi.begin(ssid, password);
  WiFi.setSleep(false);

  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("WiFi connected");

  startCameraServer();

  Serial.print("Camera Ready! Use 'http://");
  Serial.print(WiFi.localIP());
  Serial.println("' to connect");
}

void loop() {
  // Do nothing. Everything is done in another task by the web server
  delay(10000);
}
