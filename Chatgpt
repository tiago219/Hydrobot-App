
Fechou. Vamos come√ßar do ZERO e rodar no Expo Go (sem Android SDK).


Passo a passo (r√°pido e certeiro)




Instale o Node.js LTS






Windows (PowerShell Admin): winget install OpenJS.NodeJS.LTS


macOS (Homebrew): brew install node@20


Ubuntu/Debian:

sudo apt update
sudo apt install -y nodejs npm


(se o Node ficar velho, instale via nvm depois; por enquanto serve)






Crie o app base (template TypeScript)




npm create expo-app@latest MeuApp -- --template blank-typescript
# ou: npx create-expo-app@latest MeuApp --template blank-typescript





Entre na pasta e inicie o servidor do Expo




cd MeuApp
npx expo start





O terminal abre o Expo Dev Tools.


No terminal, tecle s para alternar entre LAN ‚Üî Tunnel:



LAN: celular e PC no mesmo Wi-Fi.


Tunnel: funciona mesmo se o celular estiver em outra rede (ex.: conectado ao AP do seu ESP).

Dica: se der problema de rede, escolha Tunnel.










Instale o app Expo Go no Android (Play Store) e escaneie o QR que aparece no terminal/Dev Tools.






Se n√£o ler o QR, toque em ‚ÄúEnter URL‚Äù no Expo Go e cole o link mostrado.






Edite o app e veja ao vivo

Abra o projeto no editor (VS Code, por ex.) e altere App.tsx. Salve e o Expo Go atualiza sozinho.





App.tsx inicial (j√° pronto pra testar)


Cole isto no App.tsx do seu projeto rec√©m-criado (se j√° existir, pode substituir):


import { StatusBar } from 'expo-status-bar';
import { SafeAreaView, Text, View, Pressable } from 'react-native';
import { useState } from 'react';

export default function App() {
  const [count, setCount] = useState(0);

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: '#0b0b0f' }}>
      <View style={{ flex: 1, padding: 24, gap: 16, justifyContent: 'center' }}>
        <Text style={{ color: '#e5e7eb', fontSize: 22, fontWeight: '600' }}>
          Meu primeiro app Expo ‚ú®
        </Text>
        <Text style={{ color: '#9ca3af', fontSize: 16 }}>
          Rodando no Expo Go (sem SDK nativo).
        </Text>

        <Pressable
          onPress={() => setCount(c => c + 1)}
          style={{
            alignSelf: 'flex-start',
            backgroundColor: '#e6403a',
            paddingHorizontal: 16,
            paddingVertical: 10,
            borderRadius: 12
          }}
        >
          <Text style={{ color: 'white', fontWeight: '700' }}>Cliquei {count}x</Text>
        </Pressable>

        <StatusBar style="light" />
      </View>
    </SafeAreaView>
  );
}




Comando √∫nico (criar e abrir direto no Tunnel)


Se quiser fazer tudo em um tiro s√≥:


npm create expo-app@latest MeuApp -- --template blank-typescript \
&& cd MeuApp \
&& npx expo start --tunnel




Dicas e erros comuns (bem pr√°tico)






Fica travado em ‚ÄúWaiting for Expo Go‚Äù?




Troque para Tunnel (s no terminal).


Desative VPN e permita nas portas 19000‚Äì19006 no firewall do Windows.


Rode com cache limpo: npx expo start -c.








Celular no Wi-Fi do ESP e PC em outra rede?

Use Tunnel. LAN n√£o vai funcionar nesse cen√°rio.






Porta ocupada/Metro bugado

Ctrl+C para parar, depois npx expo start -c.






Depend√™ncias quebradas

npx expo doctor --fix-dependencies.






Adicionar libs do futuro (ex.: c√¢mera, webview)


npx expo install expo-camera
npx expo install react-native-webview







Se quiser, na pr√≥xima te mando um esqueleto de tela de c√¢mera j√° usando WebView/expo-camera, mas por enquanto isso j√° te deixa com o projeto rodando no Expo Go sem dor de cabe√ßa. üöÄ







































Esse erro do console (‚ÄúMust specify "expo-platform" header or "platform" query parameter‚Äù) aparece quando o bundler recebe uma requisi√ß√£o sem dizer qual plataforma (android/ios/web). Normalmente acontece quando voc√™ abre o endere√ßo do bundler direto no navegador (ex.: http://192.168.x.x:8081) ou iniciou o Expo sem escolher a plataforma.


Fa√ßa assim, passo a passo, sem precisar de SDK/Android Studio (usando Expo Go no celular):






Feche o processo atual do Expo (Ctrl+C).






Limpe cache e reinicie j√° escolhendo Android:






npx expo start -c





Quando aparecer o menu, aperte s para mostrar o QR code (ou ele j√° aparece).


Abra o app ‚ÄúExpo Go‚Äù no celular e escaneie o QR.



N√£o abra a URL do bundler no navegador; sempre pelo Expo Go.










Se o QR n√£o conecta por LAN, rode com t√∫nel:




npx expo start --tunnel -c



Escaneie o novo QR no Expo Go.




Alternativas (se quiser abrir direto):






Pressione a no terminal para abrir em Android (se tiver emulador/SDK).


Ou use:




npx expo start --android



(precisa de SDK; se voc√™ n√£o tem, fique com o Expo Go + QR/tunnel).




Se o erro continuar aparecendo:






Apague caches e a pasta interna do Expo:




rm -rf .expo node_modules
npm install
npx expo start -c





Atualize o CLI local do projeto:




npm i -D expo@latest





Dicas r√°pidas






N√£o acesse http://localhost:8081/19000 no navegador: isso dispara a mensagem do ‚Äúexpo-platform‚Äù.


Garanta que o celular e o PC est√£o na mesma rede (se n√£o, use --tunnel).


No Android 9+, para carregar HTTP da c√¢mera, seu app j√° est√° usando WebView com mixedContentMode="always". Se estiver em build standalone mais tarde, lembre de permitir cleartext no Manifest.




Seguindo os passos acima (Expo Go + QR ou --tunnel), o bundler recebe automaticamente o header expo-platform: android e o app abre normalmente.




























Beleza ‚Äî vou adaptar a CameraScreen para funcionar com o ‚Äúteste do ESP32‚Äù cl√°ssico (o exemplo da ESP32-CAM que faz http://IP:81/stream e o snapshot em /capture).

Ela faz auto-detec√ß√£o de rotas mais comuns: tenta primeiro :81/stream, depois /stream, e cai para snapshot (/capture ou /snapshot) se preciso. N√£o precisa mudar o firmware.


Substitua seu arquivo inteiro por este:


// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { View, Text, TextInput, Pressable, StyleSheet, Image, AppState, AppStateStatus } from "react-native";
import { WebView } from "react-native-webview";

type Mode = "mjpeg" | "snapshot";

const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", accent: "#e6403a", text: "#e5e7eb" };

// Utilit√°rio de timeout para fetch
async function fetchWithTimeout(url: string, ms = 2000) {
  const ctrl = new AbortController();
  const to = setTimeout(() => ctrl.abort(), ms);
  try {
    const r = await fetch(url, { method: "GET", signal: ctrl.signal });
    return r;
  } finally {
    clearTimeout(to);
  }
}

export default function CameraScreen() {
  const [ip, setIp] = useState("192.168.4.1"); // coloque o IP do seu ESP
  const [status, setStatus] = useState("Aguardando IP");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [streamURL, setStreamURL] = useState<string>("");
  const [snapshotURL, setSnapshotURL] = useState<string>("");
  const [snapTick, setSnapTick] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  const snapTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const appState = useRef<AppStateStatus>(AppState.currentState);

  // Candidatos t√≠picos do firmware ‚Äúteste esp32‚Äù
  const streamCandidates = useMemo(() => {
    const base = (ip || "").trim();
    if (!base) return [];
    return [
      `http://${base}:81/stream`,   // padr√£o do exemplo oficial
      `http://${base}/stream`,      // alguns firmwares servem na 80
      `http://${base}:80/stream`,
      `http://${base}:81/mjpeg`,    // varia√ß√µes
      `http://${base}/mjpeg`,
    ];
  }, [ip]);

  const snapshotCandidates = useMemo(() => {
    const base = (ip || "").trim();
    if (!base) return [];
    return [
      `http://${base}/capture`,     // padr√£o do exemplo oficial
      `http://${base}/snapshot`,
      `http://${base}:81/capture`,
      `http://${base}:81/snapshot`,
      `http://${base}:80/capture`,
      `http://${base}:80/snapshot`,
    ];
  }, [ip]);

  // Loop do snapshot (fallback)
  const startSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) return;
    snapTimerRef.current = setInterval(() => setSnapTick((t) => (t + 1) % 1_000_000), 200); // ~5 fps est√°vel
  }, []);
  const stopSnapshotLoop = useCallback(() => {
    if (!snapTimerRef.current) return;
    clearInterval(snapTimerRef.current);
    snapTimerRef.current = null;
  }, []);
  useEffect(() => {
    if (mode === "snapshot" && snapshotURL) startSnapshotLoop();
    else stopSnapshotLoop();
    return stopSnapshotLoop;
  }, [mode, snapshotURL, startSnapshotLoop, stopSnapshotLoop]);

  // Pausar ao ir para background
  useEffect(() => {
    const sub = AppState.addEventListener("change", (next) => {
      const prev = appState.current;
      appState.current = next;
      if (prev.match(/active/) && next.match(/inactive|background/)) {
        stopSnapshotLoop();
        setIsRunning(false);
      } else if (prev.match(/inactive|background/) && next === "active") {
        if (mode === "snapshot" && snapshotURL) startSnapshotLoop();
        if (streamURL || snapshotURL) setIsRunning(true);
      }
    });
    return () => sub.remove();
  }, [mode, snapshotURL, streamURL, startSnapshotLoop, stopSnapshotLoop]);

  // Teste/auto-detec√ß√£o
  const testConnection = useCallback(async () => {
    const target = (ip || "").trim();
    if (!target) {
      setStatus("Informe o IP do ESP");
      return;
    }
    setStatus("Testando...");
    setIsRunning(false);
    stopSnapshotLoop();
    setStreamURL("");
    setSnapshotURL("");

    // 1) Tentar candidatos de MJPEG
    for (const u of streamCandidates) {
      try {
        const r = await fetchWithTimeout(u, 2000);
        if (r.ok) {
          setStreamURL(u);
          setMode("mjpeg");
          setStatus(`Conectado (MJPEG): ${u}`);
          setIsRunning(true);
          return;
        }
      } catch {}
    }

    // 2) Fallback: tentar snapshot
    for (const u of snapshotCandidates) {
      try {
        const r = await fetchWithTimeout(u, 2000);
        if (r.ok) {
          setSnapshotURL(u);
          setMode("snapshot");
          setStatus(`Conectado (Snapshot): ${u}`);
          setIsRunning(true);
          startSnapshotLoop();
          return;
        }
      } catch {}
    }

    setStatus("Falha ao conectar ‚Äî verifique IP, porta 81/80 e rotas (/stream ou /capture).");
    setIsRunning(false);
  }, [ip, streamCandidates, snapshotCandidates, startSnapshotLoop, stopSnapshotLoop]);

  // HTML que carrega o MJPEG com auto-reconnect
  const mjpegHTML = useMemo(() => {
    if (!streamURL) return "";
    return `
      <!doctype html>
      <html><head><meta name="viewport" content="width=device-width, initial-scale=1"/>
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;overflow:hidden;}
        #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;}
        img{max-width:100vw;max-height:100vh;object-fit:contain;}
        #badge{position:fixed;left:8px;bottom:8px;padding:4px 8px;border-radius:8px;
               background:#121218;color:#e5e7eb;font-family:system-ui,Arial,sans-serif;font-size:12px;opacity:.7}
      </style></head>
      <body>
        <div id="wrap"><img id="mjpeg" src="${streamURL}"/></div>
        <div id="badge">${streamURL}</div>
        <script>
          const img = document.getElementById('mjpeg');
          let backoff=800;
          img.addEventListener('error',()=>{
            setTimeout(()=>{ img.src='${streamURL}?_='+Date.now(); }, backoff);
            backoff = Math.min(backoff*2, 4000);
          });
        </script>
      </body></html>
    `.trim();
  }, [streamURL]);

  const snapshotURI = useMemo(
    () => (snapshotURL ? `${snapshotURL}?_=${snapTick}` : ""),
    [snapshotURL, snapTick]
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>ESP32-CAM Viewer</Text>

      <View style={styles.row}>
        <Text style={styles.label}>ESP IP</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="ex.: 192.168.3.3"
          placeholderTextColor="#6b7280"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
        />
        <Pressable style={styles.button} onPress={testConnection}>
          <Text style={styles.buttonText}>Testar</Text>
        </Pressable>
      </View>

      <Text style={styles.status}>Status: {status} {isRunning ? " | OK" : ""}</Text>

      <View style={styles.viewer}>
        {isRunning ? (
          mode === "mjpeg" && streamURL ? (
            <WebView
              originWhitelist={["*"]}
              source={{ html: mjpegHTML, baseUrl: streamURL }}
              javaScriptEnabled
              domStorageEnabled
              allowsInlineMediaPlayback
              mediaPlaybackRequiresUserAction={false}
              allowsFullscreenVideo={false}
              mixedContentMode="always"                         // Android: libera HTTP claro
              androidHardwareAccelerationEnabled
              setSupportMultipleWindows={false}
              onError={() => {
                // se falhar, tenta cair automaticamente para snapshot candidates
                setStatus("MJPEG falhou ‚Äî alternando para Snapshot...");
                setMode("snapshot");
                // escolhe o melhor snapshot dispon√≠vel j√° conhecido ou o primeiro candidato
                setSnapshotURL((prev) => prev || snapshotCandidates[0] || "");
                startSnapshotLoop();
              }}
              style={styles.webview}
            />
          ) : (
            <Image
              source={{ uri: snapshotURI }}
              resizeMode="contain"
              style={styles.image}
              onError={() => setStatus("Erro no snapshot ‚Äî verifique /capture ou /snapshot")}
            />
          )
        ) : (
          <View style={styles.placeholder}>
            <Text style={{ color: PALETTE.text, opacity: 0.7, textAlign: "center" }}>
              Informe o IP e toque em ‚ÄúTestar‚Äù. A tela tenta automaticamente
              <Text> :81/stream ‚Üí /stream ‚Üí /capture.</Text>
            </Text>
          </View>
        )}
      </View>

      {isRunning ? (
        <View style={styles.footerRow}>
          <Pressable
            style={[styles.smallBtn, mode === "mjpeg" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("mjpeg"); setStatus("Tentando MJPEG /stream..."); }}
          >
            <Text style={styles.smallBtnText}>Usar MJPEG</Text>
          </Pressable>
          <Pressable
            style={[styles.smallBtn, mode === "snapshot" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("snapshot"); setStatus("Usando Snapshot (/capture)"); }}
          >
            <Text style={styles.smallBtnText}>Usar Snapshot</Text>
          </Pressable>
        </View>
      ) : null}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, gap: 12 },
  title: { color: PALETTE.text, fontSize: 20, fontWeight: "700" },
  row: { flexDirection: "row", alignItems: "center", gap: 8 },
  label: { color: PALETTE.text },
  input: {
    flex: 1, backgroundColor: PALETTE.card, color: PALETTE.text,
    borderWidth: 1, borderColor: PALETTE.border, borderRadius: 10,
    paddingHorizontal: 10, paddingVertical: 8,
  },
  button: { backgroundColor: PALETTE.accent, paddingHorizontal: 14, paddingVertical: 10, borderRadius: 10 },
  buttonText: { color: "#fff", fontWeight: "700" },
  status: { color: PALETTE.text, opacity: 0.9 },
  viewer: {
    flex: 1, backgroundColor: "#000", borderRadius: 12, overflow: "hidden",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  webview: { flex: 1, backgroundColor: "#000" },
  image: { width: "100%", height: "100%" },
  placeholder: { flex: 1, alignItems: "center", justifyContent: "center", padding: 24 },
  footerRow: { flexDirection: "row", gap: 10, justifyContent: "center" },
  smallBtn: {
    paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1,
    borderColor: PALETTE.border, backgroundColor: PALETTE.card,
  },
  smallBtnActive: { borderColor: PALETTE.accent },
  smallBtnText: { color: PALETTE.text, fontWeight: "600" },
});



Dicas r√°pidas




No navegador, confirme qual rota seu firmware exp√µe (geralmente http://IP:81/stream e http://IP/capture).


No Android, se ainda bloquear HTTP, ative usesCleartextTraffic="true" no Manifest (Expo Dev costuma permitir).


Se o stream abrir no navegador mas no app cair para snapshot, deixe em ‚ÄúUsar Snapshot‚Äù ‚Äî √© mais tolerante quando o firmware est√° reiniciando.

































Valeu pelo print ‚Äî o erro vem desta linha dentro do stream_handler:


snprintf(part_buf, sizeof(part_buf),
         "Content-Type: %s\r\n" _JPG_CONTENT_LENGTH "\r\n",
         _JPG_CONTENT_TYPE, fb->len);



Em C/C++ s√≥ d√° para ‚Äúcolar‚Äù literais de string. Como _JPG_CONTENT_LENGTH √© uma vari√°vel const char*, o compilador quebra. Vamos simplificar o handler e montar o cabe√ßalho numa √∫nica snprintf.


Abaixo est√° o firmware completo j√° corrigido (cole num sketch novo e grave). √â exatamente o mesmo que te mandei, mas com stream_handler reescrito e uns ajustes pequenos:


#include <WiFi.h>
#include "esp_camera.h"
#include "esp_timer.h"
#include "img_converters.h"
#include "esp_http_server.h"

// ================= WIFI =================
const char* WIFI_SSID  = "HydroBot";
const char* WIFI_PASS  = "loud2025emibr";

// ============ PINOS (AI Thinker) ============
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27

#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ============ HTTP SERVER ============
httpd_handle_t httpd_handle = NULL;

static void set_nocache(httpd_req_t *req) {
  httpd_resp_set_hdr(req, "Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Expires", "0");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
}

static esp_err_t status_handler(httpd_req_t *req) {
  set_nocache(req);
  char buf[96];
  snprintf(buf, sizeof(buf),
           "{\"ok\":true,\"ip\":\"%s\"}", WiFi.localIP().toString().c_str());
  httpd_resp_set_type(req, "application/json");
  return httpd_resp_send(req, buf, HTTPD_RESP_USE_STRLEN);
}

static esp_err_t jpg_handler(httpd_req_t *req) {
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) { httpd_resp_send_500(req); return ESP_FAIL; }
  set_nocache(req);
  httpd_resp_set_type(req, "image/jpeg");
  esp_err_t res = httpd_resp_send(req, (const char *)fb->buf, fb->len);
  esp_camera_fb_return(fb);
  return res;
}

static esp_err_t stream_handler(httpd_req_t *req) {
  // Cabe√ßalho MIME multipart (MJPEG)
  const char *STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";
  const char *BOUNDARY            = "\r\n--frame\r\n";
  httpd_resp_set_type(req, STREAM_CONTENT_TYPE);
  set_nocache(req);

  esp_err_t res = ESP_OK;
  while (true) {
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) { res = ESP_FAIL; break; }

    // --- boundary ---
    if ((res = httpd_resp_send_chunk(req, BOUNDARY, strlen(BOUNDARY))) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }

    // --- header do frame (Content-Type + Content-Length) ---
    char header[96];
    int hlen = snprintf(header, sizeof(header),
                        "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n", fb->len);
    if (hlen < 0 || hlen >= (int)sizeof(header)) { esp_camera_fb_return(fb); res = ESP_FAIL; break; }
    if ((res = httpd_resp_send_chunk(req, header, hlen)) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }

    // --- payload (JPEG) + CRLF ---
    if ((res = httpd_resp_send_chunk(req, (const char*)fb->buf, fb->len)) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }
    esp_camera_fb_return(fb);
    if ((res = httpd_resp_send_chunk(req, "\r\n", 2)) != ESP_OK) {
      break;
    }

    // respiro curto para evitar overrun
    vTaskDelay(pdMS_TO_TICKS(5));
  }

  // fecha chunked
  httpd_resp_send_chunk(req, NULL, 0);
  return res;
}

static void apply_sensor_defaults(sensor_t* s) {
  if (!s) return;
  s->set_framesize(s, FRAMESIZE_QVGA); // 320x240 est√°vel
  s->set_quality(s, 15);               // 10~15 boa qualidade; maior = mais leve
  s->set_vflip(s, 0);
  s->set_hmirror(s, 0);
}

static void startCameraServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 80;
  config.max_uri_handlers = 8;
  config.stack_size = 6144;

  httpd_uri_t root_uri   = { .uri="/",        .method=HTTP_GET, .handler=status_handler, .user_ctx=NULL };
  httpd_uri_t status_uri = { .uri="/status",  .method=HTTP_GET, .handler=status_handler, .user_ctx=NULL };
  httpd_uri_t snap_uri   = { .uri="/snapshot",.method=HTTP_GET, .handler=jpg_handler,    .user_ctx=NULL };
  httpd_uri_t stream_uri = { .uri="/stream",  .method=HTTP_GET, .handler=stream_handler, .user_ctx=NULL };

  if (httpd_start(&httpd_handle, &config) == ESP_OK) {
    httpd_register_uri_handler(httpd_handle, &root_uri);
    httpd_register_uri_handler(httpd_handle, &status_uri);
    httpd_register_uri_handler(httpd_handle, &snap_uri);
    httpd_register_uri_handler(httpd_handle, &stream_uri);
  }
}

void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println("\nBooting...");

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;

  config.xclk_freq_hz = 10000000; // 10 MHz est√°vel
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_QVGA;
  config.jpeg_quality = 15;
  config.fb_count     = 2;
  config.grab_mode    = CAMERA_GRAB_LATEST;
  config.fb_location  = CAMERA_FB_IN_PSRAM;

  if (!psramFound()) {
    Serial.println("PSRAM not found -> DRAM fallback");
    config.fb_location  = CAMERA_FB_IN_DRAM;
    config.fb_count     = 1;
    config.jpeg_quality = 18;
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed 0x%x, fallback...\n", err);
    config.xclk_freq_hz = 8000000;
    config.frame_size   = FRAMESIZE_QQVGA;
    config.jpeg_quality = 20;
    config.fb_count     = 1;
    err = esp_camera_init(&config);
    if (err != ESP_OK) {
      Serial.printf("Fallback failed 0x%x\n", err);
      while(true){ delay(1000); }
    }
  }
  apply_sensor_defaults(esp_camera_sensor_get());

  WiFi.setSleep(false);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) { delay(400); Serial.print("."); }
  Serial.printf("\nWiFi connected: %s\n", WiFi.localIP().toString().c_str());

  startCameraServer();
  Serial.println("HTTP server started");
  Serial.printf("Open: http://%s/stream\n", WiFi.localIP().toString().c_str());
}

void loop() { delay(1000); }



Depois de compilar/gravar:




Abra no navegador do celular: http://<IP>/stream.


No app, use o mesmo IP e toque Testar.




Se ainda aparecer reboot, reduza carga r√°pida:




troque FRAMESIZE_QVGA ‚Üí FRAMESIZE_QQVGA


aumente o vTaskDelay do stream_handler para 10‚Äì12 ms


confira a alimenta√ß√£o (5V ‚â• 1A).


























#include <WiFi.h>
#include "esp_camera.h"
#include "esp_timer.h"
#include "img_converters.h"
#include "esp_http_server.h"

// ================= WIFI =================
const char* WIFI_SSID  = "HydroBot";
const char* WIFI_PASS  = "loud2025emibr";

// ============ PINOS (AI Thinker) ============
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27

#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ============ HTTP SERVER ============
httpd_handle_t stream_httpd = NULL;
httpd_handle_t capture_httpd = NULL;

static void set_nocache(httpd_req_t *req) {
  httpd_resp_set_hdr(req, "Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Expires", "0");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
}

static esp_err_t status_handler(httpd_req_t *req) {
  set_nocache(req);
  char buf[96];
  snprintf(buf, sizeof(buf),
           "{\"ok\":true,\"ip\":\"%s\"}", WiFi.localIP().toString().c_str());
  httpd_resp_set_type(req, "application/json");
  return httpd_resp_send(req, buf, HTTPD_RESP_USE_STRLEN);
}

static esp_err_t jpg_handler(httpd_req_t *req) {
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) {
    httpd_resp_send_500(req);
    return ESP_FAIL;
  }
  set_nocache(req);
  httpd_resp_set_type(req, "image/jpeg");
  esp_err_t res = httpd_resp_send(req, (const char *)fb->buf, fb->len);
  esp_camera_fb_return(fb);
  return res;
}

static esp_err_t stream_handler(httpd_req_t *req) {
  static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";
  static const char* _STREAM_BOUNDARY = "\r\n--frame\r\n";
  static const char* _JPG_CONTENT_TYPE = "image/jpeg";
  static const char* _JPG_CONTENT_LENGTH = "Content-Length: %u\r\n";
  esp_err_t res = ESP_OK;

  set_nocache(req);
  httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);

  while (true) {
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) { res = ESP_FAIL; break; }

    char part_buf[64];
    size_t hlen = snprintf(part_buf, sizeof(part_buf),
                           "Content-Type: %s\r\n" _JPG_CONTENT_LENGTH "\r\n",
                           _JPG_CONTENT_TYPE, fb->len);

    if ((res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY))) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }
    if ((res = httpd_resp_send_chunk(req, part_buf, hlen)) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }
    if ((res = httpd_resp_send_chunk(req, (const char *)fb->buf, fb->len)) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }
    esp_camera_fb_return(fb);

    if ((res = httpd_resp_send_chunk(req, "\r\n", 2)) != ESP_OK) {
      break;
    }

    // respiro curto para evitar overrun em cenas complexas
    vTaskDelay(pdMS_TO_TICKS(5));
  }

  // fecha chunked
  httpd_resp_send_chunk(req, NULL, 0);
  return res;
}

static void apply_sensor_defaults(sensor_t* s) {
  if (!s) return;
  // perfil est√°vel
  s->set_framesize(s, FRAMESIZE_QVGA);  // 320x240
  s->set_quality(s, 15);                // menor = melhor qualidade (10~15 bom)
  s->set_vflip(s, 0);
  s->set_hmirror(s, 0);
  s->set_brightness(s, 0);
  s->set_saturation(s, 0);
}

static void startCameraServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 80;
  config.max_uri_handlers = 8;
  config.stack_size = 6144; // suficiente para handlers

  // /snapshot e /status no servidor principal
  httpd_uri_t status_uri = { .uri="/status", .method=HTTP_GET, .handler=status_handler, .user_ctx=NULL };
  httpd_uri_t still_uri  = { .uri="/snapshot", .method=HTTP_GET, .handler=jpg_handler, .user_ctx=NULL };
  httpd_uri_t stream_uri = { .uri="/stream", .method=HTTP_GET, .handler=stream_handler, .user_ctx=NULL };

  if (httpd_start(&capture_httpd, &config) == ESP_OK) {
    httpd_register_uri_handler(capture_httpd, &status_uri);
    httpd_register_uri_handler(capture_httpd, &still_uri);
    httpd_register_uri_handler(capture_httpd, &stream_uri);
  }
}

void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println("\nBooting...");

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;

  // XCLK moderado (10 MHz) para evitar instabilidade
  config.xclk_freq_hz = 10000000;
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_QVGA;
  config.jpeg_quality = 15;
  config.fb_count     = 2;
  config.grab_mode    = CAMERA_GRAB_LATEST;
  config.fb_location  = CAMERA_FB_IN_PSRAM;

  if (!psramFound()) {
    config.fb_location  = CAMERA_FB_IN_DRAM;
    config.fb_count     = 1;
    config.jpeg_quality = 18;
    Serial.println("PSRAM not found -> using DRAM fallback");
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed 0x%x, trying safer fallback...\n", err);
    // fallback ainda mais leve
    config.xclk_freq_hz = 8000000;
    config.frame_size   = FRAMESIZE_QQVGA; // 160x120
    config.jpeg_quality = 20;
    config.fb_count     = 1;
    err = esp_camera_init(&config);
    if (err != ESP_OK) {
      Serial.printf("Fallback failed 0x%x\n", err);
      while(true){ delay(1000); }
    }
  }
  apply_sensor_defaults(esp_camera_sensor_get());

  WiFi.setSleep(false);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) {
    delay(400); Serial.print(".");
  }
  Serial.printf("\nWiFi connected: %s\n", WiFi.localIP().toString().c_str());

  startCameraServer();
  Serial.println("HTTP server started");
  Serial.printf("Open: http://%s/stream\n", WiFi.localIP().toString().c_str());
}

void loop() {
  delay(1000);
}

























Perfeito ‚Äî vamos simplificar tudo para ‚Äúapp ‚áÑ ESP32-CAM direto‚Äù, sem servidor intermedi√°rio nem detec√ß√£o. Abaixo vai:




CameraScreen.tsx (apenas ajustes m√≠nimos pra Android/WebView aceitar HTTP e MJPEG)


Firmware ESP32-CAM minimalista com rotas /stream, /snapshot e /status est√°veis, resolu√ß√£o segura (QVGA), duplo buffer e backoff ‚Äî ideal pra parar com travamentos/overflow.





1) src/screens/CameraScreen.tsx (substitua o arquivo todo)


Principais mudan√ßas:




mixedContentMode="always" no WebView (Android bloqueia HTTP claro por padr√£o).


androidHardwareAccelerationEnabled e setSupportMultipleWindows={false} s√≥ pra estabilidade.


Mantive sua l√≥gica de fallback para /snapshot sem alterar o resto.




// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  Image,
  AppState,
  AppStateStatus,
} from "react-native";
import { WebView } from "react-native-webview";

type Mode = "mjpeg" | "snapshot";
const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", accent: "#e6403a", text: "#e5e7eb" };

export default function CameraScreen() {
  const [ip, setIp] = useState<string>("192.168.4.1");
  const [testedIp, setTestedIp] = useState<string>("");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [status, setStatus] = useState<string>("Aguardando IP");
  const [snapTick, setSnapTick] = useState<number>(0);
  const [isRunning, setIsRunning] = useState<boolean>(false);
  const snapTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const appState = useRef<AppStateStatus>(AppState.currentState);

  const streamURL = useMemo(() => (testedIp ? `http://${testedIp}/stream` : ""), [testedIp]);
  const snapshotURL = useMemo(
    () => (testedIp ? `http://${testedIp}/snapshot?_=${snapTick}` : ""),
    [testedIp, snapTick]
  );
  const healthURL = useMemo(() => (testedIp ? `http://${testedIp}/status` : ""), [testedIp]);

  const startSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) return;
    snapTimerRef.current = setInterval(() => setSnapTick((t) => (t + 1) % 1_000_000), 150);
  }, []);
  const stopSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) {
      clearInterval(snapTimerRef.current);
      snapTimerRef.current = null;
    }
  }, []);

  useEffect(() => {
    if (mode === "snapshot" && testedIp) startSnapshotLoop();
    else stopSnapshotLoop();
    return stopSnapshotLoop;
  }, [mode, testedIp, startSnapshotLoop, stopSnapshotLoop]);

  useEffect(() => {
    const sub = AppState.addEventListener("change", (nextState) => {
      const prev = appState.current;
      appState.current = nextState;
      if (prev.match(/active/) && nextState.match(/inactive|background/)) {
        stopSnapshotLoop();
        setIsRunning(false);
      } else if (prev.match(/inactive|background/) && nextState === "active") {
        if (mode === "snapshot" && testedIp) startSnapshotLoop();
        if (testedIp) setIsRunning(true);
      }
    });
    return () => sub.remove();
  }, [mode, testedIp, startSnapshotLoop, stopSnapshotLoop]);

  const testConnection = useCallback(async () => {
    const target = (ip || "").trim();
    if (!target) {
      setStatus("Informe o IP do ESP");
      return;
    }
    setStatus("Testando conex√£o...");
    setIsRunning(false);
    stopSnapshotLoop();

    // Primeiro tenta /status (r√°pido)
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/status`, { signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("mjpeg");
        setStatus("Conectado (tentando MJPEG)...");
        setIsRunning(true);
        return;
      }
    } catch {}

    // Tenta /stream
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/stream`, { method: "GET", signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("mjpeg");
        setStatus("Conectado (MJPEG)...");
        setIsRunning(true);
        return;
      }
    } catch {}

    // Fallback /snapshot
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/snapshot`, { method: "GET", signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("snapshot");
        setStatus("Conectado (Snapshot cont√≠nuo)...");
        setIsRunning(true);
        startSnapshotLoop();
        return;
      }
    } catch {}

    setStatus("Falha ao conectar. Verifique IP/rede/firmware.");
    setIsRunning(false);
  }, [ip, startSnapshotLoop, stopSnapshotLoop]);

  const mjpegHTML = useMemo(() => {
    if (!streamURL) return "";
    return `
      <!doctype html>
      <html><head><meta name="viewport" content="width=device-width, initial-scale=1" />
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;overflow:hidden;}
        #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;}
        img{max-width:100vw;max-height:100vh;object-fit:contain;}
        #badge{position:fixed;left:8px;bottom:8px;padding:4px 8px;border-radius:8px;
               background:#121218;color:#e5e7eb;font-family:system-ui,Arial,sans-serif;font-size:12px;opacity:.7}
      </style></head>
      <body>
        <div id="wrap"><img id="mjpeg" src="${streamURL}" /></div>
        <div id="badge">Stream: ${streamURL}</div>
        <script>
          const img = document.getElementById('mjpeg');
          let retryMs = 800;
          img.addEventListener('error', () => {
            setTimeout(() => { img.src = '${streamURL}' + '?_=' + Date.now(); }, retryMs);
            retryMs = Math.min(retryMs * 2, 4000);
          });
        </script>
      </body></html>
    `.trim();
  }, [streamURL]);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>ESP32-CAM Viewer</Text>

      <View style={styles.row}>
        <Text style={styles.label}>ESP IP</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="ex.: 192.168.4.1"
          placeholderTextColor="#6b7280"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
        />
        <Pressable style={styles.button} onPress={testConnection}>
          <Text style={styles.buttonText}>Testar</Text>
        </Pressable>
      </View>

      <Text style={styles.status}>
        Status: {status} {testedIp ? `| IP: ${testedIp}` : ""}
        {testedIp ? ` | Modo: ${mode}` : ""}
      </Text>

      <View style={styles.viewer}>
        {testedIp && isRunning ? (
          mode === "mjpeg" ? (
            <WebView
              originWhitelist={["*"]}
              source={{ html: mjpegHTML, baseUrl: `http://${testedIp}` }}
              javaScriptEnabled
              domStorageEnabled
              allowsInlineMediaPlayback
              allowsFullscreenVideo={false}
              mediaPlaybackRequiresUserAction={false}
              mixedContentMode="always"
              androidHardwareAccelerationEnabled
              setSupportMultipleWindows={false}
              onError={() => {
                setMode("snapshot");
                setStatus("MJPEG falhou ‚Äî alternando para Snapshot...");
              }}
              style={styles.webview}
            />
          ) : (
            <Image
              source={{ uri: snapshotURL }}
              resizeMode="contain"
              style={styles.image}
              onError={() => setStatus("Erro no snapshot ‚Äî checar conex√£o")}
            />
          )
        ) : (
          <View style={styles.placeholder}>
            <Text style={{ color: PALETTE.text, opacity: 0.7, textAlign: "center" }}>
              Informe o IP e toque em ‚ÄúTestar‚Äù para iniciar o v√≠deo.
            </Text>
          </View>
        )}
      </View>

      {testedIp ? (
        <View style={styles.footerRow}>
          <Pressable
            style={[styles.smallBtn, mode === "mjpeg" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("mjpeg"); setStatus("Tentando MJPEG /stream..."); }}
          >
            <Text style={styles.smallBtnText}>Usar MJPEG</Text>
          </Pressable>
          <Pressable
            style={[styles.smallBtn, mode === "snapshot" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("snapshot"); setStatus("Usando /snapshot cont√≠nuo..."); }}
          >
            <Text style={styles.smallBtnText}>Usar Snapshot</Text>
          </Pressable>
        </View>
      ) : null}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, gap: 12 },
  title: { color: PALETTE.text, fontSize: 20, fontWeight: "700" },
  row: { flexDirection: "row", alignItems: "center", gap: 8 },
  label: { color: PALETTE.text },
  input: {
    flex: 1,
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderWidth: 1,
    borderColor: PALETTE.border,
    borderRadius: 10,
    paddingHorizontal: 10,
    paddingVertical: 8,
  },
  button: { backgroundColor: PALETTE.accent, paddingHorizontal: 14, paddingVertical: 10, borderRadius: 10 },
  buttonText: { color: "#fff", fontWeight: "700" },
  status: { color: PALETTE.text, opacity: 0.9 },
  viewer: {
    flex: 1, backgroundColor: "#000", borderRadius: 12, overflow: "hidden",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  webview: { flex: 1, backgroundColor: "#000" },
  image: { width: "100%", height: "100%" },
  placeholder: { flex: 1, alignItems: "center", justifyContent: "center", padding: 24 },
  footerRow: { flexDirection: "row", gap: 10, justifyContent: "center" },
  smallBtn: {
    paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1,
    borderColor: PALETTE.border, backgroundColor: PALETTE.card,
  },
  smallBtnActive: { borderColor: PALETTE.accent },
  smallBtnText: { color: PALETTE.text, fontWeight: "600" },
});





Obs. importante (Android Manifest): se seu app n√£o abre HTTP claro, garanta usesCleartextTraffic="true" (Expo/Dev geralmente j√° permite). Como voc√™ est√° usando fetch("http://...") no testConnection, isso tamb√©m depende desse flag.





2) Firmware ESP32-CAM minimalista (apenas ‚Äúmostrar c√¢mera‚Äù)




Rotas:



GET /stream ‚Üí MJPEG (multipart/x-mixed-replace)


GET /snapshot ‚Üí JPEG √∫nico


GET /status ‚Üí JSON simplificado






Estabilidade: QVGA, jpeg_quality=15, fb_count=2, grab_mode=CAMERA_GRAB_LATEST, WiFi.setSleep(false) e pequeno backoff entre frames do stream.


CORS: Access-Control-Allow-Origin: * (para seu fetch/Image/WebView n√£o toparem CORS).


Pins: usa seu board_config.h. Certifique-se que ele est√° para AI Thinker (ou seu m√≥dulo).




Cole no seu projeto como HydrobotCam_Minimal.ino:


#include "esp_camera.h"
#include <WiFi.h>
#include <WebServer.h>

// ====== CONFIG WIFI ======
const char* ssid     = "HydroBot";
const char* password = "loud2025emibr";

// ====== CAMERA PINS via board_config.h ======
#include "board_config.h"

// ====== SERVIDOR ======
WebServer server(80);

// ====== AJUSTES CAMERA ======
static void apply_sensor_tweaks(sensor_t* s) {
  if (!s) return;
  // Ajustes comuns pra estabilizar cores e flip conforme m√≥dulo
  if (s->id.PID == OV3660_PID) {
    s->set_vflip(s, 1);
    s->set_brightness(s, 1);
    s->set_saturation(s, -2);
  }
  // Resolu√ß√£o segura p/ estabilidade (pode subir p/ VGA se quiser)
  s->set_framesize(s, FRAMESIZE_QVGA);
  s->set_quality(s, 15); // 10=melhor qualidade; 15-20=mais leve
  s->set_colorbar(s, 0);
}

// ====== HEADERS CORS/NO-CACHE ======
static void set_no_cache_headers() {
  server.sendHeader("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  server.sendHeader("Access-Control-Allow-Origin", "*");
}

// ====== HANDLERS ======
void handle_status() {
  set_no_cache_headers();
  String json = "{";
  json += "\"ok\":true,";
  json += "\"ip\":\"" + WiFi.localIP().toString() + "\"";
  json += "}";
  server.send(200, "application/json", json);
}

void handle_snapshot() {
  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb) {
    set_no_cache_headers();
    server.send(503, "text/plain", "NO_FRAME");
    return;
  }
  set_no_cache_headers();
  server.setContentLength(fb->len);
  server.send(200, "image/jpeg", "");
  WiFiClient client = server.client();
  client.write(fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

void handle_stream() {
  WiFiClient client = server.client();
  const char* _boundary = "frame";
  String hdr = 
    "HTTP/1.1 200 OK\r\n"
    "Access-Control-Allow-Origin: *\r\n"
    "Cache-Control: no-store, no-cache, must-revalidate, max-age=0\r\n"
    "Pragma: no-cache\r\n"
    "Connection: close\r\n"
    "Content-Type: multipart/x-mixed-replace; boundary=" + String(_boundary) + "\r\n\r\n";
  client.print(hdr);

  // Loop de streaming
  while (client.connected()) {
    camera_fb_t* fb = esp_camera_fb_get();
    if (!fb) {
      delay(5);
      continue;
    }
    client.print("--"); client.print(_boundary); client.print("\r\n");
    client.print("Content-Type: image/jpeg\r\n");
    client.print("Content-Length: "); client.print(fb->len); client.print("\r\n\r\n");
    client.write(fb->buf, fb->len);
    client.print("\r\n");
    esp_camera_fb_return(fb);

    // pequeno respiro pra reduzir overrun em cenas complexas
    delay(5);
  }
}

void handle_root() {
  set_no_cache_headers();
  server.send(200, "text/plain", "ESP32-CAM OK. Rotas: /status, /snapshot, /stream");
}

// ====== SETUP ======
void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println("\nBooting...");

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;

  // XCLK mais baixo ajuda a estabilidade (8~10 MHz); 20 MHz d√° mais fps mas pode estourar buffer
  config.xclk_freq_hz = 10000000; // 10 MHz est√°vel
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_QVGA;
  config.jpeg_quality = 15;
  config.fb_count     = 2;
  config.grab_mode    = CAMERA_GRAB_LATEST;
  config.fb_location  = CAMERA_FB_IN_PSRAM;

  if (!psramFound()) {
    // Sem PSRAM, adapta
    config.fb_count    = 1;
    config.fb_location = CAMERA_FB_IN_DRAM;
    config.jpeg_quality = 18;
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed 0x%x\n", err);
    // Tenta fallback leve
    config.xclk_freq_hz = 8000000;
    config.frame_size   = FRAMESIZE_QQVGA;
    err = esp_camera_init(&config);
    if (err != ESP_OK) {
      Serial.printf("Camera init fallback failed 0x%x\n", err);
      while (true) { delay(1000); }
    }
  }

  apply_sensor_tweaks(esp_camera_sensor_get());

  WiFi.begin(ssid, password);
  WiFi.setSleep(false);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.printf("\nWiFi connected: %s\n", WiFi.localIP().toString().c_str());

  // Rotas
  server.on("/", handle_root);
  server.on("/status", HTTP_GET, handle_status);
  server.on("/snapshot", HTTP_GET, handle_snapshot);
  server.on("/stream", HTTP_GET, handle_stream);
  server.begin();

  Serial.println("HTTP server started");
  Serial.printf("Use http://%s/stream\n", WiFi.localIP().toString().c_str());
}

void loop() {
  server.handleClient();
}



Notas r√°pidas




Se quiser mais qualidade ap√≥s confirmar estabilidade, suba para FRAMESIZE_VGA ou melhore jpeg_quality (ex.: 12). Fa√ßa um ajuste por vez.


Se ainda notar ‚Äúsensibilidade‚Äù quando a cena tem muito detalhe, aumente delay(5) do stream para delay(8~12); isso reduz taxa de quadros, mas evita overflow.


Se sua build anterior usava /stream na porta 81, este firmware usa porta 80 (padr√£o HTTP). No app eu j√° aponto para http://IP/stream (sem porta), ent√£o tudo certo.





Como testar (sequ√™ncia curtinha)




Grave o firmware no ESP32-CAM. Abra o Serial Monitor e pegue o IP que ele imprime.


No app, abra a tela C√¢mera, coloque o IP (ex.: 192.168.4.1 ou o IP que o serial mostrou) e toque Testar.


Deve entrar em MJPEG. Se falhar (rede oscilando), o bot√£o Usar Snapshot funciona como fallback imediato.




Se algo ainda n√£o aparecer:




Confirme se consegue abrir http://SEU_IP/stream no navegador do celular (mesma rede).


Se o WebView abrir ‚Äúvazio‚Äù no Android, verifique o usesCleartextTraffic="true" no Manifest do app.




Pronto ‚Äî agora √© s√≥ stream direto, sem heur√≠stica nem proxy.

















































// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  Image,
  AppState,
  AppStateStatus,
} from "react-native";
import { WebView } from "react-native-webview";

type Mode = "mjpeg" | "snapshot";

const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", accent: "#e6403a", text: "#e5e7eb" };

export default function CameraScreen() {
  const [ip, setIp] = useState<string>("192.168.4.1"); // ajuste para seu IP (ou mDNS se usar proxy)
  const [testedIp, setTestedIp] = useState<string>(""); // IP efetivo em uso na visualiza√ß√£o
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [status, setStatus] = useState<string>("Aguardando IP");
  const [snapTick, setSnapTick] = useState<number>(0);
  const [isRunning, setIsRunning] = useState<boolean>(false);
  const snapTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const appState = useRef<AppStateStatus>(AppState.currentState);

  const streamURL = useMemo(() => (testedIp ? `http://${testedIp}/stream` : ""), [testedIp]);
  const snapshotURL = useMemo(
    () => (testedIp ? `http://${testedIp}/snapshot?_=${snapTick}` : ""),
    [testedIp, snapTick]
  );
  const healthURL = useMemo(() => (testedIp ? `http://${testedIp}/status` : ""), [testedIp]);

  // ---- Controle do modo snapshot (polling) ----
  const startSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) return;
    snapTimerRef.current = setInterval(() => setSnapTick((t) => (t + 1) % 1_000_000), 150); // ~6-7 FPS
  }, []);

  const stopSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) {
      clearInterval(snapTimerRef.current);
      snapTimerRef.current = null;
    }
  }, []);

  useEffect(() => {
    if (mode === "snapshot" && testedIp) {
      startSnapshotLoop();
    } else {
      stopSnapshotLoop();
    }
    return stopSnapshotLoop;
  }, [mode, testedIp, startSnapshotLoop, stopSnapshotLoop]);

  // Pausar quando app em background (evita consumo)
  useEffect(() => {
    const sub = AppState.addEventListener("change", (nextState) => {
      const prev = appState.current;
      appState.current = nextState;
      if (prev.match(/active/) && nextState.match(/inactive|background/)) {
        stopSnapshotLoop();
        setIsRunning(false);
      } else if (prev.match(/inactive|background/) && nextState === "active") {
        if (mode === "snapshot" && testedIp) startSnapshotLoop();
        if (testedIp) setIsRunning(true);
      }
    });
    return () => sub.remove();
  }, [mode, testedIp, startSnapshotLoop, stopSnapshotLoop]);

  // ---- Teste de conex√£o e fallback autom√°tico ----
  const testConnection = useCallback(async () => {
    const target = (ip || "").trim();
    if (!target) {
      setStatus("Informe o IP do ESP");
      return;
    }
    setStatus("Testando conex√£o...");
    setIsRunning(false);
    stopSnapshotLoop();

    // 1) Tenta um GET r√°pido no /status (se existir)
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/status`, { signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("mjpeg");
        setStatus("Conectado (tentando MJPEG)...");
        setIsRunning(true);
        return;
      }
    } catch (_) {
      // segue para checar /stream e /snapshot
    }

    // 2) Checa se /stream responde pelo menos com headers
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/stream`, { method: "GET", signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("mjpeg");
        setStatus("Conectado (MJPEG)...");
        setIsRunning(true);
        return;
      }
    } catch (_) {
      // segue
    }

    // 3) Fallback: tenta /snapshot
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/snapshot`, { method: "GET", signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("snapshot");
        setStatus("Conectado (Snapshot cont√≠nuo)...");
        setIsRunning(true);
        startSnapshotLoop();
        return;
      }
    } catch (_) {
      // segue
    }

    setStatus("Falha ao conectar. Verifique IP/rede/firmware.");
    setIsRunning(false);
  }, [ip, startSnapshotLoop, stopSnapshotLoop]);

  // ---- UI MJPEG via WebView (funciona bem no Android) ----
  const mjpegHTML = useMemo(() => {
    if (!streamURL) return "";
    // HTML simples que carrega o MJPEG e tenta auto-reconectar em caso de erro
    return `
      <!doctype html>
      <html><head><meta name="viewport" content="width=device-width, initial-scale=1" />
      <style>
        html,body{margin:0;padding:0;background:#0b0b0f;height:100%;overflow:hidden;}
        #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;}
        img{max-width:100vw;max-height:100vh;object-fit:contain;}
        #badge{position:fixed;left:8px;bottom:8px;padding:4px 8px;border-radius:8px;
               background:#121218;color:#e5e7eb;font-family:system-ui,Arial,sans-serif;font-size:12px;opacity:.7}
      </style></head>
      <body>
        <div id="wrap">
          <img id="mjpeg" src="${streamURL}" />
        </div>
        <div id="badge">Stream: ${streamURL}</div>
        <script>
          const img = document.getElementById('mjpeg');
          let retryMs = 1000;
          img.addEventListener('error', () => {
            setTimeout(() => {
              img.src = '${streamURL}' + '?_=' + Date.now();
            }, retryMs);
            retryMs = Math.min(retryMs * 2, 5000);
          });
        </script>
      </body></html>
    `.trim();
  }, [streamURL]);

  // ---- Render ----
  return (
    <View style={styles.container}>
      <Text style={styles.title}>ESP32-CAM Viewer</Text>

      <View style={styles.row}>
        <Text style={styles.label}>ESP IP</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="ex.: 192.168.4.1"
          placeholderTextColor="#6b7280"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
        />
        <Pressable style={styles.button} onPress={testConnection}>
          <Text style={styles.buttonText}>Testar</Text>
        </Pressable>
      </View>

      <Text style={styles.status}>
        Status: {status} {testedIp ? `| IP: ${testedIp}` : ""}
        {testedIp ? ` | Modo: ${mode}` : ""}
      </Text>

      <View style={styles.viewer}>
        {testedIp && isRunning ? (
          mode === "mjpeg" ? (
            <WebView
              originWhitelist={["*"]}
              source={{ html: mjpegHTML, baseUrl: `http://${testedIp}` }}
              javaScriptEnabled
              domStorageEnabled
              allowsInlineMediaPlayback
              allowsFullscreenVideo={false}
              mediaPlaybackRequiresUserAction={false}
              onError={() => {
                // Cai para snapshot se o WebView reportar erro
                setMode("snapshot");
                setStatus("MJPEG falhou ‚Äî alternando para Snapshot...");
              }}
              style={styles.webview}
            />
          ) : (
            <Image
              source={{ uri: snapshotURL }}
              resizeMode="contain"
              style={styles.image}
              onError={() => setStatus("Erro no snapshot ‚Äî checar conex√£o")}
            />
          )
        ) : (
          <View style={styles.placeholder}>
            <Text style={{ color: PALETTE.text, opacity: 0.7, textAlign: "center" }}>
              Informe o IP e toque em ‚ÄúTestar‚Äù para iniciar o v√≠deo.
            </Text>
          </View>
        )}
      </View>

      {testedIp ? (
        <View style={styles.footerRow}>
          <Pressable
            style={[styles.smallBtn, mode === "mjpeg" ? styles.smallBtnActive : null]}
            onPress={() => {
              setMode("mjpeg");
              setStatus("Tentando MJPEG /stream...");
            }}
          >
            <Text style={styles.smallBtnText}>Usar MJPEG</Text>
          </Pressable>
          <Pressable
            style={[styles.smallBtn, mode === "snapshot" ? styles.smallBtnActive : null]}
            onPress={() => {
              setMode("snapshot");
              setStatus("Usando /snapshot cont√≠nuo...");
            }}
          >
            <Text style={styles.smallBtnText}>Usar Snapshot</Text>
          </Pressable>
        </View>
      ) : null}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, gap: 12 },
  title: { color: PALETTE.text, fontSize: 20, fontWeight: "700" },
  row: { flexDirection: "row", alignItems: "center", gap: 8 },
  label: { color: PALETTE.text },
  input: {
    flex: 1,
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderWidth: 1,
    borderColor: PALETTE.border,
    borderRadius: 10,
    paddingHorizontal: 10,
    paddingVertical: 8,
  },
  button: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 10,
  },
  buttonText: { color: "#fff", fontWeight: "700" },
  status: { color: PALETTE.text, opacity: 0.9 },
  viewer: {
    flex: 1,
    backgroundColor: "#000",
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  webview: { flex: 1, backgroundColor: "#000" },
  image: { width: "100%", height: "100%" },
  placeholder: { flex: 1, alignItems: "center", justifyContent: "center", padding: 24 },
  footerRow: { flexDirection: "row", gap: 10, justifyContent: "center" },
  smallBtn: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: PALETTE.card,
  },
  smallBtnActive: { borderColor: PALETTE.accent },
  smallBtnText: { color: PALETTE.text, fontWeight: "600" },
});














#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HydroBot Server (EST√ÅVEL) ‚Äì L√™ /stream (MJPEG) do ESP32-CAM, guarda o √∫ltimo frame,
serve /frame.jpg e calcula score simples de fogo (HSV + EMA).

Rodar:
  uvicorn server_heuristic:app --host 0.0.0.0 --port 8000
Deps:
  pip install fastapi uvicorn requests opencv-python numpy pydantic
"""

import time
import threading
from typing import Optional, Dict, Any
import re

import requests
import cv2
import numpy as np
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ========= CONFIG =========
CAMERA_IP = "hydrobot.local"
STREAM_URL_FMT = "http://{}/stream"
CONNECT_TIMEOUT = 3.0
READ_TIMEOUT = 10.0
MAX_FRAME_AGE_MS = 10_000
MAX_RESULT_AGE_MS = 800
JPEG_QUALITY = 85

# Fire (HSV simples)
HSV_LOW = (8, 70, 120)
HSV_HIGH = (40, 255, 255)
EMA_ALPHA = 0.3
FIRE_THRESHOLD = 0.15

BOUNDARY_RE = re.compile(br'--[^\r\n]+')
REQ_HEADERS = {"Connection": "keep-alive", "User-Agent": "HydroBot-Grabber/3.0"}

# ========= FASTAPI =========
app = FastAPI(title="HydroBot Server (Stable)", version="4.0")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True,
                   allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
  camera_ip: str

def placeholder_jpeg(msg: str = "NO FRAME") -> bytes:
  img = np.zeros((240, 320, 3), dtype=np.uint8)
  img[:, :] = (50, 50, 150)
  cv2.putText(img, msg, (38, 130), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
  cv2.putText(img, time.strftime("%H:%M:%S"), (38, 180), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
  ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY])
  return buf.tobytes()

# ========= MJPEG Stream Grabber =========
class StreamGrabber:
  def __init__(self, ip: str):
    self.ip = ip
    self._stop = threading.Event()
    self._lock = threading.Lock()
    self._last_jpeg: Optional[bytes] = None
    self._last_ts = 0
    self._fps_in = 0.0
    self._frames = 0
    self._tick = time.time()
    self._last_err: Optional[str] = None

  def start(self):
    self._stop.clear()
    t = threading.Thread(target=self._run, daemon=True)
    t.start()

  def stop(self):
    self._stop.set()

  def _run(self):
    while not self._stop.is_set():
      url = STREAM_URL_FMT.format(self.ip)
      buf = b""
      try:
        with requests.get(url, stream=True, timeout=(CONNECT_TIMEOUT, READ_TIMEOUT), headers=REQ_HEADERS) as r:
          r.raise_for_status()
          for chunk in r.iter_content(chunk_size=4096):
            if self._stop.is_set():
              break
            if not chunk:
              continue
            buf += chunk

            # procurar boundaries e extrair o pen√∫ltimo part (frame completo)
            m = BOUNDARY_RE.search(buf)
            if not m:
              if len(buf) > 2_000_000:
                buf = buf[-200_000:]
              continue

            parts = BOUNDARY_RE.split(buf)
            if len(parts) >= 2:
              frame_blob = parts[-2]
              buf = parts[-1]

              header_end = frame_blob.find(b"\r\n\r\n")
              if header_end == -1:
                continue
              body = frame_blob[header_end+4:]

              if body.startswith(b"\xff\xd8") and body.endswith(b"\xff\xd9"):
                with self._lock:
                  self._last_jpeg = body
                  self._last_ts = int(time.time()*1000)
                  self._last_err = None
                  self._frames += 1
                  now = time.time()
                  if now - self._tick >= 1.0:
                    self._fps_in = self._frames / (now - self._tick)
                    self._frames = 0
                    self._tick = now

      except Exception as e:
        with self._lock:
          self._last_err = str(e)
        time.sleep(0.8)  # backoff curto e reconecta

  def get_latest(self, max_age_ms=MAX_FRAME_AGE_MS) -> Optional[bytes]:
    with self._lock:
      if not self._last_jpeg:
        return None
      if int(time.time()*1000) - self._last_ts > max_age_ms:
        return None
      return self._last_jpeg

  def status(self) -> Dict[str, Any]:
    with self._lock:
      age = int(time.time()*1000) - self._last_ts if self._last_ts else None
      return {
        "ip": self.ip,
        "hasFrame": self._last_jpeg is not None,
        "age_ms": age,
        "fps_in": round(self._fps_in, 2),
        "last_err": self._last_err
      }

grabber = StreamGrabber(CAMERA_IP)
grabber.start()

# ========= Fire Detection =========
def simple_fire_score(frame_bgr: np.ndarray) -> float:
  try:
    hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))
    fire_ratio = float(np.count_nonzero(mask)) / float(mask.size)
    v_mean = float(np.mean(hsv[:, :, 2])) / 255.0
    score = min(1.0, fire_ratio * 4.0 + v_mean * 0.1)
    return float(score)
  except Exception:
    return 0.0

class FireDetector:
  def __init__(self, src: StreamGrabber):
    self.src = src
    self._lock = threading.Lock()
    self._stop = threading.Event()
    self._thr: Optional[threading.Thread] = None

    self._ema = 0.0
    self._raw = 0.0
    self._is_fire = False
    self._ts = 0
    self._fps = 0.0
    self._frames = 0
    self._tick = time.time()
    self._wh: Optional[tuple] = None

  def start(self):
    self._stop.clear()
    self._thr = threading.Thread(target=self._run, daemon=True)
    self._thr.start()

  def stop(self):
    self._stop.set()
    if self._thr and self._thr.is_alive():
      self._thr.join(timeout=1.0)

  def _run(self):
    interval = 1.0 / 5.0
    while not self._stop.is_set():
      t0 = time.time()
      jpeg = self.src.get_latest()
      if jpeg is None:
        time.sleep(0.1)
        continue
      try:
        frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
        if frame is None:
          time.sleep(0.05)
          continue
        H, W = frame.shape[:2]
        score = simple_fire_score(frame)
        ema = score if self._ema == 0.0 else EMA_ALPHA*score + (1.0-EMA_ALPHA)*self._ema
        is_fire = (ema >= FIRE_THRESHOLD)
        with self._lock:
          self._raw = score
          self._ema = ema
          self._is_fire = is_fire
          self._ts = int(time.time()*1000)
          self._wh = (W, H)
          self._frames += 1
          now = time.time()
          if now - self._tick >= 1.0:
            self._fps = self._frames / (now - self._tick)
            self._frames = 0
            self._tick = now
      except Exception:
        pass
      dt = time.time() - t0
      time.sleep(max(0.0, interval - dt))

  def get(self) -> Dict[str, Any]:
    with self._lock:
      return {
        "ok": True,
        "isFire": bool(self._is_fire),
        "score": round(float(self._ema), 3),
        "score_raw": round(float(self._raw), 3),
        "ts": int(self._ts),
        "fps_det": round(float(self._fps), 2),
        "frame_wh": list(self._wh) if self._wh else None
      }

detector = FireDetector(grabber)
detector.start()

# ========= Endpoints =========
@app.get("/healthz")
def healthz():
  s = grabber.status()
  return {"ok": True, "camera_ip": s.get("ip"), **s}

@app.get("/status")
def status():
  s = grabber.status()
  d = detector.get()
  return {"ok": True, "camera_ip": s.get("ip"), **s, **d}

@app.post("/config")
def set_config(cfg: ConfigIn):
  global CAMERA_IP, grabber, detector
  CAMERA_IP = cfg.camera_ip
  # reinicia o grabber
  grabber.stop()
  grabber = StreamGrabber(CAMERA_IP)
  grabber.start()
  # detector continua usando o mesmo objeto? recria para limpar estado
  detector.stop()
  detector = FireDetector(grabber)
  detector.start()
  return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
  b = grabber.get_latest() or placeholder_jpeg("NO FRAME")
  headers = {
    "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
    "Pragma": "no-cache",
    "Expires": "0",
    "Content-Type": "image/jpeg"
  }
  return Response(content=b, headers=headers, media_type="image/jpeg")

@app.get("/frame.jpg")
def frame_jpg():
  return snapshot()

@app.get("/detect")
def detect():
  res = detector.get()
  if res.get("ts", 0) and (int(time.time()*1000) - int(res["ts"]) <= MAX_RESULT_AGE_MS):
    return res
  # fallback r√°pido
  jpeg = grabber.get_latest()
  if jpeg is None:
    return {"ok": False, "error": "no recent frame"}
  frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
  if frame is None:
    return {"ok": False, "error": "decode failed"}
  score = simple_fire_score(frame)
  is_fire = (score >= FIRE_THRESHOLD)
  H, W = frame.shape[:2]
  return {
    "ok": True,
    "isFire": bool(is_fire),
    "score": round(float(score), 3),
    "score_raw": round(float(score), 3),
    "ts": int(time.time()*1000),
    "frame_wh": [W, H],
    "fallback": True
  }

if __name__ == "__main__":
  import uvicorn
  print("HydroBot Server (Stable) ‚Äî lendo /stream")
  print(f"Camera IP: {CAMERA_IP}")
  uvicorn.run(app, host="0.0.0.0", port=8000)













#include "esp_camera.h"
#include <WiFi.h>

// ===========================
// Select camera model in board_config.h
// ===========================
#include "board_config.h"

// ===========================
// Enter your WiFi credentials
// ===========================
const char *ssid = "HydroBot";
const char *password = "loud2025emibr";

void startCameraServer();
void setupLedFlash();

void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println();

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.frame_size = FRAMESIZE_UXGA;
  config.pixel_format = PIXFORMAT_JPEG;  // for streaming
  //config.pixel_format = PIXFORMAT_RGB565; // for face detection/recognition
  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
  config.fb_location = CAMERA_FB_IN_PSRAM;
  config.jpeg_quality = 12;
  config.fb_count = 1;

  // if PSRAM IC present, init with UXGA resolution and higher JPEG quality
  //                      for larger pre-allocated frame buffer.
  if (config.pixel_format == PIXFORMAT_JPEG) {
    if (psramFound()) {
      config.jpeg_quality = 10;
      config.fb_count = 2;
      config.grab_mode = CAMERA_GRAB_LATEST;
    } else {
      // Limit the frame size when PSRAM is not available
      config.frame_size = FRAMESIZE_SVGA;
      config.fb_location = CAMERA_FB_IN_DRAM;
    }
  } else {
    // Best option for face detection/recognition
    config.frame_size = FRAMESIZE_240X240;
#if CONFIG_IDF_TARGET_ESP32S3
    config.fb_count = 2;
#endif
  }

#if defined(CAMERA_MODEL_ESP_EYE)
  pinMode(13, INPUT_PULLUP);
  pinMode(14, INPUT_PULLUP);
#endif

  // camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }

  sensor_t *s = esp_camera_sensor_get();
  // initial sensors are flipped vertically and colors are a bit saturated
  if (s->id.PID == OV3660_PID) {
    s->set_vflip(s, 1);        // flip it back
    s->set_brightness(s, 1);   // up the brightness just a bit
    s->set_saturation(s, -2);  // lower the saturation
  }
  // drop down frame size for higher initial frame rate
  if (config.pixel_format == PIXFORMAT_JPEG) {
    s->set_framesize(s, FRAMESIZE_QVGA);
  }

#if defined(CAMERA_MODEL_M5STACK_WIDE) || defined(CAMERA_MODEL_M5STACK_ESP32CAM)
  s->set_vflip(s, 1);
  s->set_hmirror(s, 1);
#endif

#if defined(CAMERA_MODEL_ESP32S3_EYE)
  s->set_vflip(s, 1);
#endif

// Setup LED FLash if LED pin is defined in camera_pins.h
#if defined(LED_GPIO_NUM)
  setupLedFlash();
#endif

  WiFi.begin(ssid, password);
  WiFi.setSleep(false);

  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("WiFi connected");

  startCameraServer();

  Serial.print("Camera Ready! Use 'http://");
  Serial.print(WiFi.localIP());
  Serial.println("' to connect");
}

void loop() {
  // Do nothing. Everything is done in another task by the web server
  delay(10000);
}
