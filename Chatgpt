
Beleza — hasFrame:false no /healthz significa que o servidor ainda não conseguiu ler o /stream do ESP. O mais comum é:




o servidor está tentando hydrobot.local (mDNS) e não resolve;


o ESP não está acessível pelo IP certo;


o stream /stream não está abrindo (rede/sub-rede diferentes ou firewall).




Faça isso, na ordem, e não precisa mudar código:


1) Confirme o IP real do ESP




No Serial Monitor do Arduino IDE aparece o IP ao conectar (“WiFi: 192.168.x.y”).


Ou entre em http://hydrobot.local/ pelo celular/PC — se abrir a página do ESP, copie o IP exibido.




2) Diga ao servidor qual IP usar


Abra o Swagger do FastAPI no PC onde o servidor roda:

http://SEU_SERVIDOR:8000/docs




Clique em POST /config → Try it out → em camera_ip coloque o IP do ESP, por ex.:

{ "camera_ip": "192.168.3.3" }





Execute → deve retornar {ok:true, camera_ip:"192.168.3.3"}.






Alternativas se preferir linha de comando:

curl -X POST http://SEU_SERVIDOR:8000/config -H "Content-Type: application/json" -d '{"camera_ip":"192.168.3.3"}'




3) Teste direto no ESP


No mesmo PC do servidor, abra:




http://192.168.3.3/snapshot → deve baixar uma foto.


http://192.168.3.3/stream → deve abrir o MJPEG (página “quebrando” com imagens trocando).




Se isso não abrir, o problema é rede (sub-redes diferentes, firewall do PC/roteador, ESP não conectado ao mesmo Wi-Fi).


4) Volte ao /healthz


Abra http://SEU_SERVIDOR:8000/healthz. Se tudo ok, verá algo como:


{"ok":true,"camera_ip":"192.168.3.3","ip":"192.168.3.3","hasFrame":true,"age_ms":...,"fps_in":...,"last_err":null}




Se ainda ficar hasFrame:false


Cheque estes pontos rápidos:




mDNS não funciona no seu PC/roteador → use IP numérico e sempre faça o POST /config.


Firewall do servidor: permita saída HTTP (porta 80) e entrada na porta 8000 (se o app acessa de outro dispositivo).


Sub-rede: PC (servidor) e ESP precisam estar na mesma (ex.: 192.168.3.*).


ESP: confirme /stream está respondendo; se cair, baixe a pressão:



no .ino, deixe FRAMESIZE_QVGA e JPEG_QUALITY 30;


aumente STREAM_MIN_DELAY_MS para 90–110 ms;


mantenha WiFi.setSleep(false);


fonte 5 V robusta.








Se quiser, me diga o IP do ESP e o IP do servidor (e se /snapshot abre direto no browser). Com isso eu te digo exatamente onde está o gargalo.








































Perfeito. Abaixo estão os três códigos completos já ajustados para eliminar os crashes:




ESP32-CAM servindo /stream (MJPEG) com backpressure, /snapshot leve, Wi-Fi sem sleep, compressão mais alta, resolução conservadora, reinit defensivo.


Servidor FastAPI lendo /stream, guardando o último frame em memória, servindo /frame.jpg e calculando score de fogo (HSV + EMA).


CameraScreen.tsx consumindo apenas o servidor (/frame.jpg + /detect), com crossfade e fallbacks suaves (sem pressionar o ESP).





1) ESP32-CAM (Arduino) — HydroBot_ESP32CAM_Stable.ino


/*
  HydroBot - ESP32-CAM (AI Thinker) – Perfil ESTÁVEL (anti-crash)
  - Endpoints:
      GET  /              -> página info
      GET  /status        -> JSON (uptime, RSSI, heap, ip, último STATUS do Arduino)
      GET  /snapshot      -> JPEG único (usa fb direto, sem cópias)
      GET  /stream        -> MJPEG stream (limite de FPS + reinit defensivo)
      POST /uart?cmd=...  -> envia comando na UART (ex: CMD:FWD:ms=400:spd=70)
      POST /led?on=0|1    -> liga/desliga flash (GPIO 4)
      POST /restart       -> reinicia
  - mDNS: http://hydrobot.local
  - CORS: *
  - UART: Serial2 (RX=15, TX=14) — ajuste se necessário
*/

#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include "esp_camera.h"
#include "soc/rtc_cntl_reg.h"
#include "esp_timer.h"

// ====== CONFIG Wi-Fi ======
const char* WIFI_SSID = "HydroBot";
const char* WIFI_PASS = "loud2025emibr";

// (Opcional) IP fixo — comente para DHCP
//#define USE_STATIC_IP
IPAddress local_IP(192,168,0,50);
IPAddress gateway(192,168,0,1);
IPAddress subnet(255,255,255,0);
IPAddress dns1(8,8,8,8);
IPAddress dns2(1,1,1,1);

// mDNS
const char* MDNS_NAME = "hydrobot"; // http://hydrobot.local

// ====== UART p/ Arduino ======
#define UART_RX_PIN 15
#define UART_TX_PIN 14
#define UART_BAUD   115200
#define STATUS_POLL_MS 1000

// ====== CAMERA PINS (AI Thinker) ======
#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

// ====== SERVER ======
WebServer server(80);
String lastStatusLine = "";

// LED do flash
static const int FLASH_PIN = 4;

// Parametrização do stream
static const char* STREAM_BOUNDARY = "frame";
static const char* STREAM_CT = "multipart/x-mixed-replace; boundary=frame";
static const int  JPEG_QUALITY = 30;        // número MAIOR = mais compressão (menor arquivo)
static const bool STREAM_HFLIP  = false;
static const bool STREAM_VFLIP  = false;
static const uint16_t STREAM_MIN_DELAY_MS = 70; // ~14 fps; suba p/ 90–110ms se precisar

// Watchdogs
unsigned long lastWiFiCheck  = 0;
unsigned long lastStatusPoll = 0;

// --------- Util ---------
static inline void addCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}
void handleOptions() { addCORS(); server.send(204); }

// --------- UART ---------
void initUART() {
  Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN);
}
void pollArduinoStatus() {
  static String rxBuf;
  Serial2.print("REQ:STATUS\n");
  while (Serial2.available()) {
    char c = (char)Serial2.read();
    if (c == '\n' || c == '\r') {
      if (rxBuf.length() > 0) {
        if (rxBuf.startsWith("STAT:")) lastStatusLine = rxBuf;
        rxBuf = "";
      }
    } else {
      rxBuf += c;
    }
  }
}

// --------- Câmera ---------
bool initCamera() {
  // evita brownout reset
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;

  // Perfil estável
  config.frame_size   = FRAMESIZE_QVGA;   // 320x240 (suba gradualmente se ficar 100% estável)
  config.jpeg_quality = JPEG_QUALITY;     // 30 = compressão forte (menor tamanho)
  config.fb_count     = 2;
#if defined(CAMERA_GRAB_LATEST)
  config.grab_mode    = CAMERA_GRAB_LATEST;
#endif

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed 0x%x\n", err);
    return false;
  }

  sensor_t* s = esp_camera_sensor_get();
  if (s) {
    s->set_hmirror  (s, STREAM_HFLIP);
    s->set_vflip    (s, STREAM_VFLIP);
    s->set_whitebal (s, 1);
    s->set_awb_gain (s, 1);
    s->set_exposure_ctrl(s, 1);
    s->set_gain_ctrl(s, 1);
    s->set_brightness(s, -1);  // reduz brilho → menos bytes no JPEG
  }
  return true;
}

void safeReinitCamera() {
  esp_camera_deinit();
  delay(120);
  initCamera();
}

// --------- Handlers ---------
void handleRoot() {
  addCORS();
  String html = "<!doctype html><html><head><meta charset='utf-8'/>"
                "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
                "<title>HydroBot ESP32-CAM</title>"
                "<style>body{font-family:system-ui;background:#0b0b0f;color:#e5e7eb;padding:16px}"
                "a,button{background:#e6403a;color:#fff;padding:8px 12px;border:none;border-radius:8px;text-decoration:none;margin-right:8px}"
                "code{background:#121218;padding:2px 6px;border-radius:6px}</style></head><body>";
  html += "<h2>HydroBot ESP32-CAM (Estável)</h2>";
  html += "<p>IP: <code>" + WiFi.localIP().toString() + "</code> | RSSI: <code>" + String(WiFi.RSSI()) + " dBm</code></p>";
  html += "<p>Heap livre: <code>" + String(ESP.getFreeHeap()) + " bytes</code> | JPEG quality: <code>" + String(JPEG_QUALITY) + "</code></p>";
  html += "<p><a href='/snapshot'>/snapshot</a> <a href='/stream'>/stream</a> <a href='/status'>/status</a></p>";
  html += "<p>mDNS: <code>http://" + String(MDNS_NAME) + ".local</code></p>";
  html += "<p>Último STATUS Arduino: <code>" + (lastStatusLine.length()? lastStatusLine : "(ainda não)") + "</code></p>";
  html += "</body></html>";
  server.send(200, "text/html", html);
}

void handleStatus() {
  addCORS();
  String json = "{";
  json += "\"ip\":\"" + WiFi.localIP().toString() + "\",";
  json += "\"rssi\":" + String(WiFi.RSSI()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"uptime_ms\":" + String(millis()) + ",";
  json += "\"jpeg_quality\":" + String(JPEG_QUALITY) + ",";
  json += "\"arduino_status\":\"" + lastStatusLine + "\"";
  json += "}";
  server.send(200, "application/json", json);
}

void handleSnapshot() {
  addCORS();
  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb) { server.send(503, "text/plain", "Camera capture failed"); return; }

  server.sendHeader("Content-Type", "image/jpeg");
  server.sendHeader("Content-Disposition", "inline; filename=capture.jpg");
  server.sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  server.send_P(200, "image/jpeg", (const char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

void handleStream() {
  WiFiClient client = server.client();

  client.println("HTTP/1.1 200 OK");
  client.println("Content-Type: multipart/x-mixed-replace; boundary=frame");
  client.println("Access-Control-Allow-Origin: *");
  client.println("Cache-Control: no-cache, no-store, must-revalidate");
  client.println("Pragma: no-cache");
  client.println();

  uint8_t failStreak = 0;

  while (client.connected()) {
    camera_fb_t* fb = esp_camera_fb_get();
    if (!fb) {
      failStreak++;
      if (failStreak >= 5) { safeReinitCamera(); failStreak = 0; }
      delay(40);
      continue;
    }
    failStreak = 0;

    client.println("--frame");
    client.println("Content-Type: image/jpeg");
    client.print("Content-Length: ");
    client.println(fb->len);
    client.println();
    client.write(fb->buf, fb->len);
    client.println();

    esp_camera_fb_return(fb);

    delay(STREAM_MIN_DELAY_MS); // limita FPS → menos calor/memória
    if (!client.connected()) break;
    yield();
  }
}

void handleUART() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  String cmd = server.arg("cmd");
  if (!cmd.length()) { server.send(400, "application/json", "{\"error\":\"use /uart?cmd=...\"}"); return; }
  if (!cmd.endsWith("\n")) cmd += "\n";
  Serial2.print(cmd);
  server.send(200, "application/json", "{\"ok\":true}");
}

void handleLED() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  int on = server.arg("on").toInt();
  digitalWrite(FLASH_PIN, on ? HIGH : LOW);
  server.send(200, "application/json", String("{\"on\":") + (on? "true":"false") + "}");
}

void handleRestart() {
  addCORS();
  server.send(200, "application/json", "{\"restarting\":true}");
  delay(300);
  ESP.restart();
}

// --------- Wi-Fi ---------
void connectWiFi() {
#ifdef USE_STATIC_IP
  WiFi.config(local_IP, gateway, subnet, dns1, dns2);
#endif
  WiFi.mode(WIFI_STA);
  WiFi.setSleep(false); // MUITO IMPORTANTE p/ stream estável
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 15000) {
    delay(250);
  }
}

void setupServer() {
  server.on("/",       HTTP_GET,     handleRoot);
  server.on("/status", HTTP_GET,     handleStatus);
  server.on("/snapshot", HTTP_GET,   handleSnapshot);
  server.on("/stream", HTTP_GET,     handleStream);
  server.on("/uart",   HTTP_POST,    handleUART);
  server.on("/led",    HTTP_POST,    handleLED);
  server.on("/restart",HTTP_POST,    handleRestart);

  server.on("/uart",   HTTP_OPTIONS, handleOptions);
  server.on("/led",    HTTP_OPTIONS, handleOptions);
  server.on("/restart",HTTP_OPTIONS, handleOptions);

  server.onNotFound([](){
    addCORS();
    server.send(404, "application/json", "{\"error\":\"not found\"}");
  });

  server.begin();
}

// --------- Setup / Loop ---------
void setup() {
  Serial.begin(115200);
  delay(200);

  pinMode(FLASH_PIN, OUTPUT);
  digitalWrite(FLASH_PIN, LOW); // evite picos

  initUART();

  if (!initCamera()) {
    Serial.println("Falha câmera – tentando novamente...");
    delay(1000);
    if (!initCamera()) { Serial.println("Falha crítica na câmera"); }
  } else {
    Serial.println("Câmera OK");
  }

  connectWiFi();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("WiFi: " + WiFi.localIP().toString());
    if (MDNS.begin(MDNS_NAME)) {
      MDNS.addService("http", "tcp", 80);
      Serial.println("mDNS: http://" + String(MDNS_NAME) + ".local");
    }
  } else {
    Serial.println("WiFi FAIL");
  }

  setupServer();
  Serial.println("HTTP server OK");
}

void loop() {
  server.handleClient();

  if (millis() - lastWiFiCheck > 3000) {
    lastWiFiCheck = millis();
    if (WiFi.status() != WL_CONNECTED) {
      connectWiFi();
    }
  }
  if (millis() - lastStatusPoll > STATUS_POLL_MS) {
    lastStatusPoll = millis();
    pollArduinoStatus();
  }
}





Notas rápidas




Comece com QVGA + jpeg_quality=30. Se ficar 100% estável, suba para HVGA e depois VGA, ajustando STREAM_MIN_DELAY_MS p/ 80–110 ms se necessário.


Mantenha WiFi.setSleep(false), LED off, fonte 5 V estável (≥2 A).







2) Servidor (FastAPI) — server_heuristic.py


#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HydroBot Server (ESTÁVEL) – Lê /stream (MJPEG) do ESP32-CAM, guarda o último frame,
serve /frame.jpg e calcula score simples de fogo (HSV + EMA).

Rodar:
  uvicorn server_heuristic:app --host 0.0.0.0 --port 8000
Deps:
  pip install fastapi uvicorn requests opencv-python numpy pydantic
"""

import time
import threading
from typing import Optional, Dict, Any
import re

import requests
import cv2
import numpy as np
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ========= CONFIG =========
CAMERA_IP = "hydrobot.local"
STREAM_URL_FMT = "http://{}/stream"
CONNECT_TIMEOUT = 3.0
READ_TIMEOUT = 10.0
MAX_FRAME_AGE_MS = 10_000
MAX_RESULT_AGE_MS = 800
JPEG_QUALITY = 85

# Fire (HSV simples)
HSV_LOW = (8, 70, 120)
HSV_HIGH = (40, 255, 255)
EMA_ALPHA = 0.3
FIRE_THRESHOLD = 0.15

BOUNDARY_RE = re.compile(br'--[^\r\n]+')
REQ_HEADERS = {"Connection": "keep-alive", "User-Agent": "HydroBot-Grabber/3.0"}

# ========= FASTAPI =========
app = FastAPI(title="HydroBot Server (Stable)", version="4.0")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True,
                   allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
  camera_ip: str

def placeholder_jpeg(msg: str = "NO FRAME") -> bytes:
  img = np.zeros((240, 320, 3), dtype=np.uint8)
  img[:, :] = (50, 50, 150)
  cv2.putText(img, msg, (38, 130), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
  cv2.putText(img, time.strftime("%H:%M:%S"), (38, 180), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
  ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY])
  return buf.tobytes()

# ========= MJPEG Stream Grabber =========
class StreamGrabber:
  def __init__(self, ip: str):
    self.ip = ip
    self._stop = threading.Event()
    self._lock = threading.Lock()
    self._last_jpeg: Optional[bytes] = None
    self._last_ts = 0
    self._fps_in = 0.0
    self._frames = 0
    self._tick = time.time()
    self._last_err: Optional[str] = None

  def start(self):
    self._stop.clear()
    t = threading.Thread(target=self._run, daemon=True)
    t.start()

  def stop(self):
    self._stop.set()

  def _run(self):
    while not self._stop.is_set():
      url = STREAM_URL_FMT.format(self.ip)
      buf = b""
      try:
        with requests.get(url, stream=True, timeout=(CONNECT_TIMEOUT, READ_TIMEOUT), headers=REQ_HEADERS) as r:
          r.raise_for_status()
          for chunk in r.iter_content(chunk_size=4096):
            if self._stop.is_set():
              break
            if not chunk:
              continue
            buf += chunk

            # procurar boundaries e extrair o penúltimo part (frame completo)
            m = BOUNDARY_RE.search(buf)
            if not m:
              if len(buf) > 2_000_000:
                buf = buf[-200_000:]
              continue

            parts = BOUNDARY_RE.split(buf)
            if len(parts) >= 2:
              frame_blob = parts[-2]
              buf = parts[-1]

              header_end = frame_blob.find(b"\r\n\r\n")
              if header_end == -1:
                continue
              body = frame_blob[header_end+4:]

              if body.startswith(b"\xff\xd8") and body.endswith(b"\xff\xd9"):
                with self._lock:
                  self._last_jpeg = body
                  self._last_ts = int(time.time()*1000)
                  self._last_err = None
                  self._frames += 1
                  now = time.time()
                  if now - self._tick >= 1.0:
                    self._fps_in = self._frames / (now - self._tick)
                    self._frames = 0
                    self._tick = now

      except Exception as e:
        with self._lock:
          self._last_err = str(e)
        time.sleep(0.8)  # backoff curto e reconecta

  def get_latest(self, max_age_ms=MAX_FRAME_AGE_MS) -> Optional[bytes]:
    with self._lock:
      if not self._last_jpeg:
        return None
      if int(time.time()*1000) - self._last_ts > max_age_ms:
        return None
      return self._last_jpeg

  def status(self) -> Dict[str, Any]:
    with self._lock:
      age = int(time.time()*1000) - self._last_ts if self._last_ts else None
      return {
        "ip": self.ip,
        "hasFrame": self._last_jpeg is not None,
        "age_ms": age,
        "fps_in": round(self._fps_in, 2),
        "last_err": self._last_err
      }

grabber = StreamGrabber(CAMERA_IP)
grabber.start()

# ========= Fire Detection =========
def simple_fire_score(frame_bgr: np.ndarray) -> float:
  try:
    hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))
    fire_ratio = float(np.count_nonzero(mask)) / float(mask.size)
    v_mean = float(np.mean(hsv[:, :, 2])) / 255.0
    score = min(1.0, fire_ratio * 4.0 + v_mean * 0.1)
    return float(score)
  except Exception:
    return 0.0

class FireDetector:
  def __init__(self, src: StreamGrabber):
    self.src = src
    self._lock = threading.Lock()
    self._stop = threading.Event()
    self._thr: Optional[threading.Thread] = None

    self._ema = 0.0
    self._raw = 0.0
    self._is_fire = False
    self._ts = 0
    self._fps = 0.0
    self._frames = 0
    self._tick = time.time()
    self._wh: Optional[tuple] = None

  def start(self):
    self._stop.clear()
    self._thr = threading.Thread(target=self._run, daemon=True)
    self._thr.start()

  def stop(self):
    self._stop.set()
    if self._thr and self._thr.is_alive():
      self._thr.join(timeout=1.0)

  def _run(self):
    interval = 1.0 / 5.0
    while not self._stop.is_set():
      t0 = time.time()
      jpeg = self.src.get_latest()
      if jpeg is None:
        time.sleep(0.1)
        continue
      try:
        frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
        if frame is None:
          time.sleep(0.05)
          continue
        H, W = frame.shape[:2]
        score = simple_fire_score(frame)
        ema = score if self._ema == 0.0 else EMA_ALPHA*score + (1.0-EMA_ALPHA)*self._ema
        is_fire = (ema >= FIRE_THRESHOLD)
        with self._lock:
          self._raw = score
          self._ema = ema
          self._is_fire = is_fire
          self._ts = int(time.time()*1000)
          self._wh = (W, H)
          self._frames += 1
          now = time.time()
          if now - self._tick >= 1.0:
            self._fps = self._frames / (now - self._tick)
            self._frames = 0
            self._tick = now
      except Exception:
        pass
      dt = time.time() - t0
      time.sleep(max(0.0, interval - dt))

  def get(self) -> Dict[str, Any]:
    with self._lock:
      return {
        "ok": True,
        "isFire": bool(self._is_fire),
        "score": round(float(self._ema), 3),
        "score_raw": round(float(self._raw), 3),
        "ts": int(self._ts),
        "fps_det": round(float(self._fps), 2),
        "frame_wh": list(self._wh) if self._wh else None
      }

detector = FireDetector(grabber)
detector.start()

# ========= Endpoints =========
@app.get("/healthz")
def healthz():
  s = grabber.status()
  return {"ok": True, "camera_ip": s.get("ip"), **s}

@app.get("/status")
def status():
  s = grabber.status()
  d = detector.get()
  return {"ok": True, "camera_ip": s.get("ip"), **s, **d}

@app.post("/config")
def set_config(cfg: ConfigIn):
  global CAMERA_IP, grabber, detector
  CAMERA_IP = cfg.camera_ip
  # reinicia o grabber
  grabber.stop()
  grabber = StreamGrabber(CAMERA_IP)
  grabber.start()
  # detector continua usando o mesmo objeto? recria para limpar estado
  detector.stop()
  detector = FireDetector(grabber)
  detector.start()
  return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
  b = grabber.get_latest() or placeholder_jpeg("NO FRAME")
  headers = {
    "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
    "Pragma": "no-cache",
    "Expires": "0",
    "Content-Type": "image/jpeg"
  }
  return Response(content=b, headers=headers, media_type="image/jpeg")

@app.get("/frame.jpg")
def frame_jpg():
  return snapshot()

@app.get("/detect")
def detect():
  res = detector.get()
  if res.get("ts", 0) and (int(time.time()*1000) - int(res["ts"]) <= MAX_RESULT_AGE_MS):
    return res
  # fallback rápido
  jpeg = grabber.get_latest()
  if jpeg is None:
    return {"ok": False, "error": "no recent frame"}
  frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
  if frame is None:
    return {"ok": False, "error": "decode failed"}
  score = simple_fire_score(frame)
  is_fire = (score >= FIRE_THRESHOLD)
  H, W = frame.shape[:2]
  return {
    "ok": True,
    "isFire": bool(is_fire),
    "score": round(float(score), 3),
    "score_raw": round(float(score), 3),
    "ts": int(time.time()*1000),
    "frame_wh": [W, H],
    "fallback": True
  }

if __name__ == "__main__":
  import uvicorn
  print("HydroBot Server (Stable) — lendo /stream")
  print(f"Camera IP: {CAMERA_IP}")
  uvicorn.run(app, host="0.0.0.0", port=8000)




3) React Native — CameraScreen.tsx (simplificado, consumindo o servidor)


// HydroBotApp2/src/screens/CameraScreen.tsx
// Versão estável: usa apenas o servidor (/frame.jpg e /detect). Sem “snapshot direto no ESP”.

import { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet,
  PanResponder, GestureResponderEvent, PanResponderGestureState,
  Image, Animated
} from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: { heroSubtitle:"Monitoramento e Controle", espIp:"ESP:", pumpOn:"BOMBA ON", pumpOff:"BOMBA OFF",
        server:"Servidor:", detecting:"Detectando…", waiting:"Aguardando servidor…", statusFail:"Falha ao conectar. Confira o Wi-Fi/IP.",
        noVideo:"Sem vídeo. Verifique o servidor.", fireOn:(s:number)=>`🔥 FOGO • score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sem fogo • score ${s.toFixed(2)}`, synced:"Server sincronizado",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  en: { heroSubtitle:"Monitoring & Control", espIp:"ESP:", pumpOn:"PUMP ON", pumpOff:"PUMP OFF",
        server:"Server:", detecting:"Detecting…", waiting:"Waiting for server…", statusFail:"Failed to connect. Check Wi-Fi/IP.",
        noVideo:"No video. Check server.", fireOn:(s:number)=>`🔥 FIRE • score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`No fire • score ${s.toFixed(2)}`, synced:"Server sync OK",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  es: { heroSubtitle:"Monitoreo y Control", espIp:"ESP:", pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.",
        server:"Servidor:", detecting:"Detectando…", waiting:"Esperando servidor…", statusFail:"Error de conexión. Revisa Wi-Fi/IP.",
        noVideo:"Sin vídeo. Revisa el servidor.", fireOn:(s:number)=>`🔥 FUEGO • score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sin fuego • score ${s.toFixed(2)}`, synced:"Sincronizado con servidor",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
};

const DEFAULT_IP = "hydrobot.local";
const DEFAULT_SERVER = "http://192.168.0.100:8000";
const appLogo = require("../../assets/logo.png");

/* ---------- UI ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown,
}: { currentUri: string; nextUri: string; onNextLoadStart: () => void; onNextShown: (ok: boolean) => void; }) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={() => { onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- Screen ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [statusText, setStatusText] = useState(T.waiting);
  const [pumpOn, setPumpOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);
  const failCountRef = useRef(0);

  const clean = (s:string)=>s.replace(/\/+$/,"");
  const healthUrl   = useMemo(()=>`${clean(server)}/healthz`,[server]);
  const detectUrl   = useMemo(()=>`${clean(server)}/detect`,[server]);
  const frameUrl    = useMemo(()=>`${clean(server)}/frame.jpg`,[server]);
  const configUrl   = useMemo(()=>`${clean(server)}/config`,[server]);
  const uartPost    = useMemo(()=> (cmd:string)=>`http://${ip}/uart?cmd=${encodeURIComponent(cmd)}`, [ip]);
  const ledPost     = useMemo(()=> (on:boolean)=>`http://${ip}/led?on=${on?1:0}`, [ip]);

  // Sincroniza IP da câmera no servidor (para o grabber do /stream)
  useEffect(()=>{
    let aborted=false;
    (async()=>{
      try{
        const r=await fetch(configUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({camera_ip:ip})});
        const j=await r.json();
        if(!aborted && j?.ok) setStatusText(`${T.synced} (${j.camera_ip})`);
      }catch{ if(!aborted) setStatusText(T.statusFail); }
    })();
    return()=>{aborted=true};
  },[ip, configUrl, T]);

  // Health do servidor
  useEffect(()=>{
    let stop=false, backoff=600;
    const poll=async()=>{
      if(stop) return;
      try{
        const r=await fetch(healthUrl); const j=await r.json();
        if(j?.ok){ setStatusText(`Server OK • fps_in:${j.fps_in||0} • hasFrame:${j.hasFrame||false}`); }
        else setStatusText(T.waiting);
      }catch{ setStatusText(T.waiting); }
      setTimeout(poll, backoff);
      backoff=Math.min(backoff*1.4, 5000);
    };
    poll(); return()=>{stop=true};
  },[healthUrl, T]);

  // Loop de frames: SEM snapshot direto no ESP — só /frame.jpg do servidor
  useEffect(()=>{
    let stop=false, interval=220;
    setCurrentFrameUri(`${frameUrl}?ts=${Date.now()}`);
    const tick=()=>{
      if(stop) return;
      try{
        if(!loadingNextRef.current){
          setNextFrameUri(`${frameUrl}?ts=${Date.now()}`);
        }
        interval=220;
      }catch{
        interval=Math.min(interval*1.6, 1500);
      }
      setTimeout(tick, interval);
    };
    tick();
    return()=>{stop=true};
  },[frameUrl]);

  const onNextLoadStart = ()=>{ loadingNextRef.current=true; };
  const onNextShown = (ok:boolean)=>{
    if(ok){
      failCountRef.current = 0;
      if(nextFrameUri) setCurrentFrameUri(nextFrameUri);
    }else{
      failCountRef.current += 1;
    }
    loadingNextRef.current=false;
  };

  // DETECT loop (score simplificado)
  useEffect(()=>{
    let stop=false, interval=350;
    const loop=async()=>{
      if(stop) return;
      try{
        const r=await fetch(detectUrl);
        const j=await r.json();
        if(j && j.ok!==false){
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score||0));
          interval=350;
        }
      }catch{
        setIsFire(false); setFireScore(0);
        interval=Math.min(interval*1.5, 2000);
      }finally{ setTimeout(loop, interval); }
    };
    loop(); return()=>{stop=true};
  },[detectUrl]);

  // UART + LED (direto no ESP)
  async function sendUART(cmd: string) {
    try {
      const res = await fetch(uartPost(cmd), { method: "POST" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return true;
    } catch {
      setStatusText(T.statusFail);
      return false;
    }
  }
  async function togglePump(){
    const target = !pumpOn;
    const ok = await sendUART(`CMD:PUMP:${target ? "1" : "0"}`);
    if (ok) setPumpOn(target);
  }
  async function led(on:boolean){
    try{
      const res = await fetch(ledPost(on), { method: "POST" });
      const txt = await res.text();
      setStatusText(`${on?T.ledOn:T.ledOff} • ${res.status} ${txt||""}`);
    }catch{ setStatusText(T.statusFail); }
  }

  // Joystick (pulsos discretos)
  const RADIUS=64;
  const [joy, setJoy] = useState({x:0, y:0});
  const [dragging, setDragging] = useState(false);
  const pan = useRef(PanResponder.create({
    onStartShouldSetPanResponder:()=>true,
    onMoveShouldSetPanResponder:()=>true,
    onPanResponderGrant:()=>{ setDragging(true); },
    onPanResponderMove:(_e:GestureResponderEvent,g:PanResponderGestureState)=>{
      let nx=g.dx/RADIUS, ny=g.dy/RADIUS; const len=Math.hypot(nx,ny); if(len>1){ nx/=len; ny/=len; }
      setJoy({x:nx, y:-ny});
    },
    onPanResponderRelease:()=>{ setJoy({x:0,y:0}); setDragging(false); },
    onPanResponderTerminate:()=>{ setJoy({x:0,y:0}); setDragging(false); },
  })).current;

  const lastSendRef = useRef(0);
  const lastDirRef  = useRef<string>("STOP");
  const vecToDir=(x:number,y:number):"FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP"=>{
    const mag=Math.hypot(x,y); if(mag<0.2) return "STOP";
    const deg=(Math.atan2(y,x)*180)/Math.PI;
    if(deg>-45&&deg<=45) return "RIGHT";
    if(deg>45&&deg<=135) return "FWD";
    if(deg<=-45&&deg>-135) return "BACK";
    return "LEFT";
  };

  useEffect(()=>{
    let cancelled=false;
    const tick=async()=>{
      if(cancelled) return;
      const now=Date.now();
      if(now-lastSendRef.current<120){ setTimeout(tick,20); return; }
      lastSendRef.current=now;

      const {x,y}=joy;
      const mag=Math.hypot(x,y);
      const dir=vecToDir(x,y);

      if(dir!==lastDirRef.current){
        if(dir==="STOP"){ await sendUART("CMD:STOP"); }
        else{
          const ms=140+Math.round(260*Math.min(1,mag));
          const spd=50+Math.round(50*Math.min(1,mag));
          await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
        }
        lastDirRef.current=dir;
      }else if(dir!=="STOP"){
        const ms=120+Math.round(200*Math.min(1,mag));
        const spd=50+Math.round(50*Math.min(1,mag));
        await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
      }
      setTimeout(tick,120);
    };
    tick(); return()=>{cancelled=true};
  },[joy, ip]);

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder={T.placeholderIp} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={styles.input} />
        <Text style={styles.label}>{T.server}</Text>
        <TextInput value={server} onChangeText={setServer} placeholder={T.placeholderServer} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={[styles.input,{minWidth:220}]} />

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn?styles.btnOn:styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn?T.pumpOn:T.pumpOff}</Text>
        </Pressable>
        <Pressable onPress={()=>led(true)} style={[styles.btn, {backgroundColor:"#2563eb"}]}>
          <Text style={styles.btnText}>{T.ledOn}</Text>
        </Pressable>
        <Pressable onPress={()=>led(false)} style={[styles.btn, {backgroundColor:"#374151"}]}>
          <Text style={styles.btnText}>{T.ledOff}</Text>
        </Pressable>
      </View>

      <View style={[styles.statusRow,{paddingTop:4,paddingBottom:8}]}>
        <Text numberOfLines={2} style={styles.status}>{statusText}</Text>
        <View style={[styles.badge,{backgroundColor: "#065f46"}]}>
          <Text style={{ color:"#fff", fontWeight:"800" }}>{isFire ? T.detecting : T.waiting}</Text>
        </View>
      </View>

      <View style={[styles.fireBanner, isFire?styles.fireOn:styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      <View style={{ flex:1 }}>
        <CrossfadeImage
          currentUri={currentFrameUri}
          nextUri={nextFrameUri}
          onNextLoadStart={()=>{ loadingNextRef.current=true; }}
          onNextShown={(ok)=>{ if(ok && nextFrameUri) setCurrentFrameUri(nextFrameUri); loadingNextRef.current=false; }}
        />
      </View>

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap,{width:64*2+24,height:64*2+24}]}
              {...(pan.panHandlers as any)}>
          <View style={[styles.joyBase,{width:64*2,height:64*2,borderRadius:64}]} />
          <View style={[styles.joyKnob,{width:22*2,height:22*2,borderRadius:22,
                        transform:[{translateX:joy.x*64},{translateY:-joy.y*64}], opacity: dragging?1:0.9}]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", flexWrap:"wrap",
           paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:120 },
  btn:{ backgroundColor:PALETTE.accent, paddingHorizontal:10, paddingVertical:10, borderRadius:10 },
  btnOn:{ backgroundColor:"#17a34a" }, btnOff:{ backgroundColor:"#374151" },
  btnText:{ color:"white", fontWeight:"600" },

  statusRow:{ flexDirection:"row", alignItems:"center", paddingHorizontal:12, paddingVertical:8, gap:8,
              backgroundColor:"#0f1322", borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  badge:{ paddingHorizontal:10, paddingVertical:6, borderRadius:8, borderWidth:1, borderColor:PALETTE.border },
  status:{ color:"#cbd5ff", flex:1, fontSize:12 },

  fireBanner:{ alignItems:"center", justifyContent:"center", paddingVertical:6 },
  fireOn:{ backgroundColor:"#8b0000" }, fireOff:{ backgroundColor:"#223" },
  fireText:{ color:"white", fontWeight:"800" },

  joyWrap:{ position:"absolute", bottom:24, left:24, alignItems:"center", justifyContent:"center" },
  joyBase:{ position:"absolute", backgroundColor:"rgba(255,255,255,0.08)", borderWidth:2, borderColor:"rgba(255,255,255,0.14)" },
  joyKnob:{ position:"absolute", backgroundColor:"rgba(230,64,58,0.9)", borderWidth:2, borderColor:"rgba(255,255,255,0.85)" },
  joyText:{ position:"absolute", bottom:-22, color:"#cbd5ff", fontSize:12 },
});




Checklist rápido de integração




Flash o ESP com o .ino acima (board “AI Thinker ESP32-CAM”).


Confirme no Serial Monitor: IP, “HTTP server OK”.


No PC/servidor: uvicorn server_heuristic:app --host 0.0.0.0 --port 8000.


Teste no navegador:



http://SEU_SERVIDOR:8000/healthz → hasFrame=true após alguns segundos.


http://SEU_SERVIDOR:8000/frame.jpg → deve mostrar o último frame.






No app, em Servidor, coloque http://SEU_SERVIDOR:8000. Em ESP, deixe hydrobot.local (ou IP da câmera).


A tela deve atualizar fluida; se ainda cair em cena “rica”, aumente STREAM_MIN_DELAY_MS (ESP) para 90–110ms ou suba jpeg_quality (ex.: 32) e mantenha QVGA/HVGA.




Se quiser, me manda o código que “funcionava bem” para eu cruzar e manter qualquer ajuste fino que você curtiu (pins, timers, etc.).


















































// CameraScreen.tsx - Versão Simplificada (apenas score de fogo)
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet,
  PanResponder, GestureResponderEvent, PanResponderGestureState,
  Image, Animated, LayoutChangeEvent,
} from "react-native";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg:"#0b0b0f", card:"#121218", border:"#25273a", accent:"#e6403a", text:"#e5e7eb" };

const textsByLang = {
  pt: { heroSubtitle:"Monitoramento e Controle", espIp:"ESP:", pumpOn:"BOMBA ON", pumpOff:"BOMBA OFF",
        server:"Servidor:", detecting:"Detectando…", waiting:"Aguardando servidor…", statusFail:"Falha ao conectar. Confira o Wi-Fi/IP.",
        noVideo:"Sem vídeo (snapshot). Verifique o servidor.", fireOn:(s:number)=>`🔥 FOGO • score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sem fogo • score ${s.toFixed(2)}`, synced:"Server sincronizado",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  en: { heroSubtitle:"Monitoring & Control", espIp:"ESP:", pumpOn:"PUMP ON", pumpOff:"PUMP OFF",
        server:"Server:", detecting:"Detecting…", waiting:"Waiting for server…", statusFail:"Failed to connect. Check Wi-Fi/IP.",
        noVideo:"No video (snapshot). Check server.", fireOn:(s:number)=>`🔥 FIRE • score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`No fire • score ${s.toFixed(2)}`, synced:"Server sync OK",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
  es: { heroSubtitle:"Monitoreo y Control", espIp:"ESP:", pumpOn:"BOMBA ENC.", pumpOff:"BOMBA APAG.",
        server:"Servidor:", detecting:"Detectando…", waiting:"Esperando servidor…", statusFail:"Error de conexión. Revisa Wi-Fi/IP.",
        noVideo:"Sin vídeo (snapshot). Revisa el servidor.", fireOn:(s:number)=>`🔥 FUEGO • score ${s.toFixed(2)}`,
        fireOff:(s:number)=>`Sin fuego • score ${s.toFixed(2)}`, synced:"Sincronizado con servidor",
        placeholderIp:"hydrobot.local", placeholderServer:"http://192.168.0.100:8000",
        ledOn:"LED ON", ledOff:"LED OFF" },
};

const DEFAULT_IP = "hydrobot.local";
const DEFAULT_SERVER = "http://192.168.0.100:8000";

const appLogo = require("../../assets/logo.png");

/* ---------------------- UI AUX ---------------------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

function CrossfadeImage({
  currentUri, nextUri, onNextLoadStart, onNextShown,
}: { currentUri: string; nextUri: string; onNextLoadStart: () => void; onNextShown: (ok: boolean) => void; }) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image key={currentUri} source={{ uri: currentUri }} style={{ flex: 1, width: "100%" }} resizeMode="contain" />
      )}
      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri}
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={() => { onNextShown(false); fade.setValue(0); setShowNext(false); }}
            onLoadEnd={() => {
              Animated.timing(fade, { toValue: 1, duration: 80, useNativeDriver: true }).start(() => {
                onNextShown(true); fade.setValue(0); setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------------------- SCREEN ---------------------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [statusText, setStatusText] = useState(T.waiting);
  const [pumpOn, setPumpOn] = useState(false);
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  const [useDirectSnapshot, setUseDirectSnapshot] = useState(false);
  const failCountRef = useRef(0);

  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const clean = (s:string)=>s.replace(/\/+$/,"");

  // Server endpoints
  const healthUrl     = useMemo(()=>`${clean(server)}/healthz`,[server]);
  const detectUrl     = useMemo(()=>`${clean(server)}/detect`,[server]);
  const snapshotSrv   = useMemo(()=>`${clean(server)}/snapshot`,[server]);
  const snapshotSrvAlt= useMemo(()=>`${clean(server)}/frame.jpg`,[server]);
  const configUrl     = useMemo(()=>`${clean(server)}/config`,[server]);

  // ESP endpoints
  const snapshotEsp   = useMemo(()=> `http://${ip}/snapshot`, [ip]);
  const uartPost      = useMemo(()=> (cmd:string)=>`http://${ip}/uart?cmd=${encodeURIComponent(cmd)}`, [ip]);
  const ledPost       = useMemo(()=> (on:boolean)=>`http://${ip}/led?on=${on?1:0}`, [ip]);

  // Sincroniza IP da câmera no server
  useEffect(()=>{
    let aborted=false;
    (async()=>{
      try{
        const r=await fetch(configUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({camera_ip:ip})});
        const j=await r.json();
        if(!aborted && j?.ok) setStatusText(`${T.synced} (${j.camera_ip})`);
      }catch{ if(!aborted) setStatusText(T.statusFail); }
    })();
    return()=>{aborted=true};
  },[ip, configUrl, T]);

  // Health do servidor
  useEffect(()=>{
    let stop=false, backoff=500;
    const poll=async()=>{
      if(stop) return;
      try{
        const r=await fetch(healthUrl); const j=await r.json();
        if(j?.ok){ setStatusText(`Server OK • fps_in:${j.fps_in || 0} • hasFrame:${j.hasFrame || false}`); return; }
      }catch{}
      setStatusText(T.waiting);
      setTimeout(poll, backoff); backoff=Math.min(backoff*1.6, 5000);
    };
    poll(); return()=>{stop=true};
  },[healthUrl, T]);

  // SNAPSHOT loop com fallback server->ESP
  useEffect(()=>{
    let stop=false, interval=200; // Intervalo mais conservador
    const pickBase = ()=>{
      if (useDirectSnapshot) return snapshotEsp;
      return failCountRef.current >= 2 ? snapshotSrvAlt : snapshotSrv;
    };

    setCurrentFrameUri(`${pickBase()}?ts=${Date.now()}`);
    const tick=()=>{
      if(stop) return;
      try{
        if(!loadingNextRef.current){
          const base = pickBase();
          setNextFrameUri(`${base}?ts=${Date.now()}`);
        }
        interval=200;
      }catch{
        interval=Math.min(interval*1.7, 1500);
      }
      setTimeout(tick, interval);
    };
    tick();
    return()=>{stop=true};
  },[snapshotSrv, snapshotSrvAlt, snapshotEsp, useDirectSnapshot]);

  const onNextLoadStart = ()=>{ loadingNextRef.current=true; };
  const onNextShown = (ok:boolean)=>{
    if(ok){
      failCountRef.current = 0;
      if(useDirectSnapshot){ setUseDirectSnapshot(false); }
      if(nextFrameUri) setCurrentFrameUri(nextFrameUri);
    }else{
      failCountRef.current += 1;
      if(!useDirectSnapshot && failCountRef.current >= 3){
        setUseDirectSnapshot(true);
        failCountRef.current = 0;
      }
    }
    loadingNextRef.current=false;
  };

  // DETECT loop - SIMPLIFICADO (apenas score)
  useEffect(()=>{
    let stop=false, interval=300;
    const loop=async()=>{
      if(stop) return;
      try{
        const r=await fetch(detectUrl); 
        const j=await r.json();
        if(j && j.ok!==false){
          setIsFire(!!j.isFire); 
          setFireScore(Number(j.score||0));
          interval=300;
        }
      }catch{
        setIsFire(false); 
        setFireScore(0); 
        interval=Math.min(interval*1.5,2000);
      }finally{ 
        setTimeout(loop, interval); 
      }
    };
    loop(); return()=>{stop=true};
  },[detectUrl]);

  // ------- COMANDOS (UART + LED) -------
  async function sendUART(cmd: string) {
    try {
      const res = await fetch(uartPost(cmd), { method: "POST" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return true;
    } catch {
      setStatusText(T.statusFail);
      return false;
    }
  }

  async function togglePump(){
    const target = !pumpOn;
    const ok = await sendUART(`CMD:PUMP:${target ? "1" : "0"}`);
    if (ok) setPumpOn(target);
  }

  async function led(on:boolean){
    try{
      const res = await fetch(ledPost(on), { method: "POST" });
      const txt = await res.text();
      setStatusText(`${on?T.ledOn:T.ledOff} • ${res.status} ${txt||""}`);
    }catch{
      setStatusText(T.statusFail);
    }
  }

  // Joystick: envia PULSOS discretos por UART
  const RADIUS=64;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder:()=>true,
      onMoveShouldSetPanResponder:()=>true,
      onPanResponderGrant:()=>{ setDragging(true); },
      onPanResponderMove:(_e:GestureResponderEvent,g:PanResponderGestureState)=>{
        let nx=g.dx/RADIUS, ny=g.dy/RADIUS;
        const len=Math.hypot(nx,ny); if(len>1){ nx/=len; ny/=len; }
        setJoy({x:nx, y:-ny});
      },
      onPanResponderRelease:()=>{ setJoy({x:0,y:0}); setDragging(false); },
      onPanResponderTerminate:()=>{ setJoy({x:0,y:0}); setDragging(false); },
    })
  ).current;

  const lastSendRef = useRef(0);
  const lastDirRef  = useRef<string>("STOP");

  const vecToDir=(x:number,y:number):"FWD"|"BACK"|"LEFT"|"RIGHT"|"STOP"=>{
    const mag=Math.hypot(x,y); if(mag<0.2) return "STOP";
    const deg=(Math.atan2(y,x)*180)/Math.PI;
    if(deg>-45&&deg<=45) return "RIGHT";
    if(deg>45&&deg<=135) return "FWD";
    if(deg<=-45&&deg>-135) return "BACK";
    return "LEFT";
  };

  useEffect(()=>{
    let cancelled=false;
    const tick=async()=>{
      if(cancelled) return;
      const now=Date.now();
      if(now-lastSendRef.current<120){ setTimeout(tick,20); return; }
      lastSendRef.current=now;

      const {x,y}=joy;
      const mag=Math.hypot(x,y);
      const dir=vecToDir(x,y);

      if(dir!==lastDirRef.current){
        if(dir==="STOP"){
          await sendUART("CMD:STOP");
        }else{
          const ms=140+Math.round(260*Math.min(1,mag));
          const spd=50+Math.round(50*Math.min(1,mag));
          await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
        }
        lastDirRef.current=dir;
      }else if(dir!=="STOP"){
        const ms=120+Math.round(200*Math.min(1,mag));
        const spd=50+Math.round(50*Math.min(1,mag));
        await sendUART(`CMD:${dir}:ms=${ms}:spd=${spd}`);
      }

      setTimeout(tick,120);
    };
    tick(); return()=>{cancelled=true};
  },[joy, ip]);

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder={T.placeholderIp} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={styles.input} />
        <Text style={styles.label}>{T.server}</Text>
        <TextInput value={server} onChangeText={setServer} placeholder={T.placeholderServer} placeholderTextColor="#8a93a5"
                   autoCapitalize="none" autoCorrect={false} style={[styles.input,{minWidth:220}]} />

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn?styles.btnOn:styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn?T.pumpOn:T.pumpOff}</Text>
        </Pressable>
        <Pressable onPress={()=>led(true)} style={[styles.btn, {backgroundColor:"#2563eb"}]}>
          <Text style={styles.btnText}>{T.ledOn}</Text>
        </Pressable>
        <Pressable onPress={()=>led(false)} style={[styles.btn, {backgroundColor:"#374151"}]}>
          <Text style={styles.btnText}>{T.ledOff}</Text>
        </Pressable>
      </View>

      <View style={[styles.statusRow,{paddingTop:4,paddingBottom:8}]}>
        <Text numberOfLines={2} style={styles.status}>{statusText} {useDirectSnapshot ? "• (snapshot direto)" : ""}</Text>
        <View style={[styles.badge,{backgroundColor: "#065f46"}]}>
          <Text style={{ color:"#fff", fontWeight:"800" }}>{isFire ? T.detecting : T.waiting}</Text>
        </View>
      </View>

      <View style={[styles.fireBanner, isFire?styles.fireOn:styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      {/* Video simples - sem overlay de boxes */}
      <View style={{ flex:1 }}>
        <CrossfadeImage 
          currentUri={currentFrameUri} 
          nextUri={nextFrameUri}
          onNextLoadStart={onNextLoadStart}
          onNextShown={onNextShown}
        />
      </View>

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap,{width:64*2+24,height:64*2+24}]}
              {...(pan.panHandlers as any)}>
          <View style={[styles.joyBase,{width:64*2,height:64*2,borderRadius:64}]} />
          <View style={[styles.joyKnob,{width:22*2,height:22*2,borderRadius:22,
                        transform:[{translateX:joy.x*64},{translateY:-joy.y*64}], opacity: dragging?1:0.9}]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container:{ flex:1, backgroundColor:PALETTE.bg },
  hero:{ alignItems:"center", paddingTop:12, paddingBottom:6 },
  heroLogo:{ width:80, height:80, marginBottom:6, resizeMode:"contain" },
  heroTitle:{ color:"#fff", fontSize:22, fontWeight:"800" },
  heroSubtitle:{ color:"#d1d5db", marginTop:2 },

  topbar:{ flexDirection:"row", alignItems:"center", flexWrap:"wrap",
           paddingHorizontal:12, paddingVertical:10, gap:8,
           backgroundColor:PALETTE.card, borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  label:{ color:"#cfd3d8", fontSize:12 },
  input:{ backgroundColor:"#0b0d14", color:"white", borderRadius:8, paddingHorizontal:10, paddingVertical:8,
          borderWidth:1, borderColor:PALETTE.border, minWidth:120 },
  btn:{ backgroundColor:PALETTE.accent, paddingHorizontal:10, paddingVertical:10, borderRadius:10 },
  btnOn:{ backgroundColor:"#17a34a" }, btnOff:{ backgroundColor:"#374151" },
  btnText:{ color:"white", fontWeight:"600" },

  statusRow:{ flexDirection:"row", alignItems:"center", paddingHorizontal:12, paddingVertical:8, gap:8,
              backgroundColor:"#0f1322", borderBottomWidth:StyleSheet.hairlineWidth, borderBottomColor:PALETTE.border },
  badge:{ paddingHorizontal:10, paddingVertical:6, borderRadius:8, borderWidth:1, borderColor:PALETTE.border },
  status:{ color:"#cbd5ff", flex:1, fontSize:12 },

  fireBanner:{ alignItems:"center", justifyContent:"center", paddingVertical:6 },
  fireOn:{ backgroundColor:"#8b0000" }, fireOff:{ backgroundColor:"#223" },
  fireText:{ color:"white", fontWeight:"800" },

  joyWrap:{ position:"absolute", bottom:24, left:24, alignItems:"center", justifyContent:"center" },
  joyBase:{ position:"absolute", backgroundColor:"rgba(255,255,255,0.08)", borderWidth:2, borderColor:"rgba(255,255,255,0.14)" },
  joyKnob:{ position:"absolute", backgroundColor:"rgba(230,64,58,0.9)", borderWidth:2, borderColor:"rgba(255,255,255,0.85)" },
  joyText:{ position:"absolute", bottom:-22, color:"#cbd5ff", fontSize:12 },
});










# FastAPI proxy + heurística de fogo SIMPLES para ESP32-CAM

import time
import threading
from typing import Optional, Dict, Any

import cv2
import numpy as np
import requests
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ========= CONFIG SIMPLES =========
CAMERA_IP = "hydrobot.local"
SNAPSHOT_URL_FMT = "http://{}/snapshot"
CONNECT_TIMEOUT = 3.0
READ_TIMEOUT = 10.0
POLL_FPS_TARGET = 6.0
MAX_FRAME_AGE_MS = 10000
MAX_RESULT_AGE_MS = 1000
JPEG_QUALITY = 85

# Heurística simples de fogo - APENAS SCORE
HSV_LOW = (8, 70, 120)
HSV_HIGH = (40, 255, 255)
EMA_ALPHA = 0.3
FIRE_THRESHOLD = 0.15  # threshold único simples

REQUEST_HEADERS = {
    "Connection": "keep-alive",
    "User-Agent": "HydroBot-Simple/1.0",
    "Cache-Control": "no-cache",
}

def is_jpeg_bytes(b: bytes) -> bool:
    return len(b) > 4 and b[0] == 0xFF and b[1] == 0xD8

# ========= FASTAPI =========
app = FastAPI(title="HydroBot Server (Simple)", version="3.0")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True,
                   allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
    camera_ip: str

# ========= PLACEHOLDER =========
def placeholder_jpeg(msg: str = "NO FRAME") -> bytes:
    img = np.zeros((240, 320, 3), dtype=np.uint8)
    img[:, :] = (50, 50, 150)
    cv2.putText(img, msg, (50, 130), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
    cv2.putText(img, time.strftime("%H:%M:%S"), (50, 180), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
    ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY])
    return buf.tobytes()

# ========= SNAPSHOT GRABBER SIMPLES =========
class SimpleGrabber:
    def __init__(self):
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._ip = CAMERA_IP
        self._last_jpeg: Optional[bytes] = None
        self._last_ts_ms: int = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._session = requests.Session()
        self._last_err: Optional[str] = None

    def start(self, ip: Optional[str] = None):
        if ip:
            self._ip = ip
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)

    def _fetch_once(self) -> Optional[bytes]:
        try:
            u = f"{SNAPSHOT_URL_FMT.format(self._ip)}?ts={int(time.time()*1000)}"
            r = self._session.get(u, timeout=(CONNECT_TIMEOUT, READ_TIMEOUT), headers=REQUEST_HEADERS)
            
            if r.status_code == 200 and len(r.content) > 0:
                if is_jpeg_bytes(r.content):
                    return r.content
        except Exception as e:
            print(f"Fetch error: {e}")
        return None

    def _run(self):
        interval = 1.0 / POLL_FPS_TARGET
        
        while not self._stop.is_set():
            t0 = time.time()
            
            try:
                jpeg = self._fetch_once()
                if jpeg:
                    with self._lock:
                        self._last_jpeg = jpeg
                        self._last_ts_ms = int(time.time() * 1000)
                        self._last_err = None
                    
                    self._frames += 1
                    now = time.time()
                    if now - self._last_fps_tick >= 1.0:
                        self._fps = self._frames / (now - self._last_fps_tick)
                        self._frames = 0
                        self._last_fps_tick = now
                else:
                    with self._lock:
                        self._last_err = "Failed to fetch frame"
                        
            except Exception as e:
                with self._lock:
                    self._last_err = str(e)

            elapsed = time.time() - t0
            sleep_time = max(0.0, interval - elapsed)
            if not self._stop.is_set():
                time.sleep(sleep_time)

    def get_latest_jpeg(self, max_age_ms=MAX_FRAME_AGE_MS) -> Optional[bytes]:
        with self._lock:
            if self._last_jpeg is None:
                return None
            if int(time.time()*1000) - self._last_ts_ms > max_age_ms:
                return None
            return self._last_jpeg

    def status(self) -> Dict[str, Any]:
        with self._lock:
            age = int(time.time()*1000) - self._last_ts_ms if self._last_ts_ms else None
            return {
                "ip": self._ip,
                "hasFrame": self._last_jpeg is not None,
                "age_ms": age,
                "fps_in": round(self._fps, 2),
                "last_err": self._last_err
            }

grabber = SimpleGrabber()
grabber.start(CAMERA_IP)

# ========= DETECÇÃO SIMPLES =========
def simple_fire_score(frame_bgr: np.ndarray) -> float:
    """Calcula score simples de fogo (0.0 a 1.0)"""
    try:
        hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
        mask = cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))
        
        # Proporção de pixels "fogo"
        fire_pixels = np.count_nonzero(mask)
        total_pixels = mask.size
        fire_ratio = fire_pixels / total_pixels
        
        # Brilho médio do canal V
        v_mean = np.mean(hsv[:,:,2]) / 255.0
        
        # Score combinado simples
        score = min(1.0, fire_ratio * 4.0 + v_mean * 0.1)
        return score
        
    except Exception as e:
        print(f"Fire detection error: {e}")
        return 0.0

class SimpleFireDetector:
    def __init__(self, src: SimpleGrabber):
        self.src = src
        self._lock = threading.Lock()
        self._stop = threading.Event()
        self._thread: Optional[threading.Thread] = None
        
        self._ema_score = 0.0
        self._raw_score = 0.0
        self._is_fire = False
        self._last_ts = 0
        self._fps = 0.0
        self._frames = 0
        self._last_fps_tick = time.time()
        self._frame_wh: Optional[tuple] = None

    def start(self):
        self.stop()
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)

    def _run(self):
        interval = 1.0 / 5.0  # 5 FPS para detecção
        
        while not self._stop.is_set():
            t0 = time.time()
            
            jpeg = self.src.get_latest_jpeg()
            if jpeg is None:
                time.sleep(0.1)
                continue
                
            try:
                frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
                if frame is None:
                    continue
                
                H, W = frame.shape[:2]
                self._frame_wh = (W, H)
                
                # Calcula score simples
                raw_score = simple_fire_score(frame)
                
                # EMA suavizado
                if self._ema_score == 0.0:
                    ema_score = raw_score
                else:
                    ema_score = EMA_ALPHA * raw_score + (1.0 - EMA_ALPHA) * self._ema_score
                
                # Detecção simples
                is_fire = ema_score >= FIRE_THRESHOLD
                
                with self._lock:
                    self._raw_score = raw_score
                    self._ema_score = ema_score
                    self._is_fire = is_fire
                    self._last_ts = int(time.time() * 1000)
                    
                    # FPS
                    self._frames += 1
                    now = time.time()
                    if now - self._last_fps_tick >= 1.0:
                        self._fps = self._frames / (now - self._last_fps_tick)
                        self._frames = 0
                        self._last_fps_tick = now
                        
            except Exception as e:
                print(f"Detection error: {e}")
                continue
            
            elapsed = time.time() - t0
            sleep_time = max(0.0, interval - elapsed)
            if not self._stop.is_set():
                time.sleep(sleep_time)

    def get(self) -> Dict[str, Any]:
        with self._lock:
            return {
                "ok": True,
                "isFire": bool(self._is_fire),
                "score": round(float(self._ema_score), 3),
                "score_raw": round(float(self._raw_score), 3),
                "ts": int(self._last_ts),
                "fps_det": round(float(self._fps), 2),
                "frame_wh": list(self._frame_wh) if self._frame_wh else None
            }

detector = SimpleFireDetector(grabber)
detector.start()

# ========= ENDPOINTS =========
@app.get("/healthz")
def healthz():
    s = grabber.status()
    return {
        "ok": True,
        "camera_ip": s.get("ip"),
        "fps_in": s.get("fps_in"),
        "hasFrame": s.get("hasFrame"),
        "age_ms": s.get("age_ms"),
        "last_err": s.get("last_err")
    }

@app.get("/status")
def status():
    s = grabber.status()
    d = detector.get()
    return {"ok": True, "camera_ip": s["ip"], **s, **d}

@app.post("/config")
def set_config(cfg: ConfigIn):
    global CAMERA_IP
    CAMERA_IP = cfg.camera_ip
    grabber.start(CAMERA_IP)
    return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
    b = grabber.get_latest_jpeg() or placeholder_jpeg("NO RECENT FRAME")
    headers = {
        "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
        "Pragma": "no-cache",
        "Expires": "0",
        "Content-Type": "image/jpeg"
    }
    return Response(content=b, headers=headers, media_type="image/jpeg")

@app.get("/frame.jpg")
def frame_jpg():
    """Endpoint alternativo para snapshot"""
    return snapshot()

@app.get("/detect")
def detect():
    res = detector.get()
    
    # Se resultado é recente, retorna
    if res.get("ts", 0) and (int(time.time()*1000) - res["ts"] <= MAX_RESULT_AGE_MS):
        return res
    
    # Senão, faz detecção rápida
    jpeg = grabber.get_latest_jpeg()
    if jpeg is None:
        return {"ok": False, "error": "no recent frame"}
    
    try:
        frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
        if frame is None:
            return {"ok": False, "error": "decode failed"}
        
        H, W = frame.shape[:2]
        score = simple_fire_score(frame)
        is_fire = score >= FIRE_THRESHOLD
        
        return {
            "ok": True,a
            "isFire": is_fire,
            "score": round(score, 3),
            "score_raw": round(score, 3),
            "ts": int(time.time()*1000),
            "frame_wh": [W, H],
            "fallback": True
        }
        
    except Exception as e:
        return {"ok": False, "error": f"detection failed: {str(e)}"}

if __name__ == "__main__":
    import uvicorn
    print("Iniciando HydroBot Server (versão simplificada)...")
    print(f"Camera IP: {CAMERA_IP}")
    print(f"FPS alvo: {POLL_FPS_TARGET}")
    print(f"Fire threshold: {FIRE_THRESHOLD}")
    uvicorn.run(app, host="0.0.0.0", port=8000)












/*
  HydroBot - ESP32-CAM em modo STA (versão simplificada)
  - Endpoints:
      GET  /              -> página info rápida
      GET  /status        -> JSON (uptime, RSSI, heap, ip, último STATUS do Arduino)
      GET  /snapshot      -> JPEG único
      GET  /stream        -> MJPEG stream
      POST /uart?cmd=...  -> envia comando na UART para o Arduino (ex: CMD:FWD:ms=400:spd=70)
      POST /led?on=0|1    -> liga/desliga flash (GPIO 4)
      POST /restart       -> reinicia ESP
  - mDNS: http://hydrobot.local
  - CORS: Access-Control-Allow-Origin: *
  - UART: Serial2 (pinos configuráveis abaixo). ESP requisita "REQ:STATUS\n" periodicamente e armazena última linha "STAT:...".
*/

#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include "esp_timer.h"
#include "img_converters.h"
#include "esp_camera.h"
#include "fb_gfx.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ====== CONFIG ======
const char* WIFI_SSID   = "HydroBot";
const char* WIFI_PASS   = "loud2025emibr";

// (Opcional) IP fixo – deixe comentado se preferir DHCP
//#define USE_STATIC_IP
IPAddress local_IP(192,168,0,50);
IPAddress gateway(192,168,0,1);
IPAddress subnet(255,255,255,0);
IPAddress dns1(8,8,8,8);
IPAddress dns2(1,1,1,1);

// mDNS
const char* MDNS_NAME = "hydrobot"; // http://hydrobot.local

// UART com Arduino (ajuste conforme seu fio)
// Recomenda-se ESP32-CAM: RX=15, TX=14 (costuma estar disponível nesse módulo)
#define UART_RX_PIN 15
#define UART_TX_PIN 14
#define UART_BAUD   115200

// Requisição periódica ao Arduino
#define STATUS_POLL_MS  1000

// Camera: selecione pinos do modelo AI Thinker
#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

// ====== FIM CONFIG ======

// Servidor HTTP
WebServer server(80);

// Buffer do último STATUS do Arduino
String lastStatusLine = "";

// Controle de LED do flash (AI Thinker usa GPIO 4 pra lâmpada)
static const int FLASH_PIN = 4;

// Controle de stream - CONFIGURAÇÕES FIXAS SIMPLES
static const char* STREAM_BOUNDARY = "frame";
static const char* STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" "frame";
static const int JPEG_QUALITY = 25;    // QUALIDADE BAIXA FIXA para estabilidade
static const bool STREAM_HFLIP = false; 
static const bool STREAM_VFLIP = false; 

// Watchdog / reconexão
unsigned long lastWiFiCheck = 0;
unsigned long lastStatusPoll = 0;

// ---------- Util ----------
void addCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}
void handleOptions() {
  addCORS();
  server.send(204);
}

// ---------- UART ----------
void initUART() {
  Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN);
}
void pollArduinoStatus() {
  static String rxBuf;
  // Solicita status
  Serial2.print("REQ:STATUS\n");
  // Lê o que chegou desde a última chamada
  while (Serial2.available()) {
    char c = (char)Serial2.read();
    if (c == '\n' || c == '\r') {
      if (rxBuf.length() > 0) {
        // Guarda última linha completa
        if (rxBuf.startsWith("STAT:")) {
          lastStatusLine = rxBuf;
        }
        rxBuf = "";
      }
    } else {
      rxBuf += c;
    }
  }
}

// ---------- Câmera SIMPLIFICADA ----------
bool initCamera() {
  // Evitar brownout reset
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;

  // CONFIGURAÇÃO SIMPLES E ESTÁVEL
  config.frame_size   = FRAMESIZE_VGA;      // VGA padrão
  config.jpeg_quality = JPEG_QUALITY;      // Qualidade baixa fixa
  config.fb_count     = 2;                 // 2 buffers simples
  
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x\n", err);
    return false;
  }

  // Configurações básicas do sensor
  sensor_t * s = esp_camera_sensor_get();
  if (s) {
    s->set_vflip(s, STREAM_VFLIP);
    s->set_hmirror(s, STREAM_HFLIP);
    // Configurações simples - sem adaptação
    s->set_whitebal(s, 1);       // white balance automático
    s->set_awb_gain(s, 1);       // AWB gain automático
    s->set_exposure_ctrl(s, 1);  // controle de exposição automático
    s->set_gain_ctrl(s, 1);      // controle de ganho automático
  }

  return true;
}

// ---------- Handlers HTTP ----------
void handleRoot() {
  addCORS();
  String html = "<!doctype html><html><head><meta charset='utf-8'/>"
                "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
                "<title>HydroBot ESP32-CAM</title>"
                "<style>body{font-family:system-ui;background:#0b0b0f;color:#e5e7eb;padding:16px}"
                "a,button{background:#e6403a;color:#fff;padding:8px 12px;border:none;border-radius:8px;text-decoration:none;margin-right:8px}"
                "code{background:#121218;padding:2px 6px;border-radius:6px}</style></head><body>";
  html += "<h2>HydroBot ESP32-CAM (Simplificado)</h2>";
  html += "<p>IP: <code>" + WiFi.localIP().toString() + "</code> | RSSI: <code>" + String(WiFi.RSSI()) + " dBm</code></p>";
  html += "<p>Heap livre: <code>" + String(ESP.getFreeHeap()) + " bytes</code> | Qualidade JPEG: <code>" + String(JPEG_QUALITY) + "</code></p>";
  html += "<p><a href='/snapshot'>/snapshot</a> <a href='/stream'>/stream</a> <a href='/status'>/status</a></p>";
  html += "<p>mDNS: <code>http://" + String(MDNS_NAME) + ".local</code></p>";
  html += "<p>Último STATUS Arduino: <code>" + (lastStatusLine.length() ? lastStatusLine : "(ainda não)") + "</code></p>";
  html += "</body></html>";
  server.send(200, "text/html", html);
}

void handleStatus() {
  addCORS();
  // Monta JSON simples
  String json = "{";
  json += "\"ip\":\"" + WiFi.localIP().toString() + "\",";
  json += "\"rssi\":" + String(WiFi.RSSI()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"uptime_ms\":" + String(millis()) + ",";
  json += "\"jpeg_quality\":" + String(JPEG_QUALITY) + ",";
  // Se quiser, parse do lastStatusLine -> chave:valor
  json += "\"arduino_status\":\"" + lastStatusLine + "\"";
  json += "}";
  server.send(200, "application/json", json);
}

void handleSnapshot() {
  addCORS();
  
  camera_fb_t * fb = esp_camera_fb_get();
  
  if (!fb) {
    Serial.println("Camera capture failed");
    server.send(503, "text/plain", "Camera capture failed");
    return;
  }
  
  server.sendHeader("Content-Type", "image/jpeg");
  server.sendHeader("Content-Disposition", "inline; filename=capture.jpg");
  server.sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  
  server.send_P(200, "image/jpeg", (const char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

void handleStream() {
  WiFiClient client = server.client();
  
  // Cabeçalhos do stream
  client.println("HTTP/1.1 200 OK");
  client.println("Content-Type: " + String(STREAM_CONTENT_TYPE));
  client.println("Access-Control-Allow-Origin: *");
  client.println("Cache-Control: no-cache, no-store, must-revalidate");
  client.println("Pragma: no-cache");
  client.println();

  while (client.connected()) {
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) {
      delay(100);
      continue;
    }

    client.println("--" + String(STREAM_BOUNDARY));
    client.println("Content-Type: image/jpeg");
    client.println("Content-Length: " + String(fb->len));
    client.println();
    client.write(fb->buf, fb->len);
    client.println();
    
    esp_camera_fb_return(fb);

    // Delay fixo simples
    delay(50);
  }
}

void handleUART() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  String cmd = server.arg("cmd");
  if (!cmd.length()) {
    server.send(400, "application/json", "{\"error\":\"use /uart?cmd=...\"}");
    return;
  }
  // Garante terminador de linha
  if (!cmd.endsWith("\n")) cmd += "\n";
  Serial2.print(cmd);
  server.send(200, "application/json", "{\"ok\":true}");
}

void handleLED() {
  addCORS();
  if (server.method() == HTTP_OPTIONS) { handleOptions(); return; }
  int on = server.arg("on").toInt();
  digitalWrite(FLASH_PIN, on ? HIGH : LOW);
  server.send(200, "application/json", String("{\"on\":") + (on? "true":"false") + "}");
}

void handleRestart() {
  addCORS();
  server.send(200, "application/json", "{\"restarting\":true}");
  delay(300);
  ESP.restart();
}

// ---------- Wi-Fi ----------
void connectWiFi() {
#ifdef USE_STATIC_IP
  WiFi.config(local_IP, gateway, subnet, dns1, dns2);
#endif
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);

  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 15000) {
    delay(250);
  }
}

void setupServer() {
  // Rotas
  server.on("/", HTTP_GET, handleRoot);
  server.on("/status", HTTP_GET, handleStatus);
  server.on("/snapshot", HTTP_GET, handleSnapshot);
  server.on("/stream", HTTP_GET, handleStream);
  server.on("/uart", HTTP_POST, handleUART);
  server.on("/led", HTTP_POST, handleLED);
  server.on("/restart", HTTP_POST, handleRestart);

  // CORS preflight
  server.onNotFound([](){
    addCORS();
    server.send(404, "application/json", "{\"error\":\"not found\"}");
  });
  server.on("/uart", HTTP_OPTIONS, handleOptions);
  server.on("/led", HTTP_OPTIONS, handleOptions);
  server.on("/restart", HTTP_OPTIONS, handleOptions);

  server.begin();
}

// ---------- setup / loop ----------
void setup() {
  // Logs seriais (opcional). Evite compartilhar TX0/RX0 com Arduino se usar USB.
  Serial.begin(115200);
  delay(200);

  pinMode(FLASH_PIN, OUTPUT);
  digitalWrite(FLASH_PIN, LOW);

  // UART secundária com Arduino
  initUART();

  // Câmera
  if (!initCamera()) {
    Serial.println("Falha na inicialização da câmera, tentando novamente...");
    delay(1000);
    if (!initCamera()) {
      Serial.println("Falha crítica na câmera");
    }
  } else {
    Serial.println("Câmera inicializada com sucesso");
  }

  // Wi-Fi
  connectWiFi();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("WiFi conectado: " + WiFi.localIP().toString());
  } else {
    Serial.println("Falha na conexão WiFi");
  }

  // mDNS
  if (WiFi.status() == WL_CONNECTED) {
    if (MDNS.begin(MDNS_NAME)) {
      MDNS.addService("http", "tcp", 80);
      Serial.println("mDNS iniciado: http://" + String(MDNS_NAME) + ".local");
    }
  }

  // HTTP
  setupServer();
  Serial.println("Servidor HTTP iniciado");
}

void loop() {
  server.handleClient();

  // Watch Wi-Fi & reconectar
  if (millis() - lastWiFiCheck > 3000) {
    lastWiFiCheck = millis();
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("WiFi desconectado, tentando reconectar...");
      connectWiFi();
    }
  }

  // Poll do STATUS no Arduino
  if (millis() - lastStatusPoll > STATUS_POLL_MS) {
    lastStatusPoll = millis();
    pollArduinoStatus();
  }
}
