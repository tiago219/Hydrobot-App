/**
 * HydroBot.ino - ESP32-CAM (AI Thinker) - AP ONLY (sem sensores)
 * - AP fixo (HYDROBOT-CAM)
 * - Stream MJPEG: /stream (porta 81)
 * - API (80): /status, /led, /mode, /joystick, /pump (on/off), /pump_pwm?duty=0..255, /snapshot (JPEG √∫nico)
 * - LED no GPIO 4 (flash onboard)
 * - Bomba por MOSFET com PWM (LEDC via ESP-IDF)
 */

#include <Arduino.h>
#include "esp_camera.h"
#include <WiFi.h>
#include <WebServer.h>
#include "esp_http_server.h"
#include <time.h>
#include "driver/ledc.h"   // PWM (ESP-IDF)

// Desativa brownout
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ===================== WIFI AP =====================
const char* AP_SSID = "HYDROBOT-CAM";
const char* AP_PASS = "12345678"; // 8+ chars

// ===================== PINOS =====================
// LED seguro no ESP32-CAM (flash onboard). Se quiser usar 2, troque aqui (n√£o recomendado).
#define LED_FLASH_PIN 4
// Bomba (MOSFET): evite 1/3/2/12/15; 14 √© est√°vel no ESP32-CAM
#define PUMP_PIN 14

// ===================== ESTADO =====================
String g_mode = "manual";
bool   g_ledOn = false;
bool   g_pumpOn = false;
float  g_joyX = 0.0f, g_joyY = 0.0f;

static httpd_handle_t stream_httpd = NULL;
WebServer server(80);

// ===================== CAMERA (AI THINKER) =====================
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ===================== UTILS =====================
String isoTimestamp() {
  time_t now = time(nullptr);
  if (now < 8 * 3600 * 2) {
    unsigned long ms = millis();
    char buf[64];
    snprintf(buf, sizeof(buf), "\"uptime_ms\":%lu", ms);
    return String("{") + buf + "}";
  }
  struct tm timeinfo;
  localtime_r(&now, &timeinfo);
  char buf[64];
  strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S%z", &timeinfo);
  String ts(buf);
  if (ts.length() >= 5) ts = ts.substring(0, ts.length()-2) + ":" + ts.substring(ts.length()-2);
  return "\"" + ts + "\"";
}

void sendCORSHeaders(httpd_req_t *req) {
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Headers", "Content-Type");
}

void sendCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}

// ===================== BOMBA (PWM via ESP-IDF LEDC) =====================
static const ledc_channel_t PUMP_CH   = LEDC_CHANNEL_0;
static const ledc_timer_t   PUMP_TMR  = LEDC_TIMER_0;
static const ledc_mode_t    PUMP_MODE = LEDC_HIGH_SPEED_MODE;

void pumpPwmInit() {
  ledc_timer_config_t tcfg = {};
  tcfg.speed_mode      = PUMP_MODE;
  tcfg.timer_num       = PUMP_TMR;
  tcfg.duty_resolution = LEDC_TIMER_8_BIT; // 0..255
  tcfg.freq_hz         = 5000;            // 5 kHz
  tcfg.clk_cfg         = LEDC_AUTO_CLK;
  ledc_timer_config(&tcfg);

  ledc_channel_config_t ccfg = {};
  ccfg.gpio_num   = PUMP_PIN;
  ccfg.speed_mode = PUMP_MODE;
  ccfg.channel    = PUMP_CH;
  ccfg.intr_type  = LEDC_INTR_DISABLE;
  ccfg.timer_sel  = PUMP_TMR;
  ccfg.duty       = 0;
  ccfg.hpoint     = 0;
  ledc_channel_config(&ccfg);

  g_pumpOn = false;
}

static inline void pumpWriteDuty(uint8_t duty) {
  ledc_set_duty(PUMP_MODE, PUMP_CH, duty);
  ledc_update_duty(PUMP_MODE, PUMP_CH);
}

void pumpSetOnOff(bool on) {
  g_pumpOn = on;
  pumpWriteDuty(on ? 255 : 0);
}

void pumpSetDuty(uint8_t duty) {
  if (duty > 255) duty = 255;
  g_pumpOn = (duty > 0);
  pumpWriteDuty(duty);
}

// ===================== STREAM (/stream) =====================
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";
static const char* _STREAM_BOUNDARY = "\r\n--frame\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

esp_err_t jpg_stream_httpd_handler(httpd_req_t *req) {
  sendCORSHeaders(req);
  camera_fb_t * fb = NULL;
  esp_err_t res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) return res;

  while (true) {
    fb = esp_camera_fb_get();
    if (!fb) return ESP_FAIL;
    if (fb->format != PIXFORMAT_JPEG) { esp_camera_fb_return(fb); continue; }

    res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    if (res == ESP_OK) {
      char part_buf[64];
      size_t hlen = snprintf(part_buf, 64, _STREAM_PART, fb->len);
      res = httpd_resp_send_chunk(req, part_buf, hlen);
    }
    if (res == ESP_OK) res = httpd_resp_send_chunk(req, (const char *)fb->buf, fb->len);

    esp_camera_fb_return(fb);
    if (res != ESP_OK) break;
    vTaskDelay(10 / portTICK_PERIOD_MS);
  }
  return res;
}

void startCameraStreamServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 81;
  config.ctrl_port = 32768;
  config.max_open_sockets = 3;
  config.task_priority = 5;

  httpd_uri_t stream_uri = { .uri="/stream", .method=HTTP_GET, .handler=jpg_stream_httpd_handler, .user_ctx=NULL };
  if (httpd_start(&stream_httpd, &config) == ESP_OK) {
    httpd_register_uri_handler(stream_httpd, &stream_uri);
    Serial.println("Stream em :81/stream");
  }
}

// ===================== API =====================
void api_status() {
  sendCORS();
  String ts = isoTimestamp();
  String json = "{";
  json += "\"ip\":\"" + WiFi.softAPIP().toString() + "\",";
  json += "\"mode\":\"" + g_mode + "\",";
  json += "\"led\":" + String(g_ledOn ? "true":"false") + ",";
  json += "\"pump\":" + String(g_pumpOn ? "true":"false") + ",";
  json += "\"uptime\":" + String(millis()) + ",";
  json += "\"heap\":" + String(ESP.getFreeHeap()) + ",";
  json += "\"ts\":" + ts;
  json += "}";
  server.send(200, "application/json", json);
}

void api_led() {
  sendCORS();
  bool on = server.arg("on") == "1" || server.arg("on") == "true";
  g_ledOn = on;
  digitalWrite(LED_FLASH_PIN, g_ledOn ? HIGH : LOW);
  server.send(200, "application/json", String("{\"ok\":true,\"led\":") + (g_ledOn?"true":"false") + "}");
}

void api_pump() { // on/off r√°pido
  sendCORS();
  bool on = server.arg("on") == "1" || server.arg("on") == "true";
  pumpSetOnOff(on);
  server.send(200, "application/json", String("{\"ok\":true,\"pump\":") + (g_pumpOn?"true":"false") + "}");
}

void api_pump_pwm() { // duty 0..255
  sendCORS();
  int duty = server.hasArg("duty") ? server.arg("duty").toInt() : -1;
  if (duty < 0 || duty > 255) {
    server.send(400, "application/json", "{\"ok\":false,\"error\":\"duty 0..255\"}");
    return;
  }
  pumpSetDuty((uint8_t)duty);
  server.send(200, "application/json", String("{\"ok\":true,\"duty\":") + duty + "}");
}

void api_mode() {
  sendCORS();
  String v = server.arg("v"); if (v.length()==0) v = server.arg("mode");
  if (v != "manual" && v != "auto" && v != "patrol") {
    server.send(400, "application/json", "{\"ok\":false,\"error\":\"mode must be manual|auto|patrol\"}");
    return;
  }
  g_mode = v;
  server.send(200, "application/json", String("{\"ok\":true,\"mode\":\"") + g_mode + "\"}");
}

void api_joystick() {
  sendCORS();
  float x = server.arg("x").toFloat();
  float y = server.arg("y").toFloat();
  if (x < -1) x = -1; if (x > 1) x = 1;
  if (y < -1) y = -1; if (y > 1) y = 1;
  g_joyX = x; g_joyY = y;
  server.send(200, "application/json", String("{\"ok\":true,\"x\":") + x + ",\"y\":" + y + "}");
}

void handleCORS() {
  sendCORS();
  server.send(200);
}

// ===== NOVO: /snapshot (JPEG √∫nico para o app React Native) =====
void api_snapshot() {
  sendCORS();
  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb) {
    server.send(503, "application/json", "{\"ok\":false,\"error\":\"no_frame\"}");
    return;
  }
  if (fb->format != PIXFORMAT_JPEG) {
    esp_camera_fb_return(fb);
    server.send(500, "application/json", "{\"ok\":false,\"error\":\"not_jpeg\"}");
    return;
  }

  // Desabilita cache no cliente
  server.sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  server.setContentLength(fb->len);
  server.send(200, "image/jpeg", "");            // inicia resposta
  WiFiClient client = server.client();
  client.write(fb->buf, fb->len);                // envia bytes do JPEG
  esp_camera_fb_return(fb);
}

// ===================== SETUP =====================
void setupNTP() {
  configTime(-3 * 3600, 0, "pool.ntp.org", "time.nist.gov");
}

bool initCamera() {
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;

  if (psramFound()) {
    config.frame_size = FRAMESIZE_VGA;
    config.jpeg_quality = 12;
    config.fb_count = 2;
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
  } else {
    config.frame_size = FRAMESIZE_QVGA;
    config.jpeg_quality = 15;
    config.fb_count = 1;
    config.fb_location = CAMERA_FB_IN_DRAM;
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed: 0x%x\n", err);
    return false;
  }
  return true;
}

void startAPOnly() {
  WiFi.mode(WIFI_AP);
  WiFi.softAP(AP_SSID, AP_PASS);
  delay(100);
  Serial.println("AP iniciado:");
  Serial.print(" SSID: "); Serial.println(AP_SSID);
  Serial.print(" PASS: "); Serial.println(AP_PASS);
  Serial.print(" IP: ");   Serial.println(WiFi.softAPIP());
}

void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);
  Serial.begin(115200);
  Serial.println("\n=== HYDROBOT CAM (AP ONLY / SEM SENSORES) ===");

  pinMode(LED_FLASH_PIN, OUTPUT);
  digitalWrite(LED_FLASH_PIN, LOW);

  pumpPwmInit();

  if (!initCamera()) {
    Serial.println("Camera FAIL");
    delay(3000);
    ESP.restart();
  }

  startAPOnly();
  setupNTP();

  // Rotas
  server.on("/status",    HTTP_GET, api_status);
  server.on("/led",       HTTP_GET, api_led);
  server.on("/led",       HTTP_POST, api_led);
  server.on("/pump",      HTTP_GET, api_pump);
  server.on("/pump",      HTTP_POST, api_pump);
  server.on("/pump_pwm",  HTTP_GET, api_pump_pwm);
  server.on("/pump_pwm",  HTTP_POST, api_pump_pwm);
  server.on("/mode",      HTTP_GET, api_mode);
  server.on("/mode",      HTTP_POST, api_mode);
  server.on("/joystick",  HTTP_GET, api_joystick);
  server.on("/joystick",  HTTP_POST, api_joystick);

  // NOVO: snapshot
  server.on("/snapshot",  HTTP_GET, api_snapshot);

  // CORS (OPTIONS)
  server.on("/status",    HTTP_OPTIONS, handleCORS);
  server.on("/led",       HTTP_OPTIONS, handleCORS);
  server.on("/pump",      HTTP_OPTIONS, handleCORS);
  server.on("/pump_pwm",  HTTP_OPTIONS, handleCORS);
  server.on("/mode",      HTTP_OPTIONS, handleCORS);
  server.on("/joystick",  HTTP_OPTIONS, handleCORS);
  server.on("/snapshot",  HTTP_OPTIONS, handleCORS);

  server.begin();
  Serial.println("HTTP :80 pronto");
  startCameraStreamServer();
  Serial.println("=== PRONTO ===");
}

void loop() {
  server.handleClient();
  delay(10);
}







































































Perfeito ‚Äî o que est√° travando √© o servidor disputando o /stream do ESP.

A solu√ß√£o √© n√£o abrir o /stream no servidor. Em vez disso, o servidor deve buscar 1 frame via /snapshot do ESP (porta 80) a cada chamada de /detect (e de /snapshot do pr√≥prio servidor). Assim:




O app continua exatamente como est√° (WebView em :81/stream, sem mudar nada).


O servidor n√£o segura conex√£o nenhuma no :81/stream; ele s√≥ ‚Äúbelisca‚Äù uma foto no :80/snapshot quando preciso.


Para evitar carga, o servidor faz cache de 200 ms do √∫ltimo snapshot (throttle), ent√£o mesmo que o app pe√ßa /detect a cada 500 ms, o ESP n√£o √© sobrecarregado.




Abaixo o server_heuristic.py completo refeito para esse fluxo (sem tocar no app):


# server_heuristic.py
# FastAPI + OpenCV + requests
# N√ÉO abre o :81/stream do ESP. Apenas consome /snapshot (porta 80) por demanda,
# com cache de 200 ms para reduzir carga.

import time
import threading
from typing import Optional, List

import cv2
import numpy as np
import requests
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ================== CONFIG ==================
CAMERA_IP = "192.168.4.1"       # IP do ESP32-CAM (AP HYDROBOT-CAM)
ESP_SNAPSHOT = "http://{ip}/snapshot"   # JPEG √∫nico (porta 80)
SCORE_THRESHOLD = 0.60

HTTP_TIMEOUT = 2.0              # segundos para GET no /snapshot do ESP
CACHE_WINDOW_S = 0.20           # 200 ms: throttling de snapshot
JPEG_QUALITY = 85               # qualidade para re-encode em /snapshot

# ================== APP ==================
app = FastAPI(title="HydroBot Fire (Heuristic via ESP /snapshot)", version="0.3.0")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"]
)

class ConfigIn(BaseModel):
    camera_ip: str

# ============ Snapshot Cache ============
_last_jpeg: Optional[bytes] = None
_last_frame: Optional[np.ndarray] = None  # BGR
_last_ts: float = 0.0
_lock = threading.Lock()

def _fetch_snapshot_from_esp(ip: str) -> Optional[bytes]:
    """Busca JPEG do ESP via /snapshot (porta 80)."""
    url = ESP_SNAPSHOT.format(ip=ip)
    try:
        r = requests.get(url, timeout=HTTP_TIMEOUT)
        if r.status_code == 200 and r.headers.get("content-type", "").startswith("image/"):
            return r.content
    except Exception:
        pass
    return None

def _get_snapshot_bytes(ip: str) -> Optional[bytes]:
    """Throttle com cache de 200 ms para n√£o sobrecarregar o ESP."""
    global _last_jpeg, _last_ts
    now = time.time()
    with _lock:
        if (now - _last_ts) < CACHE_WINDOW_S and _last_jpeg is not None:
            return _last_jpeg
    # fora do cache: buscar de fato
    jpeg = _fetch_snapshot_from_esp(ip)
    if jpeg is not None:
        with _lock:
            _last_jpeg = jpeg
            _last_ts = time.time()
    return jpeg

def _get_frame_bgr(ip: str) -> Optional[np.ndarray]:
    """Retorna frame BGR decodificado do √∫ltimo JPEG (com cache)."""
    global _last_frame
    jpeg = _get_snapshot_bytes(ip)
    if jpeg is None:
        return None
    with _lock:
        # se j√° existe frame decodificado referente ao √∫ltimo _last_jpeg, reutiliza
        if _last_frame is not None and _last_jpeg is not None and len(jpeg) == len(_last_jpeg) and jpeg[:16] == _last_jpeg[:16]:
            return _last_frame.copy()
    # decodifica fora do lock
    arr = np.frombuffer(jpeg, dtype=np.uint8)
    frame = cv2.imdecode(arr, cv2.IMREAD_COLOR)
    if frame is None:
        return None
    with _lock:
        _last_frame = frame
    return frame.copy()

# ============ Heur√≠stica de fogo ============
def fire_score(frame: np.ndarray) -> float:
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, (5, 80, 120), (40, 255, 255))   # faixa laranja-amarela
    ratio = float(np.count_nonzero(mask)) / float(mask.size)
    v_mean = float(np.mean(hsv[..., 2])) / 255.0
    return min(1.0, ratio * 4.0 + v_mean * 0.2)

def fire_boxes(frame: np.ndarray) -> List[List[int]]:
    h, w = frame.shape[:2]
    scl = min(640, w)
    rs = cv2.resize(frame, (scl, int(h * scl / w)))
    hsv = cv2.cvtColor(rs, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, (5, 80, 120), (40, 255, 255))
    k = np.ones((5, 5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, k, 1)
    mask = cv2.morphologyEx(mask, cv2.MORPH_DILATE, k, 1)
    cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    rx = w / float(scl)
    ry = h / float(rs.shape[0])
    boxes: List[List[int]] = []
    for c in cnts:
        x, y, bw, bh = cv2.boundingRect(c)
        if bw * bh < 600:
            continue
        boxes.append([int(x * rx), int(y * ry), int(bw * rx), int(bh * ry)])
    return boxes

# ============ Rotas ============
@app.get("/status")
def status():
    return {
        "ok": True,
        "camera_ip": CAMERA_IP,
        "source": "ESP:/snapshot",
        "note": "Server does NOT open ESP :81/stream; it only fetches snapshots on demand with 200ms cache.",
        "ts": int(time.time() * 1000),
    }

@app.post("/config")
def set_config(cfg: ConfigIn):
    global CAMERA_IP
    CAMERA_IP = cfg.camera_ip
    return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
    jpeg = _get_snapshot_bytes(CAMERA_IP)
    if jpeg is None:
        return {"ok": False, "error": "no frame from ESP /snapshot"}
    # devolve como image/jpeg (pode ser √∫til para debug no navegador)
    return Response(content=jpeg, media_type="image/jpeg")

@app.get("/detect")
def detect():
    frame = _get_frame_bgr(CAMERA_IP)
    if frame is None:
        return {"ok": False, "error": "no frame from ESP /snapshot"}
    s = fire_score(frame)
    is_fire = bool(s >= SCORE_THRESHOLD)
    return {
        "ok": True,
        "isFire": is_fire,
        "score": round(float(s), 3),
        "boxes": (fire_boxes(frame) if is_fire else []),
        "threshold": SCORE_THRESHOLD,
        "ts": int(time.time() * 1000),
    }



Por que isso resolve




O app continua consumindo o :81/stream sem concorr√™ncia.


O servidor nunca toca o :81/stream; ele usa /snapshot (porta 80) ‚Äî uma foto por requisi√ß√£o.


O cache de 200 ms impede que m√∫ltiplas chamadas seguidas causem rajadas no ESP.




Pr√©-requisitos


Instale as depend√™ncias do servidor:


pip install fastapi uvicorn requests opencv-python



Rodar:


uvicorn server_heuristic:app --host 0.0.0.0 --port 8000



Checagem r√°pida do ESP


Como voc√™ j√° adicionou o /snapshot no ESP, confirme que estas linhas existem no setup():


server.on("/snapshot",  HTTP_GET, api_snapshot);
server.on("/snapshot",  HTTP_OPTIONS, handleCORS);



‚Ä¶e que o handler api_snapshot() envia image/jpeg (como voc√™ j√° tinha).


Se ainda assim a c√¢mera apagar quando o servidor sobe, √© quase certo que o servidor ainda esteja chamando :81/stream (algum processo antigo) ‚Äî feche processos anteriores ou troque a porta do uvicorn para garantir que voc√™ est√° usando este bin√°rio novo.


Quer que eu inclua um docker-compose.yml para esse servidor?


























































Fechou. A raiz do problema √© a disputa pelo /stream do ESP quando o servidor est√° ligado. Vou te dar um CameraScreen.tsx completo que:




Mostra o v√≠deo sempre por /snapshot do ESP (porta 80) ‚Äî sem WebView, sem MJPEG.

Isso elimina qualquer conflito com o servidor (que tamb√©m pode usar /snapshot).


Detec√ß√£o e salvamento continuam usando o servidor (campo Servidor) em /detect e seu saveEventFromServer.


Tem fallbacks robustos de rede e evita requisi√ß√µes concorrentes (sem ‚Äúfila‚Äù de fetch).




Cole este arquivo inteiro:


// app/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View, Text, TextInput, Pressable, StyleSheet, PanResponder,
  GestureResponderEvent, PanResponderGestureState, Image, Platform,
} from "react-native";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

const PALETTE = { bg: "#000000", card: "#0d0d0d", border: "#1a1a1a", red: "#E53B2F", white: "#ffffff" };

const texts = {
  pt: {
    espIp: "ESP IP:", test: "Testar", ledOn: "LED ON", ledOff: "LED OFF",
    pumpOn: "BOMBA ON", pumpOff: "BOMBA OFF", server: "Servidor:",
    detect: "Detectar", detecting: "Detectando", saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.",
    noVideo: "Sem v√≠deo. Verifique o /snapshot do ESP.",
    fireOn: (s:number)=>`üî• FOGO ‚Ä¢ score ${s.toFixed(2)}`, fireOff: (s:number)=>`Sem fogo ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts:string)=>`Evento salvo em ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    needServer: "Defina o campo Servidor para detectar fogo.",
    usingEspSnapshot: "Exibindo v√≠deo via /snapshot do ESP (porta 80).",
  },
  en: {
    espIp: "ESP IP:", test: "Test", ledOn: "LED ON", ledOff: "LED OFF",
    pumpOn: "PUMP ON", pumpOff: "PUMP OFF", server: "Server:",
    detect: "Detect", detecting: "Detecting", saving: "Saving...",
    statusFail: "Failed to connect. Check HYDROBOT-CAM Wi-Fi and IP.",
    noVideo: "No video. Check ESP /snapshot.",
    fireOn: (s:number)=>`üî• FIRE ‚Ä¢ score ${s.toFixed(2)}`, fireOff: (s:number)=>`No fire ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts:string)=>`Event saved at ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    needServer: "Set the Server field to run fire detection.",
    usingEspSnapshot: "Showing video via ESP /snapshot (port 80).",
  },
  es: {
    espIp: "ESP IP:", test: "Probar", ledOn: "LED ON", ledOff: "LED OFF",
    pumpOn: "BOMBA ON", pumpOff: "BOMBA OFF", server: "Servidor:",
    detect: "Detectar", detecting: "Detectando", saving: "Guardando...",
    statusFail: "Fallo de conexi√≥n. Verifica el Wi-Fi HYDROBOT-CAM y el IP.",
    noVideo: "Sin v√≠deo. Revisa /snapshot del ESP.",
    fireOn: (s:number)=>`üî• FUEGO ‚Ä¢ score ${s.toFixed(2)}`, fireOff: (s:number)=>`Sin fuego ‚Ä¢ score ${s.toFixed(2)}`,
    eventSavedAt: (ts:string)=>`Evento guardado a las ${ts}`,
    placeholderIp: "192.168.4.1",
    placeholderServer: "http://192.168.4.2:8000",
    needServer: "Define el Servidor para detectar fuego.",
    usingEspSnapshot: "Mostrando v√≠deo v√≠a /snapshot del ESP (puerto 80).",
  },
};

const DEFAULT_IP = "192.168.4.1";
const DEFAULT_SERVER = ""; // vazio => detec√ß√£o desligada

export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = texts[lang];

  // conex√µes
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");
  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // detec√ß√£o
  const [detectOn, setDetectOn] = useState<boolean>(false);
  const [isFire, setIsFire] = useState<boolean>(false);
  const [fireScore, setFireScore] = useState<number>(0);

  // registro
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef<number>(0);
  const wasFireRef = useRef<boolean>(false);
  const SAVE_COOLDOWN_MS = 5000;

  // v√≠deo via /snapshot (ESP)
  const [frameUri, setFrameUri] = useState<string>("");
  const fetchBusyRef = useRef<boolean>(false); // evita concorr√™ncia de updates
  const stopVideoRef = useRef<boolean>(false);

  // joystick (UI)
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // bases
  const espBase = useMemo(() => `http://${ip}`, [ip]);
  const serverBase = useMemo(() => (server && server.trim()) ? server.trim().replace(/\/+$/,"") : "", [server]);

  // URLs do ESP
  const statusUrl = useMemo(() => `${espBase}/status`, [espBase]);
  const ledUrl    = useMemo(() => (on: boolean) => `${espBase}/led?on=${on ? "1" : "0"}`, [espBase]);
  const pumpUrl   = useMemo(() => (on: boolean) => `${espBase}/pump?on=${on ? "1" : "0"}`, [espBase]);

  // ===== ESP STATUS =====
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl, { method: "GET" });
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(`OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`);
    } catch {
      setStatusText(T.statusFail);
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() { try { const t = !ledOn; await fetch(ledUrl(t)); setLedOn(t); } catch { setStatusText(T.statusFail); } }
  async function togglePump() { try { const t = !pumpOn; await fetch(pumpUrl(t)); setPumpOn(t); } catch { setStatusText(T.statusFail); } }

  useEffect(() => { pingStatus(); const id = setInterval(pingStatus, 5000); return () => clearInterval(id); }, [statusUrl]);

  // ===== V√çDEO POR SNAPSHOT DO ESP (sem MJPEG, sem WebView) =====
  // Evita disputar o /stream com o servidor. Apenas puxa /snapshot do ESP em loop.
  useEffect(() => {
    setStatusText(T.usingEspSnapshot);
    stopVideoRef.current = false;
    const TICK_MS = 250;

    const tick = () => {
      if (stopVideoRef.current) return;
      if (!fetchBusyRef.current) {
        fetchBusyRef.current = true;
        // Apenas atualiza o URI do <Image>; o RN buscar√° a imagem.
        setFrameUri(`${espBase}/snapshot?ts=${Date.now()}`);
        // Liberamos o "busy" logo ap√≥s, pois o <Image> vai fazer a requisi√ß√£o
        // sem bloquear o JS thread.
        fetchBusyRef.current = false;
      }
      setTimeout(tick, TICK_MS);
    };

    tick();
    return () => { stopVideoRef.current = true; };
  }, [espBase, T.usingEspSnapshot]);

  // ===== DETECT (sempre no SERVIDOR externo) =====
  useEffect(() => {
    if (!detectOn) return;
    if (!serverBase) {
      setStatusText(T.needServer);
      setIsFire(false);
      setFireScore(0);
      return;
    }
    let stop = false;
    const loop = async () => {
      try {
        const r = await fetch(`${serverBase}/detect`, { method: "GET" });
        const j = await r.json();
        if (!stop && j && (j.ok === undefined || j.ok)) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));
        }
      } catch {
        if (!stop) { setIsFire(false); setFireScore(0); }
      } finally {
        if (!stop) setTimeout(loop, 500);
      }
    };
    loop();
    return () => { stop = true; };
  }, [detectOn, serverBase, T.needServer]);

  // ===== Registro (rising edge) ‚Äî usa o SERVIDOR =====
  useEffect(() => {
    const risingEdge = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;
    if (detectOn && risingEdge && cooldownOk && !saving) {
      if (!serverBase) {
        setStatusText(T.needServer);
      } else {
        (async () => {
          try {
            setSaving(true);
            await saveEventFromServer(serverBase);
            lastSaveRef.current = Date.now();
            setStatusText(T.eventSavedAt(new Date(lastSaveRef.current).toLocaleString()));
          } catch {
            setStatusText(T.noVideo);
          } finally {
            setSaving(false);
          }
        })();
      }
    }
    wasFireRef.current = isFire;
  }, [detectOn, isFire, serverBase, saving, T]);

  // joystick
  const RADIUS = 64, KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS, ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny); if (len > 1) { nx /= len; ny /= len; }
        setJoy({ x: nx, y: -ny });
      },
      onPanResponderRelease: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
      onPanResponderTerminate: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
    })
  ).current;

  const knobLeft = joy.x * RADIUS, knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder={T.placeholderIp}
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType={Platform.select({ ios: "numbers-and-punctuation", android: "numeric", default: "default" })}
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : T.test}</Text>
        </Pressable>
        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? T.ledOn : T.ledOff}</Text>
        </Pressable>
        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? T.pumpOn : T.pumpOff}</Text>
        </Pressable>
      </View>

      {/* Servidor + Detect */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder={T.placeholderServer}
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn(v => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>
            {detectOn ? (saving ? T.saving : T.detecting) : T.detect}
          </Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>{statusText}</Text>
      </View>

      {/* Banner fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>
            {isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}
          </Text>
        </View>
      )}

      {/* V√çDEO: sempre via /snapshot do ESP */}
      <Image
        source={{ uri: frameUri }}
        style={styles.video}
        resizeMode="contain"
        onError={() => { setStatusText(T.noVideo); }}
      />

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View style={[styles.joyKnob, { width: KNOB_R * 2, height: KNOB_R * 2, borderRadius: KNOB_R, transform: [{ translateX: knobLeft }, { translateY: knobTop }], opacity: dragging ? 1 : 0.9 }]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },
  topbar: { flexDirection: "row", alignItems: "center", paddingHorizontal: 12, paddingVertical: 10, gap: 8, backgroundColor: PALETTE.card },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: { backgroundColor: PALETTE.bg, color: "white", borderRadius: 8, paddingHorizontal: 10, paddingVertical: 8, borderWidth: 1, borderColor: "#1e2a4d", minWidth: 110 },
  btn: { backgroundColor: "#2b48ff", paddingHorizontal: 10, paddingVertical: 10, borderRadius: 10 },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },
  statusRow: { flexDirection: "row", alignItems: "center", paddingHorizontal: 12, paddingVertical: 8, gap: 8, backgroundColor: "#0f1730" },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },
  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },
  video: { flex: 1, backgroundColor: "black", width: "100%" },
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(43,72,255,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});



Por que agora funciona




V√≠deo: o app nunca disputa o /stream; ele puxa somente **/snapshot do ESP (porta 80)**, com cache-buster no URI para for√ßar atualiza√ß√£o. Isso convive com qualquer servidor que tamb√©m use /snapshot`.


Detec√ß√£o: continua no servidor via /detect, independente do v√≠deo ‚Äî ent√£o o fogo volta a ser detectado normalmente.


Sem altern√¢ncia: abordagem √∫nica (snapshot), simples e est√°vel.




Se quiser manter frame rate mais alto, pode reduzir TICK_MS de 250 ms para ~100 ms. Se ainda assim algo n√£o aparecer, me diga qual mensagem aparece em status que eu j√° ajusto o polling.

