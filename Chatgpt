
// ====== HydroBot Arduino - Driver & Sensors (sem servo) ======
// Motores, bomba, LED e sensores ficam aqui. ESP32-CAM comanda via UART.
// Protocolo linha-a-linha (terminado em '\n'):
//  - "CMD:FWD:ms=400:spd=70"
//  - "CMD:BACK:ms=300"
//  - "CMD:LEFT:ms=200" / "CMD:RIGHT:ms=200"
//  - "CMD:STOP"
//  - "CMD:PUMP:1"  (liga)  / "CMD:PUMP:0" (desliga)
//  - "REQ:STATUS"  (Arduino responde "STAT:...")
//  - "SET:SPEED:NN" (0..100 - fator PWM soft)
//  - "SET:LED:n"    (0..255)
//
// Resposta STATUS (exemplo):
// STAT:ax=512:am=480:ad=505:water=73:pump=0:batt=0

#include <Arduino.h>

// ===== PINOS =====
#define IN1 8
#define IN2 9
#define IN3 10
#define IN4 11
#define BOMBA_PIN 13
#define LED_VERMELHO 3

#define SENSOR_FOGO_DIR A0
#define SENSOR_FOGO_MEIO A1
#define SENSOR_FOGO_ESQ A2
#define NIVEL_AGUA_PIN  A3

// ===== CONFIG =====
static uint8_t baseSpeed = 70; // 0..100 (fator de duty "soft" por tempo)
static bool pumpOn = false;

// ===== HELPERS =====
void motorsStop() {
  digitalWrite(IN1, LOW); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW); digitalWrite(IN4, LOW);
}
void motorsFwd() {
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
}
void motorsBack() {
  digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);
}
void motorsLeftTurn() { // pivô esquerdo: esquerda ré, direita frente
  digitalWrite(IN1, LOW);  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
}
void motorsRightTurn() { // pivô direito: esquerda frente, direita ré
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);  digitalWrite(IN4, HIGH);
}

void pumpWrite(bool on) {
  pumpOn = on;
  digitalWrite(BOMBA_PIN, on ? HIGH : LOW);
}

uint8_t waterPercent() {
  int raw = analogRead(NIVEL_AGUA_PIN); // 0..1023
  int pct = map(raw, 0, 1023, 0, 100);
  pct = constrain(pct, 0, 100);
  return (uint8_t)pct;
}

void ledLevelByWater(uint8_t pct) {
  static unsigned long lastBlink=0;
  static bool state=false;
  if (pct >= 50) {
    analogWrite(LED_VERMELHO, 0);
  } else if (pct >= 25) {
    analogWrite(LED_VERMELHO, 100);
  } else if (pct >= 15) {
    if (millis()-lastBlink>1000) {
      state=!state;
      analogWrite(LED_VERMELHO, state?200:0);
      lastBlink=millis();
    }
  } else {
    if (millis()-lastBlink>300) {
      state=!state;
      analogWrite(LED_VERMELHO, state?255:0);
      lastBlink=millis();
    }
  }
}

void emitStatus() {
  int ax = analogRead(SENSOR_FOGO_ESQ);
  int am = analogRead(SENSOR_FOGO_MEIO);
  int ad = analogRead(SENSOR_FOGO_DIR);
  uint8_t wp = waterPercent();
  Serial.print(F("STAT:ax=")); Serial.print(ax);
  Serial.print(F(":am=")); Serial.print(am);
  Serial.print(F(":ad=")); Serial.print(ad);
  Serial.print(F(":water=")); Serial.print(wp);
  Serial.print(F(":pump=")); Serial.print(pumpOn?1:0);
  Serial.print(F(":batt=")); Serial.println(0); // placeholder
}

void softMove(void (*fnDir)(), uint16_t ms, uint8_t spd) {
  // simples controle por tempo; spd só documenta intenção
  (void)spd;
  fnDir();
  delay(ms);
  motorsStop();
}

void setup() {
  Serial.begin(115200);

  pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);
  pinMode(BOMBA_PIN, OUTPUT);
  pinMode(LED_VERMELHO, OUTPUT);

  motorsStop();
  pumpWrite(false);

  Serial.println(F("ARDUINO_READY"));
}

String line;

void loop() {
  // LED de nível (local, independente de comandos)
  ledLevelByWater(waterPercent());

  // UART parsing
  while (Serial.available()) {
    char c = Serial.read();
    if (c=='\n' || c=='\r') {
      if (line.length()>0) {
        line.trim();

        if (line.startsWith("CMD:")) {
          // exemplos: CMD:FWD:ms=400:spd=70
          if (line.indexOf("FWD")>0) {
            uint16_t ms=400; uint8_t sp=baseSpeed;
            int p=line.indexOf("ms=");
            if (p>0) ms = (uint16_t) line.substring(p+3).toInt();
            p=line.indexOf("spd=");
            if (p>0) sp = (uint8_t) line.substring(p+4).toInt();
            softMove(motorsFwd, ms, sp);
            Serial.println(F("OK:FWD"));
          }
          else if (line.indexOf("BACK")>0) {
            uint16_t ms=300; uint8_t sp=baseSpeed;
            int p=line.indexOf("ms=");
            if (p>0) ms = (uint16_t) line.substring(p+3).toInt();
            softMove(motorsBack, ms, sp);
            Serial.println(F("OK:BACK"));
          }
          else if (line.indexOf("LEFT")>0) {
            uint16_t ms=200;
            int p=line.indexOf("ms=");
            if (p>0) ms = (uint16_t) line.substring(p+3).toInt();
            softMove(motorsLeftTurn, ms, baseSpeed);
            Serial.println(F("OK:LEFT"));
          }
          else if (line.indexOf("RIGHT")>0) {
            uint16_t ms=200;
            int p=line.indexOf("ms=");
            if (p>0) ms = (uint16_t) line.substring(p+3).toInt();
            softMove(motorsRightTurn, ms, baseSpeed);
            Serial.println(F("OK:RIGHT"));
          }
          else if (line.indexOf("STOP")>0) {
            motorsStop();
            Serial.println(F("OK:STOP"));
          }
          else if (line.indexOf("PUMP:")>0) {
            bool on = line.endsWith("1");
            if (on && waterPercent()<=15) {
              pumpWrite(false);
              Serial.println(F("WARN:NO_WATER"));
            } else {
              pumpWrite(on);
              Serial.println(on?F("OK:PUMP_ON"):F("OK:PUMP_OFF"));
            }
          }
          else {
            Serial.println(F("ERR:CMD"));
          }
        }
        else if (line.startsWith("REQ:STATUS")) {
          emitStatus();
        }
        else if (line.startsWith("SET:SPEED:")) {
          int v = line.substring(10).toInt();
          baseSpeed = (uint8_t) constrain(v,0,100);
          Serial.println(F("OK:SPEED"));
        }
        else if (line.startsWith("SET:LED:")) {
          int v = line.substring(8).toInt();
          analogWrite(LED_VERMELHO, constrain(v,0,255));
          Serial.println(F("OK:LED"));
        }
        else {
          Serial.println(F("ERR:UNKNOWN"));
        }
        line = "";
      }
    } else {
      line += c;
    }
  }
}

















































Isso é clássico de brownout/reset no ESP32-CAM quando a cena tem muita informação (JPEG fica maior → pico de CPU/PSRAM/Wi-Fi → pico de corrente). Vou resolver em duas frentes:




Firmware (reduz picos e travas)






Usa PSRAM explicitamente para o framebuffer.


Força grab_mode = CAMERA_GRAB_LATEST (evita fila travando).


1 framebuffer (menos RAM em picos).


Qualidade JPEG mais alta no número (pior compressão = arquivo menor): jpeg_quality = 20 (pode subir até 25 se ainda resetar).


Mantém VGA (640×480) que seu app espera; se ainda cair, mude para FRAMESIZE_HVGA (480×320) — já deixei comentário.


Desativa economia de energia de Wi-Fi (WiFi.setSleep(false)) para evitar burst de wake/sleep.


Pequeno “rate-limit” no /snapshot se chegar pedido em rajada.






Hardware (garante energia)






Alimente o ESP32-CAM em 5V do pino 5V com fonte ≥ 1 A (melhor 2 A).


GND comum com Arduino.


Evite ligar o flash LED continuamente (puxa muito).


Se estiver alimentando via FTDI/USB fraco, troque para fonte dedicada.




Abaixo o código completo atualizado (mantém seus endpoints e UART/joystick; só ajustei a parte da câmera, Wi-Fi e /snapshot):


// HydroBot ESP32-CAM - HTTP + UART (otimizado anti-reset)
// - Snapshot-only em VGA com PSRAM, 1 framebuffer e grab_mode LATEST
// - JPEG quality 20 (menor tráfego/pico de CPU)
// - WiFi.setSleep(false) para evitar bursts
// - Endpoints: /snapshot, /status, /led, /pump, /joystick, /uart

#include <WiFi.h>
#include <WebServer.h>
#include "esp_camera.h"
#include <ArduinoJson.h>
#include <esp_timer.h>
#include <ctype.h>

/* ========= Wi-Fi ========= */
const char* WIFI_SSID = "HydroBot";
const char* WIFI_PASS = "loud2025emibr";

/* ========= Pinos câmera (AI-Thinker) ========= */
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

/* ========= Flash / LED ========= */
#define FLASH_PIN 4

/* ========= UART para Arduino ========= */
#define UART_BAUD 115200
#define UART_TX   14
#define UART_RX   15

/* ========= HTTP ========= */
WebServer server(80);

/* ========= Estados ========= */
volatile bool flashOn = false;
volatile bool pumpOn  = false;
volatile float joyX   = 0.0f, joyY = 0.0f;
volatile uint32_t lastJoyUpdateMs = 0;

/* ========= Util ========= */
String urlDecode(const String &s) {
  String r; r.reserve(s.length());
  for (size_t i = 0; i < s.length(); ++i) {
    char c = s[i];
    if (c == '+') r += ' ';
    else if (c == '%' && i + 2 < s.length() && isxdigit(s[i+1]) && isxdigit(s[i+2])) {
      auto hex = [](char h)->uint8_t{
        if (h>='0' && h<='9') return h-'0';
        if (h>='A' && h<='F') return h-'A'+10;
        if (h>='a' && h<='f') return h-'a'+10;
        return 0;
      };
      r += char((hex(s[i+1])<<4) | hex(s[i+2]));
      i += 2;
    } else r += c;
  }
  return r;
}

void sendLineToArduino(const String &line) { Serial2.print(line); Serial2.print('\n'); }
void setFlash(bool on) { flashOn = on; digitalWrite(FLASH_PIN, on ? HIGH : LOW); }

/* ========= Câmera ========= */
bool initCamera() {
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;          // 20 MHz estável

  // *** Ajustes anti-reset ***
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_VGA;     // 640x480 (se ainda resetar, trocar para FRAMESIZE_HVGA 480x320)
  config.jpeg_quality = 20;                // 10..30 (20 reduz pico de CPU e tamanho)
  config.fb_count     = 1;                 // 1 buffer = menos PSRAM
  config.fb_location  = CAMERA_FB_IN_PSRAM;
  config.grab_mode    = CAMERA_GRAB_LATEST;

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) return false;

  // Sensor tweaks adicionais (opcional)
  sensor_t * s = esp_camera_sensor_get();
  if (s) {
    // s->set_framesize(s, FRAMESIZE_VGA); // reforça resolução
    s->set_gainceiling(s, GAINCEIL_2X);   // reduz saturação de ganho (mais estável)
    // s->set_brightness(s, 0); s->set_contrast(s, 0); // defaults ok
  }
  return true;
}

/* ========= /snapshot ========= */
static unsigned long lastSnapMs = 0;
void handleSnapshot() {
  // Rate-limit leve (evita espiral se o cliente abrir muitas conexões simultâneas)
  unsigned long now = millis();
  if (now - lastSnapMs < 60) { // ~16 fps máx. no servidor
    delay(5);
  }
  lastSnapMs = now;

  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb || fb->format != PIXFORMAT_JPEG) {
    if (fb) esp_camera_fb_return(fb);
    server.send(503, "text/plain", "NO FRAME");
    return;
  }
  server.sendHeader("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  server.setContentLength(fb->len);
  server.send(200, "image/jpeg");
  WiFiClient client = server.client();
  client.write(fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

/* ========= /status ========= */
void handleStatus() {
  StaticJsonDocument<384> doc;
  doc["ok"]   = true;
  doc["ip"]   = WiFi.localIP().toString();
  doc["mode"] = "joystick+uart";
  doc["led"]  = flashOn;
  doc["pump"] = pumpOn;
  String out; serializeJson(doc, out);
  server.send(200, "application/json", out);
}

/* ========= /led?on=0|1 ========= */
void handleLed() {
  bool on = server.hasArg("on") && server.arg("on") == "1";
  setFlash(on);
  server.send(200, "text/plain", on ? "1" : "0");
}

/* ========= /pump?on=0|1 ========= */
void handlePump() {
  bool on = server.hasArg("on") && server.arg("on") == "1";
  pumpOn = on;
  sendLineToArduino(on ? "CMD:PUMP:1" : "CMD:PUMP:0");
  server.send(200, "text/plain", on ? "1" : "0");
}

/* ========= /uart?line=... ========= */
void handleUart() {
  if (!server.hasArg("line")) { server.send(400, "text/plain", "missing line"); return; }
  String line = urlDecode(server.arg("line")); line.trim();
  if (!line.length()) { server.send(400, "text/plain", "empty line"); return; }
  sendLineToArduino(line);
  server.send(200, "text/plain", "ok");
}

/* ========= /joystick?x=&y= ========= */
void handleJoystick() {
  float x = server.hasArg("x") ? server.arg("x").toFloat() : 0.0f;
  float y = server.hasArg("y") ? server.arg("y").toFloat() : 0.0f;
  if (x > 1) x = 1; if (x < -1) x = -1;
  if (y > 1) y = 1; if (y < -1) y = -1;
  joyX = x; joyY = y; lastJoyUpdateMs = millis();
  server.send(200, "text/plain", "ok");
}

/* ========= Joystick → comandos discretos ========= */
String vecToDir(float x, float y) {
  float mag = sqrtf(x*x + y*y);
  if (mag < 0.2f) return "STOP";
  float deg = atan2f(y, x) * 180.0f / PI;
  if (deg > -45 && deg <= 45)  return "RIGHT";
  if (deg > 45  && deg <= 135) return "FWD";
  if (deg <= -45 && deg > -135) return "BACK";
  return "LEFT";
}

void joystickTask(void* _) {
  const uint32_t TICK_MS = 120;
  String lastDir = "STOP";
  for (;;) {
    float x = joyX, y = joyY;
    float mag = sqrtf(x*x + y*y);
    String dir = vecToDir(x, y);

    if (dir == "STOP") {
      if (lastDir != "STOP") {
        sendLineToArduino("CMD:STOP");
        lastDir = "STOP";
      }
    } else {
      int ms  = 140 + int(260.0f * (mag > 1 ? 1 : mag)); // 140..400
      int spd = 50  + int(50.0f  * (mag > 1 ? 1 : mag)); // 50..100
      char buf[64];
      snprintf(buf, sizeof(buf), "CMD:%s:ms=%d:spd=%d", dir.c_str(), ms, spd);
      sendLineToArduino(String(buf));
      lastDir = dir;
    }
    vTaskDelay(pdMS_TO_TICKS(TICK_MS));
  }
}

/* ========= Setup ========= */
void setup() {
  Serial.begin(115200);
  delay(200);

  Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX, UART_TX);

  pinMode(FLASH_PIN, OUTPUT);
  setFlash(false);

  // Wi-Fi antes da câmera (às vezes estabiliza a alocação)
  WiFi.mode(WIFI_STA);
  WiFi.setSleep(false);                 // evita picos por power-save
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.printf("[WiFi] Connecting to %s", WIFI_SSID);
  uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 20000) { delay(300); Serial.print("."); }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("[WiFi] IP: "); Serial.println(WiFi.localIP());
  } else {
    Serial.println("[WiFi] Failed — will retry in loop()");
  }

  // Câmera
  if (!initCamera()) Serial.println("[ERR] Camera init failed");
  else               Serial.println("[OK] Camera init");

  // HTTP
  server.on("/snapshot", HTTP_GET, handleSnapshot);
  server.on("/status",   HTTP_GET, handleStatus);
  server.on("/led",      HTTP_GET, handleLed);
  server.on("/pump",     HTTP_GET, handlePump);
  server.on("/uart",     HTTP_GET, handleUart);
  server.on("/joystick", HTTP_GET, handleJoystick);
  server.onNotFound([](){ server.send(404, "text/plain", "not found"); });
  server.begin();

  // Task joystick (core 0)
  xTaskCreatePinnedToCore(joystickTask, "joyTask", 4096, nullptr, 1, nullptr, 0);

  sendLineToArduino("REQ:STATUS");
}

/* ========= Loop ========= */
void loop() {
  server.handleClient();

  static uint32_t lastWiFiCheck = 0;
  if (millis() - lastWiFiCheck > 2000) {
    lastWiFiCheck = millis();
    if (WiFi.status() != WL_CONNECTED) {
      WiFi.disconnect();
      WiFi.begin(WIFI_SSID, WIFI_PASS);
    }
  }
}



Se ainda resetar




Troque apenas esta linha:

// config.frame_size = FRAMESIZE_VGA;
config.frame_size   = FRAMESIZE_HVGA; // 480x320 (app ainda exibe, só fica menor)





Ou aumente:

config.jpeg_quality = 25; // arquivos menores







Checklist elétrico rápido




Fonte 5 V ≥ 1 A no pino 5V do ESP32-CAM (não 3.3 V).


Cabos curtos e grossos; GND comum com Arduino.


Evite manter o flash ligado por longos períodos.




Testa assim e me fala: se estabilizar, podemos tentar voltar gradualmente para jpeg_quality=18 ou fb_count=2.




























































// HydroBot ESP32-CAM - HTTP + UART (sem LEDC/PWM)
// - Conecta no Wi-Fi (HydroBot)
// - Fornece /snapshot, /status, /led, /pump, /joystick, /uart
// - Envia comandos via UART2 (TX=GPIO14, RX=GPIO15) para o Arduino
// - Flash (GPIO4) controlado por digitalWrite (sem PWM)

#include <WiFi.h>
#include <WebServer.h>
#include "esp_camera.h"
#include <ArduinoJson.h>
#include <esp_timer.h>
#include <ctype.h>

/* ========= Wi-Fi ========= */
const char* WIFI_SSID = "HydroBot";
const char* WIFI_PASS = "loud2025emibr";

/* ========= Pinos câmera (AI-Thinker) ========= */
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

/* ========= Flash / LED ========= */
#define FLASH_PIN 4

/* ========= UART para Arduino =========
   ESP32-CAM UART2: TX = GPIO14, RX = GPIO15
   ATENÇÃO: Níveis lógicos 3.3V no ESP (use divisor no RX do ESP).
*/
#define UART_BAUD 115200
#define UART_TX   14
#define UART_RX   15

/* ========= HTTP ========= */
WebServer server(80);

/* ========= Estados ========= */
volatile bool flashOn = false;
volatile bool pumpOn  = false;   // espelha último comando enviado
volatile float joyX   = 0.0f;    // −1..+1
volatile float joyY   = 0.0f;    // −1..+1
volatile uint32_t lastJoyUpdateMs = 0;

/* ========= Util: URL decode simples ========= */
String urlDecode(const String &s) {
  String r; r.reserve(s.length());
  for (size_t i = 0; i < s.length(); ++i) {
    char c = s[i];
    if (c == '+') r += ' ';
    else if (c == '%' && i + 2 < s.length() && isxdigit(s[i+1]) && isxdigit(s[i+2])) {
      auto hex = [](char h)->uint8_t{
        if (h>='0' && h<='9') return h-'0';
        if (h>='A' && h<='F') return h-'A'+10;
        if (h>='a' && h<='f') return h-'a'+10;
        return 0;
      };
      r += char((hex(s[i+1])<<4) | hex(s[i+2]));
      i += 2;
    } else r += c;
  }
  return r;
}

/* ========= UART helper ========= */
void sendLineToArduino(const String &line) {
  Serial2.print(line);
  Serial2.print('\n');
}

/* ========= Flash ========= */
void setFlash(bool on) {
  flashOn = on;
  digitalWrite(FLASH_PIN, on ? HIGH : LOW);
}

/* ========= Câmera ========= */
bool initCamera() {
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;

  // Estável para snapshot do app (640x480)
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_VGA;
  config.jpeg_quality = 12;   // 10..20 (menor = melhor)
  config.fb_count     = 2;

  esp_err_t err = esp_camera_init(&config);
  return (err == ESP_OK);
}

/* ========= /snapshot ========= */
void handleSnapshot() {
  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb || fb->format != PIXFORMAT_JPEG) {
    if (fb) esp_camera_fb_return(fb);
    server.send(503, "text/plain", "NO FRAME");
    return;
  }
  server.sendHeader("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  server.setContentLength(fb->len);
  server.send(200, "image/jpeg");
  WiFiClient client = server.client();
  client.write(fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

/* ========= /status ========= */
void handleStatus() {
  StaticJsonDocument<384> doc;
  doc["ok"]   = true;
  doc["ip"]   = WiFi.localIP().toString();
  doc["mode"] = "joystick+uart";
  doc["led"]  = flashOn;
  doc["pump"] = pumpOn;
  String out; serializeJson(doc, out);
  server.send(200, "application/json", out);
}

/* ========= /led?on=0|1 ========= */
void handleLed() {
  bool on = server.hasArg("on") && server.arg("on") == "1";
  setFlash(on);
  server.send(200, "text/plain", on ? "1" : "0");
}

/* ========= /pump?on=0|1  → UART ========= */
void handlePump() {
  bool on = server.hasArg("on") && server.arg("on") == "1";
  pumpOn = on;
  sendLineToArduino(on ? "CMD:PUMP:1" : "CMD:PUMP:0");
  server.send(200, "text/plain", on ? "1" : "0");
}

/* ========= /uart?line=... ========= */
void handleUart() {
  if (!server.hasArg("line")) { server.send(400, "text/plain", "missing line"); return; }
  String line = urlDecode(server.arg("line")); line.trim();
  if (!line.length()) { server.send(400, "text/plain", "empty line"); return; }
  sendLineToArduino(line);
  server.send(200, "text/plain", "ok");
}

/* ========= /joystick?x=&y=  (−1..+1) ========= */
void handleJoystick() {
  float x = server.hasArg("x") ? server.arg("x").toFloat() : 0.0f;
  float y = server.hasArg("y") ? server.arg("y").toFloat() : 0.0f;
  if (x > 1) x = 1; if (x < -1) x = -1;
  if (y > 1) y = 1; if (y < -1) y = -1;
  joyX = x; joyY = y; lastJoyUpdateMs = millis();
  server.send(200, "text/plain", "ok");
}

/* ========= Joystick → comandos discretos ========= */
String vecToDir(float x, float y) {
  float mag = sqrtf(x*x + y*y);
  if (mag < 0.2f) return "STOP";
  float deg = atan2f(y, x) * 180.0f / PI;
  if (deg > -45 && deg <= 45)  return "RIGHT";
  if (deg > 45  && deg <= 135) return "FWD";
  if (deg <= -45 && deg > -135) return "BACK";
  return "LEFT";
}

void joystickTask(void* _) {
  const uint32_t TICK_MS = 120;
  String lastDir = "STOP";
  for (;;) {
    float x = joyX, y = joyY;
    float mag = sqrtf(x*x + y*y);
    String dir = vecToDir(x, y);

    if (dir == "STOP") {
      if (lastDir != "STOP") {
        sendLineToArduino("CMD:STOP");
        lastDir = "STOP";
      }
    } else {
      int ms  = 140 + int(260.0f * (mag > 1 ? 1 : mag)); // 140..400
      int spd = 50  + int(50.0f  * (mag > 1 ? 1 : mag)); // 50..100
      char buf[64];
      snprintf(buf, sizeof(buf), "CMD:%s:ms=%d:spd=%d", dir.c_str(), ms, spd);
      sendLineToArduino(String(buf));
      lastDir = dir;
    }
    vTaskDelay(pdMS_TO_TICKS(TICK_MS));
  }
}

/* ========= Setup ========= */
void setup() {
  Serial.begin(115200);
  delay(200);

  // UART2 → Arduino
  Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX, UART_TX);

  // Flash (GPIO)
  pinMode(FLASH_PIN, OUTPUT);
  setFlash(false);

  // Câmera
  if (!initCamera()) {
    Serial.println("[ERR] Camera init failed");
  } else {
    Serial.println("[OK] Camera init");
  }

  // Wi-Fi STA
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.printf("[WiFi] Connecting to %s", WIFI_SSID);
  uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 20000) {
    delay(300); Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("[WiFi] IP: "); Serial.println(WiFi.localIP());
  } else {
    Serial.println("[WiFi] Failed — will keep retrying in loop()");
  }

  // HTTP
  server.on("/snapshot", HTTP_GET, handleSnapshot);
  server.on("/status",   HTTP_GET, handleStatus);
  server.on("/led",      HTTP_GET, handleLed);
  server.on("/pump",     HTTP_GET, handlePump);
  server.on("/uart",     HTTP_GET, handleUart);
  server.on("/joystick", HTTP_GET, handleJoystick);
  server.onNotFound([](){ server.send(404, "text/plain", "not found"); });
  server.begin();

  // Task de joystick (core 0)
  xTaskCreatePinnedToCore(joystickTask, "joyTask", 4096, nullptr, 1, nullptr, 0);

  // Ping inicial ao Arduino
  sendLineToArduino("REQ:STATUS");
}

/* ========= Loop ========= */
void loop() {
  server.handleClient();

  // Reconnect Wi-Fi se cair
  static uint32_t lastWiFiCheck = 0;
  if (millis() - lastWiFiCheck > 2000) {
    lastWiFiCheck = millis();
    if (WiFi.status() != WL_CONNECTED) {
      WiFi.disconnect();
      WiFi.begin(WIFI_SSID, WIFI_PASS);
    }
  }
}


























































Perfeito — abaixo está um firmware completo para ESP32-CAM (AI-Thinker) que:




Conecta no roteador SSID HydroBot | senha loud2025emibr em modo STA


Inicia a câmera e expõe /snapshot (JPEG único por requisição)


Expõe os endpoints que seu app já usa:



/status → JSON de saúde/estados


/led?on=0|1 → liga/desliga o flash (GPIO 4)


/pump?on=0|1 → repassa ao Arduino via UART (CMD:PUMP:1/0)


/joystick?x=..&y=.. → controle contínuo (loop em background converte vetor em pulsos CMD:FWD/BACK/LEFT/RIGHT com ms/spd)


/uart?line=... → pass-through para o Arduino (sua string é enviada crua + \n)






Usa UART2 para falar com o Arduino (TX=GPIO 14, RX=GPIO 15, 115200 bps).


É robusto (sem stream MJPEG), mantendo só snapshot — isso reduz muito reboots.






Ligações sugeridas (ESP32-CAM ↔ Arduino):




ESP32-CAM TX2 (GPIO14) → RX do Arduino (via divisor de tensão 5V→3.3V se necessário)


ESP32-CAM RX2 (GPIO15) ← TX do Arduino (NUNCA 5V direto; use divisor para 3.3V)


GND comum entre os dois.


Motores/bomba continuam controlados no Arduino; o ESP apenas envia comandos UART.







ESP32-CAM (AI-Thinker) – HydroBot_ESP32Cam_HTTP_UART.ino




Biblioteca: já vem com esp32-camera ao instalar o core ESP32; use Board: “AI Thinker ESP32-CAM”.




#include <WiFi.h>
#include <WebServer.h>
#include "esp_camera.h"
#include <esp_timer.h>
#include <ArduinoJson.h>
#include <driver/ledc.h>
#include <esp_task_wdt.h>
#include <ctype.h>

/* ========= Wi-Fi ========= */
const char* WIFI_SSID = "HydroBot";
const char* WIFI_PASS = "loud2025emibr";

/* ========= Pinos câmera (AI-Thinker) ========= */
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27

#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

/* ========= Flash / LED ========= */
#define FLASH_PIN 4
// Usamos PWM (LEDC) para não “chacoalhar” a alimentação
#define FLASH_LEDC_CHANNEL 2
#define FLASH_LEDC_FREQ    5000
#define FLASH_LEDC_RES     LEDC_TIMER_8_BIT

/* ========= UART para Arduino =========
   ESP32-CAM UART2: TX = GPIO14, RX = GPIO15
   (Atenção aos níveis lógicos: ESP é 3.3V)
*/
#define UART_BAUD 115200
#define UART_TX   14
#define UART_RX   15

/* ========= HTTP ========= */
WebServer server(80);

/* ========= Estados ========= */
volatile bool flashOn = false;
volatile bool pumpOn  = false;   // espelha último comando enviado ao Arduino

// Joystick (−1..+1) — atualizado via HTTP; consumido por task em background
volatile float joyX = 0.0f;
volatile float joyY = 0.0f;
volatile uint32_t lastJoyUpdateMs = 0;

/* ========= Util: URL decode simples ========= */
String urlDecode(const String &s) {
  String r; r.reserve(s.length());
  for (size_t i = 0; i < s.length(); ++i) {
    char c = s[i];
    if (c == '+') r += ' ';
    else if (c == '%' && i + 2 < s.length() && isxdigit(s[i+1]) && isxdigit(s[i+2])) {
      char h1 = s[i+1], h2 = s[i+2];
      auto hex = [](char h) -> uint8_t {
        if (h >= '0' && h <= '9') return h - '0';
        if (h >= 'A' && h <= 'F') return h - 'A' + 10;
        if (h >= 'a' && h <= 'f') return h - 'a' + 10;
        return 0;
      };
      r += char((hex(h1) << 4) | hex(h2));
      i += 2;
    } else r += c;
  }
  return r;
}

/* ========= Envio de linhas ao Arduino ========= */
void sendLineToArduino(const String &line) {
  Serial2.print(line);
  Serial2.print('\n');
}

/* ========= Controle do flash ========= */
void setFlash(bool on) {
  flashOn = on;
  if (on) {
    ledcWrite(FLASH_LEDC_CHANNEL, 255); // 100%
  } else {
    ledcWrite(FLASH_LEDC_CHANNEL, 0);
  }
}

/* ========= Câmera: init ========= */
bool initCamera() {
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;

  // Resolução estável p/ snapshot no app (640x480)
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_VGA;
  config.jpeg_quality = 12;      // 10~20 (menor = melhor qualidade)
  config.fb_count     = 2;       // 2 framebuffers ajuda a estabilidade

  esp_err_t err = esp_camera_init(&config);
  return (err == ESP_OK);
}

/* ========= Endpoint: /snapshot ========= */
void handleSnapshot() {
  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb || fb->format != PIXFORMAT_JPEG) {
    if (fb) esp_camera_fb_return(fb);
    server.send(503, "text/plain", "NO FRAME");
    return;
  }
  // Cabeçalhos anti-cache (o app já coloca ?ts=)
  server.sendHeader("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  server.setContentLength(fb->len);
  server.send(200, "image/jpeg");
  WiFiClient client = server.client();
  client.write(fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

/* ========= Endpoint: /status ========= */
void handleStatus() {
  StaticJsonDocument<384> doc;
  doc["ok"]   = true;
  doc["ip"]   = WiFi.localIP().toString();
  doc["mode"] = "joystick+uart";
  doc["led"]  = flashOn;
  doc["pump"] = pumpOn;
  String out;
  serializeJson(doc, out);
  server.send(200, "application/json", out);
}

/* ========= Endpoint: /led?on=0|1 ========= */
void handleLed() {
  bool on = false;
  if (server.hasArg("on")) {
    on = server.arg("on") == "1";
  }
  setFlash(on);
  server.send(200, "text/plain", on ? "1" : "0");
}

/* ========= Endpoint: /pump?on=0|1  → UART p/ Arduino ========= */
void handlePump() {
  bool on = false;
  if (server.hasArg("on")) {
    on = server.arg("on") == "1";
  }
  pumpOn = on;
  sendLineToArduino(on ? "CMD:PUMP:1" : "CMD:PUMP:0");
  server.send(200, "text/plain", on ? "1" : "0");
}

/* ========= Endpoint: /uart?line=...  → pass-through ========= */
void handleUart() {
  if (!server.hasArg("line")) {
    server.send(400, "text/plain", "missing line");
    return;
  }
  String line = urlDecode(server.arg("line"));
  line.trim();
  if (line.length() == 0) {
    server.send(400, "text/plain", "empty line");
    return;
  }
  sendLineToArduino(line);
  server.send(200, "text/plain", "ok");
}

/* ========= Endpoint: /joystick?x=&y=  (−1..+1) =========
   Apenas armazena; uma task em background manda pulsos ao Arduino.
*/
void handleJoystick() {
  float x = server.hasArg("x") ? server.arg("x").toFloat() : 0.0f;
  float y = server.hasArg("y") ? server.arg("y").toFloat() : 0.0f;
  if (x > 1) x = 1; if (x < -1) x = -1;
  if (y > 1) y = 1; if (y < -1) y = -1;
  joyX = x; joyY = y;
  lastJoyUpdateMs = millis();
  server.send(200, "text/plain", "ok");
}

/* ========= Joystick → comandos discretos =========
   Converte vetor (x,y) em direção + intensidade e envia pulsos no padrão do seu Arduino.
*/
String vecToDir(float x, float y) {
  float mag = sqrtf(x*x + y*y);
  if (mag < 0.2f) return "STOP";
  float deg = atan2f(y, x) * 180.0f / PI;
  if (deg > -45 && deg <= 45)  return "RIGHT";
  if (deg > 45  && deg <= 135) return "FWD";
  if (deg <= -45 && deg > -135) return "BACK";
  return "LEFT";
}

void joystickTask(void* _) {
  const uint32_t TICK_MS = 120;
  String lastDir = "STOP";
  for (;;) {
    float x = joyX;
    float y = joyY;
    float mag = sqrtf(x*x + y*y);
    String dir = vecToDir(x, y);

    if (dir == "STOP") {
      if (lastDir != "STOP") {
        sendLineToArduino("CMD:STOP");
        lastDir = "STOP";
      }
    } else {
      int ms  = 140 + int(260.0f * (mag > 1 ? 1 : mag)); // 140..400
      int spd = 50  + int(50.0f  * (mag > 1 ? 1 : mag)); // 50..100
      char buf[64];
      snprintf(buf, sizeof(buf), "CMD:%s:ms=%d:spd=%d", dir.c_str(), ms, spd);
      sendLineToArduino(String(buf));
      lastDir = dir;
    }

    vTaskDelay(pdMS_TO_TICKS(TICK_MS));
  }
}

/* ========= Setup ========= */
void setup() {
  // Console
  Serial.begin(115200);
  delay(200);

  // UART2 → Arduino
  Serial2.begin(UART_BAUD, SERIAL_8N1, UART_RX, UART_TX);

  // Flash como PWM
  ledcSetup(FLASH_LEDC_CHANNEL, FLASH_LEDC_FREQ, FLASH_LEDC_RES);
  ledcAttachPin(FLASH_PIN, FLASH_LEDC_CHANNEL);
  setFlash(false);

  // Câmera
  if (!initCamera()) {
    Serial.println("[ERR] Camera init failed");
    // Ainda oferecemos HTTP p/ debug
  } else {
    Serial.println("[OK] Camera init");
  }

  // Wi-Fi STA
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.printf("[WiFi] Connecting to %s", WIFI_SSID);
  uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 20000) {
    delay(300);
    Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("[WiFi] IP: "); Serial.println(WiFi.localIP());
  } else {
    Serial.println("[WiFi] Failed — will keep retrying in loop()");
  }

  // HTTP rotas
  server.on("/snapshot", HTTP_GET, handleSnapshot);
  server.on("/status",   HTTP_GET, handleStatus);
  server.on("/led",      HTTP_GET, handleLed);
  server.on("/pump",     HTTP_GET, handlePump);
  server.on("/uart",     HTTP_GET, handleUart);
  server.on("/joystick", HTTP_GET, handleJoystick);
  server.onNotFound([](){
    server.send(404, "text/plain", "not found");
  });
  server.begin();

  // Task de joystick (core 0 para aliviar core 1 da câmera)
  xTaskCreatePinnedToCore(joystickTask, "joyTask", 4096, nullptr, 1, nullptr, 0);

  // “Acorda” Arduino com um ping
  sendLineToArduino("REQ:STATUS");
}

/* ========= Loop ========= */
void loop() {
  // mantém HTTP
  server.handleClient();

  // reconecta Wi-Fi se cair
  static uint32_t lastWiFiCheck = 0;
  if (millis() - lastWiFiCheck > 2000) {
    lastWiFiCheck = millis();
    if (WiFi.status() != WL_CONNECTED) {
      WiFi.disconnect();
      WiFi.begin(WIFI_SSID, WIFI_PASS);
    }
  }

  // watchdog leve para o flash ficar “limpo”
  // (nada a fazer aqui — tasks e handlers já são curtos)
}




Notas rápidas




Câmera em VGA (640×480) e /snapshot único: é exatamente o que seu app espera hoje.


/status retorna {ok, ip, mode, led, pump} — o app mostra isso na barra.


Flash no GPIO 4 com PWM (suave e estável).


Bomba: o ESP não comanda relé; ele apenas envia CMD:PUMP:1/0 ao Arduino, que de fato liga/desliga. Assim, o estado que o app vê é espelhado por software e fica consistente com seu protocolo.


Joystick: mesmo sem o app mandar /uart?..., o /joystick já converte o vetor em pulsos discretos compatíveis com seu Arduino (ms + spd), exatamente como o fallback do app — isso dá latência menor e suavidade.


Pass-through: se quiser mandar qualquer coisa manualmente, use /uart?line=SET:SPEED:70 etc.




Se precisar que o ESP também ofereça /stream (multipart MJPEG) para testar em navegador, dá pra adicionar depois — mas manter apenas /snapshot costuma eliminar os reboots que você viu ao apontar a câmera para cenas complexas.



































































































// HydroBotApp2/src/screens/CameraScreen.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
  Image,
  Animated,
  LayoutChangeEvent,
  AppState,
} from "react-native";
import { saveEventFromServer } from "../storage/fireLog";
import { useLanguage } from "../context/LanguageContext";

/* ---------- PALETA ---------- */
const PALETTE = {
  bg: "#0b0b0f",
  card: "#121218",
  border: "#25273a",
  accent: "#e6403a",
  text: "#e5e7eb",
};

/* ---------- TEXTOS ---------- */
const textsByLang = {
  pt: {
    heroSubtitle: "Monitoramento e Controle",
    espIp: "ESP IP:",
    test: "Testar",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "BOMBA ON",
    pumpOff: "BOMBA OFF",
    server: "Servidor:",
    detecting: "Detectando…",
    saving: "Salvando...",
    statusFail: "Falha ao conectar. Confira o Wi-Fi/IP.",
    noVideo: "Sem vídeo (snapshot). Verifique o servidor.",
    fireOn: (s: number) => `🔥 FOGO • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sem fogo • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento salvo em ${ts}`,
    placeholderIp: "192.168.3.3",
    placeholderServer: "http://192.168.3.4:8000",
    persons: "Pessoas",
    animals: "Animais",
    backend: "Modelo",
    waiting: "Aguardando servidor…",
    synced: "Server sync OK",
  },
  en: {
    heroSubtitle: "Monitoring & Control",
    espIp: "ESP IP:",
    test: "Test",
    ledOn: "LED ON",
    ledOff: "LED OFF",
    pumpOn: "PUMP ON",
    pumpOff: "PUMP OFF",
    server: "Server:",
    detecting: "Detecting…",
    saving: "Saving...",
    statusFail: "Failed to connect. Check Wi-Fi/IP.",
    noVideo: "No video (snapshot). Check the server.",
    fireOn: (s: number) => `🔥 FIRE • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `No fire • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Event saved at ${ts}`,
    placeholderIp: "192.168.3.3",
    placeholderServer: "http://192.168.3.4:8000",
    persons: "People",
    animals: "Animals",
    backend: "Model",
    waiting: "Waiting for server…",
    synced: "Server sync OK",
  },
  es: {
    heroSubtitle: "Monitoreo y Control",
    espIp: "ESP IP:",
    test: "Probar",
    ledOn: "LED ENC.",
    ledOff: "LED APAG.",
    pumpOn: "BOMBA ENC.",
    pumpOff: "BOMBA APAG.",
    server: "Servidor:",
    detecting: "Detectando…",
    saving: "Guardando...",
    statusFail: "Error de conexión. Revisa Wi-Fi/IP.",
    noVideo: "Sin vídeo (snapshot). Revisa el servidor.",
    fireOn: (s: number) => `🔥 FUEGO • score ${s.toFixed(2)}`,
    fireOff: (s: number) => `Sin fuego • score ${s.toFixed(2)}`,
    eventSavedAt: (ts: string) => `Evento guardado a las ${ts}`,
    placeholderIp: "192.168.3.3",
    placeholderServer: "http://192.168.3.4:8000",
    persons: "Personas",
    animals: "Animales",
    backend: "Modelo",
    waiting: "Esperando servidor…",
    synced: "Server sync OK",
  },
};

const DEFAULT_IP = "192.168.3.3"; // ESP
const DEFAULT_SERVER = "http://192.168.3.4:8000"; // FastAPI
const DEFAULT_FRAME_WH = { w: 640, h: 480 };

const appLogo = require("../../assets/logo.png");

/* ---------- HERO ---------- */
function AppHero({ subtitle }: { subtitle: string }) {
  return (
    <View style={styles.hero}>
      <Image source={appLogo} style={styles.heroLogo} />
      <Text style={styles.heroTitle}>HydroBot</Text>
      <Text style={styles.heroSubtitle}>{subtitle}</Text>
    </View>
  );
}

/* ---------- SNAPSHOT com crossfade ---------- */
function CrossfadeImage({
  currentUri,
  nextUri,
  onNextLoadStart,
  onNextShown,
}: {
  currentUri: string;
  nextUri: string;
  onNextLoadStart: () => void;
  onNextShown: (ok: boolean) => void;
}) {
  const fade = useRef(new Animated.Value(0)).current;
  const [showNext, setShowNext] = useState(false);
  const lastNextRef = useRef<string>("");

  useEffect(() => {
    if (!nextUri || nextUri === lastNextRef.current) return;
    lastNextRef.current = nextUri;
    setShowNext(true);
  }, [nextUri]);

  return (
    <View style={{ flex: 1, backgroundColor: "black" }}>
      {!!currentUri && (
        <Image
          key={currentUri} // força re-render
          source={{ uri: currentUri }}
          style={{ flex: 1, width: "100%" }}
          resizeMode="contain"
        />
      )}

      {showNext && (
        <Animated.View style={[StyleSheet.absoluteFill, { opacity: fade }]}>
          <Image
            key={nextUri} // força re-render
            source={{ uri: nextUri }}
            style={{ flex: 1, width: "100%" }}
            resizeMode="contain"
            onLoadStart={onNextLoadStart}
            onError={() => {
              onNextShown(false);
              fade.setValue(0);
              setShowNext(false);
            }}
            onLoadEnd={() => {
              Animated.timing(fade, {
                toValue: 1,
                duration: 80,
                useNativeDriver: true,
              }).start(() => {
                onNextShown(true);
                fade.setValue(0);
                setShowNext(false);
              });
            }}
          />
        </Animated.View>
      )}
    </View>
  );
}

/* ---------- OVERLAY DE CAIXAS ---------- */
type BoxType = "fire" | "person" | "animal";
type SrcBox = {
  x: number;
  y: number;
  w: number;
  h: number;
  type: BoxType;
  conf?: number;
};

function BoxesOverlay({
  frameWH,
  containerWH,
  boxes,
}: {
  frameWH: { w: number; h: number } | null;
  containerWH: { w: number; h: number } | null;
  boxes: SrcBox[];
}) {
  const f = frameWH && frameWH.w > 0 && frameWH.h > 0 ? frameWH : DEFAULT_FRAME_WH;
  if (!containerWH || containerWH.w <= 0 || containerWH.h <= 0) return null;

  const scale = Math.min(containerWH.w / f.w, containerWH.h / f.h);
  const dispW = f.w * scale;
  const dispH = f.h * scale;
  const offsetX = (containerWH.w - dispW) / 2;
  const offsetY = (containerWH.h - dispH) / 2;

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFill}>
      <View
        style={{
          position: "absolute",
          left: offsetX,
          top: offsetY,
          width: dispW,
          height: dispH,
        }}
      >
        {boxes.map((b, i) => {
          const left = b.x * scale;
          const top = b.y * scale;
          const width = b.w * scale;
          const height = b.h * scale;

          let borderColor = "#ff3b30"; // fogo
          if (b.type === "person") borderColor = "#00e5ff";
          else if (b.type === "animal") borderColor = "#7CFC00";

          return (
            <View
              key={`${i}-${b.type}`}
              style={{
                position: "absolute",
                left,
                top,
                width,
                height,
                borderWidth: 3,
                borderColor,
                borderRadius: 6,
              }}
            >
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  top: -18,
                  paddingHorizontal: 6,
                  paddingVertical: 2,
                  borderRadius: 4,
                  backgroundColor: borderColor,
                }}
              >
                <Text style={{ color: "#000", fontWeight: "800", fontSize: 10 }}>
                  {b.type.toUpperCase()}
                  {typeof b.conf === "number" ? ` ${b.conf.toFixed(2)}` : ""}
                </Text>
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* ---------- TELA PRINCIPAL ---------- */
export default function CameraScreen() {
  const { lang } = useLanguage();
  const T = textsByLang[lang];

  // conexões
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  // estados do ESP
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState(T.waiting);
  const [ledOn, setLedOn] = useState(false);
  const [pumpOn, setPumpOn] = useState(false);

  // detecção (sempre ativa)
  const [isFire, setIsFire] = useState(false);
  const [fireScore, setFireScore] = useState(0);

  // pessoas/animais
  const [people, setPeople] = useState(0);
  const [animals, setAnimals] = useState(0);
  const [backend, setBackend] = useState<string>("—");
  const [confMax, setConfMax] = useState<number>(0);

  // caixas + dimensões para overlay
  const [overlayBoxes, setOverlayBoxes] = useState<SrcBox[]>([]);
  const [frameWH, setFrameWH] = useState<{ w: number; h: number } | null>(null);
  const [videoContainerWH, setVideoContainerWH] = useState<{ w: number; h: number } | null>(null);

  // registro automático
  const [saving, setSaving] = useState(false);
  const lastSaveRef = useRef(0);
  const wasFireRef = useRef(false);
  const SAVE_COOLDOWN_MS = 5000;

  // visão: SNAPSHOT (sempre)
  const [currentFrameUri, setCurrentFrameUri] = useState("");
  const [nextFrameUri, setNextFrameUri] = useState("");
  const loadingNextRef = useRef(false);

  // joystick (UI)
  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  // health gate
  const [ready, setReady] = useState(false);

  // helpers URL
  const cleanServer = (s: string) => s.replace(/\/+$/, "");
  // server (frames + detecção)
  const healthUrl = useMemo(() => `${cleanServer(server)}/healthz`, [server]);
  const detectUrl = useMemo(() => `${cleanServer(server)}/detect`, [server]);
  const snapshotUrl = useMemo(() => `${cleanServer(server)}/snapshot`, [server]);
  const configUrl = useMemo(() => `${cleanServer(server)}/config`, [server]);
  // ESP (controle direto)
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);
  const joystickUrl = useMemo(
    () => (x: number, y: number) => `http://${ip}/joystick?x=${x.toFixed(2)}&y=${y.toFixed(2)}`,
    [ip]
  );
  const uartUrl = useMemo(
    () => (line: string) => `http://${ip}/uart?line=${encodeURIComponent(line)}`,
    [ip]
  );

  /* ===== AppState pausa/retoma loops ===== */
  const appStateRef = useRef(AppState.currentState);
  useEffect(() => {
    const sub = AppState.addEventListener("change", (s) => {
      appStateRef.current = s;
    });
    return () => sub.remove();
  }, []);

  /* ===== Sincroniza IP do ESP dentro do server ===== */
  useEffect(() => {
    let aborted = false;
    (async () => {
      try {
        const r = await fetch(configUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ camera_ip: ip }),
        });
        const j = await r.json();
        if (!aborted && j?.ok) setStatusText(T.synced + ` (${j.camera_ip})`);
      } catch {
        if (!aborted) setStatusText(T.statusFail);
      }
    })();
    return () => {
      aborted = true;
    };
  }, [ip, configUrl, T]);

  /* ===== ESP STATUS ===== */
  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl);
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK • ip:${j.ip ?? ip} • mode:${j.mode ?? "—"} • led:${j.led ? "on" : "off"} • pump:${
          j.pump ? "on" : "off"
        }`
      );
    } catch {
      setStatusText(T.statusFail);
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try {
      const t = !ledOn;
      await fetch(ledUrl(t));
      setLedOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  async function togglePump() {
    try {
      const t = !pumpOn;
      await fetch(pumpUrl(t));
      setPumpOn(t);
    } catch {
      setStatusText(T.statusFail);
    }
  }
  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  /* ===== HEALTH-CHECK DO SERVIDOR ===== */
  useEffect(() => {
    let stop = false;
    let backoff = 500; // ms
    const controller = new AbortController();

    const poll = async () => {
      if (stop) return;
      try {
        const r = await fetch(healthUrl, { signal: controller.signal });
        const j = await r.json();
        if (j?.ok) {
          setReady(true);
          setStatusText(`Server OK • fps_in:${j.fps_in} • hasFrame:${j.hasFrame}`);
          return;
        }
      } catch {
        // ignore
      }
      setReady(false);
      setStatusText(T.waiting);
      setTimeout(poll, backoff);
      backoff = Math.min(backoff * 1.6, 5000);
    };

    poll();
    return () => {
      stop = true;
      controller.abort();
    };
  }, [healthUrl, T]);

  /* ===== SNAPSHOT LOOP (~10–12 fps) ===== */
  useEffect(() => {
    if (!ready) return;
    let stop = false;
    let interval = 90; // estável no Wi-Fi do roteador

    setCurrentFrameUri(`${snapshotUrl}?ts=${Date.now()}`);

    const tick = async () => {
      if (stop || appStateRef.current !== "active") return;
      try {
        if (!loadingNextRef.current) {
          const url = `${snapshotUrl}?ts=${Date.now()}`;
          setNextFrameUri(url);
        }
        interval = 90;
      } catch {
        interval = Math.min(interval * 1.7, 1200);
      }
      setTimeout(tick, interval);
    };
    tick();

    return () => {
      stop = true;
    };
  }, [snapshotUrl, ready]);

  function onNextLoadStart() {
    loadingNextRef.current = true;
  }
  function onNextShown(ok: boolean) {
    if (ok && nextFrameUri) setCurrentFrameUri(nextFrameUri);
    loadingNextRef.current = false;
  }

  /* ===== LOOP DE DETECÇÃO + CAIXAS (5–6 Hz) ===== */
  useEffect(() => {
    if (!ready) return;
    let stop = false;
    let interval = 180;
    const controller = new AbortController();

    const loop = async () => {
      if (stop || appStateRef.current !== "active") return;
      try {
        const r = await fetch(detectUrl, { signal: controller.signal });
        const j = await r.json();

        if (j && j.ok !== false) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));

          // frame size
          const wh =
            Array.isArray(j.frame_wh) && j.frame_wh.length === 2
              ? { w: Number(j.frame_wh[0]) || 0, h: Number(j.frame_wh[1]) || 0 }
              : null;
          if (wh && wh.w > 0 && wh.h > 0) setFrameWH(wh);

          // objetos
          const o = j.objects || {};
          const objs = o.objects || [];
          const nPerson =
            typeof o.n_person_stable === "number"
              ? o.n_person_stable
              : typeof o.n_person === "number"
              ? o.n_person
              : objs.filter((x: any) => String(x.label).toLowerCase() === "person").length;
          const nAnimals =
            typeof o.n_animals_stable === "number"
              ? o.n_animals_stable
              : typeof o.n_animals === "number"
              ? o.n_animals
              : objs.filter((x: any) => String(x.label).toLowerCase() !== "person").length;

          setPeople(nPerson || 0);
          setAnimals(nAnimals || 0);
          setBackend(o.backend || "—");
          setConfMax(Number(o.conf_max || 0));

          // montar caixas
          const boxes: SrcBox[] = [];
          if (j.isFire && Array.isArray(j.boxes)) {
            for (const b of j.boxes) {
              if (!Array.isArray(b) || b.length < 4) continue;
              const [x, y, w, h] = b.map((n: any) => Number(n) || 0);
              boxes.push({ x, y, w, h, type: "fire" });
            }
          }
          for (const it of objs) {
            if (!it || !Array.isArray(it.box) || it.box.length < 4) continue;
            const [x, y, w, h] = it.box.map((n: any) => Number(n) || 0);
            const label = String(it.label || "").toLowerCase();
            const conf = typeof it.conf === "number" ? it.conf : undefined;
            if (label === "person") boxes.push({ x, y, w, h, type: "person", conf });
            else boxes.push({ x, y, w, h, type: "animal", conf });
          }
          setOverlayBoxes(boxes);

          interval = 180;
        }
      } catch {
        // zera UI sem quebrar
        setIsFire(false);
        setFireScore(0);
        setPeople(0);
        setAnimals(0);
        setOverlayBoxes([]);
        interval = Math.min(interval * 1.5, 1500);
      } finally {
        setTimeout(loop, interval);
      }
    };
    loop();

    return () => {
      stop = true;
      controller.abort();
    };
  }, [detectUrl, ready]);

  /* ===== Registro automático (rising edge) ===== */
  useEffect(() => {
    const rising = !wasFireRef.current && isFire;
    const now = Date.now();
    const cooldownOk = now - lastSaveRef.current >= SAVE_COOLDOWN_MS;

    if (rising && cooldownOk && !saving) {
      (async () => {
        try {
          setSaving(true);
          await saveEventFromServer(server);
          lastSaveRef.current = Date.now();
          setStatusText(T.eventSavedAt(new Date(lastSaveRef.current).toLocaleString()));
        } catch {
          setStatusText(T.noVideo);
        } finally {
          setSaving(false);
        }
      })();
    }
    wasFireRef.current = isFire;
  }, [isFire, server, saving, T]);

  /* ===== Joystick: envia para o ESP =====
     1) Tenta /joystick?x=&y= (controle contínuo no ESP)
     2) Se falhar, fallback em comandos discretos via /uart?line=CMD:...
  */
  const RADIUS = 64,
    KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS,
          ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) {
          nx /= len;
          ny /= len;
        }
        setJoy({ x: nx, y: -ny }); // y invertido: pra cima = +y
      },
      onPanResponderRelease: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
      onPanResponderTerminate: () => {
        setDragging(false);
        setJoy({ x: 0, y: 0 });
      },
    })
  ).current;

  const lastSendRef = useRef(0);
  const lastDirRef = useRef<string>("STOP");

  const trySendJoystick = async (x: number, y: number) => {
    try {
      await fetch(joystickUrl(x, y), { method: "GET" });
      return true;
    } catch {
      return false;
    }
  };
  const sendDiscreteCmd = async (
    dir: "FWD" | "BACK" | "LEFT" | "RIGHT" | "STOP",
    ms = 180,
    spd = 70
  ) => {
    const line =
      dir === "STOP"
        ? "CMD:STOP"
        : `CMD:${dir}:ms=${Math.max(80, Math.min(ms, 600))}:spd=${Math.max(30, Math.min(
            spd,
            100
          ))}`;
    try {
      await fetch(uartUrl(line), { method: "GET" });
      return true;
    } catch {
      return false;
    }
  };
  const vecToDir = (x: number, y: number): "FWD" | "BACK" | "LEFT" | "RIGHT" | "STOP" => {
    const mag = Math.hypot(x, y);
    if (mag < 0.2) return "STOP";
    const deg = (Math.atan2(y, x) * 180) / Math.PI;
    if (deg > -45 && deg <= 45) return "RIGHT";
    if (deg > 45 && deg <= 135) return "FWD";
    if (deg <= -45 && deg > -135) return "BACK";
    return "LEFT";
  };

  useEffect(() => {
    let cancelled = false;

    const tick = async () => {
      if (cancelled) return;
      const now = Date.now();
      if (now - lastSendRef.current < 120) {
        setTimeout(tick, 20);
        return;
      }
      lastSendRef.current = now;

      const x = joy.x;
      const y = joy.y;
      const mag = Math.hypot(x, y);

      // 1) controle contínuo no ESP
      const ok = await trySendJoystick(x, y);
      if (ok) {
        // enviar STOP discreto ao soltar (garantia)
        if (mag < 0.2 && lastDirRef.current !== "STOP") {
          await sendDiscreteCmd("STOP");
          lastDirRef.current = "STOP";
        }
        setTimeout(tick, 120);
        return;
      }

      // 2) fallback discreto por pulsos
      const dir = vecToDir(x, y);
      if (dir !== lastDirRef.current) {
        const ms = 140 + Math.round(260 * Math.min(1, mag)); // 140..400
        const spd = 50 + Math.round(50 * Math.min(1, mag)); // 50..100
        await sendDiscreteCmd(dir, ms, spd);
        lastDirRef.current = dir;
      } else if (dir !== "STOP") {
        const ms = 120 + Math.round(200 * Math.min(1, mag));
        const spd = 50 + Math.round(50 * Math.min(1, mag));
        await sendDiscreteCmd(dir, ms, spd);
      }
      setTimeout(tick, 120);
    };

    if (AppState.currentState === "active") tick();
    return () => {
      cancelled = true;
    };
  }, [joy, ip]); // envia para o ESP

  // STOP garantido ao sair da tela/app
  useEffect(() => {
    const handleBg = (s: string) => {
      if (s !== "active") {
        sendDiscreteCmd("STOP");
        lastDirRef.current = "STOP";
      }
    };
    const sub = AppState.addEventListener("change", handleBg);
    return () => sub.remove();
  }, []);

  /* ===== Medidas do container do vídeo ===== */
  function onVideoLayout(e: LayoutChangeEvent) {
    const { width, height } = e.nativeEvent.layout;
    setVideoContainerWH({ w: width, h: height });
  }

  return (
    <View style={styles.container}>
      <AppHero subtitle={T.heroSubtitle} />

      {/* Linha: ESP + LED + BOMBA */}
      <View style={styles.topbar}>
        <Text style={styles.label}>{T.espIp}</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder={T.placeholderIp}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : T.test}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? T.ledOn : T.ledOff}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? T.pumpOn : T.pumpOff}</Text>
        </Pressable>
      </View>

      {/* Linha: Servidor + indicador */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>{T.server}</Text>
        <TextInput
          value={server}
          onChangeText={(s) => {
            setServer(s);
            setReady(false); // força novo health-check
            setStatusText(T.waiting);
          }}
          placeholder={T.placeholderServer}
          placeholderTextColor="#8a93a5"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <View style={[styles.badge, { backgroundColor: ready ? "#065f46" : "#1f2937" }]}>
          <Text style={{ color: "#fff", fontWeight: "800" }}>
            {ready ? T.detecting : T.waiting}
          </Text>
        </View>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>
          {statusText}
        </Text>
      </View>

      {/* Banner de fogo */}
      <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
        <Text style={styles.fireText}>{isFire ? T.fireOn(fireScore) : T.fireOff(fireScore)}</Text>
      </View>

      {/* Banner de pessoas/animais + backend */}
      <View style={[styles.statusRow, { justifyContent: "space-between" }]}>
        <Text style={styles.statChip}>
          {T.persons}: <Text style={styles.statNumber}>{people}</Text>
        </Text>
        <Text style={styles.statChip}>
          {T.animals}: <Text style={styles.statNumber}>{animals}</Text>
        </Text>
        <Text style={styles.modelChip}>
          {T.backend}: {backend} • conf_max {confMax.toFixed(2)}
        </Text>
      </View>

      {/* Vídeo (snapshot) + Overlay */}
      <View style={{ flex: 1 }} onLayout={onVideoLayout}>
        <CrossfadeImage
          currentUri={currentFrameUri}
          nextUri={nextFrameUri}
          onNextLoadStart={onNextLoadStart}
          onNextShown={onNextShown}
        />
        {overlayBoxes.length > 0 && (
          <BoxesOverlay frameWH={frameWH} containerWH={videoContainerWH} boxes={overlayBoxes} />
        )}
      </View>

      {/* Joystick overlay (UI) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View
          style={[styles.joyWrap, { width: 64 * 2 + 24, height: 64 * 2 + 24 }]}
          {...pan.panHandlers}
        >
          <View style={[styles.joyBase, { width: 64 * 2, height: 64 * 2, borderRadius: 64 }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: 22 * 2,
                height: 22 * 2,
                borderRadius: 22,
                transform: [{ translateX: joy.x * 64 }, { translateY: -joy.y * 64 }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)} y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

/* ---------- ESTILOS ---------- */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },

  // HERO
  hero: { alignItems: "center", paddingTop: 12, paddingBottom: 6 },
  heroLogo: { width: 80, height: 80, marginBottom: 6, resizeMode: "contain" },
  heroTitle: { color: "#fff", fontSize: 22, fontWeight: "800" },
  heroSubtitle: { color: "#d1d5db", marginTop: 2 },

  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: PALETTE.card,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: {
    backgroundColor: "#0b0d14",
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
    minWidth: 110,
  },
  btn: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },

  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1322",
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: PALETTE.border,
  },
  badge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },

  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },
  fireText: { color: "white", fontWeight: "800" },

  statChip: { color: "#dbeafe", fontSize: 14, fontWeight: "600" },
  statNumber: { color: "#fff" },
  modelChip: { marginLeft: "auto", color: "#9fb0ff", fontSize: 12 },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: {
    position: "absolute",
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.14)",
  },
  joyKnob: {
    position: "absolute",
    backgroundColor: "rgba(230,64,58,0.9)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.85)",
  },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});








# server_heuristic.py
# FOGO (heurístico) + OBJETOS (MobileNet-SSD -> fallback YOLOv4-tiny) com votação/hold anti-pisca
# *** Agora usando SNAPSHOT-ONLY do ESP (GET /snapshot), sem MJPEG multipart ***

import os, time, threading
from collections import deque
from typing import Optional, List, Tuple, Dict, Any

import numpy as np
import cv2
import requests
from fastapi import FastAPI, Response, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ===================== CÂMERA (snapshot) =====================
CAMERA_IP = "192.168.3.3"  # <- IP padrão novo
SNAPSHOT_URL_FMT = "http://{}/snapshot"   # ESP32-CAM agora serve só snapshot
POLL_FPS_TARGET = 12.0                    # ~12 fps (ajuste conforme sua rede)

# Robustez de rede
CONNECT_TIMEOUT = 4.0
READ_TIMEOUT = 8.0
JPEG_QUALITY = 85
REQUEST_HEADERS = {
    "Connection": "keep-alive",
    "User-Agent": "HydroBot-Grabber/1.0"
}
MAX_BYTES = 4_000_000  # (aqui só por compatibilidade; com snapshot não usamos buffer grande)

# ===================== FOGO (heurístico) =====================
HSV_LOW = (8, 80, 120)
HSV_HIGH = (40, 255, 255)
RED_DELTA = 15

DETECTOR_MAX_FPS = 14.0
HYST_HIGH = 0.18
HYST_LOW  = 0.15
VOTE_WINDOW = 7
VOTE_NEED   = 4
EMA_ALPHA   = 0.25
MIN_BLOB_AREA = 1200
KERNEL_SZ = 5

MOTION_THRESH = 22
MOTION_DILATE_ITERS = 1

PERSIST_CONSEC = 2
IOU_MIN = 0.15

MAX_FRAME_AGE_MS = 3000
MAX_RESULT_AGE_MS = 800

# ===================== OBJETOS =====================
OBJECTS_MAX_FPS = 12.0
OBJ_CONF_THRESH = 0.25
OBJ_NMS_THRESH  = 0.45

# anti-pisca (votação/hold)
VOTE_WIN_OBJ   = 10
VOTE_NEED_OBJ  = 3
HOLD_MS_OBJ    = 900

COCO_ANIMAL_NAMES = {"person","cat","dog","bird","horse","sheep","cow"}

# MobileNet-SSD (VOC)
MNET_CLASSES = [
    "background","aeroplane","bicycle","bird","boat","bottle","bus","car","cat","chair",
    "cow","diningtable","dog","horse","motorbike","person","pottedplant","sheep","sofa","train","tvmonitor"
]
MNET_ANIMALS = {"person","cat","dog","bird","horse","sheep","cow"}
MNET_IN_SIZE = (300,300); MNET_SCALE = 0.007843; MNET_MEAN = 127.5
MNET_PROTOTXT_CANDS = [
    "./models/MobileNetSSD_deploy.prototxt",
    "./models/MobileNetSSD_deploy.prototxt.txt",
    "./models/deploy.prototxt",
    "./models/voc/MobileNetSSD_test.prototxt",
]
MNET_WEIGHTS_CANDS = [
    "./models/MobileNetSSD_deploy.caffemodel",
    "./models/mobilenet_iter_73000.caffemodel",
]

# YOLOv4-tiny (COCO)
YOLO_CFG  = "./models/yolov4-tiny.cfg"
YOLO_WTS  = "./models/yolov4-tiny.weights"
COCO_NAMES= "./models/coco.names"
YOLO_IN_SZ = (416,416)

# ===================== FASTAPI =====================
app = FastAPI(title="HydroBot Fire + Objects (Stable)", version="1.8.0 (snapshot-only)")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
  camera_ip: str

# ===================== PLACEHOLDER =====================
def placeholder_jpeg(msg: str = "NO FRAME") -> bytes:
  import numpy as np, cv2, time
  img = np.zeros((270, 480, 3), dtype=np.uint8)
  img[:, :] = (40, 40, 200)
  cv2.putText(img, msg, (20, 150), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255,255,255), 2, cv2.LINE_AA)
  cv2.putText(img, time.strftime("%H:%M:%S"), (20, 200), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255,255,255), 2, cv2.LINE_AA)
  ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), 80])
  return buf.tobytes()

# ===================== SNAPSHOT GRABBER =====================
class MJPEGGrabber:
  """
  SnapshotGrabber: em vez de multipart MJPEG, faz GET /snapshot em loop
  e mantém o último JPEG válido em memória.
  """
  def __init__(self):
    self._lock = threading.Lock()
    self._stop = threading.Event()
    self._thread: Optional[threading.Thread] = None
    self._ip = CAMERA_IP
    self._last_jpeg: Optional[bytes] = None
    self._last_ts_ms: int = 0
    self._frames = 0
    self._fps = 0.0
    self._last_fps_tick = time.time()
    self._session = requests.Session()

  def start(self, ip: Optional[str] = None):
    if ip:
      self._ip = ip
    self.stop()
    self._stop.clear()
    self._thread = threading.Thread(target=self._run, daemon=True)
    self._thread.start()

  def stop(self):
    self._stop.set()
    if self._thread and self._thread.is_alive():
      self._thread.join(timeout=1.0)
    self._thread = None

  def _run(self):
    backoff = 0.2
    min_interval = 1.0 / POLL_FPS_TARGET

    while not self._stop.is_set():
      t0 = time.time()
      url = SNAPSHOT_URL_FMT.format(self._ip)
      try:
        u = f"{url}?ts={int(time.time()*1000)}"  # evita cache
        r = self._session.get(
          u,
          timeout=(CONNECT_TIMEOUT, READ_TIMEOUT),
          headers=REQUEST_HEADERS,
          stream=False,
        )
        if r.status_code == 200 and r.headers.get("Content-Type","").startswith("image/jpeg"):
          jpeg_bytes = r.content
          if jpeg_bytes:
            ts_ms = int(time.time() * 1000)
            with self._lock:
              self._last_jpeg = jpeg_bytes
              self._last_ts_ms = ts_ms
            # FPS
            self._frames += 1
            now = time.time()
            if now - self._last_fps_tick >= 1.0:
              self._fps = self._frames / (now - self._last_fps_tick)
              self._frames = 0
              self._last_fps_tick = now
            backoff = 0.0  # OK, sem backoff extra
        else:
          backoff = min(max(backoff * 1.6, 0.2), 2.5)
      except Exception:
        backoff = min(max(backoff * 1.6, 0.2), 3.0)

      # controla taxa (fps) + backoff em erro
      elapsed = time.time() - t0
      wait = max(0.0, min_interval - elapsed) + backoff
      if self._stop.is_set():
        break
      time.sleep(wait)

  def get_latest_jpeg(self, max_age_ms: int = MAX_FRAME_AGE_MS) -> Optional[bytes]:
    with self._lock:
      if self._last_jpeg is None:
        return None
      if int(time.time() * 1000) - self._last_ts_ms > max_age_ms:
        return None
      return self._last_jpeg

  def status(self):
    with self._lock:
      age_ms = (int(time.time() * 1000) - self._last_ts_ms) if self._last_ts_ms else None
      return {
        "ip": self._ip,
        "hasFrame": self._last_jpeg is not None,
        "age_ms": age_ms,
        "fps_in": round(self._fps, 2),
        "ts_ms": self._last_ts_ms,
        "mode": "snapshot-poll"
      }

grabber = MJPEGGrabber()
grabber.start(CAMERA_IP)

# ===================== VISÃO (fogo) =====================
def rgb_red_dominance_mask(frame_bgr: np.ndarray, delta: int = RED_DELTA) -> np.ndarray:
  b, g, r = cv2.split(frame_bgr)
  return ((r.astype(np.int16) > (g.astype(np.int16) + delta)) &
          (r.astype(np.int16) > (b.astype(np.int16) + delta))).astype(np.uint8) * 255

def hsv_fire_mask(frame_bgr: np.ndarray) -> np.ndarray:
  hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
  return cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))

def skin_mask_ycrcb(frame_bgr: np.ndarray) -> np.ndarray:
  ycrcb = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2YCrCb)
  y, cr, cb = cv2.split(ycrcb)
  skin = cv2.inRange(ycrcb, (0,133,77), (255,173,127))
  dark = cv2.threshold(y, 60, 255, cv2.THRESH_BINARY)[1]
  return cv2.bitwise_and(skin, dark)

def iou(a: Tuple[int,int,int,int], b: Tuple[int,int,int,int]) -> float:
  ax, ay, aw, ah = a; bx, by, bw, bh = b
  ax2, ay2 = ax+aw, ay+ah; bx2, by2 = bx+bw, by+bh
  ix1, iy1 = max(ax,bx), max(ay,by); ix2, iy2 = min(ax2,bx2), min(ay2,by2)
  iw, ih = max(0, ix2-ix1), max(0, iy2-iy1)
  inter = iw*ih; union = aw*ah + bw*bh - inter
  return float(inter)/float(union) if union>0 else 0.0

def boxes_from_mask(mask_bin: np.ndarray, min_area: int = MIN_BLOB_AREA) -> List[List[int]]:
  k = np.ones((KERNEL_SZ,KERNEL_SZ), np.uint8)
  m = cv2.morphologyEx(mask_bin, cv2.MORPH_OPEN, k, 1)
  m = cv2.morphologyEx(m, cv2.MORPH_DILATE, k, 1)
  cnts, _ = cv2.findContours(m, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  boxes = []
  for c in cnts:
    x,y,w,h = cv2.boundingRect(c)
    if w*h >= min_area: boxes.append([x,y,w,h])
  return boxes

class Detector:
  def __init__(self, src: MJPEGGrabber):
    self.src = src
    self._lock = threading.Lock()
    self._stop = threading.Event()
    self._thread: Optional[threading.Thread] = None
    self._prev_gray: Optional[np.ndarray] = None
    self._score_raw = 0.0; self._score_ema = 0.0
    self._is_fire = False; self._boxes: List[List[int]] = []
    self._votes = deque(maxlen=VOTE_WINDOW); self._persist_hits = 0
    self._last_main_box: Optional[Tuple[int,int,int,int]] = None
    self._det_fps = 0.0; self._det_frames = 0; self._last_fps_tick = time.time()
    self._last_result_ts = 0
    self._last_frame_wh: Tuple[int,int] = (0,0)

  def start(self):
    self.stop(); self._stop.clear()
    self._thread = threading.Thread(target=self._run, daemon=True); self._thread.start()

  def stop(self):
    self._stop.set()
    if self._thread and self._thread.is_alive(): self._thread.join(timeout=1.0)
    self._thread = None

  def _run(self):
    min_interval = 1.0/DETECTOR_MAX_FPS
    while not self._stop.is_set():
      t0 = time.time()
      jpeg = self.src.get_latest_jpeg()
      if jpeg is None:
        time.sleep(0.01); continue
      frame = cv2.imdecode(np.frombuffer(jpeg,np.uint8), cv2.IMREAD_COLOR)
      if frame is None:
        time.sleep(0.005); continue
      H,W = frame.shape[:2]
      self._last_frame_wh = (W,H)

      mask_hsv = hsv_fire_mask(frame)
      mask_skin = skin_mask_ycrcb(frame)
      mask_red  = rgb_red_dominance_mask(frame)

      gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
      gray = cv2.GaussianBlur(gray,(3,3),0)
      motion_mask = np.zeros_like(gray,np.uint8)
      if self._prev_gray is not None:
        diff = cv2.absdiff(gray,self._prev_gray)
        _, motion_mask = cv2.threshold(diff, MOTION_THRESH, 255, cv2.THRESH_BINARY)
        if MOTION_DILATE_ITERS>0:
          k = np.ones((3,3),np.uint8)
          motion_mask = cv2.morphologyEx(motion_mask, cv2.MORPH_DILATE, k, MOTION_DILATE_ITERS)
      self._prev_gray = gray

      stable = cv2.bitwise_and(mask_hsv, cv2.bitwise_not(mask_skin))
      stable = cv2.bitwise_and(stable, cv2.bitwise_not(motion_mask))

      hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
      V = hsv[...,2]
      bright = cv2.threshold(V,200,255,cv2.THRESH_BINARY)[1]
      red_boost = cv2.bitwise_and(mask_red,bright)
      combined = cv2.bitwise_or(stable, red_boost)

      ratio_hsv = float(np.count_nonzero(mask_hsv))/float(mask_hsv.size)
      v_mean = float(np.mean(V))/255.0
      score_raw = min(1.0, ratio_hsv*4.0 + v_mean*0.2)
      ratio_combined = float(np.count_nonzero(combined))/float(combined.size)
      score_combined = min(1.0, ratio_combined*5.0 + v_mean*0.1)
      ema = score_combined if self._score_ema==0.0 else (EMA_ALPHA*score_combined + (1.0-EMA_ALPHA)*self._score_ema)

      boxes = boxes_from_mask(combined, MIN_BLOB_AREA)
      main_box = None
      if boxes:
        areas = [w*h for(_,_,w,h) in boxes]; main_box = boxes[int(np.argmax(areas))]
        if self._last_main_box is not None:
          self._persist_hits = self._persist_hits+1 if iou(tuple(main_box),tuple(self._last_main_box))>=IOU_MIN else 1
        else: self._persist_hits = 1
      else: self._persist_hits = 0
      self._last_main_box = tuple(main_box) if main_box is not None else None

      if ema>=HYST_HIGH and self._persist_hits>=PERSIST_CONSEC: guess=1
      elif ema<=HYST_LOW: guess=0
      else: guess=(1 if (len(self._votes)>0 and self._votes[-1]==1 and self._persist_hits>=PERSIST_CONSEC) else 0)

      self._votes.append(guess)
      final_fire = 1 if sum(self._votes)>=VOTE_NEED else 0

      with self._lock:
        self._score_raw=float(score_raw); self._score_ema=float(ema)
        self._is_fire=bool(final_fire==1); self._boxes=boxes if self._is_fire else []
        self._last_result_ts=int(time.time()*1000)
        self._det_frames+=1
        now=time.time()
      if now-self._last_fps_tick>=1.0:
        self._det_fps=self._det_frames/(now-self._last_fps_tick)
        self._det_frames=0; self._last_fps_tick=now

      elapsed = time.time()-t0
      if elapsed<min_interval: time.sleep(min_interval-elapsed)

  def get_result(self)->Dict[str,Any]:
    with self._lock:
      return {
        "ok": True,
        "isFire": self._is_fire,
        "score": round(self._score_ema,3),
        "score_raw": round(self._score_raw,3),
        "score_ema": round(self._score_ema,3),
        "boxes": self._boxes,
        "ts": self._last_result_ts,
        "fps_det": round(self._det_fps,2),
        "vote": {"win":VOTE_WINDOW,"need":VOTE_NEED,"sum":int(sum(self._votes))},
        "persist": {"hits":self._persist_hits,"need":PERSIST_CONSEC,"iou_min":IOU_MIN},
        "hyst": {"hi":HYST_HIGH,"lo":HYST_LOW},
        "frame_wh": list(self._last_frame_wh) if self._last_frame_wh else None,
      }

detector = Detector(grabber); detector.start()

# ===================== OBJETOS =====================
class ObjectsDetector:
  def __init__(self, src: MJPEGGrabber):
    self.src = src
    self._lock = threading.Lock()
    self._stop = threading.Event()
    self._thread: Optional[threading.Thread] = None

    self.backend = "mobilenet-ssd"
    self.net = None; self.ok = False
    self.proto = None; self.weights = None; self.cfg = None; self.names = None
    self.labels = []
    self.swap_rb = False
    self._nohit = 0
    self._last_conf_max = 0.0

    self.votes_person = deque(maxlen=VOTE_WIN_OBJ)
    self.votes_animal = deque(maxlen=VOTE_WIN_OBJ)
    self.hold_person_until = 0
    self.hold_animal_until = 0

    self._frames = 0; self._fps = 0.0; self._last_fps_tick = time.time()
    self._last: Dict[str, Any] = {"ok": False, "backend": self.backend, "fps_obj": 0.0, "objects": [], "ts": 0}

    self._try_load_mnet()
    if not self.ok:
      self._try_load_yolo()

  def _try_load_mnet(self):
    self.backend = "mobilenet-ssd"
    self.labels = MNET_CLASSES
    self.proto = next((p for p in MNET_PROTOTXT_CANDS if os.path.exists(p)), None)
    self.weights = next((w for w in MNET_WEIGHTS_CANDS if os.path.exists(w)), None)
    if not self.proto or not self.weights:
      self.ok = False; self.net=None; return
    try:
      net = cv2.dnn.readNetFromCaffe(self.proto, self.weights)
      net.setPreferableBackend(cv2.dnn.DNN_BACKEND_OPENCV)
      net.setPreferableTarget(cv2.dnn.DNN_TARGET_CPU)
      self.net = net; self.ok = True; self.swap_rb=False
    except Exception:
      self.ok = False; self.net=None

  def _try_load_yolo(self):
    self.backend = "yolov4-tiny"
    if not (os.path.exists(YOLO_CFG) and os.path.exists(YOLO_WTS) and os.path.exists(COCO_NAMES)):
      self.ok=False; self.net=None; return
    try:
      net = cv2.dnn.readNetFromDarknet(YOLO_CFG, YOLO_WTS)
      net.setPreferableBackend(cv2.dnn.DNN_BACKEND_OPENCV)
      net.setPreferableTarget(cv2.dnn.DNN_TARGET_CPU)
      with open(COCO_NAMES, "r", encoding="utf-8") as f:
        self.labels = [ln.strip() for ln in f if ln.strip()]
      self.net = net; self.ok = True
    except Exception:
      self.ok=False; self.net=None

  def start(self):
    self.stop(); self._stop.clear()
    self._thread = threading.Thread(target=self._run, daemon=True); self._thread.start()

  def stop(self):
    self._stop.set()
    if self._thread and self._thread.is_alive(): self._thread.join(timeout=1.0)
    self._thread=None

  def _infer_mnet(self, frame, conf_th):
    (h,w)=frame.shape[:2]
    blob = cv2.dnn.blobFromImage(cv2.resize(frame,(300,300)),
                                 0.007843, (300,300), 127.5, swapRB=self.swap_rb, crop=False)
    self.net.setInput(blob); det=self.net.forward()
    boxes=[]; confs=[]; labels=[]
    conf_max=0.0
    for i in range(det.shape[2]):
      conf=float(det[0,0,i,2]); conf_max=max(conf_max, conf)
      if conf<conf_th: continue
      idx=int(det[0,0,i,1])
      if 0<=idx<len(self.labels):
        label=self.labels[idx]
        if label not in {"person","cat","dog","bird","horse","sheep","cow"}: continue
        x1,y1,x2,y2=(det[0,0,i,3:7]*np.array([w,h,w,h])).astype(int)
        x,y=max(0,x1),max(0,y1); rw,rh=max(0,x2-x),max(0,y2-y)
        if rw*rh<=0: continue
        boxes.append([x,y,rw,rh]); confs.append(conf); labels.append(label)
    idxs=cv2.dnn.NMSBoxes(boxes,confs,conf_th,0.45)
    keep = [int(i) for i in (idxs.flatten().tolist() if isinstance(idxs,np.ndarray) else (idxs or []))]
    out=[{"label":labels[i],"conf":float(confs[i]),"box":boxes[i]} for i in keep]
    out.sort(key=lambda o:o["conf"], reverse=True)
    return out[:15], conf_max

  def _infer_yolo(self, frame, conf_th):
    (H,W)=frame.shape[:2]
    ln = self.net.getUnconnectedOutLayersNames()
    blob = cv2.dnn.blobFromImage(frame, 1/255.0, (416,416), swapRB=True, crop=False)
    self.net.setInput(blob); layerOutputs = self.net.forward(ln)
    boxes=[]; confs=[]; labels=[]
    conf_max = 0.0
    for output in layerOutputs:
      for det in output:
        scores = det[5:]
        classID = int(np.argmax(scores))
        conf = float(scores[classID])
        conf_max = max(conf_max, conf)
        if conf < conf_th: continue
        label = self.labels[classID] if 0<=classID<len(self.labels) else str(classID)
        if label not in COCO_ANIMAL_NAMES: continue
        bx = det[0:4]
        (cx,cy,w,h) = (bx[0]*W, bx[1]*H, bx[2]*W, bx[3]*H)
        x = int(cx - w/2); y = int(cy - h/2)
        boxes.append([max(0,x), max(0,y), int(w), int(h)])
        confs.append(conf); labels.append(label)
    idxs=cv2.dnn.NMSBoxes(boxes,confs,conf_th,0.45)
    keep = [int(i) for i in (idxs.flatten().tolist() if isinstance(idxs,np.ndarray) else (idxs or []))]
    out=[{"label":labels[i],"conf":float(confs[i]),"box":[int(v) for v in boxes[i]]} for i in keep]
    out.sort(key=lambda o:o["conf"], reverse=True)
    return out[:15], conf_max

  def _run(self):
    min_interval = 1.0/OBJECTS_MAX_FPS
    while not self._stop.is_set():
      t0 = time.time()
      jpeg = self.src.get_latest_jpeg()
      if jpeg is None: time.sleep(0.01); continue
      frame = cv2.imdecode(np.frombuffer(jpeg,np.uint8), cv2.IMREAD_COLOR)
      if frame is None: time.sleep(0.005); continue

      out=[]; cmax=0.0; backend=self.backend
      if self.ok and self.net is not None:
        try:
          if self.backend=="mobilenet-ssd":
            out,cmax = self._infer_mnet(frame, OBJ_CONF_THRESH)
            self._nohit = self._nohit+1 if cmax<0.05 else 0
            if self._nohit>=10:
              self.swap_rb = not self.swap_rb
              self._nohit = 0
          else:
            out,cmax = self._infer_yolo(frame, OBJ_CONF_THRESH)
        except Exception as e:
          self.ok=False
          with self._lock:
            self._last={"ok":False,"backend":backend,"fps_obj":round(self._fps,2),
                        "objects":[], "ts":int(time.time()*1000), "error":f"forward failed: {e}"}
          time.sleep(0.05); continue

      if (backend=="mobilenet-ssd" and cmax<0.05 and
          os.path.exists(YOLO_CFG) and os.path.exists(YOLO_WTS) and os.path.exists(COCO_NAMES)):
        self._try_load_yolo()
        backend=self.backend
        if self.ok and self.backend=="yolov4-tiny":
          out,cmax = self._infer_yolo(frame, max(0.2, OBJ_CONF_THRESH))

      n_person  = sum(1 for o in out if o["label"]=="person")
      n_animals = sum(1 for o in out if o["label"]!="person")
      hit_person  = 1 if n_person  > 0 else 0
      hit_animal  = 1 if n_animals > 0 else 0
      self.votes_person.append(hit_person)
      self.votes_animal.append(hit_animal)
      now_ms = int(time.time()*1000)
      if hit_person: self.hold_person_until = now_ms + HOLD_MS_OBJ
      if hit_animal: self.hold_animal_until = now_ms + HOLD_MS_OBJ
      stable_person = (sum(self.votes_person) >= VOTE_NEED_OBJ) or (now_ms < self.hold_person_until)
      stable_animal = (sum(self.votes_animal) >= VOTE_NEED_OBJ) or (now_ms < self.hold_animal_until)

      with self._lock:
        self._last_conf_max=cmax
        self._last={"ok":bool(self.ok),"backend":backend,"fps_obj":round(self._fps,2),
                    "objects":out,"ts":int(time.time()*1000),
                    "proto":self.proto,"weights":self.weights,"cfg":YOLO_CFG if backend=="yolov4-tiny" else None,
                    "names":COCO_NAMES if backend=="yolov4-tiny" else None,
                    "conf_max":round(cmax,3),"swap_rb":self.swap_rb,
                    "n_person":n_person,"n_animals":n_animals,
                    "n_person_stable":1 if stable_person else 0,
                    "n_animals_stable":1 if stable_animal else 0}

      self._frames+=1; now=time.time()
      if now-self._last_fps_tick>=1.0:
        self._fps=self._frames/(now-self._last_fps_tick); self._frames=0; self._last_fps_tick=now

      dt = time.time()-t0
      if dt<min_interval: time.sleep(min_interval-dt)

  def get(self)->Dict[str,Any]:
    with self._lock:
      return dict(self._last)

objects_det = ObjectsDetector(grabber); objects_det.start()

# ===================== ENDPOINTS =====================
@app.get("/healthz")
def healthz():
  s = grabber.status()
  return {"ok": True, "fps_in": s.get("fps_in"), "hasFrame": s.get("hasFrame"), "age_ms": s.get("age_ms")}

@app.get("/status")
def status():
  s1 = grabber.status(); s2 = detector.get_result()
  return {"ok": True, "camera_ip": s1["ip"], "model": "balanced_detector",
          "fps_in": s1["fps_in"], "hasFrame": s1["hasFrame"], "age_ms": s1["age_ms"], **s2}

@app.post("/config")
def set_config(cfg: ConfigIn):
  global CAMERA_IP
  CAMERA_IP = cfg.camera_ip
  grabber.start(CAMERA_IP)
  return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
  jpeg = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS)
  if jpeg is None:
    jpeg = placeholder_jpeg("NO LIVE FRAME")
  headers = {
      "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
      "Pragma": "no-cache",
      "Expires": "0",
      "Content-Length": str(len(jpeg)),   # <- importante pro RN <Image/>
  }
  return Response(content=jpeg, media_type="image/jpeg", headers=headers)

@app.get("/detect")
def detect():
  res = detector.get_result()
  res["objects"] = objects_det.get()
  if res.get("ts", 0) and (int(time.time()*1000)-res["ts"] <= MAX_RESULT_AGE_MS):
    return res
  jpeg = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS)
  if jpeg is None: return {"ok": False, "error": "no recent frame"}
  frame = cv2.imdecode(np.frombuffer(jpeg,np.uint8), cv2.IMREAD_COLOR)
  if frame is None: return {"ok": False, "error": "decode failed"}
  H,W = frame.shape[:2]
  mask_hsv = hsv_fire_mask(frame)
  ratio_hsv = float(np.count_nonzero(mask_hsv))/float(mask_hsv.size)
  v_mean = float(np.mean(cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)[...,2]))/255.0
  score_raw = min(1.0, ratio_hsv*4.0 + v_mean*0.2)
  is_fire = bool(score_raw >= HYST_HIGH)
  return {"ok":True,"isFire":is_fire,"score":round(score_raw,3),"score_raw":round(score_raw,3),
          "score_ema":round(score_raw,3),"boxes":[],"ts":int(time.time()*1000),"fallback":True,
          "frame_wh":[W,H],
          "objects": objects_det.get()}

@app.get("/objects")
def objects(conf: float = Query(None)):
  global OBJ_CONF_THRESH
  if conf is not None:
    OBJ_CONF_THRESH = max(0.05, min(0.95, float(conf)))
  return objects_det.get()

@app.get("/objects_frame")
def objects_frame(conf: float = Query(0.25)):
  jpeg = grabber.get_latest_jpeg(max_age_ms=MAX_FRAME_AGE_MS)
  if jpeg is None: return Response(content=placeholder_jpeg("NO LIVE FRAME"), media_type="image/jpeg")
  frame = cv2.imdecode(np.frombuffer(jpeg,np.uint8), cv2.IMREAD_COLOR)
  if frame is None: return Response(content=placeholder_jpeg("DECODE ERR"), media_type="image/jpeg")

  o = objects_det.get(); backend = o.get("backend"); det = objects_det
  try:
    if backend=="yolov4-tiny":
      objs, _ = det._infer_yolo(frame, max(0.05, min(0.95, conf)))
    else:
      objs, _ = det._infer_mnet(frame, max(0.05, min(0.95, conf)))
  except Exception:
    return Response(content=placeholder_jpeg("FORWARD ERR"), media_type="image/jpeg")

  for obj in objs:
    x,y,w,h = obj["box"]
    cv2.rectangle(frame,(x,y),(x+w,y+h),(0,255,0),2)
    cv2.putText(frame, f'{obj["label"]} {obj["conf"]:.2f}', (x, max(15,y-6)),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,255,0), 1, cv2.LINE_AA)
  ok, buf = cv2.imencode(".jpg", frame, [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY])
  return Response(content=buf.tobytes(), media_type="image/jpeg")

@app.get("/debug_models")
def debug_models():
  o = objects_det.get(); s = grabber.status()
  return {"ok":True, "backend":o.get("backend"), "objects_ok":o.get("ok"),
          "proto":o.get("proto"), "weights":o.get("weights"),
          "cfg":o.get("cfg"), "names":o.get("names"),
          "swap_rb":o.get("swap_rb"), "conf_max":o.get("conf_max"),
          "conf_thresh":OBJ_CONF_THRESH, "fps_obj":o.get("fps_obj"),
          "stream_hasFrame":s.get("hasFrame"), "stream_fps_in":s.get("fps_in"),
          "n_person":o.get("n_person"), "n_animals":o.get("n_animals"),
          "n_person_stable":o.get("n_person_stable"), "n_animals_stable":o.get("n_animals_stable"),
          "num_objects":len(o.get("objects",[])), "error":o.get("error")}


















