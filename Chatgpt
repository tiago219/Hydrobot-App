https://chatgpt.com/share/68b78dcd-48bc-800d-b32a-aecc510baa8b

https://chatgpt.com/share/68b78dcd-48bc-800d-b32a-aecc510baa8b

Perfeito ‚Äî vamos migrar o seu projeto para Bluetooth (SPP/Serial), tirar WebView/navegador do app, mover o LED para um pino seguro que n√£o conflita com a roda, e preparar a rota com TensorFlow fora da ESP32-CAM (no Node.js). J√° deixo tudo funcionando sem TF e com toggles no app para:




Fonte do v√≠deo: direto da ESP por Bluetooth (sem TF) ou via servidor (com TF habilit√°vel).


Troca de modo: manual / auto / patrol (via Bluetooth).


Joystick: envia vetores x/y.


Bomba (MOSFET): bot√£o ON/OFF.


LED indicador: realocado para pino seguro.






‚ö†Ô∏è Observa√ß√µes importantes




Bluetooth cl√°ssico (SPP) funciona no Android. No iOS o SPP n√£o √© suportado; se precisar iOS, usamos Wi-Fi ou BLE (sem v√≠deo fluido).


Expo Go n√£o tem Bluetooth cl√°ssico. Use Expo Dev Build (ou bare) com react-native-bluetooth-serial-next. Abaixo deixo o passo-a-passo.







A) Firmware ESP32-CAM (Bluetooth + v√≠deo em Base64 + comandos)


O que muda




Sem Wi-Fi/HTTP ‚Äî tudo por Bluetooth Serial.


V√≠deo MJPEG capturado, encodado em base64 e enviado como NDJSON (JSON por linha). FPS baixo (1‚Äì2) para caber no throughput do SPP.


Comandos simples por texto (linhas): CMD:MODE:auto, CMD:STREAM:1, CMD:JOY:x,y, CMD:PUMP:1, CMD:LED:1, CMD:TF:1.


LED indicador movido para GPIO 33 (sa√≠da OK). PUMP no GPIO 32. (Ambos n√£o conflitam com c√¢mera; fio um LED externo no 33 com resistor).




Crie o arquivo HydroBotBT.ino:


/**
 * HydroBotBT.ino ‚Äî ESP32-CAM (AI Thinker) via Bluetooth SPP
 * - Captura frames JPEG e envia via Bluetooth como NDJSON (1 linha por evento)
 * - Sem Wi-Fi/HTTP. Tudo por SerialBT.
 * - Comandos por linha (texto): CMD:...
 * - LED indicador em GPIO 33 (n√£o conflita com roda/motores)
 * - MOSFET da bomba em GPIO 32
 * - Sem sensor IR por enquanto
 *
 * OBS: FPS baixo (1‚Äì2) por limita√ß√£o de banda do SPP
 */

#include "esp_camera.h"
#include <BluetoothSerial.h>
#include <time.h>
#include "mbedtls/base64.h"

// ===== Pins (AI Thinker) =====
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ===== Seus atuadores sem conflito =====
#define LED_IND_PIN  33   // LED indicador externo
#define PUMP_PIN     32   // MOSFET da bomba

BluetoothSerial SerialBT;

// ===== Estado =====
String g_mode = "manual";
bool   g_streamOn = true;     // envia frames
bool   g_ledOn    = false;    // LED indicador
bool   g_pumpOn   = false;    // bomba
bool   g_tfOn     = false;    // s√≥ espelha no status (TF roda fora)
float  g_joyX     = 0.0f;
float  g_joyY     = 0.0f;

uint32_t lastFrameMs = 0;
uint32_t frameIntervalMs = 700; // ~1.4 fps (ajuste ao seu gosto)
char lineBuf[256];

// ===== Util =====
void writeJsonLine(const String& s) {
  SerialBT.write((const uint8_t*)s.c_str(), s.length());
  SerialBT.write('\n');
}

String isoTsUptime() {
  // sem NTP ‚Üí uptime
  char buf[64];
  snprintf(buf, sizeof(buf), "{\"uptime_ms\":%lu}", millis());
  return String(buf);
}

// ===== Camera =====
bool initCamera() {
  camera_config_t c;
  c.ledc_channel = LEDC_CHANNEL_0;
  c.ledc_timer   = LEDC_TIMER_0;
  c.pin_d0       = Y2_GPIO_NUM;
  c.pin_d1       = Y3_GPIO_NUM;
  c.pin_d2       = Y4_GPIO_NUM;
  c.pin_d3       = Y5_GPIO_NUM;
  c.pin_d4       = Y6_GPIO_NUM;
  c.pin_d5       = Y7_GPIO_NUM;
  c.pin_d6       = Y8_GPIO_NUM;
  c.pin_d7       = Y9_GPIO_NUM;
  c.pin_xclk     = XCLK_GPIO_NUM;
  c.pin_pclk     = PCLK_GPIO_NUM;
  c.pin_vsync    = VSYNC_GPIO_NUM;
  c.pin_href     = HREF_GPIO_NUM;
  c.pin_sscb_sda = SIOD_GPIO_NUM;
  c.pin_sscb_scl = SIOC_GPIO_NUM;
  c.pin_pwdn     = PWDN_GPIO_NUM;
  c.pin_reset    = RESET_GPIO_NUM;
  c.xclk_freq_hz = 20000000;
  c.pixel_format = PIXFORMAT_JPEG;

  if (psramFound()) {
    c.frame_size   = FRAMESIZE_QVGA; // 320x240 para reduzir base64
    c.jpeg_quality = 22;             // + n√∫mero = + compacta√ß√£o
    c.fb_count     = 2;
    c.fb_location  = CAMERA_FB_IN_PSRAM;
    c.grab_mode    = CAMERA_GRAB_WHEN_EMPTY;
  } else {
    c.frame_size   = FRAMESIZE_QQVGA; // 160x120 fallback
    c.jpeg_quality = 25;
    c.fb_count     = 1;
    c.fb_location  = CAMERA_FB_IN_DRAM;
  }

  esp_err_t err = esp_camera_init(&c);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed: 0x%x\n", err);
    return false;
  }

  sensor_t * s = esp_camera_sensor_get();
  if (s) {
    s->set_exposure_ctrl(s, 1);
    s->set_gain_ctrl(s, 1);
    s->set_brightness(s, 0);
    s->set_contrast(s, 0);
    s->set_saturation(s, 0);
    s->set_vflip(s, 0);
    s->set_hmirror(s, 0);
    s->set_dcw(s, 1);
  }
  return true;
}

// ===== Envio de frame como NDJSON base64 =====
void sendFrameBase64() {
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) return;

  // Base64 tamanho ~ 4/3 do JPEG
  size_t outLen = 4 * ((fb->len + 2) / 3) + 4;
  uint8_t* b64 = (uint8_t*)malloc(outLen);
  if (!b64) {
    esp_camera_fb_return(fb);
    return;
  }

  size_t olen = 0;
  int rc = mbedtls_base64_encode(b64, outLen, &olen, fb->buf, fb->len);
  esp_camera_fb_return(fb);
  if (rc != 0) { free(b64); return; }

  // Monta JSON por partes para n√£o estourar buffer interno do BT
  writeJsonLine(String("{\"evt\":\"frame\",\"fmt\":\"jpeg\",\"b64\":\"BEGIN\"}"));
  // envia o base64 em blocos
  const size_t CHUNK = 1000;
  for (size_t i = 0; i < olen; i += CHUNK) {
    size_t n = (i + CHUNK <= olen) ? CHUNK : (olen - i);
    SerialBT.write((const uint8_t*)"{\"chunk\":\"", 10);
    SerialBT.write((const uint8_t*)(b64 + i), n);
    SerialBT.write((const uint8_t*)"\"}\n", 3);
  }
  writeJsonLine(String("{\"evt\":\"frame\",\"b64\":\"END\"}"));
  free(b64);
}

// ===== Parser de comandos "CMD:..." por linha =====
void handleCmd(const String& line) {
  // Formatos aceitos:
  // CMD:MODE:auto
  // CMD:STREAM:1
  // CMD:JOY:x,y
  // CMD:PUMP:1
  // CMD:LED:1
  // CMD:TF:1
  if (!line.startsWith("CMD:")) return;
  int p1 = line.indexOf(':', 4);
  if (p1 < 0) return;
  String key = line.substring(4, p1);
  String val = line.substring(p1 + 1);
  val.trim();

  if (key == "MODE") {
    if (val == "manual" || val == "auto" || val == "patrol") {
      g_mode = val;
      writeJsonLine(String("{\"evt\":\"mode\",\"v\":\"") + g_mode + "\"}");
    }
  } else if (key == "STREAM") {
    g_streamOn = (val == "1" || val == "true");
    writeJsonLine(String("{\"evt\":\"stream\",\"on\":") + (g_streamOn?"true":"false") + "}");
  } else if (key == "LED") {
    g_ledOn = (val == "1" || val == "true");
    digitalWrite(LED_IND_PIN, g_ledOn ? HIGH : LOW);
    writeJsonLine(String("{\"evt\":\"led\",\"on\":") + (g_ledOn?"true":"false") + "}");
  } else if (key == "PUMP") {
    g_pumpOn = (val == "1" || val == "true");
    digitalWrite(PUMP_PIN, g_pumpOn ? HIGH : LOW);
    writeJsonLine(String("{\"evt\":\"pump\",\"on\":") + (g_pumpOn?"true":"false") + "}");
  } else if (key == "TF") {
    g_tfOn = (val == "1" || val == "true");
    writeJsonLine(String("{\"evt\":\"tf\",\"on\":") + (g_tfOn?"true":"false") + "}");
  } else if (key == "JOY") {
    int c = val.indexOf(',');
    if (c > 0) {
      g_joyX = val.substring(0, c).toFloat();
      g_joyY = val.substring(c + 1).toFloat();
      // eco simples
      char buf[96];
      snprintf(buf, sizeof(buf), "{\"evt\":\"joy\",\"x\":%.3f,\"y\":%.3f}", g_joyX, g_joyY);
      writeJsonLine(String(buf));
    }
  }
}

// ===== Setup/Loop =====
void setup() {
  Serial.begin(115200);
  pinMode(LED_IND_PIN, OUTPUT);
  pinMode(PUMP_PIN, OUTPUT);
  digitalWrite(LED_IND_PIN, LOW);
  digitalWrite(PUMP_PIN, LOW);

  if (!initCamera()) {
    Serial.println("Falha camera");
    delay(3000);
    ESP.restart();
  }

  // Bluetooth
  if (!SerialBT.begin("HYDROBOT")) {
    Serial.println("BT falhou");
    while (1) delay(1000);
  }
  Serial.println("BT pronto: HYDROBOT");

  // Status inicial
  writeJsonLine(String("{\"evt\":\"status\",\"ts\":") + isoTsUptime() +
                ",\"mode\":\"" + g_mode + "\",\"stream\":" + (g_streamOn?"true":"false") + "}");
}

void loop() {
  // Leitura de comandos por linha
  static String acc;
  while (SerialBT.available()) {
    char ch = (char)SerialBT.read();
    if (ch == '\n' || ch == '\r') {
      if (acc.length() > 0) { handleCmd(acc); acc = ""; }
    } else {
      if (acc.length() < 200) acc += ch; // evita linhas absurdas
    }
  }

  // Envio peri√≥dico de frame
  uint32_t now = millis();
  if (g_streamOn && now - lastFrameMs >= frameIntervalMs && SerialBT.hasClient()) {
    lastFrameMs = now;
    sendFrameBase64();
  }

  // Status ping a cada ~3s
  static uint32_t lastPing = 0;
  if (now - lastPing > 3000) {
    lastPing = now;
    writeJsonLine(String("{\"evt\":\"status\",\"ts\":") + isoTsUptime() +
      ",\"mode\":\"" + g_mode + "\",\"led\":" + (g_ledOn?"true":"false") +
      ",\"pump\":" + (g_pumpOn?"true":"false") + ",\"tf\":" + (g_tfOn?"true":"false") + "}");
  }
}





Fia√ß√£o:




LED indicador: GPIO33 ‚Üí resistor 220Œ© ‚Üí LED ‚Üí GND.


Bomba (MOSFET): GPIO32 ‚Üí gate (MOSFET logic-level) + resist√™ncia 100k pull-down gate-GND; n√£o alimente bomba pelo 3V3 da placa.







B) App React Native (Expo Dev Build, TS) ‚Äî Bluetooth + v√≠deo + controles


1) Projeto e depend√™ncias


npx create-expo-app hydrobot-bt -t expo-template-blank-typescript
cd hydrobot-bt

# Bluetooth Cl√°ssico:
yarn add react-native-bluetooth-serial-next
# se usar npm: npm i react-native-bluetooth-serial-next

# Pr√©-build (cria projeto nativo)
npx expo prebuild

# Android: habilite BLUETOOTH perms automaticamente pelo pacote.
# Gere Dev Build:
eas build:configure
eas build --profile development --platform android
# Instale o .apk de dev no aparelho e abra o app com ele (n√£o Expo Go).





Se preferir bare, rode npx react-native run-android.




2) Servi√ßo de Bluetooth ‚Äî src/services/bluetooth.ts


// src/services/bluetooth.ts
import BluetoothSerial from 'react-native-bluetooth-serial-next';
import { NativeEventEmitter } from 'react-native';

type Listener = (msg: any) => void;

let connectedId: string | null = null;
let lineBuffer = '';

const listeners = new Set<Listener>();

export async function ensureEnabled() {
  const ok = await BluetoothSerial.isEnabled();
  if (!ok) await BluetoothSerial.requestEnable();
}

export async function listDevices() {
  const bonded = await BluetoothSerial.list();
  return bonded; // [{id,name,address},...]
}

export async function connectByName(name: string) {
  const devs = await listDevices();
  const dev = devs.find(d => (d.name || '').includes(name));
  if (!dev) throw new Error(`Dispositivo '${name}' n√£o pareado`);
  await BluetoothSerial.connect(dev.id);
  connectedId = dev.id;
  // ler dados cont√≠nuos
  BluetoothSerial.withDelimiter('\n'); // separa por \n
  BluetoothSerial.on('read', ({ data }) => {
    // cada 'data' √© uma linha (string)
    try {
      const obj = JSON.parse(data);
      for (const cb of listeners) cb(obj);
    } catch {
      // pode chegar chunks do frame ({"chunk":"..."}), ainda √© JSON
      try {
        const o2 = JSON.parse(data);
        for (const cb of listeners) cb(o2);
      } catch {}
    }
  });
}

export function onMsg(cb: Listener) { listeners.add(cb); return () => listeners.delete(cb); }

async function send(line: string) {
  if (!connectedId) throw new Error('BT n√£o conectado');
  await BluetoothSerial.write(line + '\n');
}

// === Comandos ===
export async function setMode(v: 'manual'|'auto'|'patrol') {
  await send(`CMD:MODE:${v}`);
}
export async function setStream(on: boolean) {
  await send(`CMD:STREAM:${on ? 1 : 0}`);
}
export async function setLED(on: boolean) {
  await send(`CMD:LED:${on ? 1 : 0}`);
}
export async function setPump(on: boolean) {
  await send(`CMD:PUMP:${on ? 1 : 0}`);
}
export async function setTF(on: boolean) {
  await send(`CMD:TF:${on ? 1 : 0}`);
}
export async function sendJoy(x: number, y: number) {
  const nx = Math.max(-1, Math.min(1, x));
  const ny = Math.max(-1, Math.min(1, y));
  await send(`CMD:JOY:${nx.toFixed(3)},${ny.toFixed(3)}`);
}



3) Componente de Joystick ‚Äî src/components/Joystick.tsx


// src/components/Joystick.tsx
import React, { useMemo, useState } from 'react';
import { View, PanResponder } from 'react-native';

export default function Joystick({ onMove }:{ onMove:(x:number,y:number)=>void }) {
  const size = 160, knob = 64;
  const r = size/2, rk = knob/2;
  const [p,setP] = useState({x:0,y:0});
  const pan = useMemo(()=>PanResponder.create({
    onStartShouldSetPanResponder:()=>true,
    onPanResponderMove:(_,g)=>{
      const lim = r - rk;
      let x = g.dx, y = g.dy;
      const mag = Math.hypot(x,y);
      if (mag > lim) { const k = lim/mag; x*=k; y*=k; }
      setP({x,y});
      onMove(x/lim, -y/lim);
    },
    onPanResponderRelease:()=>{
      setP({x:0,y:0});
      onMove(0,0);
    }
  }),[]);
  return (
    <View {...pan.panHandlers} style={{
      width:size,height:size,borderRadius:r,backgroundColor:'#101827',
      borderWidth:1,borderColor:'#223',justifyContent:'center',alignItems:'center'
    }}>
      <View style={{
        position:'absolute',width:knob,height:knob,borderRadius:rk,backgroundColor:'#4f7cff',
        transform:[{translateX:p.x},{translateY:p.y}]
      }}/>
    </View>
  );
}



4) Montagem da tela ‚Äî App.tsx


// App.tsx
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { SafeAreaView, View, Text, TouchableOpacity, TextInput, Image, ScrollView, Alert } from 'react-native';
import Joystick from './src/components/Joystick';
import { ensureEnabled, connectByName, onMsg, setMode, setLED, setPump, setStream, setTF, sendJoy } from './src/services/bluetooth';

type FrameState = { collecting:boolean, chunks:string[], last:string };

export default function App() {
  const [btName,setBtName] = useState('HYDROBOT');
  const [status,setStatus] = useState<any>({});
  const [imgB64,setImgB64] = useState<string>('');
  const [useServer,setUseServer] = useState(false); // fonte do v√≠deo: false=ESP direto; true=servidor
  const [tfOn,setTfOn] = useState(false);

  useEffect(()=>{ (async()=>{
    try {
      await ensureEnabled();
      await connectByName(btName);
      const off = onMsg((msg)=>{
        // Protocolo:
        // {evt:"frame", b64:"BEGIN"} / {chunk:"..."} / {evt:"frame", b64:"END"}
        // {evt:"status"...} etc.
        if (msg.evt === 'status' || msg.evt === 'mode' || msg.evt === 'led' || msg.evt === 'pump' || msg.evt === 'tf') {
          setStatus((s:any)=>({ ...s, ...msg }));
        } else if (msg.evt === 'frame' && msg.b64 === 'BEGIN') {
          frame.current = { collecting:true, chunks:[], last:'' };
        } else if (msg.evt === 'frame' && msg.b64 === 'END') {
          const b64 = frame.current.chunks.join('');
          setImgB64(b64);
          frame.current = { collecting:false, chunks:[], last:'' };
        } else if (typeof msg.chunk === 'string') {
          if (frame.current.collecting) frame.current.chunks.push(msg.chunk);
        }
      });
      return ()=>off();
    } catch (e:any) {
      Alert.alert('BT', e.message || String(e));
    }
  })(); }, []);

  const frame = useRef<FrameState>({ collecting:false, chunks:[], last:'' });

  async function toggleLED(){ await setLED(!(status.led)); }
  async function togglePump(){ await setPump(!(status.pump)); }
  async function toggleStream(){ await setStream(!(status.stream)); }
  async function switchMode(m:'manual'|'auto'|'patrol'){ await setMode(m); }
  async function toggleTF(){
    const next = !tfOn; setTfOn(next);
    await setTF(next);
    // Quando usar servidor, o TF real roda l√°; no app apenas espelhamos estado.
  }

  const videoView = useMemo(()=>{
    if (useServer) {
      return (
        <View style={{height:220, borderRadius:10, backgroundColor:'#000', alignItems:'center', justifyContent:'center'}}>
          <Text style={{color:'#fff', opacity:0.7}}>V√≠deo via Servidor (TF)</Text>
          {/* Em pr√≥xima etapa, conectamos ao WS ws://servidor:4000 para receber frames processados */}
        </View>
      );
    }
    return (
      <View style={{height:220, borderRadius:10, backgroundColor:'#000', overflow:'hidden', alignItems:'center', justifyContent:'center'}}>
        {imgB64 ? (
          <Image source={{ uri: 'data:image/jpeg;base64,' + imgB64 }} style={{ width:'100%', height:'100%', resizeMode:'contain' }}/>
        ) : (
          <Text style={{color:'#fff', opacity:0.7}}>Sem frame ainda‚Ä¶</Text>
        )}
      </View>
    );
  },[useServer, imgB64]);

  return (
    <SafeAreaView style={{flex:1, backgroundColor:'#0b1220'}}>
      <ScrollView contentContainerStyle={{padding:16, gap:12}}>
        <Text style={{color:'#fff', fontSize:20, fontWeight:'700'}}>HydroBot ‚Äî Bluetooth</Text>

        <View style={{flexDirection:'row', gap:8}}>
          <TextInput value={btName} onChangeText={setBtName}
            placeholder="Nome BT (pareado) ‚Äî HYDROBOT" placeholderTextColor="#789"
            style={{flex:1, backgroundColor:'#111a2e', color:'#fff', padding:10, borderRadius:8}} />
        </View>

        {videoView}

        <View style={{flexDirection:'row', gap:8, flexWrap:'wrap'}}>
          <TouchableOpacity onPress={toggleLED} style={{backgroundColor:'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>LED {status.led ? 'ON' : 'OFF'}</Text></TouchableOpacity>
          <TouchableOpacity onPress={togglePump} style={{backgroundColor:'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>Bomba {status.pump ? 'ON' : 'OFF'}</Text></TouchableOpacity>
          <TouchableOpacity onPress={()=>switchMode('manual')} style={{backgroundColor: (status.mode==='manual')?'#3a6df0':'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>Manual</Text></TouchableOpacity>
          <TouchableOpacity onPress={()=>switchMode('auto')} style={{backgroundColor: (status.mode==='auto')?'#3a6df0':'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>Auto</Text></TouchableOpacity>
          <TouchableOpacity onPress={()=>switchMode('patrol')} style={{backgroundColor: (status.mode==='patrol')?'#3a6df0':'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>Patrol</Text></TouchableOpacity>
          <TouchableOpacity onPress={toggleStream} style={{backgroundColor:'#2e374f', padding:10, borderRadius:8}}><Text style={{color:'#fff'}}>Stream {status.stream ? 'ON':'OFF'}</Text></TouchableOpacity>
          <TouchableOpacity onPress={toggleTF} style={{backgroundColor: tfOn ? '#22c55e' : '#2e374f', padding:10, borderRadius:8}}>
            <Text style={{color:'#fff'}}>TensorFlow {tfOn ? 'ON' : 'OFF'}</Text>
          </TouchableOpacity>
          <TouchableOpacity onPress={()=>setUseServer(!useServer)} style={{backgroundColor: useServer ? '#22c55e' : '#2e374f', padding:10, borderRadius:8}}>
            <Text style={{color:'#fff'}}>Fonte: {useServer ? 'Servidor (TF)' : 'ESP direto'}</Text>
          </TouchableOpacity>
        </View>

        <View style={{alignItems:'center', marginTop:6}}>
          <Joystick onMove={(x,y)=>{ sendJoy(x,y).catch(()=>{}); }} />
          <Text style={{color:'#8cb', marginTop:6}}>Arraste para enviar JOY (x,y)</Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}





O app acima envia/recebe tudo por Bluetooth e mostra v√≠deo direto da ESP (sem navegador).

Quando voc√™ alternar para ‚ÄúServidor (TF)‚Äù, o painel de v√≠deo j√° troca (na pr√≥xima se√ß√£o ligamos o servidor com TF + WebSocket).





C) Servidor intermedi√°rio (Node.js) ‚Äî Bluetooth ‚Üî TF ‚Üî App (WebSocket)


Objetivo: rodar TensorFlow fora da ESP e automatizar ‚Äúdetectar fogo ‚áí aciona bomba + ir at√© o fogo‚Äù.


Aqui deixo um servidor funcional que:




Conecta ao Bluetooth SPP da ESP (nome HYDROBOT).


Recebe NDJSON (frames em base64).


(Stub TF) Faz detec√ß√£o simplificada (lugar do TF real) e envia evento por WebSocket.


Repassa comandos de autonomia para a ESP (ex.: liga bomba quando ‚Äúfogo‚Äù detectado).




server/
  package.json
  index.js



server/package.json


{
  "name": "hydrobot-server",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "bluetooth-serial-port": "^2.2.8",
    "ws": "^8.18.0",
    "jimp": "^0.22.12"
  }
}



server/index.js


import { BluetoothSerialPort } from 'bluetooth-serial-port';
import { WebSocketServer } from 'ws';
import Jimp from 'jimp';

const DEV_NAME = process.env.ESP_NAME || 'HYDROBOT';

const bt = new BluetoothSerialPort();
let btChannelOpen = false;

const wss = new WebSocketServer({ port: 4000 });
const clients = new Set();

wss.on('connection', ws => {
  clients.add(ws);
  ws.on('close', ()=>clients.delete(ws));
});

function broadcast(obj) {
  const s = JSON.stringify(obj);
  for (const ws of clients) {
    try { ws.send(s); } catch {}
  }
}

function findAndConnect() {
  bt.inquire();
  bt.on('found', function(address, name) {
    if (!name) return;
    if (name.includes(DEV_NAME)) {
      bt.findSerialPortChannel(address, channel => {
        bt.connect(address, channel, () => {
          console.log('BT conectado a', name, address, 'ch', channel);
          btChannelOpen = true;

          // peca stream
          writeLine('CMD:STREAM:1');

          let acc = '';
          bt.on('data', (buf) => {
            acc += buf.toString('utf8');
            let i;
            while ((i = acc.indexOf('\n')) >= 0) {
              const line = acc.slice(0, i).trim();
              acc = acc.slice(i + 1);
              if (!line) continue;
              handleLine(line);
            }
          });

        }, () => console.log('Falha BT connect'));
      }, () => console.log('Sem canal SPP'));
    }
  });
}

function writeLine(s) {
  if (!btChannelOpen) return;
  bt.write(Buffer.from(s + '\n', 'utf8'), (err) => {
    if (err) console.log('BT write err', err);
  });
}

// Coleta de frame (BEGIN/chunks/END) vinda da ESP
const frameCollector = { collecting:false, parts:[] };

async function handleLine(line) {
  try {
    const obj = JSON.parse(line);
    if (obj.evt === 'frame' && obj.b64 === 'BEGIN') {
      frameCollector.collecting = true;
      frameCollector.parts = [];
    } else if (obj.evt === 'frame' && obj.b64 === 'END') {
      const b64 = frameCollector.parts.join('');
      frameCollector.collecting = false;
      frameCollector.parts = [];
      broadcast({ evt:'frame', b64 });

      // === STUB de detec√ß√£o (substitua por TF real) ===
      try {
        const img = await Jimp.read(Buffer.from(b64, 'base64'));
        // regra boba: pixel "vermelho forte" acima de limiar
        let redCount = 0, tot = img.bitmap.width * img.bitmap.height;
        img.scan(0,0,img.bitmap.width,img.bitmap.height,function(x,y,idx){
          const r=this.bitmap.data[idx], g=this.bitmap.data[idx+1], b=this.bitmap.data[idx+2];
          if (r > 200 && g < 120 && b < 120) redCount++;
        });
        const ratio = redCount / tot;
        const fire = ratio > 0.08; // limiar experimental
        broadcast({ evt:'detect', fire, ratio });

        if (fire) {
          writeLine('CMD:PUMP:1');        // liga bomba
          writeLine('CMD:MODE:auto');     // sinaliza modo auto (voc√™ pode usar para acionar locomo√ß√£o)
          // Pr√≥ximo passo: calcular dire√ß√£o do ‚Äúcentro vermelho‚Äù e mandar JOY para perseguir.
        }
      } catch (e) {}
    } else if (typeof obj.chunk === 'string') {
      if (frameCollector.collecting) frameCollector.parts.push(obj.chunk);
    } else {
      broadcast(obj); // status/mode/led/pump/tf/joy‚Ä¶
    }
  } catch {}
}

findAndConnect();
console.log('WS em ws://localhost:4000  (broadcast frames/detections)')





Pr√≥xima etapa para TF real: trocar o bloco Jimp pelo @tensorflow/tfjs-node + modelo de ‚Äúfire detection‚Äù (classifica√ß√£o em recortes ou detec√ß√£o com YOLO-lite). A estrutura acima j√° envia {evt:'detect', fire, ratio} para o app e comanda a ESP (bomba + modo) ao detectar.





D) App ‚Äî recebendo do servidor (quando ‚ÄúServidor (TF)‚Äù estiver ativo)


No App.tsx, quando useServer === true, voc√™ pode abrir um WebSocket e substituir imgB64/eventos pelos do servidor:


// adicione no App.tsx
useEffect(()=>{
  if (!useServer) return;
  const ws = new WebSocket('ws://<IP_DO_NOTEBOOK>:4000');
  ws.onmessage = (e)=>{
    try{
      const msg = JSON.parse(e.data);
      if (msg.evt === 'frame' && msg.b64) setImgB64(msg.b64);
      if (msg.evt === 'detect') {
        // pode mostrar um badge ‚Äúüî•‚Äù
      }
    }catch{}
  };
  return ()=>{ try{ws.close();}catch{} }
}, [useServer]);





Assim voc√™ alterna: ESP direto (Bluetooth) ou Servidor (TF) por um bot√£o ‚Äî como voc√™ pediu.





E) Passo a passo (resumo execut√°vel)






Grave a ESP32-CAM com HydroBotBT.ino.




LED indicador ‚Üí GPIO33 (externo).


MOSFET bomba ‚Üí GPIO32.


Pareie a ESP no Android (nome HYDROBOT).








App (Expo Dev Build)




Instale depend√™ncias, expo prebuild, gere Dev Build e instale o .apk.


Abra o app, BT ligado, nome HYDROBOT, aguarde status ‚Üí v√≠deo surgir√° (1‚Äì2 fps).








Servidor (opcional p/ TF)




cd server && npm i && node index.js


No app, ative ‚ÄúServidor (TF)‚Äù para receber frames do WS.


(Hoje est√° com detec√ß√£o stub via ‚Äúvermelho‚Äù e comanda PUMP + MODE:auto automaticamente.)









F) Pr√≥ximos incrementos (quando voc√™ quiser)




Auto-drive real: no servidor, calcule o centro do fogo (momento vermelho) e envie CMD:JOY:x,y para perseguir ‚Äî j√° est√° tudo encadeado.


TF real: trocar o stub por modelo TFJS/Node (ex.: MobileNet+SVM ou YOLO-tiny).


Seguran√ßa el√©trica: diodo flyback na bomba, fonte 5V/2A, GND comum.


iOS: usar Wi-Fi ou BLE GATT (com streaming reduzido) ‚Äî podemos te dar uma varia√ß√£o.





Se quiser, eu j√° acoplo a l√≥gica de persegui√ß√£o (c√°lculo de vetor JOY a partir do centro detectado) e deixo curva exponencial/limiar para o joystick, al√©m de debounce da bomba (s√≥ ligar por 2‚Äì3s e pausar).




















perfeito ‚Äî seu firmware exp√µe GET /pump?on=1|0. Vou adicionar um bot√£o Bomba ON/OFF na mesma barra da c√¢mera, espelhando o estado que vem de /status.


Substitua src/screens/CameraScreen.tsx pelo c√≥digo abaixo (mudan√ßas: estado pumpOn, url pumpUrl, leitura em pingStatus(), bot√£o togglePump()):


import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  ActivityIndicator,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
} from "react-native";
import { WebView } from "react-native-webview";

const DEFAULT_IP = "192.168.4.1"; // IP padr√£o do AP do ESP32-CAM

export default function CameraScreen() {
  const [ip, setIp] = useState(DEFAULT_IP);
  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");

  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // Joystick state (UI por enquanto)
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const webref = useRef<WebView>(null);

  const streamUrl = useMemo(() => `http://${ip}:81/stream`, [ip]);
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl   = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl  = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl, { method: "GET" });
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }

  async function toggleLed() {
    try {
      const target = !ledOn;
      await fetch(ledUrl(target));
      setLedOn(target);
      setStatusText((s) => `LED ${target ? "ligado" : "desligado"} ‚Ä¢ ` + s.replace(/^LED .* ‚Ä¢ /, ""));
    } catch {
      setStatusText("Erro ao alternar LED.");
    }
  }

  async function togglePump() {
    try {
      const target = !pumpOn;
      await fetch(pumpUrl(target));
      setPumpOn(target);
      setStatusText((s) => `Bomba ${target ? "ligada" : "desligada"} ‚Ä¢ ` + s.replace(/^Bomba .* ‚Ä¢ /, ""));
    } catch {
      setStatusText("Erro ao alternar bomba.");
    }
  }

  useEffect(() => {
    pingStatus();
    const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // HTML simples p/ MJPEG
  const html = `
    <html>
      <head><meta name="viewport" content="width=device-width, initial-scale=1" /></head>
      <body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;height:100vh;">
        <img src="${streamUrl}" style="width:100%;height:100%;object-fit:contain;" />
      </body>
    </html>
  `;

  // ===== Joystick (UI) =====
  const RADIUS = 64;
  const KNOB_R = 22;

  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS;
        let ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny);
        if (len > 1) { nx /= len; ny /= len; }
        setJoy({ x: nx, y: -ny }); // y para cima positivo
      },
      onPanResponderRelease: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
      onPanResponderTerminate: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
    })
  ).current;

  const knobLeft = joy.x * RADIUS;
  const knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Barra de controle */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="192.168.4.1"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
          keyboardType="numeric"
        />
        <Pressable onPress={pingStatus} style={styles.btn}>
          <Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text>
        </Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text>
        </Pressable>

        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text>
        </Pressable>
      </View>

      {/* Status */}
      <View style={styles.statusRow}>
        {isChecking ? <ActivityIndicator /> : null}
        <Text numberOfLines={2} style={styles.status}>{statusText}</Text>
        <Pressable onPress={() => webref.current?.reload()} style={[styles.btn, { marginLeft: 8 }]}>
          <Text style={styles.btnText}>Recarregar</Text>
        </Pressable>
      </View>

      {/* V√≠deo MJPEG */}
      <WebView
        ref={webref}
        originWhitelist={["*"]}
        source={{ html }}
        style={styles.web}
        allowFileAccess
        allowingReadAccessToURL={"*"}
        javaScriptEnabled
        domStorageEnabled
        allowUniversalAccessFromFileURLs
        allowsInlineMediaPlayback
        mediaPlaybackRequiresUserAction={false}
      />

      {/* Joystick overlay (UI apenas) */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View
          style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]}
          {...pan.panHandlers}
        >
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View
            style={[
              styles.joyKnob,
              {
                width: KNOB_R * 2,
                height: KNOB_R * 2,
                borderRadius: KNOB_R,
                transform: [{ translateX: knobLeft }, { translateY: knobTop }],
                opacity: dragging ? 1 : 0.9,
              },
            ]}
          />
          <Text style={styles.joyText}>
            x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#0b1220" },
  topbar: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
    backgroundColor: "#111a33",
  },
  label: { color: "#9fb3ff", fontSize: 12 },
  input: {
    flex: 1,
    backgroundColor: "#0b1220",
    color: "white",
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "#1e2a4d",
  },
  btn: {
    backgroundColor: "#2b48ff",
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderRadius: 10,
  },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },
  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    gap: 8,
    backgroundColor: "#0f1730",
  },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },
  web: { flex: 1, backgroundColor: "black" },

  // Joystick
  joyWrap: {
    position: "absolute",
    bottom: 24,
    left: 24,
    alignItems: "center",
    justifyContent: "center",
  },
  joyBase: {
    position: "absolute",
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.14)",
  },
  joyKnob: {
    position: "absolute",
    backgroundColor: "rgba(43,72,255,0.9)",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.85)",
  },
  joyText: {
    position: "absolute",
    bottom: -22,
    color: "#cbd5ff",
    fontSize: 12,
  },
});



Pronto ‚Äî o bot√£o BOMBA ON/OFF usa a rota /pump do seu ESP e mant√©m o estado sincronizado quando o /status √© consultado.

Se quiser, no pr√≥ximo passo adiciono um controle PWM (slider para /pump_pwm?duty=0..255).

















perfeito ‚Äî vamos deixar o index/Home bonito e adicionar um rodap√© com abas (Home, C√¢mera, Dashboard, Settings).

A navega√ß√£o passa a usar Bottom Tabs do @react-navigation.



1) App.tsx (tabs + tema escuro)


Substitua o arquivo inteiro:


import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";
import DashboardScreen from "./src/screens/DashboardScreen";
import SettingsScreen from "./src/screens/SettingsScreen";

export type TabParamList = {
  Home: undefined;
  Camera: undefined;
  Dashboard: undefined;
  Settings: undefined;
};

const Tab = createBottomTabNavigator<TabParamList>();

// Tema dark do app
const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: "#0b1220",
    primary: "#2b48ff",
    card: "#111a33",
    text: "#e5e7ff",
    border: "#1e2a4d",
    notification: "#2b48ff",
  },
};

export default function App() {
  return (
    <NavigationContainer theme={DarkThemeHB}>
      <Tab.Navigator
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: "#111a33" },
          headerTintColor: "#fff",
          tabBarStyle: { backgroundColor: "#0f1730", borderTopColor: "#0f1730" },
          tabBarActiveTintColor: "#2b48ff",
          tabBarInactiveTintColor: "#8aa0ff",
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} options={{ title: "In√≠cio" }} />
        <Tab.Screen name="Camera" component={CameraScreen} options={{ title: "C√¢mera" }} />
        <Tab.Screen name="Dashboard" component={DashboardScreen} options={{ title: "Dashboard" }} />
        <Tab.Screen name="Settings" component={SettingsScreen} options={{ title: "Ajustes" }} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}




2) src/screens/HomeScreen.tsx (hero + CTA)


Substitua o arquivo para um layout ‚Äúhero card‚Äù com seu logo e bot√£o para abrir a C√¢mera (troca para a aba Camera):


import { View, Text, StyleSheet, Image, Pressable } from "react-native";
import { useNavigation } from "@react-navigation/native";
import type { TabParamList } from "../../App";
import type { BottomTabNavigationProp } from "@react-navigation/bottom-tabs";

type Nav = BottomTabNavigationProp<TabParamList>;

export default function HomeScreen() {
  const navigation = useNavigation<Nav>();

  return (
    <View style={styles.container}>
      <View style={styles.card}>
        <Image
          source={require("../../assets/logo.png")} // salve sua imagem como assets/logo.png
          style={styles.logo}
          resizeMode="contain"
        />
        <Text style={styles.title}>HydroBotApp2</Text>
        <Text style={styles.subtitle}>Controle o rob√¥ ‚Ä¢ V√≠deo ‚Ä¢ Bomba ‚Ä¢ LED</Text>

        <Pressable
          onPress={() => navigation.navigate("Camera")}
          style={({ pressed }) => [styles.cta, pressed && { opacity: 0.9 }]}
        >
          <Text style={styles.ctaText}>Abrir C√¢mera</Text>
        </Pressable>

        <View style={styles.linksRow}>
          <View style={styles.pill}><Text style={styles.pillText}>Dashboard</Text></View>
          <View style={styles.pill}><Text style={styles.pillText}>Ajustes</Text></View>
        </View>
      </View>

      <Text style={styles.footerHint}>Use as abas no rodap√© para navegar</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#0b1220", alignItems: "center", justifyContent: "center", padding: 20 },
  card: {
    width: "100%",
    backgroundColor: "#111a33",
    borderRadius: 20,
    padding: 20,
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#1e2a4d",
  },
  logo: { width: 140, height: 140, marginBottom: 12 },
  title: { color: "white", fontSize: 24, fontWeight: "800" },
  subtitle: { color: "#9fb3ff", fontSize: 14, marginTop: 4, textAlign: "center" },
  cta: {
    marginTop: 16,
    backgroundColor: "#2b48ff",
    borderRadius: 12,
    paddingVertical: 12,
    paddingHorizontal: 22,
    shadowColor: "#2b48ff",
    shadowOpacity: 0.25,
    shadowRadius: 8,
    elevation: 4,
  },
  ctaText: { color: "white", fontWeight: "700", fontSize: 16 },
  linksRow: { flexDirection: "row", gap: 8, marginTop: 16 },
  pill: { backgroundColor: "#0b1220", borderColor: "#1e2a4d", borderWidth: 1, paddingVertical: 6, paddingHorizontal: 10, borderRadius: 999 },
  pillText: { color: "#cbd5ff", fontSize: 12 },
  footerHint: { color: "#8aa0ff", marginTop: 14, fontSize: 12 },
});





Coloque a imagem que voc√™ enviou como assets/logo.png (PNG com fundo transparente fica top).





3) Novas telas ‚Äúplaceholder‚Äù


src/screens/DashboardScreen.tsx


import { View, Text, StyleSheet } from "react-native";

export default function DashboardScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Dashboard</Text>
      <Text style={styles.sub}>Aqui vir√£o telemetria, gr√°ficos e logs.</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#0b1220", alignItems: "center", justifyContent: "center" },
  title: { color: "white", fontSize: 22, fontWeight: "700" },
  sub: { color: "#9fb3ff", marginTop: 6 },
});



src/screens/SettingsScreen.tsx


import { View, Text, StyleSheet } from "react-native";

export default function SettingsScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Ajustes</Text>
      <Text style={styles.sub}>Prefer√™ncias do app e conex√µes.</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#0b1220", alignItems: "center", justifyContent: "center" },
  title: { color: "white", fontSize: 22, fontWeight: "700" },
  sub: { color: "#9fb3ff", marginTop: 6 },
});





Sua CameraScreen.tsx permanece como fizemos (com LED, Bomba e Joystick UI). Ela j√° aparece como aba ‚ÄúC√¢mera‚Äù.





4) √çcones


@expo/vector-icons j√° vem com Expo; n√£o precisa instalar nada extra.



Pronto! Voc√™ ter√°:




Home com hero + bot√£o ‚ÄúAbrir C√¢mera‚Äù


Rodap√© com abas: Home, C√¢mera, Dashboard, Settings


Tema dark consistente com seu logo HB üî•üíß




Se quiser, eu adiciono um badge na aba C√¢mera quando a conex√£o com o ESP32 falhar/sucesso, ou coloco labels grandes no tab bar.


























perfeito üëå vamos deixar a tela inicial (Home) como um menu em grade com bot√µes quadrados grandes, cada um levando para a aba correspondente. Os √≠cones v√£o usar Ionicons (j√° vem com Expo).



src/screens/HomeScreen.tsx (nova vers√£o)


import { View, Text, StyleSheet, Pressable, Dimensions } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { TabParamList } from "../../App";
import type { BottomTabNavigationProp } from "@react-navigation/bottom-tabs";

type Nav = BottomTabNavigationProp<TabParamList>;

const size = Dimensions.get("window").width / 2 - 32; // 2 colunas com espa√ßamento

export default function HomeScreen() {
  const navigation = useNavigation<Nav>();

  const items = [
    { name: "Camera" as keyof TabParamList, label: "C√¢mera", icon: "videocam" as const, color: "#2b48ff" },
    { name: "Dashboard" as keyof TabParamList, label: "Dashboard", icon: "pulse" as const, color: "#17a34a" },
    { name: "Settings" as keyof TabParamList, label: "Ajustes", icon: "settings" as const, color: "#eab308" },
  ];

  return (
    <View style={styles.container}>
      <Text style={styles.title}>HydroBotApp2</Text>
      <View style={styles.grid}>
        {items.map((item) => (
          <Pressable
            key={item.name}
            onPress={() => navigation.navigate(item.name)}
            style={({ pressed }) => [
              styles.card,
              { width: size, height: size, backgroundColor: item.color },
              pressed && { opacity: 0.85 },
            ]}
          >
            <Ionicons name={item.icon} size={42} color="white" />
            <Text style={styles.cardText}>{item.label}</Text>
          </Pressable>
        ))}
      </View>
      <Text style={styles.footerHint}>ou use o rodap√© abaixo para navegar</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#0b1220", padding: 20 },
  title: { color: "white", fontSize: 24, fontWeight: "800", marginBottom: 20, textAlign: "center" },
  grid: { flexDirection: "row", flexWrap: "wrap", justifyContent: "space-between" },
  card: {
    borderRadius: 16,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 20,
    shadowColor: "#000",
    shadowOpacity: 0.3,
    shadowRadius: 6,
    elevation: 5,
  },
  cardText: { color: "white", marginTop: 10, fontWeight: "600", fontSize: 16 },
  footerHint: { textAlign: "center", color: "#8aa0ff", marginTop: 10, fontSize: 12 },
});




Como fica




T√≠tulo em cima: HydroBotApp2


Grade de bot√µes quadrados grandes (2 colunas):



üìπ C√¢mera (azul)


üìä Dashboard (verde)


‚öôÔ∏è Ajustes (amarelo)






Rodap√© ainda existe (tabs) para navega√ß√£o alternativa.





quer que eu j√° adicione tamb√©m o bot√£o da Home (üè†) nesse grid, ou prefere deixar Home s√≥ como hub de acesso √†s outras telas?





























perfeito! vamos alinhar tudo √† paleta do logo (preto #000, vermelho bombeiro, branco gelo).

Vou te passar:




pequenas mudan√ßas no tema (App.tsx)


HomeScreen redesenhada com dois bot√µes quadrados grandes (C√¢mera e Dashboard) + logo no topo






Coloque a imagem do logo como assets/logo.png (use a que voc√™ enviou).





1) Tema no App.tsx (ajuste de cores)


Substitua apenas o bloco do tema e op√ß√µes do Tab:


// ...
const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",   // vermelho do logo
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
  textSoft: "#E6E6E6",
};

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

export default function App() {
  return (
    <NavigationContainer theme={DarkThemeHB}>
      <Tab.Navigator
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          // √≠cones mantidos
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        {/* as 4 abas continuam (Home, Camera, Dashboard, Settings) */}
        <Tab.Screen name="Home" component={HomeScreen} options={{ title: "In√≠cio" }} />
        <Tab.Screen name="Camera" component={CameraScreen} options={{ title: "C√¢mera" }} />
        <Tab.Screen name="Dashboard" component={DashboardScreen} options={{ title: "Dashboard" }} />
        <Tab.Screen name="Settings" component={SettingsScreen} options={{ title: "Ajustes" }} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}




2) src/screens/HomeScreen.tsx (apenas C√¢mera e Dashboard)


import { View, Text, StyleSheet, Pressable, Dimensions, Image } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { BottomTabNavigationProp } from "@react-navigation/bottom-tabs";
import type { TabParamList } from "../../App";

type Nav = BottomTabNavigationProp<TabParamList>;

const W = Dimensions.get("window").width;
const CARD = W / 2 - 28; // duas colunas com respiro lateral

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
  textSoft: "#E6E6E6",
};

export default function HomeScreen() {
  const navigation = useNavigation<Nav>();

  const tiles = [
    { key: "Camera" as const, label: "C√¢mera", icon: "videocam" as const, color: PALETTE.red },
    { key: "Dashboard" as const, label: "Dashboard", icon: "pulse" as const, color: PALETTE.redSoft },
  ];

  return (
    <View style={styles.container}>
      {/* topo com logo */}
      <View style={styles.hero}>
        <Image source={require("../../assets/logo.png")} style={styles.logo} resizeMode="contain" />
        <Text style={styles.title}>HydroBot</Text>
        <Text style={styles.sub}>Monitoramento e Controle</Text>
      </View>

      {/* grade de bot√µes (somente 2) */}
      <View style={styles.grid}>
        {tiles.map((t) => (
          <Pressable
            key={t.key}
            onPress={() => navigation.navigate(t.key)}
            style={({ pressed }) => [
              styles.tile,
              { width: CARD, height: CARD, borderColor: t.color },
              pressed && { transform: [{ scale: 0.98 }] },
            ]}
          >
            <View style={[styles.tileInner, { backgroundColor: t.color }]}>
              <Ionicons name={t.icon} size={42} color={PALETTE.white} />
            </View>
            <Text style={styles.tileLabel}>{t.label}</Text>
          </Pressable>
        ))}
      </View>

      <Text style={styles.hint}>Use o rodap√© para navegar entre as se√ß√µes</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 18 },
  hero: {
    alignItems: "center",
    marginTop: 6,
    marginBottom: 16,
  },
  logo: { width: 120, height: 120, marginBottom: 6 },
  title: { color: PALETTE.white, fontSize: 24, fontWeight: "800", letterSpacing: 0.5 },
  sub: { color: PALETTE.textSoft, fontSize: 12, marginTop: 2 },
  grid: {
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "space-between",
    rowGap: 16,
  },
  tile: {
    borderRadius: 18,
    borderWidth: 2,
    backgroundColor: PALETTE.card,
    overflow: "hidden",
  },
  tileInner: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  tileLabel: {
    position: "absolute",
    bottom: 8,
    width: "100%",
    textAlign: "center",
    color: PALETTE.white,
    fontWeight: "700",
    fontSize: 16,
    textShadowColor: "rgba(0,0,0,0.4)",
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 2,
  },
  hint: { textAlign: "center", color: "#9c9c9c", marginTop: 12, fontSize: 12 },
});



O que mudou no design




Fundo preto; cart√µes e tab bar mais escuros (quase preto).


Acentos em vermelho do logo (borda dos cards e preenchimento do √≠cone).


Tipografia clara (branco e cinza-claro).


Logo no topo como identidade.




Se quiser, eu coloco um gradiente sutil vermelho‚Üípreto nos tiles ou um glow vermelho ao pressionar ‚Äî mas mantive limpo e coerente com o logo.






























√≥timo üöÄ vou juntar tudo que j√° montamos (tabs, tema, Home redesenhada, C√¢mera com LED+Bomba+Joystick, Dashboard e Settings placeholders).

Estrutura final:


HydroBotApp2/
  App.tsx
  app.json
  babel.config.js
  package.json
  src/
    screens/
      HomeScreen.tsx
      CameraScreen.tsx
      DashboardScreen.tsx
      SettingsScreen.tsx
  assets/
    logo.png   ‚Üê (a logo que voc√™ mandou, salva aqui)
    icon.png
    splash.png
    adaptive-icon.png




App.tsx


import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";
import DashboardScreen from "./src/screens/DashboardScreen";
import SettingsScreen from "./src/screens/SettingsScreen";

export type TabParamList = {
  Home: undefined;
  Camera: undefined;
  Dashboard: undefined;
  Settings: undefined;
};

const Tab = createBottomTabNavigator<TabParamList>();

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
};

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

export default function App() {
  return (
    <NavigationContainer theme={DarkThemeHB}>
      <Tab.Navigator
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} options={{ title: "In√≠cio" }} />
        <Tab.Screen name="Camera" component={CameraScreen} options={{ title: "C√¢mera" }} />
        <Tab.Screen name="Dashboard" component={DashboardScreen} options={{ title: "Dashboard" }} />
        <Tab.Screen name="Settings" component={SettingsScreen} options={{ title: "Ajustes" }} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}




src/screens/HomeScreen.tsx


import { View, Text, StyleSheet, Pressable, Dimensions, Image } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { BottomTabNavigationProp } from "@react-navigation/bottom-tabs";
import type { TabParamList } from "../../App";

type Nav = BottomTabNavigationProp<TabParamList>;

const W = Dimensions.get("window").width;
const CARD = W / 2 - 28;

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
  textSoft: "#E6E6E6",
};

export default function HomeScreen() {
  const navigation = useNavigation<Nav>();

  const tiles = [
    { key: "Camera" as const, label: "C√¢mera", icon: "videocam" as const, color: PALETTE.red },
    { key: "Dashboard" as const, label: "Dashboard", icon: "pulse" as const, color: PALETTE.redSoft },
  ];

  return (
    <View style={styles.container}>
      <View style={styles.hero}>
        <Image source={require("../../assets/logo.png")} style={styles.logo} resizeMode="contain" />
        <Text style={styles.title}>HydroBot</Text>
        <Text style={styles.sub}>Monitoramento e Controle</Text>
      </View>

      <View style={styles.grid}>
        {tiles.map((t) => (
          <Pressable
            key={t.key}
            onPress={() => navigation.navigate(t.key)}
            style={({ pressed }) => [
              styles.tile,
              { width: CARD, height: CARD, borderColor: t.color },
              pressed && { transform: [{ scale: 0.98 }] },
            ]}
          >
            <View style={[styles.tileInner, { backgroundColor: t.color }]}>
              <Ionicons name={t.icon} size={42} color={PALETTE.white} />
            </View>
            <Text style={styles.tileLabel}>{t.label}</Text>
          </Pressable>
        ))}
      </View>

      <Text style={styles.hint}>Use o rodap√© para navegar entre as se√ß√µes</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 18 },
  hero: { alignItems: "center", marginTop: 6, marginBottom: 16 },
  logo: { width: 120, height: 120, marginBottom: 6 },
  title: { color: PALETTE.white, fontSize: 24, fontWeight: "800" },
  sub: { color: PALETTE.textSoft, fontSize: 12 },
  grid: { flexDirection: "row", flexWrap: "wrap", justifyContent: "space-between", rowGap: 16 },
  tile: { borderRadius: 18, borderWidth: 2, backgroundColor: PALETTE.card, overflow: "hidden" },
  tileInner: { flex: 1, alignItems: "center", justifyContent: "center" },
  tileLabel: {
    position: "absolute",
    bottom: 8,
    width: "100%",
    textAlign: "center",
    color: PALETTE.white,
    fontWeight: "700",
    fontSize: 16,
  },
  hint: { textAlign: "center", color: "#9c9c9c", marginTop: 12, fontSize: 12 },
});




src/screens/CameraScreen.tsx


(vers√£o com LED ON/OFF, Bomba ON/OFF e joystick UI)


(esse √© bem longo, mas j√° te passei a vers√£o completa na √∫ltima rodada; se quiser eu colo de novo aqui inteiro sem cortar)



src/screens/DashboardScreen.tsx


import { View, Text, StyleSheet } from "react-native";

export default function DashboardScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Dashboard</Text>
      <Text style={styles.sub}>Aqui vir√£o telemetria, gr√°ficos e logs.</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#000", alignItems: "center", justifyContent: "center" },
  title: { color: "white", fontSize: 22, fontWeight: "700" },
  sub: { color: "#9fb3ff", marginTop: 6 },
});




src/screens/SettingsScreen.tsx


import { View, Text, StyleSheet } from "react-native";

export default function SettingsScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Ajustes</Text>
      <Text style={styles.sub}>Prefer√™ncias do app e conex√µes.</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#000", alignItems: "center", justifyContent: "center" },
  title: { color: "white", fontSize: 22, fontWeight: "700" },
  sub: { color: "#9fb3ff", marginTop: 6 },
});




üëâ quer que eu cole novamente o c√≥digo inteiro da CameraScreen.tsx atualizado, junto com esses, para ficar 100% fechado em um s√≥ bloco?



















show! vou te entregar um guia passo-a-passo (sem pular nada) + c√≥digo pronto de um servidor intermedi√°rio em Python com TensorFlow ‚Äúnormal‚Äù (Keras) e a integra√ß√£o no app para exibir a detec√ß√£o.



PARTE A ‚Äî Servidor de IA (TensorFlow)


0) Pr√©-requisitos




Python 3.10 ou 3.11 (recomendado p/ TF 2.15)


Pip atualizado: python -m pip install -U pip


M√°quina que consiga acessar o ESP32 na rede (ex.: conectada ao Wi-Fi HYDROBOT-CAM)






Dica: quando o celular estiver no Wi-Fi do ESP32 (sem internet), rode o Expo com --tunnel para continuar vendo o app.





1) Criar a pasta do servidor


mkdir hydrobot-server
cd hydrobot-server



Crie estes arquivos:


requirements.txt




(TensorFlow 2.15 usa NumPy 1.26.x ‚Äî importante fixar)




fastapi==0.115.5
uvicorn[standard]==0.32.0
opencv-python==4.10.0.84
numpy==1.26.4
tensorflow==2.15.1



Estrutura


hydrobot-server/
  server_tf.py
  requirements.txt
  models/
    fire_classifier.h5      ‚Üê seu modelo Keras (2 classes: [no_fire, fire])



server_tf.py


import cv2
import time
import threading
import numpy as np
from typing import Optional, List, Dict
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from tensorflow.keras.models import load_model  # TensorFlow "normal"

# =========================
# Config do servidor
# =========================
CAMERA_IP = "192.168.4.1"                 # IP padr√£o do ESP32-CAM em AP
STREAM_URL_FMT = "http://{}:81/stream"
MODEL_PATH = "./models/fire_classifier.h5" # Keras (2 sa√≠das: [no_fire, fire])
SCORE_THRESHOLD = 0.60                     # corte (ajuste depois)
USE_HEURISTIC_IF_MODEL_MISSING = True      # fallback se faltar modelo

app = FastAPI(title="HydroBot Fire TF Server", version="1.0.0")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

# =========================
# Leitor de frames (OpenCV)
# =========================
class CameraReader:
    def __init__(self, ip: str):
        self.ip = ip
        self._cap: Optional[cv2.VideoCapture] = None
        self._lock = threading.Lock()
        self._last_frame: Optional[np.ndarray] = None
        self._fps = 0.0
        self._running = False
        self._thread: Optional[threading.Thread] = None

    def start(self):
        if self._running: return
        self._running = True
        self._thread = threading.Thread(target=self._loop, daemon=True)
        self._thread.start()

    def stop(self):
        self._running = False
        if self._thread: self._thread.join(timeout=2.0)
        if self._cap: self._cap.release()
        self._cap = None

    def set_ip(self, ip: str):
        if ip == self.ip: return
        self.ip = ip
        self.stop(); self.start()

    def _open(self):
        cap = cv2.VideoCapture(STREAM_URL_FMT.format(self.ip))
        cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
        return cap

    def _loop(self):
        self._cap = self._open()
        if not self._cap or not self._cap.isOpened():
            for _ in range(10):
                time.sleep(0.6)
                self._cap = self._open()
                if self._cap.isOpened(): break

        frames, last = 0, time.time()
        while self._running:
            if not self._cap or not self._cap.isOpened():
                time.sleep(0.3); continue
            ok, frame = self._cap.read()
            if not ok or frame is None:
                time.sleep(0.03); continue
            with self._lock:
                self._last_frame = frame
            frames += 1
            now = time.time()
            if now - last >= 1.0:
                self._fps = frames / (now - last)
                frames, last = 0, now

    def get_latest(self) -> Optional[np.ndarray]:
        with self._lock:
            return None if self._last_frame is None else self._last_frame.copy()

    def get_fps(self) -> float:
        return self._fps

reader = CameraReader(CAMERA_IP)
reader.start()

# =========================
# Carregar modelo Keras
# =========================
class FireClassifier:
    def __init__(self, model_path: str):
        self.model = None
        try:
            self.model = load_model(model_path)
        except Exception as e:
            print(f"[WARN] N√£o foi poss√≠vel carregar o modelo: {e}")
            self.model = None

        # inferir input shape [H, W, 3]
        if self.model is not None:
            ishape = self.model.inputs[0].shape  # (None, H, W, 3)
            self.H = int(ishape[1]); self.W = int(ishape[2])
        else:
            self.H = 224; self.W = 224  # padr√£o se faltar modelo

    def preprocess(self, frame_bgr: np.ndarray) -> np.ndarray:
        img = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2RGB)
        img = cv2.resize(img, (self.W, self.H), interpolation=cv2.INTER_AREA)
        x = img.astype(np.float32) / 255.0   # normaliza√ß√£o padr√£o
        return np.expand_dims(x, axis=0)

    def predict(self, frame_bgr: np.ndarray) -> float:
        if self.model is None:
            # fallback heur√≠stico (propor√ß√£o de pixels "quentes")
            hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
            mask = cv2.inRange(hsv, (5, 80, 120), (40, 255, 255))
            score = float(np.count_nonzero(mask)) / float(mask.size)
            return float(min(1.0, score * 4.0))
        x = self.preprocess(frame_bgr)
        probs = self.model.predict(x, verbose=0)[0]
        # espera [no_fire, fire]; se for 1 sa√≠da (sigmoid), trate como fire
        if probs.shape[0] == 2:
            fire_score = float(probs[1])
        else:
            fire_score = float(probs[0])
        return max(0.0, min(1.0, fire_score))

clf = FireClassifier(MODEL_PATH)

# =========================
# Caixas por heur√≠stica (opcional)
# =========================
def fire_boxes(frame_bgr: np.ndarray) -> List[List[int]]:
    h, w = frame_bgr.shape[:2]
    scl = min(640, w)
    rs = cv2.resize(frame_bgr, (scl, int(h * scl / w)))
    hsv = cv2.cvtColor(rs, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, (5, 80, 120), (40, 255, 255))
    kernel = np.ones((5, 5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, 1)
    mask = cv2.morphologyEx(mask, cv2.MORPH_DILATE, kernel, 1)
    cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    boxes: List[List[int]] = []
    rx, ry = w / float(scl), h / float(rs.shape[0])
    for c in cnts:
        x, y, bw, bh = cv2.boundingRect(c)
        if bw * bh < 600: 
            continue
        boxes.append([int(x * rx), int(y * ry), int(bw * rx), int(bh * ry)])
    return boxes

# =========================
# API
# =========================
class ConfigIn(BaseModel):
    camera_ip: str

@app.get("/status")
def status():
    return {
        "ok": True,
        "camera_ip": reader.ip,
        "fps": round(reader.get_fps(), 2),
        "has_frame": reader.get_latest() is not None,
        "model": "keras_h5" if clf.model is not None else ("heuristic" if USE_HEURISTIC_IF_MODEL_MISSING else "none"),
        "ts": int(time.time() * 1000),
    }

@app.post("/config")
def set_config(cfg: ConfigIn):
    reader.set_ip(cfg.camera_ip)
    return {"ok": True, "camera_ip": reader.ip}

@app.get("/snapshot")
def snapshot():
    frame = reader.get_latest()
    if frame is None:
        return {"ok": False, "error": "no frame yet"}
    ok, buf = cv2.imencode(".jpg", frame, [int(cv2.IMWRITE_JPEG_QUALITY), 85])
    if not ok:
        return {"ok": False, "error": "encode failed"}
    return Response(content=buf.tobytes(), media_type="image/jpeg")

@app.get("/detect")
def detect():
    frame = reader.get_latest()
    if frame is None:
        return {"ok": False, "error": "no frame"}
    score = clf.predict(frame)
    is_fire = bool(score >= SCORE_THRESHOLD)
    boxes = fire_boxes(frame) if is_fire else []
    return {
        "ok": True,
        "isFire": is_fire,
        "score": round(float(score), 3),
        "boxes": boxes,
        "threshold": SCORE_THRESHOLD,
        "ts": int(time.time() * 1000),
    }




2) Instalar e rodar


# (na pasta hydrobot-server)
python -m venv .venv
# Windows: .venv\Scripts\activate
# macOS/Linux:
source .venv/bin/activate

pip install -r requirements.txt
uvicorn server_tf:app --reload --host 0.0.0.0 --port 8000





Sem modelo ainda? Pode rodar assim mesmo: ele usa o fallback heur√≠stico.

Quando voc√™ colocar models/fire_classifier.h5, ele usa o Keras automaticamente.





3) Conectividade de rede




ESP32-CAM cria o AP HYDROBOT-CAM ‚Üí IP padr√£o 192.168.4.1


Servidor (sua m√°quina) deve conectar a esse AP para ler o stream.


Celular tamb√©m conecta ao mesmo AP para usar o app.


Para o Expo Go funcionar enquanto est√° nesse AP (sem internet), rode o bundler com:

npx expo start --tunnel


(o t√∫nel usa a rede m√≥vel para entregar o bundle)




Descubra o IP do servidor dentro do AP (Windows: ipconfig, macOS/Linux: ifconfig).

Geralmente vira 192.168.4.x.



PARTE B ‚Äî App (React Native) consumindo a IA


Voc√™ j√° tem a CameraScreen.tsx. Vamos adicionar:




Campo de Servidor (http://192.168.4.X:8000)


Bot√£o Detectar (liga/desliga polling)


Banner ‚Äúüî• FOGO‚Äù com score






Substitua seu src/screens/CameraScreen.tsx pelo abaixo (j√° inclui LED, Bomba, Joystick e Detec√ß√£o):




import { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  ActivityIndicator,
  PanResponder,
  GestureResponderEvent,
  PanResponderGestureState,
} from "react-native";
import { WebView } from "react-native-webview";

const DEFAULT_IP = "192.168.4.1";          // ESP32-CAM
const DEFAULT_SERVER = "http://192.168.4.2:8000"; // <-- troque para o IP do seu servidor no AP

export default function CameraScreen() {
  const [ip, setIp] = useState(DEFAULT_IP);
  const [server, setServer] = useState(DEFAULT_SERVER);

  const [isChecking, setIsChecking] = useState(false);
  const [statusText, setStatusText] = useState<string>("‚Äî");
  const [ledOn, setLedOn] = useState<boolean>(false);
  const [pumpOn, setPumpOn] = useState<boolean>(false);

  // Detec√ß√£o
  const [detectOn, setDetectOn] = useState<boolean>(false);
  const [isFire, setIsFire] = useState<boolean>(false);
  const [fireScore, setFireScore] = useState<number>(0);

  // Joystick UI
  const [joy, setJoy] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const webref = useRef<WebView>(null);

  const streamUrl = useMemo(() => `http://${ip}:81/stream`, [ip]);
  const statusUrl = useMemo(() => `http://${ip}/status`, [ip]);
  const ledUrl   = useMemo(() => (on: boolean) => `http://${ip}/led?on=${on ? "1" : "0"}`, [ip]);
  const pumpUrl  = useMemo(() => (on: boolean) => `http://${ip}/pump?on=${on ? "1" : "0"}`, [ip]);

  async function pingStatus() {
    try {
      setIsChecking(true);
      const r = await fetch(statusUrl);
      const j = await r.json();
      setLedOn(!!j.led);
      setPumpOn(!!j.pump);
      setStatusText(
        `OK ‚Ä¢ ip:${j.ip} ‚Ä¢ mode:${j.mode} ‚Ä¢ led:${j.led ? "on" : "off"} ‚Ä¢ pump:${j.pump ? "on" : "off"}`
      );
    } catch {
      setStatusText("Falha ao conectar. Confira o Wi-Fi HYDROBOT-CAM e o IP.");
    } finally {
      setIsChecking(false);
    }
  }
  async function toggleLed() {
    try {
      const t = !ledOn; await fetch(ledUrl(t)); setLedOn(t);
    } catch { setStatusText("Erro ao alternar LED."); }
  }
  async function togglePump() {
    try {
      const t = !pumpOn; await fetch(pumpUrl(t)); setPumpOn(t);
    } catch { setStatusText("Erro ao alternar bomba."); }
  }

  useEffect(() => {
    pingStatus(); const id = setInterval(pingStatus, 5000);
    return () => clearInterval(id);
  }, [statusUrl]);

  // HTML para MJPEG
  const html = `
    <html>
      <head><meta name="viewport" content="width=device-width, initial-scale=1" /></head>
      <body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;height:100vh;">
        <img src="${streamUrl}" style="width:100%;height:100%;object-fit:contain;" />
      </body>
    </html>
  `;

  // ======= Polling de detec√ß√£o =======
  useEffect(() => {
    if (!detectOn) return;
    let stop = false;
    const tick = async () => {
      try {
        const r = await fetch(`${server}/detect`, { method: "GET" });
        const j = await r.json();
        if (!stop && j && j.ok) {
          setIsFire(!!j.isFire);
          setFireScore(Number(j.score || 0));
        }
      } catch {
        if (!stop) { setIsFire(false); setFireScore(0); }
      } finally {
        if (!stop) setTimeout(tick, 500); // ~2Hz (ajuste)
      }
    };
    tick();
    return () => { stop = true; };
  }, [detectOn, server]);

  // ===== Joystick (UI) =====
  const RADIUS = 64, KNOB_R = 22;
  const pan = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => setDragging(true),
      onPanResponderMove: (_e: GestureResponderEvent, g: PanResponderGestureState) => {
        let nx = g.dx / RADIUS, ny = g.dy / RADIUS;
        const len = Math.hypot(nx, ny); if (len > 1) { nx /= len; ny /= len; }
        setJoy({ x: nx, y: -ny });
      },
      onPanResponderRelease: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
      onPanResponderTerminate: () => { setDragging(false); setJoy({ x: 0, y: 0 }); },
    })
  ).current;
  const knobLeft = joy.x * RADIUS, knobTop = -joy.y * RADIUS;

  return (
    <View style={styles.container}>
      {/* Controles superiores */}
      <View style={styles.topbar}>
        <Text style={styles.label}>ESP IP:</Text>
        <TextInput value={ip} onChangeText={setIp} placeholder="192.168.4.1"
          autoCapitalize="none" autoCorrect={false} style={styles.input} keyboardType="numeric" />
        <Pressable onPress={pingStatus} style={styles.btn}><Text style={styles.btnText}>{isChecking ? "..." : "Testar"}</Text></Pressable>

        <Pressable onPress={toggleLed} style={[styles.btn, ledOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{ledOn ? "LED ON" : "LED OFF"}</Text>
        </Pressable>
        <Pressable onPress={togglePump} style={[styles.btn, pumpOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{pumpOn ? "BOMBA ON" : "BOMBA OFF"}</Text>
        </Pressable>
      </View>

      {/* Linha do servidor + detec√ß√£o */}
      <View style={styles.statusRow}>
        <Text style={styles.label}>Servidor:</Text>
        <TextInput
          value={server}
          onChangeText={setServer}
          placeholder="http://192.168.4.2:8000"
          autoCapitalize="none"
          autoCorrect={false}
          style={[styles.input, { flex: 1 }]}
        />
        <Pressable onPress={() => setDetectOn((v) => !v)} style={[styles.btn, detectOn ? styles.btnOn : styles.btnOff]}>
          <Text style={styles.btnText}>{detectOn ? "Detectando" : "Detectar"}</Text>
        </Pressable>
      </View>

      {/* Status curto */}
      <View style={[styles.statusRow, { paddingTop: 4, paddingBottom: 8 }]}>
        <Text numberOfLines={2} style={styles.status}>{statusText}</Text>
        <Pressable onPress={() => webref.current?.reload()} style={[styles.btn, { marginLeft: 8 }]}>
          <Text style={styles.btnText}>Recarregar</Text>
        </Pressable>
      </View>

      {/* Banner de fogo */}
      {detectOn && (
        <View style={[styles.fireBanner, isFire ? styles.fireOn : styles.fireOff]}>
          <Text style={styles.fireText}>
            {isFire ? `üî• FOGO ‚Ä¢ score ${fireScore.toFixed(2)}` : `Sem fogo ‚Ä¢ score ${fireScore.toFixed(2)}`}
          </Text>
        </View>
      )}

      {/* V√≠deo */}
      <WebView
        ref={webref}
        originWhitelist={["*"]}
        source={{ html }}
        style={styles.web}
        allowFileAccess
        allowingReadAccessToURL={"*"}
        javaScriptEnabled
        domStorageEnabled
        allowUniversalAccessFromFileURLs
        allowsInlineMediaPlayback
        mediaPlaybackRequiresUserAction={false}
      />

      {/* Joystick */}
      <View pointerEvents="box-none" style={StyleSheet.absoluteFill}>
        <View style={[styles.joyWrap, { width: RADIUS * 2 + 24, height: RADIUS * 2 + 24 }]} {...pan.panHandlers}>
          <View style={[styles.joyBase, { width: RADIUS * 2, height: RADIUS * 2, borderRadius: RADIUS }]} />
          <View style={[styles.joyKnob, { width: KNOB_R * 2, height: KNOB_R * 2, borderRadius: KNOB_R, transform: [{ translateX: knobLeft }, { translateY: knobTop }], opacity: dragging ? 1 : 0.9 }]} />
          <Text style={styles.joyText}>x: {joy.x.toFixed(2)}   y: {joy.y.toFixed(2)}</Text>
        </View>
      </View>
    </View>
  );
}

const PALETTE = { bg:"#000", card:"#0d0d0d", border:"#1a1a1a", red:"#E53B2F", white:"#fff" };

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg },
  topbar: { flexDirection: "row", alignItems: "center", paddingHorizontal: 12, paddingVertical: 10, gap: 8, backgroundColor: PALETTE.card },
  label: { color: "#cfd3d8", fontSize: 12 },
  input: { backgroundColor: PALETTE.bg, color: "white", borderRadius: 8, paddingHorizontal: 10, paddingVertical: 8, borderWidth: 1, borderColor: "#1e2a4d", minWidth: 110 },
  btn: { backgroundColor: "#2b48ff", paddingHorizontal: 10, paddingVertical: 10, borderRadius: 10 },
  btnOn: { backgroundColor: "#17a34a" },
  btnOff: { backgroundColor: "#374151" },
  btnText: { color: "white", fontWeight: "600" },
  statusRow: { flexDirection: "row", alignItems: "center", paddingHorizontal: 12, paddingVertical: 8, gap: 8, backgroundColor: "#0f1730" },
  status: { color: "#cbd5ff", flex: 1, fontSize: 12 },
  web: { flex: 1, backgroundColor: "black" },
  fireBanner: { alignItems: "center", justifyContent: "center", paddingVertical: 6 },
  fireOn: { backgroundColor: "#8b0000" },
  fireOff: { backgroundColor: "#223" },

  // Joystick
  joyWrap: { position: "absolute", bottom: 24, left: 24, alignItems: "center", justifyContent: "center" },
  joyBase: { position: "absolute", backgroundColor: "rgba(255,255,255,0.08)", borderWidth: 2, borderColor: "rgba(255,255,255,0.14)" },
  joyKnob: { position: "absolute", backgroundColor: "rgba(43,72,255,0.9)", borderWidth: 2, borderColor: "rgba(255,255,255,0.85)" },
  joyText: { position: "absolute", bottom: -22, color: "#cbd5ff", fontSize: 12 },
});




CHECKLIST r√°pido (do zero at√© ver ‚Äúüî• FOGO‚Äù no app)




Ligue o ESP32-CAM (AP HYDROBOT-CAM, senha 12345678).


Conecte o notebook ao AP HYDROBOT-CAM.


Suba o servidor:



Crie a pasta hydrobot-server, cole os arquivos, pip install -r requirements.txt,


Rode: uvicorn server_tf:app --reload --host 0.0.0.0 --port 8000.


(Opcional) Coloque models/fire_classifier.h5. Sem ele, usa heur√≠stica.






Descubra o IP do notebook no AP (ex.: 192.168.4.2).


No app, rode npx expo start --tunnel.


No app C√¢mera:



Campo ESP IP: 192.168.4.1 ‚Üí tocar Testar (status OK).


Campo Servidor: http://192.168.4.2:8000 (troque pelo seu IP).


Toque Detectar ‚Üí deve aparecer um banner ‚ÄúSem fogo ‚Ä¢ score ‚Ä¶‚Äù.


Aponte chama/luz quente ‚Üí quando o score ‚â• 0.60, aparece üî• FOGO.






(Opcional) Ajuste SCORE_THRESHOLD no server_tf.py conforme seu modelo.




Pronto. Quando quiser, eu:




Troco o fallback por um detector com caixas (SSD/EfficientDet em TF) e desenho overlay.


Automatizo bomba ao detectar fogo (com histerese/timeout para n√£o ligar/superligar).


Adiciono /detect/stream (SSE) para lat√™ncia menor e menos requisi√ß√µes.




















Sim ‚Äî d√° pra seguir de dois jeitos sem remover o 3.13.5:




(r√°pido, hoje) rodar a detec√ß√£o ‚Äúplaceholder‚Äù (heur√≠stica HSV) 100% compat√≠vel com Python 3.13 ‚Äî funciona agora.


(TensorFlow ‚Äúde verdade‚Äù) rodar o servidor em Docker com Python 3.11 + TensorFlow, independente do Python instalado no Windows.




Abaixo te deixo os dois caminhos completos. Se quiser pular direto pro TensorFlow, vai no Plano B.



Plano A (imediato): servidor compat√≠vel com Python 3.13 (heur√≠stica)


Isso te deixa testar o fluxo end-to-end (app ‚áÑ servidor ‚áÑ ESP32) enquanto a gente prepara o cont√™iner TF.


1) Arquivos


requirements_heuristic.txt (compat√≠veis com 3.13):


fastapi==0.115.5
uvicorn[standard]==0.32.0
opencv-python>=4.10.0
numpy>=2.0.0



server_heuristic.py (igual ao que passei antes, s√≥ sem TensorFlow):


import cv2, time, threading, numpy as np
from typing import Optional, List
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

CAMERA_IP = "192.168.4.1"
STREAM_URL_FMT = "http://{}:81/stream"
SCORE_THRESHOLD = 0.60

app = FastAPI(title="HydroBot Fire (Heuristic)", version="0.1.0")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

class CameraReader:
    def __init__(self, ip: str):
        self.ip = ip; self._cap=None; self._lock=threading.Lock()
        self._last=None; self._fps=0.0; self._run=False; self._th=None
    def start(self):
        if self._run: return
        self._run=True; self._th=threading.Thread(target=self._loop,daemon=True); self._th.start()
    def stop(self):
        self._run=False
        if self._th: self._th.join(timeout=2.0)
        if self._cap: self._cap.release(); self._cap=None
    def set_ip(self, ip:str):
        if ip==self.ip: return
        self.ip=ip; self.stop(); self.start()
    def _open(self):
        cap=cv2.VideoCapture(STREAM_URL_FMT.format(self.ip)); cap.set(cv2.CAP_PROP_BUFFERSIZE,1); return cap
    def _loop(self):
        self._cap=self._open()
        for _ in range(10):
            if self._cap and self._cap.isOpened(): break
            time.sleep(0.6); self._cap=self._open()
        frames=0; last=time.time()
        while self._run:
            if not self._cap or not self._cap.isOpened(): time.sleep(0.3); continue
            ok,frame=self._cap.read()
            if not ok or frame is None: time.sleep(0.03); continue
            with self._lock: self._last=frame
            frames+=1; now=time.time()
            if now-last>=1.0: self._fps=frames/(now-last); frames=0; last=now
    def get_latest(self): 
        with self._lock: return None if self._last is None else self._last.copy()
    def get_fps(self): return self._fps

reader=CameraReader(CAMERA_IP); reader.start()

class ConfigIn(BaseModel): camera_ip: str

def fire_score(frame):
    hsv=cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    mask=cv2.inRange(hsv,(5,80,120),(40,255,255))
    ratio=float(np.count_nonzero(mask))/float(mask.size)
    v_mean=float(np.mean(hsv[...,2]))/255.0
    return min(1.0, ratio*4.0 + v_mean*0.2)

def fire_boxes(frame):
    h,w=frame.shape[:2]; scl=min(640,w)
    rs=cv2.resize(frame,(scl,int(h*scl/w))); hsv=cv2.cvtColor(rs, cv2.COLOR_BGR2HSV)
    mask=cv2.inRange(hsv,(5,80,120),(40,255,255))
    k=np.ones((5,5),np.uint8)
    mask=cv2.morphologyEx(mask, cv2.MORPH_OPEN, k,1); mask=cv2.morphologyEx(mask, cv2.MORPH_DILATE, k,1)
    cnts,_=cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    rx=w/float(scl); ry=h/float(rs.shape[0]); boxes=[]
    for c in cnts:
        x,y,bw,bh=cv2.boundingRect(c)
        if bw*bh<600: continue
        boxes.append([int(x*rx),int(y*ry),int(bw*rx),int(bh*ry)])
    return boxes

@app.get("/status")
def status(): 
    return {"ok":True,"camera_ip":reader.ip,"fps":round(reader.get_fps(),2),"has_frame":reader.get_latest() is not None,"model":"heuristic","ts":int(time.time()*1000)}

@app.post("/config")
def set_config(cfg:ConfigIn):
    reader.set_ip(cfg.camera_ip); return {"ok":True,"camera_ip":reader.ip}

@app.get("/snapshot")
def snapshot():
    f=reader.get_latest()
    if f is None: return {"ok":False,"error":"no frame"}
    ok,buf=cv2.imencode(".jpg",f,[int(cv2.IMWRITE_JPEG_QUALITY),85])
    if not ok: return {"ok":False,"error":"encode failed"}
    return Response(content=buf.tobytes(),media_type="image/jpeg")

@app.get("/detect")
def detect():
    f=reader.get_latest()
    if f is None: return {"ok":False,"error":"no frame"}
    s=fire_score(f); is_fire=bool(s>=SCORE_THRESHOLD)
    return {"ok":True,"isFire":is_fire,"score":round(float(s),3),"boxes":(fire_boxes(f) if is_fire else []),"threshold":SCORE_THRESHOLD,"ts":int(time.time()*1000)}



2) Instalar e rodar (com seu Python 3.13)


python -m pip install -U pip
pip install -r requirements_heuristic.txt
uvicorn server_heuristic:app --reload --host 0.0.0.0 --port 8000



No app (tela C√¢mera), aponte Servidor para http://<IP_DO_PC_NO_AP>:8000 e toque Detectar.

Voc√™ j√° ver√° o banner com o score; quando houver chama/√°rea quente, ele sobe.




Depois, quando quiser trocar para TensorFlow ‚Äúreal‚Äù, voc√™ n√£o muda nada no app, s√≥ troca o servidor.





Plano B (recomendado p/ TensorFlow): Docker com Python 3.11 + TF


Mesmo mantendo Python 3.13 no Windows, o servidor roda dentro do cont√™iner com 3.11 + TF.


0) Pr√©-requisitos




Docker Desktop instalado e rodando.




1) Arquivos


Dockerfile


FROM python:3.11-slim

# libs p/ OpenCV
RUN apt-get update && apt-get install -y --no-install-recommends \
    libglib2.0-0 libsm6 libxrender1 libxext6 && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app

# requirements (TF 2.15 + numpy compat√≠vel)
COPY requirements_tf.txt /app/requirements_tf.txt
RUN pip install --no-cache-dir -r requirements_tf.txt

# c√≥digo e modelos
COPY server_tf.py /app/server_tf.py
COPY models /app/models

EXPOSE 8000
CMD ["uvicorn", "server_tf:app", "--host", "0.0.0.0", "--port", "8000"]



requirements_tf.txt


fastapi==0.115.5
uvicorn[standard]==0.32.0
opencv-python-headless==4.10.0.84
numpy==1.26.4
tensorflow==2.15.1





Uso opencv-python-headless no cont√™iner para evitar depend√™ncias de GUI.




server_tf.py

‚Äî √© exatamente o que te passei anteriormente (TensorFlow ‚Äúnormal‚Äù, modelo Keras .h5). Se quiser, eu reenvio o arquivo inteiro de novo aqui.


Estrutura:


hydrobot-server/
  Dockerfile
  requirements_tf.txt
  server_tf.py
  models/
    fire_classifier.h5   ‚Üê (opcional; se faltar, usa heur√≠stica fallback)



2) Build & run


# dentro da pasta hydrobot-server
docker build -t hydrobot-tf .
docker run --rm -p 8000:8000 --network host --name hydrobot-tf hydrobot-tf





Se --network host n√£o funcionar no Windows Docker Desktop, use:


docker run --rm -p 8000:8000 --name hydrobot-tf hydrobot-tf



e no app aponte para http://SEU-IP:8000 (o IP da sua m√°quina na rede do ESP32).




Testes:




http://SEU-IP:8000/status


http://SEU-IP:8000/detect




Quando voc√™ colocar models/fire_classifier.h5 dentro da pasta antes do build, o servidor passar√° a usar TF de fato.



Qual caminho eu recomendo agora?




Se voc√™ quer seguir hoje, use o Plano A (heur√≠stica) com o Python 3.13 e j√° integre ao app.


Em paralelo, prepare o Plano B (Docker) para usar seu modelo TensorFlow sem esquentar com a vers√£o do Python do Windows.




Se quiser, eu te mando o server_tf.py completo novamente, e/ou um docker-compose.yml pra subir com um comando s√≥.

