
Valeu pelo print — o erro vem desta linha dentro do stream_handler:


snprintf(part_buf, sizeof(part_buf),
         "Content-Type: %s\r\n" _JPG_CONTENT_LENGTH "\r\n",
         _JPG_CONTENT_TYPE, fb->len);



Em C/C++ só dá para “colar” literais de string. Como _JPG_CONTENT_LENGTH é uma variável const char*, o compilador quebra. Vamos simplificar o handler e montar o cabeçalho numa única snprintf.


Abaixo está o firmware completo já corrigido (cole num sketch novo e grave). É exatamente o mesmo que te mandei, mas com stream_handler reescrito e uns ajustes pequenos:


#include <WiFi.h>
#include "esp_camera.h"
#include "esp_timer.h"
#include "img_converters.h"
#include "esp_http_server.h"

// ================= WIFI =================
const char* WIFI_SSID  = "HydroBot";
const char* WIFI_PASS  = "loud2025emibr";

// ============ PINOS (AI Thinker) ============
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27

#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ============ HTTP SERVER ============
httpd_handle_t httpd_handle = NULL;

static void set_nocache(httpd_req_t *req) {
  httpd_resp_set_hdr(req, "Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Expires", "0");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
}

static esp_err_t status_handler(httpd_req_t *req) {
  set_nocache(req);
  char buf[96];
  snprintf(buf, sizeof(buf),
           "{\"ok\":true,\"ip\":\"%s\"}", WiFi.localIP().toString().c_str());
  httpd_resp_set_type(req, "application/json");
  return httpd_resp_send(req, buf, HTTPD_RESP_USE_STRLEN);
}

static esp_err_t jpg_handler(httpd_req_t *req) {
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) { httpd_resp_send_500(req); return ESP_FAIL; }
  set_nocache(req);
  httpd_resp_set_type(req, "image/jpeg");
  esp_err_t res = httpd_resp_send(req, (const char *)fb->buf, fb->len);
  esp_camera_fb_return(fb);
  return res;
}

static esp_err_t stream_handler(httpd_req_t *req) {
  // Cabeçalho MIME multipart (MJPEG)
  const char *STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";
  const char *BOUNDARY            = "\r\n--frame\r\n";
  httpd_resp_set_type(req, STREAM_CONTENT_TYPE);
  set_nocache(req);

  esp_err_t res = ESP_OK;
  while (true) {
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) { res = ESP_FAIL; break; }

    // --- boundary ---
    if ((res = httpd_resp_send_chunk(req, BOUNDARY, strlen(BOUNDARY))) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }

    // --- header do frame (Content-Type + Content-Length) ---
    char header[96];
    int hlen = snprintf(header, sizeof(header),
                        "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n", fb->len);
    if (hlen < 0 || hlen >= (int)sizeof(header)) { esp_camera_fb_return(fb); res = ESP_FAIL; break; }
    if ((res = httpd_resp_send_chunk(req, header, hlen)) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }

    // --- payload (JPEG) + CRLF ---
    if ((res = httpd_resp_send_chunk(req, (const char*)fb->buf, fb->len)) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }
    esp_camera_fb_return(fb);
    if ((res = httpd_resp_send_chunk(req, "\r\n", 2)) != ESP_OK) {
      break;
    }

    // respiro curto para evitar overrun
    vTaskDelay(pdMS_TO_TICKS(5));
  }

  // fecha chunked
  httpd_resp_send_chunk(req, NULL, 0);
  return res;
}

static void apply_sensor_defaults(sensor_t* s) {
  if (!s) return;
  s->set_framesize(s, FRAMESIZE_QVGA); // 320x240 estável
  s->set_quality(s, 15);               // 10~15 boa qualidade; maior = mais leve
  s->set_vflip(s, 0);
  s->set_hmirror(s, 0);
}

static void startCameraServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 80;
  config.max_uri_handlers = 8;
  config.stack_size = 6144;

  httpd_uri_t root_uri   = { .uri="/",        .method=HTTP_GET, .handler=status_handler, .user_ctx=NULL };
  httpd_uri_t status_uri = { .uri="/status",  .method=HTTP_GET, .handler=status_handler, .user_ctx=NULL };
  httpd_uri_t snap_uri   = { .uri="/snapshot",.method=HTTP_GET, .handler=jpg_handler,    .user_ctx=NULL };
  httpd_uri_t stream_uri = { .uri="/stream",  .method=HTTP_GET, .handler=stream_handler, .user_ctx=NULL };

  if (httpd_start(&httpd_handle, &config) == ESP_OK) {
    httpd_register_uri_handler(httpd_handle, &root_uri);
    httpd_register_uri_handler(httpd_handle, &status_uri);
    httpd_register_uri_handler(httpd_handle, &snap_uri);
    httpd_register_uri_handler(httpd_handle, &stream_uri);
  }
}

void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println("\nBooting...");

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;

  config.xclk_freq_hz = 10000000; // 10 MHz estável
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_QVGA;
  config.jpeg_quality = 15;
  config.fb_count     = 2;
  config.grab_mode    = CAMERA_GRAB_LATEST;
  config.fb_location  = CAMERA_FB_IN_PSRAM;

  if (!psramFound()) {
    Serial.println("PSRAM not found -> DRAM fallback");
    config.fb_location  = CAMERA_FB_IN_DRAM;
    config.fb_count     = 1;
    config.jpeg_quality = 18;
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed 0x%x, fallback...\n", err);
    config.xclk_freq_hz = 8000000;
    config.frame_size   = FRAMESIZE_QQVGA;
    config.jpeg_quality = 20;
    config.fb_count     = 1;
    err = esp_camera_init(&config);
    if (err != ESP_OK) {
      Serial.printf("Fallback failed 0x%x\n", err);
      while(true){ delay(1000); }
    }
  }
  apply_sensor_defaults(esp_camera_sensor_get());

  WiFi.setSleep(false);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) { delay(400); Serial.print("."); }
  Serial.printf("\nWiFi connected: %s\n", WiFi.localIP().toString().c_str());

  startCameraServer();
  Serial.println("HTTP server started");
  Serial.printf("Open: http://%s/stream\n", WiFi.localIP().toString().c_str());
}

void loop() { delay(1000); }



Depois de compilar/gravar:




Abra no navegador do celular: http://<IP>/stream.


No app, use o mesmo IP e toque Testar.




Se ainda aparecer reboot, reduza carga rápida:




troque FRAMESIZE_QVGA → FRAMESIZE_QQVGA


aumente o vTaskDelay do stream_handler para 10–12 ms


confira a alimentação (5V ≥ 1A).


























#include <WiFi.h>
#include "esp_camera.h"
#include "esp_timer.h"
#include "img_converters.h"
#include "esp_http_server.h"

// ================= WIFI =================
const char* WIFI_SSID  = "HydroBot";
const char* WIFI_PASS  = "loud2025emibr";

// ============ PINOS (AI Thinker) ============
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27

#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ============ HTTP SERVER ============
httpd_handle_t stream_httpd = NULL;
httpd_handle_t capture_httpd = NULL;

static void set_nocache(httpd_req_t *req) {
  httpd_resp_set_hdr(req, "Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Expires", "0");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
}

static esp_err_t status_handler(httpd_req_t *req) {
  set_nocache(req);
  char buf[96];
  snprintf(buf, sizeof(buf),
           "{\"ok\":true,\"ip\":\"%s\"}", WiFi.localIP().toString().c_str());
  httpd_resp_set_type(req, "application/json");
  return httpd_resp_send(req, buf, HTTPD_RESP_USE_STRLEN);
}

static esp_err_t jpg_handler(httpd_req_t *req) {
  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) {
    httpd_resp_send_500(req);
    return ESP_FAIL;
  }
  set_nocache(req);
  httpd_resp_set_type(req, "image/jpeg");
  esp_err_t res = httpd_resp_send(req, (const char *)fb->buf, fb->len);
  esp_camera_fb_return(fb);
  return res;
}

static esp_err_t stream_handler(httpd_req_t *req) {
  static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";
  static const char* _STREAM_BOUNDARY = "\r\n--frame\r\n";
  static const char* _JPG_CONTENT_TYPE = "image/jpeg";
  static const char* _JPG_CONTENT_LENGTH = "Content-Length: %u\r\n";
  esp_err_t res = ESP_OK;

  set_nocache(req);
  httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);

  while (true) {
    camera_fb_t * fb = esp_camera_fb_get();
    if (!fb) { res = ESP_FAIL; break; }

    char part_buf[64];
    size_t hlen = snprintf(part_buf, sizeof(part_buf),
                           "Content-Type: %s\r\n" _JPG_CONTENT_LENGTH "\r\n",
                           _JPG_CONTENT_TYPE, fb->len);

    if ((res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY))) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }
    if ((res = httpd_resp_send_chunk(req, part_buf, hlen)) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }
    if ((res = httpd_resp_send_chunk(req, (const char *)fb->buf, fb->len)) != ESP_OK) {
      esp_camera_fb_return(fb); break;
    }
    esp_camera_fb_return(fb);

    if ((res = httpd_resp_send_chunk(req, "\r\n", 2)) != ESP_OK) {
      break;
    }

    // respiro curto para evitar overrun em cenas complexas
    vTaskDelay(pdMS_TO_TICKS(5));
  }

  // fecha chunked
  httpd_resp_send_chunk(req, NULL, 0);
  return res;
}

static void apply_sensor_defaults(sensor_t* s) {
  if (!s) return;
  // perfil estável
  s->set_framesize(s, FRAMESIZE_QVGA);  // 320x240
  s->set_quality(s, 15);                // menor = melhor qualidade (10~15 bom)
  s->set_vflip(s, 0);
  s->set_hmirror(s, 0);
  s->set_brightness(s, 0);
  s->set_saturation(s, 0);
}

static void startCameraServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 80;
  config.max_uri_handlers = 8;
  config.stack_size = 6144; // suficiente para handlers

  // /snapshot e /status no servidor principal
  httpd_uri_t status_uri = { .uri="/status", .method=HTTP_GET, .handler=status_handler, .user_ctx=NULL };
  httpd_uri_t still_uri  = { .uri="/snapshot", .method=HTTP_GET, .handler=jpg_handler, .user_ctx=NULL };
  httpd_uri_t stream_uri = { .uri="/stream", .method=HTTP_GET, .handler=stream_handler, .user_ctx=NULL };

  if (httpd_start(&capture_httpd, &config) == ESP_OK) {
    httpd_register_uri_handler(capture_httpd, &status_uri);
    httpd_register_uri_handler(capture_httpd, &still_uri);
    httpd_register_uri_handler(capture_httpd, &stream_uri);
  }
}

void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println("\nBooting...");

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;

  // XCLK moderado (10 MHz) para evitar instabilidade
  config.xclk_freq_hz = 10000000;
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_QVGA;
  config.jpeg_quality = 15;
  config.fb_count     = 2;
  config.grab_mode    = CAMERA_GRAB_LATEST;
  config.fb_location  = CAMERA_FB_IN_PSRAM;

  if (!psramFound()) {
    config.fb_location  = CAMERA_FB_IN_DRAM;
    config.fb_count     = 1;
    config.jpeg_quality = 18;
    Serial.println("PSRAM not found -> using DRAM fallback");
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed 0x%x, trying safer fallback...\n", err);
    // fallback ainda mais leve
    config.xclk_freq_hz = 8000000;
    config.frame_size   = FRAMESIZE_QQVGA; // 160x120
    config.jpeg_quality = 20;
    config.fb_count     = 1;
    err = esp_camera_init(&config);
    if (err != ESP_OK) {
      Serial.printf("Fallback failed 0x%x\n", err);
      while(true){ delay(1000); }
    }
  }
  apply_sensor_defaults(esp_camera_sensor_get());

  WiFi.setSleep(false);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) {
    delay(400); Serial.print(".");
  }
  Serial.printf("\nWiFi connected: %s\n", WiFi.localIP().toString().c_str());

  startCameraServer();
  Serial.println("HTTP server started");
  Serial.printf("Open: http://%s/stream\n", WiFi.localIP().toString().c_str());
}

void loop() {
  delay(1000);
}

























Perfeito — vamos simplificar tudo para “app ⇄ ESP32-CAM direto”, sem servidor intermediário nem detecção. Abaixo vai:




CameraScreen.tsx (apenas ajustes mínimos pra Android/WebView aceitar HTTP e MJPEG)


Firmware ESP32-CAM minimalista com rotas /stream, /snapshot e /status estáveis, resolução segura (QVGA), duplo buffer e backoff — ideal pra parar com travamentos/overflow.





1) src/screens/CameraScreen.tsx (substitua o arquivo todo)


Principais mudanças:




mixedContentMode="always" no WebView (Android bloqueia HTTP claro por padrão).


androidHardwareAccelerationEnabled e setSupportMultipleWindows={false} só pra estabilidade.


Mantive sua lógica de fallback para /snapshot sem alterar o resto.




// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  Image,
  AppState,
  AppStateStatus,
} from "react-native";
import { WebView } from "react-native-webview";

type Mode = "mjpeg" | "snapshot";
const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", accent: "#e6403a", text: "#e5e7eb" };

export default function CameraScreen() {
  const [ip, setIp] = useState<string>("192.168.4.1");
  const [testedIp, setTestedIp] = useState<string>("");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [status, setStatus] = useState<string>("Aguardando IP");
  const [snapTick, setSnapTick] = useState<number>(0);
  const [isRunning, setIsRunning] = useState<boolean>(false);
  const snapTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const appState = useRef<AppStateStatus>(AppState.currentState);

  const streamURL = useMemo(() => (testedIp ? `http://${testedIp}/stream` : ""), [testedIp]);
  const snapshotURL = useMemo(
    () => (testedIp ? `http://${testedIp}/snapshot?_=${snapTick}` : ""),
    [testedIp, snapTick]
  );
  const healthURL = useMemo(() => (testedIp ? `http://${testedIp}/status` : ""), [testedIp]);

  const startSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) return;
    snapTimerRef.current = setInterval(() => setSnapTick((t) => (t + 1) % 1_000_000), 150);
  }, []);
  const stopSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) {
      clearInterval(snapTimerRef.current);
      snapTimerRef.current = null;
    }
  }, []);

  useEffect(() => {
    if (mode === "snapshot" && testedIp) startSnapshotLoop();
    else stopSnapshotLoop();
    return stopSnapshotLoop;
  }, [mode, testedIp, startSnapshotLoop, stopSnapshotLoop]);

  useEffect(() => {
    const sub = AppState.addEventListener("change", (nextState) => {
      const prev = appState.current;
      appState.current = nextState;
      if (prev.match(/active/) && nextState.match(/inactive|background/)) {
        stopSnapshotLoop();
        setIsRunning(false);
      } else if (prev.match(/inactive|background/) && nextState === "active") {
        if (mode === "snapshot" && testedIp) startSnapshotLoop();
        if (testedIp) setIsRunning(true);
      }
    });
    return () => sub.remove();
  }, [mode, testedIp, startSnapshotLoop, stopSnapshotLoop]);

  const testConnection = useCallback(async () => {
    const target = (ip || "").trim();
    if (!target) {
      setStatus("Informe o IP do ESP");
      return;
    }
    setStatus("Testando conexão...");
    setIsRunning(false);
    stopSnapshotLoop();

    // Primeiro tenta /status (rápido)
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/status`, { signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("mjpeg");
        setStatus("Conectado (tentando MJPEG)...");
        setIsRunning(true);
        return;
      }
    } catch {}

    // Tenta /stream
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/stream`, { method: "GET", signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("mjpeg");
        setStatus("Conectado (MJPEG)...");
        setIsRunning(true);
        return;
      }
    } catch {}

    // Fallback /snapshot
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/snapshot`, { method: "GET", signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("snapshot");
        setStatus("Conectado (Snapshot contínuo)...");
        setIsRunning(true);
        startSnapshotLoop();
        return;
      }
    } catch {}

    setStatus("Falha ao conectar. Verifique IP/rede/firmware.");
    setIsRunning(false);
  }, [ip, startSnapshotLoop, stopSnapshotLoop]);

  const mjpegHTML = useMemo(() => {
    if (!streamURL) return "";
    return `
      <!doctype html>
      <html><head><meta name="viewport" content="width=device-width, initial-scale=1" />
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;overflow:hidden;}
        #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;}
        img{max-width:100vw;max-height:100vh;object-fit:contain;}
        #badge{position:fixed;left:8px;bottom:8px;padding:4px 8px;border-radius:8px;
               background:#121218;color:#e5e7eb;font-family:system-ui,Arial,sans-serif;font-size:12px;opacity:.7}
      </style></head>
      <body>
        <div id="wrap"><img id="mjpeg" src="${streamURL}" /></div>
        <div id="badge">Stream: ${streamURL}</div>
        <script>
          const img = document.getElementById('mjpeg');
          let retryMs = 800;
          img.addEventListener('error', () => {
            setTimeout(() => { img.src = '${streamURL}' + '?_=' + Date.now(); }, retryMs);
            retryMs = Math.min(retryMs * 2, 4000);
          });
        </script>
      </body></html>
    `.trim();
  }, [streamURL]);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>ESP32-CAM Viewer</Text>

      <View style={styles.row}>
        <Text style={styles.label}>ESP IP</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="ex.: 192.168.4.1"
          placeholderTextColor="#6b7280"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
        />
        <Pressable style={styles.button} onPress={testConnection}>
          <Text style={styles.buttonText}>Testar</Text>
        </Pressable>
      </View>

      <Text style={styles.status}>
        Status: {status} {testedIp ? `| IP: ${testedIp}` : ""}
        {testedIp ? ` | Modo: ${mode}` : ""}
      </Text>

      <View style={styles.viewer}>
        {testedIp && isRunning ? (
          mode === "mjpeg" ? (
            <WebView
              originWhitelist={["*"]}
              source={{ html: mjpegHTML, baseUrl: `http://${testedIp}` }}
              javaScriptEnabled
              domStorageEnabled
              allowsInlineMediaPlayback
              allowsFullscreenVideo={false}
              mediaPlaybackRequiresUserAction={false}
              mixedContentMode="always"
              androidHardwareAccelerationEnabled
              setSupportMultipleWindows={false}
              onError={() => {
                setMode("snapshot");
                setStatus("MJPEG falhou — alternando para Snapshot...");
              }}
              style={styles.webview}
            />
          ) : (
            <Image
              source={{ uri: snapshotURL }}
              resizeMode="contain"
              style={styles.image}
              onError={() => setStatus("Erro no snapshot — checar conexão")}
            />
          )
        ) : (
          <View style={styles.placeholder}>
            <Text style={{ color: PALETTE.text, opacity: 0.7, textAlign: "center" }}>
              Informe o IP e toque em “Testar” para iniciar o vídeo.
            </Text>
          </View>
        )}
      </View>

      {testedIp ? (
        <View style={styles.footerRow}>
          <Pressable
            style={[styles.smallBtn, mode === "mjpeg" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("mjpeg"); setStatus("Tentando MJPEG /stream..."); }}
          >
            <Text style={styles.smallBtnText}>Usar MJPEG</Text>
          </Pressable>
          <Pressable
            style={[styles.smallBtn, mode === "snapshot" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("snapshot"); setStatus("Usando /snapshot contínuo..."); }}
          >
            <Text style={styles.smallBtnText}>Usar Snapshot</Text>
          </Pressable>
        </View>
      ) : null}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, gap: 12 },
  title: { color: PALETTE.text, fontSize: 20, fontWeight: "700" },
  row: { flexDirection: "row", alignItems: "center", gap: 8 },
  label: { color: PALETTE.text },
  input: {
    flex: 1,
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderWidth: 1,
    borderColor: PALETTE.border,
    borderRadius: 10,
    paddingHorizontal: 10,
    paddingVertical: 8,
  },
  button: { backgroundColor: PALETTE.accent, paddingHorizontal: 14, paddingVertical: 10, borderRadius: 10 },
  buttonText: { color: "#fff", fontWeight: "700" },
  status: { color: PALETTE.text, opacity: 0.9 },
  viewer: {
    flex: 1, backgroundColor: "#000", borderRadius: 12, overflow: "hidden",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  webview: { flex: 1, backgroundColor: "#000" },
  image: { width: "100%", height: "100%" },
  placeholder: { flex: 1, alignItems: "center", justifyContent: "center", padding: 24 },
  footerRow: { flexDirection: "row", gap: 10, justifyContent: "center" },
  smallBtn: {
    paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1,
    borderColor: PALETTE.border, backgroundColor: PALETTE.card,
  },
  smallBtnActive: { borderColor: PALETTE.accent },
  smallBtnText: { color: PALETTE.text, fontWeight: "600" },
});





Obs. importante (Android Manifest): se seu app não abre HTTP claro, garanta usesCleartextTraffic="true" (Expo/Dev geralmente já permite). Como você está usando fetch("http://...") no testConnection, isso também depende desse flag.





2) Firmware ESP32-CAM minimalista (apenas “mostrar câmera”)




Rotas:



GET /stream → MJPEG (multipart/x-mixed-replace)


GET /snapshot → JPEG único


GET /status → JSON simplificado






Estabilidade: QVGA, jpeg_quality=15, fb_count=2, grab_mode=CAMERA_GRAB_LATEST, WiFi.setSleep(false) e pequeno backoff entre frames do stream.


CORS: Access-Control-Allow-Origin: * (para seu fetch/Image/WebView não toparem CORS).


Pins: usa seu board_config.h. Certifique-se que ele está para AI Thinker (ou seu módulo).




Cole no seu projeto como HydrobotCam_Minimal.ino:


#include "esp_camera.h"
#include <WiFi.h>
#include <WebServer.h>

// ====== CONFIG WIFI ======
const char* ssid     = "HydroBot";
const char* password = "loud2025emibr";

// ====== CAMERA PINS via board_config.h ======
#include "board_config.h"

// ====== SERVIDOR ======
WebServer server(80);

// ====== AJUSTES CAMERA ======
static void apply_sensor_tweaks(sensor_t* s) {
  if (!s) return;
  // Ajustes comuns pra estabilizar cores e flip conforme módulo
  if (s->id.PID == OV3660_PID) {
    s->set_vflip(s, 1);
    s->set_brightness(s, 1);
    s->set_saturation(s, -2);
  }
  // Resolução segura p/ estabilidade (pode subir p/ VGA se quiser)
  s->set_framesize(s, FRAMESIZE_QVGA);
  s->set_quality(s, 15); // 10=melhor qualidade; 15-20=mais leve
  s->set_colorbar(s, 0);
}

// ====== HEADERS CORS/NO-CACHE ======
static void set_no_cache_headers() {
  server.sendHeader("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
  server.sendHeader("Access-Control-Allow-Origin", "*");
}

// ====== HANDLERS ======
void handle_status() {
  set_no_cache_headers();
  String json = "{";
  json += "\"ok\":true,";
  json += "\"ip\":\"" + WiFi.localIP().toString() + "\"";
  json += "}";
  server.send(200, "application/json", json);
}

void handle_snapshot() {
  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb) {
    set_no_cache_headers();
    server.send(503, "text/plain", "NO_FRAME");
    return;
  }
  set_no_cache_headers();
  server.setContentLength(fb->len);
  server.send(200, "image/jpeg", "");
  WiFiClient client = server.client();
  client.write(fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

void handle_stream() {
  WiFiClient client = server.client();
  const char* _boundary = "frame";
  String hdr = 
    "HTTP/1.1 200 OK\r\n"
    "Access-Control-Allow-Origin: *\r\n"
    "Cache-Control: no-store, no-cache, must-revalidate, max-age=0\r\n"
    "Pragma: no-cache\r\n"
    "Connection: close\r\n"
    "Content-Type: multipart/x-mixed-replace; boundary=" + String(_boundary) + "\r\n\r\n";
  client.print(hdr);

  // Loop de streaming
  while (client.connected()) {
    camera_fb_t* fb = esp_camera_fb_get();
    if (!fb) {
      delay(5);
      continue;
    }
    client.print("--"); client.print(_boundary); client.print("\r\n");
    client.print("Content-Type: image/jpeg\r\n");
    client.print("Content-Length: "); client.print(fb->len); client.print("\r\n\r\n");
    client.write(fb->buf, fb->len);
    client.print("\r\n");
    esp_camera_fb_return(fb);

    // pequeno respiro pra reduzir overrun em cenas complexas
    delay(5);
  }
}

void handle_root() {
  set_no_cache_headers();
  server.send(200, "text/plain", "ESP32-CAM OK. Rotas: /status, /snapshot, /stream");
}

// ====== SETUP ======
void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println("\nBooting...");

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;

  // XCLK mais baixo ajuda a estabilidade (8~10 MHz); 20 MHz dá mais fps mas pode estourar buffer
  config.xclk_freq_hz = 10000000; // 10 MHz estável
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size   = FRAMESIZE_QVGA;
  config.jpeg_quality = 15;
  config.fb_count     = 2;
  config.grab_mode    = CAMERA_GRAB_LATEST;
  config.fb_location  = CAMERA_FB_IN_PSRAM;

  if (!psramFound()) {
    // Sem PSRAM, adapta
    config.fb_count    = 1;
    config.fb_location = CAMERA_FB_IN_DRAM;
    config.jpeg_quality = 18;
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed 0x%x\n", err);
    // Tenta fallback leve
    config.xclk_freq_hz = 8000000;
    config.frame_size   = FRAMESIZE_QQVGA;
    err = esp_camera_init(&config);
    if (err != ESP_OK) {
      Serial.printf("Camera init fallback failed 0x%x\n", err);
      while (true) { delay(1000); }
    }
  }

  apply_sensor_tweaks(esp_camera_sensor_get());

  WiFi.begin(ssid, password);
  WiFi.setSleep(false);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.printf("\nWiFi connected: %s\n", WiFi.localIP().toString().c_str());

  // Rotas
  server.on("/", handle_root);
  server.on("/status", HTTP_GET, handle_status);
  server.on("/snapshot", HTTP_GET, handle_snapshot);
  server.on("/stream", HTTP_GET, handle_stream);
  server.begin();

  Serial.println("HTTP server started");
  Serial.printf("Use http://%s/stream\n", WiFi.localIP().toString().c_str());
}

void loop() {
  server.handleClient();
}



Notas rápidas




Se quiser mais qualidade após confirmar estabilidade, suba para FRAMESIZE_VGA ou melhore jpeg_quality (ex.: 12). Faça um ajuste por vez.


Se ainda notar “sensibilidade” quando a cena tem muito detalhe, aumente delay(5) do stream para delay(8~12); isso reduz taxa de quadros, mas evita overflow.


Se sua build anterior usava /stream na porta 81, este firmware usa porta 80 (padrão HTTP). No app eu já aponto para http://IP/stream (sem porta), então tudo certo.





Como testar (sequência curtinha)




Grave o firmware no ESP32-CAM. Abra o Serial Monitor e pegue o IP que ele imprime.


No app, abra a tela Câmera, coloque o IP (ex.: 192.168.4.1 ou o IP que o serial mostrou) e toque Testar.


Deve entrar em MJPEG. Se falhar (rede oscilando), o botão Usar Snapshot funciona como fallback imediato.




Se algo ainda não aparecer:




Confirme se consegue abrir http://SEU_IP/stream no navegador do celular (mesma rede).


Se o WebView abrir “vazio” no Android, verifique o usesCleartextTraffic="true" no Manifest do app.




Pronto — agora é só stream direto, sem heurística nem proxy.

















































// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  Image,
  AppState,
  AppStateStatus,
} from "react-native";
import { WebView } from "react-native-webview";

type Mode = "mjpeg" | "snapshot";

const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", accent: "#e6403a", text: "#e5e7eb" };

export default function CameraScreen() {
  const [ip, setIp] = useState<string>("192.168.4.1"); // ajuste para seu IP (ou mDNS se usar proxy)
  const [testedIp, setTestedIp] = useState<string>(""); // IP efetivo em uso na visualização
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [status, setStatus] = useState<string>("Aguardando IP");
  const [snapTick, setSnapTick] = useState<number>(0);
  const [isRunning, setIsRunning] = useState<boolean>(false);
  const snapTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const appState = useRef<AppStateStatus>(AppState.currentState);

  const streamURL = useMemo(() => (testedIp ? `http://${testedIp}/stream` : ""), [testedIp]);
  const snapshotURL = useMemo(
    () => (testedIp ? `http://${testedIp}/snapshot?_=${snapTick}` : ""),
    [testedIp, snapTick]
  );
  const healthURL = useMemo(() => (testedIp ? `http://${testedIp}/status` : ""), [testedIp]);

  // ---- Controle do modo snapshot (polling) ----
  const startSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) return;
    snapTimerRef.current = setInterval(() => setSnapTick((t) => (t + 1) % 1_000_000), 150); // ~6-7 FPS
  }, []);

  const stopSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) {
      clearInterval(snapTimerRef.current);
      snapTimerRef.current = null;
    }
  }, []);

  useEffect(() => {
    if (mode === "snapshot" && testedIp) {
      startSnapshotLoop();
    } else {
      stopSnapshotLoop();
    }
    return stopSnapshotLoop;
  }, [mode, testedIp, startSnapshotLoop, stopSnapshotLoop]);

  // Pausar quando app em background (evita consumo)
  useEffect(() => {
    const sub = AppState.addEventListener("change", (nextState) => {
      const prev = appState.current;
      appState.current = nextState;
      if (prev.match(/active/) && nextState.match(/inactive|background/)) {
        stopSnapshotLoop();
        setIsRunning(false);
      } else if (prev.match(/inactive|background/) && nextState === "active") {
        if (mode === "snapshot" && testedIp) startSnapshotLoop();
        if (testedIp) setIsRunning(true);
      }
    });
    return () => sub.remove();
  }, [mode, testedIp, startSnapshotLoop, stopSnapshotLoop]);

  // ---- Teste de conexão e fallback automático ----
  const testConnection = useCallback(async () => {
    const target = (ip || "").trim();
    if (!target) {
      setStatus("Informe o IP do ESP");
      return;
    }
    setStatus("Testando conexão...");
    setIsRunning(false);
    stopSnapshotLoop();

    // 1) Tenta um GET rápido no /status (se existir)
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/status`, { signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("mjpeg");
        setStatus("Conectado (tentando MJPEG)...");
        setIsRunning(true);
        return;
      }
    } catch (_) {
      // segue para checar /stream e /snapshot
    }

    // 2) Checa se /stream responde pelo menos com headers
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/stream`, { method: "GET", signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("mjpeg");
        setStatus("Conectado (MJPEG)...");
        setIsRunning(true);
        return;
      }
    } catch (_) {
      // segue
    }

    // 3) Fallback: tenta /snapshot
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 2000);
      const r = await fetch(`http://${target}/snapshot`, { method: "GET", signal: ctrl.signal });
      clearTimeout(to);
      if (r.ok) {
        setTestedIp(target);
        setMode("snapshot");
        setStatus("Conectado (Snapshot contínuo)...");
        setIsRunning(true);
        startSnapshotLoop();
        return;
      }
    } catch (_) {
      // segue
    }

    setStatus("Falha ao conectar. Verifique IP/rede/firmware.");
    setIsRunning(false);
  }, [ip, startSnapshotLoop, stopSnapshotLoop]);

  // ---- UI MJPEG via WebView (funciona bem no Android) ----
  const mjpegHTML = useMemo(() => {
    if (!streamURL) return "";
    // HTML simples que carrega o MJPEG e tenta auto-reconectar em caso de erro
    return `
      <!doctype html>
      <html><head><meta name="viewport" content="width=device-width, initial-scale=1" />
      <style>
        html,body{margin:0;padding:0;background:#0b0b0f;height:100%;overflow:hidden;}
        #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;}
        img{max-width:100vw;max-height:100vh;object-fit:contain;}
        #badge{position:fixed;left:8px;bottom:8px;padding:4px 8px;border-radius:8px;
               background:#121218;color:#e5e7eb;font-family:system-ui,Arial,sans-serif;font-size:12px;opacity:.7}
      </style></head>
      <body>
        <div id="wrap">
          <img id="mjpeg" src="${streamURL}" />
        </div>
        <div id="badge">Stream: ${streamURL}</div>
        <script>
          const img = document.getElementById('mjpeg');
          let retryMs = 1000;
          img.addEventListener('error', () => {
            setTimeout(() => {
              img.src = '${streamURL}' + '?_=' + Date.now();
            }, retryMs);
            retryMs = Math.min(retryMs * 2, 5000);
          });
        </script>
      </body></html>
    `.trim();
  }, [streamURL]);

  // ---- Render ----
  return (
    <View style={styles.container}>
      <Text style={styles.title}>ESP32-CAM Viewer</Text>

      <View style={styles.row}>
        <Text style={styles.label}>ESP IP</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="ex.: 192.168.4.1"
          placeholderTextColor="#6b7280"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
        />
        <Pressable style={styles.button} onPress={testConnection}>
          <Text style={styles.buttonText}>Testar</Text>
        </Pressable>
      </View>

      <Text style={styles.status}>
        Status: {status} {testedIp ? `| IP: ${testedIp}` : ""}
        {testedIp ? ` | Modo: ${mode}` : ""}
      </Text>

      <View style={styles.viewer}>
        {testedIp && isRunning ? (
          mode === "mjpeg" ? (
            <WebView
              originWhitelist={["*"]}
              source={{ html: mjpegHTML, baseUrl: `http://${testedIp}` }}
              javaScriptEnabled
              domStorageEnabled
              allowsInlineMediaPlayback
              allowsFullscreenVideo={false}
              mediaPlaybackRequiresUserAction={false}
              onError={() => {
                // Cai para snapshot se o WebView reportar erro
                setMode("snapshot");
                setStatus("MJPEG falhou — alternando para Snapshot...");
              }}
              style={styles.webview}
            />
          ) : (
            <Image
              source={{ uri: snapshotURL }}
              resizeMode="contain"
              style={styles.image}
              onError={() => setStatus("Erro no snapshot — checar conexão")}
            />
          )
        ) : (
          <View style={styles.placeholder}>
            <Text style={{ color: PALETTE.text, opacity: 0.7, textAlign: "center" }}>
              Informe o IP e toque em “Testar” para iniciar o vídeo.
            </Text>
          </View>
        )}
      </View>

      {testedIp ? (
        <View style={styles.footerRow}>
          <Pressable
            style={[styles.smallBtn, mode === "mjpeg" ? styles.smallBtnActive : null]}
            onPress={() => {
              setMode("mjpeg");
              setStatus("Tentando MJPEG /stream...");
            }}
          >
            <Text style={styles.smallBtnText}>Usar MJPEG</Text>
          </Pressable>
          <Pressable
            style={[styles.smallBtn, mode === "snapshot" ? styles.smallBtnActive : null]}
            onPress={() => {
              setMode("snapshot");
              setStatus("Usando /snapshot contínuo...");
            }}
          >
            <Text style={styles.smallBtnText}>Usar Snapshot</Text>
          </Pressable>
        </View>
      ) : null}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, gap: 12 },
  title: { color: PALETTE.text, fontSize: 20, fontWeight: "700" },
  row: { flexDirection: "row", alignItems: "center", gap: 8 },
  label: { color: PALETTE.text },
  input: {
    flex: 1,
    backgroundColor: PALETTE.card,
    color: PALETTE.text,
    borderWidth: 1,
    borderColor: PALETTE.border,
    borderRadius: 10,
    paddingHorizontal: 10,
    paddingVertical: 8,
  },
  button: {
    backgroundColor: PALETTE.accent,
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 10,
  },
  buttonText: { color: "#fff", fontWeight: "700" },
  status: { color: PALETTE.text, opacity: 0.9 },
  viewer: {
    flex: 1,
    backgroundColor: "#000",
    borderRadius: 12,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: PALETTE.border,
  },
  webview: { flex: 1, backgroundColor: "#000" },
  image: { width: "100%", height: "100%" },
  placeholder: { flex: 1, alignItems: "center", justifyContent: "center", padding: 24 },
  footerRow: { flexDirection: "row", gap: 10, justifyContent: "center" },
  smallBtn: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: PALETTE.border,
    backgroundColor: PALETTE.card,
  },
  smallBtnActive: { borderColor: PALETTE.accent },
  smallBtnText: { color: PALETTE.text, fontWeight: "600" },
});














#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HydroBot Server (ESTÁVEL) – Lê /stream (MJPEG) do ESP32-CAM, guarda o último frame,
serve /frame.jpg e calcula score simples de fogo (HSV + EMA).

Rodar:
  uvicorn server_heuristic:app --host 0.0.0.0 --port 8000
Deps:
  pip install fastapi uvicorn requests opencv-python numpy pydantic
"""

import time
import threading
from typing import Optional, Dict, Any
import re

import requests
import cv2
import numpy as np
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ========= CONFIG =========
CAMERA_IP = "hydrobot.local"
STREAM_URL_FMT = "http://{}/stream"
CONNECT_TIMEOUT = 3.0
READ_TIMEOUT = 10.0
MAX_FRAME_AGE_MS = 10_000
MAX_RESULT_AGE_MS = 800
JPEG_QUALITY = 85

# Fire (HSV simples)
HSV_LOW = (8, 70, 120)
HSV_HIGH = (40, 255, 255)
EMA_ALPHA = 0.3
FIRE_THRESHOLD = 0.15

BOUNDARY_RE = re.compile(br'--[^\r\n]+')
REQ_HEADERS = {"Connection": "keep-alive", "User-Agent": "HydroBot-Grabber/3.0"}

# ========= FASTAPI =========
app = FastAPI(title="HydroBot Server (Stable)", version="4.0")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True,
                   allow_methods=["*"], allow_headers=["*"])

class ConfigIn(BaseModel):
  camera_ip: str

def placeholder_jpeg(msg: str = "NO FRAME") -> bytes:
  img = np.zeros((240, 320, 3), dtype=np.uint8)
  img[:, :] = (50, 50, 150)
  cv2.putText(img, msg, (38, 130), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
  cv2.putText(img, time.strftime("%H:%M:%S"), (38, 180), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)
  ok, buf = cv2.imencode(".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY])
  return buf.tobytes()

# ========= MJPEG Stream Grabber =========
class StreamGrabber:
  def __init__(self, ip: str):
    self.ip = ip
    self._stop = threading.Event()
    self._lock = threading.Lock()
    self._last_jpeg: Optional[bytes] = None
    self._last_ts = 0
    self._fps_in = 0.0
    self._frames = 0
    self._tick = time.time()
    self._last_err: Optional[str] = None

  def start(self):
    self._stop.clear()
    t = threading.Thread(target=self._run, daemon=True)
    t.start()

  def stop(self):
    self._stop.set()

  def _run(self):
    while not self._stop.is_set():
      url = STREAM_URL_FMT.format(self.ip)
      buf = b""
      try:
        with requests.get(url, stream=True, timeout=(CONNECT_TIMEOUT, READ_TIMEOUT), headers=REQ_HEADERS) as r:
          r.raise_for_status()
          for chunk in r.iter_content(chunk_size=4096):
            if self._stop.is_set():
              break
            if not chunk:
              continue
            buf += chunk

            # procurar boundaries e extrair o penúltimo part (frame completo)
            m = BOUNDARY_RE.search(buf)
            if not m:
              if len(buf) > 2_000_000:
                buf = buf[-200_000:]
              continue

            parts = BOUNDARY_RE.split(buf)
            if len(parts) >= 2:
              frame_blob = parts[-2]
              buf = parts[-1]

              header_end = frame_blob.find(b"\r\n\r\n")
              if header_end == -1:
                continue
              body = frame_blob[header_end+4:]

              if body.startswith(b"\xff\xd8") and body.endswith(b"\xff\xd9"):
                with self._lock:
                  self._last_jpeg = body
                  self._last_ts = int(time.time()*1000)
                  self._last_err = None
                  self._frames += 1
                  now = time.time()
                  if now - self._tick >= 1.0:
                    self._fps_in = self._frames / (now - self._tick)
                    self._frames = 0
                    self._tick = now

      except Exception as e:
        with self._lock:
          self._last_err = str(e)
        time.sleep(0.8)  # backoff curto e reconecta

  def get_latest(self, max_age_ms=MAX_FRAME_AGE_MS) -> Optional[bytes]:
    with self._lock:
      if not self._last_jpeg:
        return None
      if int(time.time()*1000) - self._last_ts > max_age_ms:
        return None
      return self._last_jpeg

  def status(self) -> Dict[str, Any]:
    with self._lock:
      age = int(time.time()*1000) - self._last_ts if self._last_ts else None
      return {
        "ip": self.ip,
        "hasFrame": self._last_jpeg is not None,
        "age_ms": age,
        "fps_in": round(self._fps_in, 2),
        "last_err": self._last_err
      }

grabber = StreamGrabber(CAMERA_IP)
grabber.start()

# ========= Fire Detection =========
def simple_fire_score(frame_bgr: np.ndarray) -> float:
  try:
    hsv = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, np.array(HSV_LOW, np.uint8), np.array(HSV_HIGH, np.uint8))
    fire_ratio = float(np.count_nonzero(mask)) / float(mask.size)
    v_mean = float(np.mean(hsv[:, :, 2])) / 255.0
    score = min(1.0, fire_ratio * 4.0 + v_mean * 0.1)
    return float(score)
  except Exception:
    return 0.0

class FireDetector:
  def __init__(self, src: StreamGrabber):
    self.src = src
    self._lock = threading.Lock()
    self._stop = threading.Event()
    self._thr: Optional[threading.Thread] = None

    self._ema = 0.0
    self._raw = 0.0
    self._is_fire = False
    self._ts = 0
    self._fps = 0.0
    self._frames = 0
    self._tick = time.time()
    self._wh: Optional[tuple] = None

  def start(self):
    self._stop.clear()
    self._thr = threading.Thread(target=self._run, daemon=True)
    self._thr.start()

  def stop(self):
    self._stop.set()
    if self._thr and self._thr.is_alive():
      self._thr.join(timeout=1.0)

  def _run(self):
    interval = 1.0 / 5.0
    while not self._stop.is_set():
      t0 = time.time()
      jpeg = self.src.get_latest()
      if jpeg is None:
        time.sleep(0.1)
        continue
      try:
        frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
        if frame is None:
          time.sleep(0.05)
          continue
        H, W = frame.shape[:2]
        score = simple_fire_score(frame)
        ema = score if self._ema == 0.0 else EMA_ALPHA*score + (1.0-EMA_ALPHA)*self._ema
        is_fire = (ema >= FIRE_THRESHOLD)
        with self._lock:
          self._raw = score
          self._ema = ema
          self._is_fire = is_fire
          self._ts = int(time.time()*1000)
          self._wh = (W, H)
          self._frames += 1
          now = time.time()
          if now - self._tick >= 1.0:
            self._fps = self._frames / (now - self._tick)
            self._frames = 0
            self._tick = now
      except Exception:
        pass
      dt = time.time() - t0
      time.sleep(max(0.0, interval - dt))

  def get(self) -> Dict[str, Any]:
    with self._lock:
      return {
        "ok": True,
        "isFire": bool(self._is_fire),
        "score": round(float(self._ema), 3),
        "score_raw": round(float(self._raw), 3),
        "ts": int(self._ts),
        "fps_det": round(float(self._fps), 2),
        "frame_wh": list(self._wh) if self._wh else None
      }

detector = FireDetector(grabber)
detector.start()

# ========= Endpoints =========
@app.get("/healthz")
def healthz():
  s = grabber.status()
  return {"ok": True, "camera_ip": s.get("ip"), **s}

@app.get("/status")
def status():
  s = grabber.status()
  d = detector.get()
  return {"ok": True, "camera_ip": s.get("ip"), **s, **d}

@app.post("/config")
def set_config(cfg: ConfigIn):
  global CAMERA_IP, grabber, detector
  CAMERA_IP = cfg.camera_ip
  # reinicia o grabber
  grabber.stop()
  grabber = StreamGrabber(CAMERA_IP)
  grabber.start()
  # detector continua usando o mesmo objeto? recria para limpar estado
  detector.stop()
  detector = FireDetector(grabber)
  detector.start()
  return {"ok": True, "camera_ip": CAMERA_IP}

@app.get("/snapshot")
def snapshot():
  b = grabber.get_latest() or placeholder_jpeg("NO FRAME")
  headers = {
    "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
    "Pragma": "no-cache",
    "Expires": "0",
    "Content-Type": "image/jpeg"
  }
  return Response(content=b, headers=headers, media_type="image/jpeg")

@app.get("/frame.jpg")
def frame_jpg():
  return snapshot()

@app.get("/detect")
def detect():
  res = detector.get()
  if res.get("ts", 0) and (int(time.time()*1000) - int(res["ts"]) <= MAX_RESULT_AGE_MS):
    return res
  # fallback rápido
  jpeg = grabber.get_latest()
  if jpeg is None:
    return {"ok": False, "error": "no recent frame"}
  frame = cv2.imdecode(np.frombuffer(jpeg, np.uint8), cv2.IMREAD_COLOR)
  if frame is None:
    return {"ok": False, "error": "decode failed"}
  score = simple_fire_score(frame)
  is_fire = (score >= FIRE_THRESHOLD)
  H, W = frame.shape[:2]
  return {
    "ok": True,
    "isFire": bool(is_fire),
    "score": round(float(score), 3),
    "score_raw": round(float(score), 3),
    "ts": int(time.time()*1000),
    "frame_wh": [W, H],
    "fallback": True
  }

if __name__ == "__main__":
  import uvicorn
  print("HydroBot Server (Stable) — lendo /stream")
  print(f"Camera IP: {CAMERA_IP}")
  uvicorn.run(app, host="0.0.0.0", port=8000)













#include "esp_camera.h"
#include <WiFi.h>

// ===========================
// Select camera model in board_config.h
// ===========================
#include "board_config.h"

// ===========================
// Enter your WiFi credentials
// ===========================
const char *ssid = "HydroBot";
const char *password = "loud2025emibr";

void startCameraServer();
void setupLedFlash();

void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println();

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.frame_size = FRAMESIZE_UXGA;
  config.pixel_format = PIXFORMAT_JPEG;  // for streaming
  //config.pixel_format = PIXFORMAT_RGB565; // for face detection/recognition
  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
  config.fb_location = CAMERA_FB_IN_PSRAM;
  config.jpeg_quality = 12;
  config.fb_count = 1;

  // if PSRAM IC present, init with UXGA resolution and higher JPEG quality
  //                      for larger pre-allocated frame buffer.
  if (config.pixel_format == PIXFORMAT_JPEG) {
    if (psramFound()) {
      config.jpeg_quality = 10;
      config.fb_count = 2;
      config.grab_mode = CAMERA_GRAB_LATEST;
    } else {
      // Limit the frame size when PSRAM is not available
      config.frame_size = FRAMESIZE_SVGA;
      config.fb_location = CAMERA_FB_IN_DRAM;
    }
  } else {
    // Best option for face detection/recognition
    config.frame_size = FRAMESIZE_240X240;
#if CONFIG_IDF_TARGET_ESP32S3
    config.fb_count = 2;
#endif
  }

#if defined(CAMERA_MODEL_ESP_EYE)
  pinMode(13, INPUT_PULLUP);
  pinMode(14, INPUT_PULLUP);
#endif

  // camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }

  sensor_t *s = esp_camera_sensor_get();
  // initial sensors are flipped vertically and colors are a bit saturated
  if (s->id.PID == OV3660_PID) {
    s->set_vflip(s, 1);        // flip it back
    s->set_brightness(s, 1);   // up the brightness just a bit
    s->set_saturation(s, -2);  // lower the saturation
  }
  // drop down frame size for higher initial frame rate
  if (config.pixel_format == PIXFORMAT_JPEG) {
    s->set_framesize(s, FRAMESIZE_QVGA);
  }

#if defined(CAMERA_MODEL_M5STACK_WIDE) || defined(CAMERA_MODEL_M5STACK_ESP32CAM)
  s->set_vflip(s, 1);
  s->set_hmirror(s, 1);
#endif

#if defined(CAMERA_MODEL_ESP32S3_EYE)
  s->set_vflip(s, 1);
#endif

// Setup LED FLash if LED pin is defined in camera_pins.h
#if defined(LED_GPIO_NUM)
  setupLedFlash();
#endif

  WiFi.begin(ssid, password);
  WiFi.setSleep(false);

  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("WiFi connected");

  startCameraServer();

  Serial.print("Camera Ready! Use 'http://");
  Serial.print(WiFi.localIP());
  Serial.println("' to connect");
}

void loop() {
  // Do nothing. Everything is done in another task by the web server
  delay(10000);
}
