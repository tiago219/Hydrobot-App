
Isso é “arquivo não encontrado” — o App.tsx está importando coisas que ainda não existem. Vamos criar os arquivos mínimos (stubs) para tudo compilar agora.


1) Estrutura de pastas


Crie estas pastas/arquivos:


src/
  screens/
    HomeScreen.tsx
    CameraScreen.tsx        // (já tem o seu; se não, use o stub abaixo)
    DashboardScreen.tsx
    SettingsScreen.tsx
  context/
    LanguageContext.tsx
  theme/
    tokens.ts



2) src/theme/tokens.ts


export const tokens = {
  color: {
    bg: "#0b0b0f",
    card: "#121218",
    border: "#25273a",
    text: "#e5e7eb",
    sub: "#9ca3af",
    accent: "#e6403a",
    success: "#10b981",
    danger: "#ef4444",
  },
  radius: { xs: 8, sm: 10, md: 12, lg: 16, xl: 20, pill: 999 },
  space: { xs: 6, sm: 8, md: 12, lg: 16, xl: 24, xxl: 32 },
  font: { regular: "System", medium: "System", bold: "System" },
  shadow: {
    card: { elevation: 3, shadowOpacity: 0.15, shadowRadius: 6, shadowOffset: { width: 0, height: 3 } },
  },
};
export type Tokens = typeof tokens;



3) src/context/LanguageContext.tsx


import React, { createContext, useContext, useMemo, useState } from "react";

type Lang = "pt" | "en" | "es";
type Ctx = { lang: Lang; setLang: (l: Lang) => void };
const LanguageCtx = createContext<Ctx | undefined>(undefined);

export function LanguageProvider({ children }: { children: React.ReactNode }) {
  const [lang, setLang] = useState<Lang>("pt");
  const value = useMemo(() => ({ lang, setLang }), [lang]);
  return <LanguageCtx.Provider value={value}>{children}</LanguageCtx.Provider>;
}

export function useLanguage() {
  const ctx = useContext(LanguageCtx);
  if (!ctx) throw new Error("useLanguage must be used inside LanguageProvider");
  return ctx;
}



4) Stubs das telas


src/screens/HomeScreen.tsx


import React from "react";
import { View, Text, StyleSheet } from "react-native";
import { tokens as t } from "../theme/tokens";

export default function HomeScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Home</Text>
      <Text style={styles.sub}>Tela inicial (placeholder)</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: t.color.bg, padding: 16 },
  title: { color: t.color.text, fontSize: 22, fontWeight: "700", marginBottom: 6 },
  sub: { color: t.color.sub },
});



src/screens/CameraScreen.tsx (se você já tem, mantenha o seu)


import React from "react";
import { View, Text, StyleSheet } from "react-native";
import { tokens as t } from "../theme/tokens";

export default function CameraScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Camera</Text>
      <Text style={styles.sub}>Substitua por sua tela da câmera que já funciona</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: t.color.bg, padding: 16 },
  title: { color: t.color.text, fontSize: 22, fontWeight: "700", marginBottom: 6 },
  sub: { color: t.color.sub },
});



src/screens/DashboardScreen.tsx


import React from "react";
import { View, Text, StyleSheet } from "react-native";
import { tokens as t } from "../theme/tokens";

export default function DashboardScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Dashboard</Text>
      <Text style={styles.sub}>Placeholder</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: t.color.bg, padding: 16 },
  title: { color: t.color.text, fontSize: 22, fontWeight: "700", marginBottom: 6 },
  sub: { color: t.color.sub },
});



src/screens/SettingsScreen.tsx


import React from "react";
import { View, Text, StyleSheet, Pressable } from "react-native";
import { tokens as t } from "../theme/tokens";
import { useLanguage } from "../context/LanguageContext";

export default function SettingsScreen() {
  const { lang, setLang } = useLanguage();
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Ajustes</Text>
      <Text style={styles.sub}>Idioma atual: {lang.toUpperCase()}</Text>

      <View style={{ flexDirection: "row", gap: 8, marginTop: 12 }}>
        {(["pt", "en", "es"] as const).map(code => (
          <Pressable
            key={code}
            onPress={() => setLang(code)}
            style={{
              paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10,
              borderWidth: 1, borderColor: t.color.border,
              backgroundColor: lang === code ? t.color.accent : "transparent",
            }}
          >
            <Text style={{ color: lang === code ? "#fff" : t.color.text, fontWeight: "700" }}>
              {code.toUpperCase()}
            </Text>
          </Pressable>
        ))}
      </View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: t.color.bg, padding: 16 },
  title: { color: t.color.text, fontSize: 22, fontWeight: "700", marginBottom: 6 },
  sub: { color: t.color.sub },
});



5) Garanta as dependências de navegação instaladas


npx expo install @react-navigation/native @react-navigation/bottom-tabs react-native-screens react-native-safe-area-context
npx expo install @expo/vector-icons



6) (Opcional) tsconfig.json saudável


Se não existir, crie na raiz:


{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["ES2017", "DOM"],
    "module": "ESNext",
    "jsx": "react-jsx",
    "strict": true,
    "noEmit": true,
    "moduleResolution": "bundler",
    "allowJs": false,
    "isolatedModules": true,
    "types": ["react", "react-native", "expo/metro-runtime"],
    "skipLibCheck": true
  },
  "include": ["**/*.ts", "**/*.tsx"]
}



7) Reinicie o bundler


npx expo start -c



Se o erro persistir, verifique:




o nome dos arquivos (ex.: HomeScreen.tsx, não .js),


os caminhos de import ("./src/screens/HomeScreen" etc.),


se você abriu no VS Code a pasta do projeto (onde está package.json).




























Aqui vai um App.tsx já alinhado com o visual (usando os tokens de tema) e mantendo sua navegação com bottom tabs, ícones do Ionicons e suporte a idiomas via LanguageProvider.




Se ainda não tem as deps de navegação:


npx expo install @react-navigation/native @react-navigation/bottom-tabs react-native-screens react-native-safe-area-context
npx expo install @expo/vector-icons





// App.tsx
import React from "react";
import { LogBox } from "react-native";
import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";
import DashboardScreen from "./src/screens/DashboardScreen";
import SettingsScreen from "./src/screens/SettingsScreen";

import { LanguageProvider, useLanguage } from "./src/context/LanguageContext";
import { tokens as t } from "./src/theme/tokens";

LogBox.ignoreLogs(["useInsertionEffect must not schedule updates"]);

export type TabParamList = {
  Home: undefined;
  Camera: undefined;
  Dashboard: undefined;
  Settings: undefined;
};

const Tab = createBottomTabNavigator<TabParamList>();

// Tema escuro baseado nos tokens
const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: t.color.bg,
    primary: t.color.accent,
    card: t.color.card,
    text: t.color.text,
    border: t.color.border,
    notification: t.color.accent,
  },
};

// Labels por idioma (simples)
const labels = {
  pt: { home: "Início", camera: "Câmera", dashboard: "Dashboard", settings: "Ajustes" },
  en: { home: "Home", camera: "Camera", dashboard: "Dashboard", settings: "Settings" },
  es: { home: "Inicio", camera: "Cámara", dashboard: "Panel", settings: "Ajustes" },
} as const;

function AppNavigator() {
  const { lang } = useLanguage();
  const L = labels[lang as keyof typeof labels] ?? labels.en;

  return (
    <NavigationContainer theme={DarkThemeHB}>
      {/* key={lang} força os rótulos a atualizarem quando o idioma muda */}
      <Tab.Navigator
        key={lang}
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: t.color.card },
          headerTintColor: t.color.text,
          tabBarStyle: { backgroundColor: t.color.bg, borderTopColor: t.color.border },
          tabBarActiveTintColor: t.color.accent,
          tabBarInactiveTintColor: t.color.sub,
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} options={() => ({ title: L.home, tabBarLabel: L.home })} />
        <Tab.Screen name="Camera" component={CameraScreen} options={() => ({ title: L.camera, tabBarLabel: L.camera })} />
        <Tab.Screen name="Dashboard" component={DashboardScreen} options={() => ({ title: L.dashboard, tabBarLabel: L.dashboard })} />
        <Tab.Screen name="Settings" component={SettingsScreen} options={() => ({ title: L.settings, tabBarLabel: L.settings })} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}

export default function App() {
  return (
    <LanguageProvider>
      <AppNavigator />
    </LanguageProvider>
  );
}



Se quiser que eu deixe os ícones, paddings e bordas idênticos ao app antigo, me manda os estilos/prints e eu ajusto os tokens (cores, radius, sombras, tipografia) para espelhar 1:1.













































import React from "react";
import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";
import { LogBox } from "react-native";
LogBox.ignoreLogs(["useInsertionEffect must not schedule updates"]);

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";
import DashboardScreen from "./src/screens/DashboardScreen";
import SettingsScreen from "./src/screens/SettingsScreen";

import { LanguageProvider, useLanguage } from "./src/context/LanguageContext";

export type TabParamList = {
  Home: undefined;
  Camera: undefined;
  Dashboard: undefined;
  Settings: undefined;
};

const Tab = createBottomTabNavigator<TabParamList>();

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
};

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

// Traduções simples
const labels = {
  pt: { home: "Início", camera: "Câmera", dashboard: "Dashboard", settings: "Ajustes" },
  en: { home: "Home", camera: "Camera", dashboard: "Dashboard", settings: "Settings" },
  es: { home: "Inicio", camera: "Cámara", dashboard: "Panel", settings: "Ajustes" },
};

function AppNavigator() {
  const { lang } = useLanguage();
  const L = labels[lang];

  return (
    <NavigationContainer theme={DarkThemeHB}>
      {/* key={lang} força o TabNavigator a reconfigurar rótulos/títulos ao mudar o idioma */}
      <Tab.Navigator
        key={lang}
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
              
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen
          name="Home"
          component={HomeScreen}
          // options como FUNÇÃO, para recomputar com L atualizado
          options={() => ({ title: L.home, tabBarLabel: L.home })}
        />
        <Tab.Screen
          name="Camera"
          component={CameraScreen}
          options={() => ({ title: L.camera, tabBarLabel: L.camera })}
        />
        <Tab.Screen
          name="Dashboard"
          component={DashboardScreen}
          options={() => ({ title: L.dashboard, tabBarLabel: L.dashboard })}
        />
        <Tab.Screen
          name="Settings"
          component={SettingsScreen}
          options={() => ({ title: L.settings, tabBarLabel: L.settings })}
        />
      </Tab.Navigator>
    </NavigationContainer>
  );
}

export default function App() {
  return (
    <LanguageProvider>
      <AppNavigator />
    </LanguageProvider>
  );
}





























massa! bora espelhar o visual do app antigo sem mexer na lógica nova.

pra agilizar, já deixei um esqueleto de tema + componentes onde a gente só “pluga” as cores/fontes/raios/sombras do seu app antigo. quando você mandar os códigos/imagens do antigo, eu só preencho os tokens — sem reescrever as telas.


o que me enviar do app antigo




colors.ts (ou onde ficavam as cores) e qualquer ThemeProvider/fonts.


1 tela que você quer copiar (JS/TSX) + styles dela.


se tiver, variáveis de spacing, radius, shadow, font family.


screenshots ajudam pra acertar microdetalhes.





1) tokens de tema (adicione em src/theme/tokens.ts)


// src/theme/tokens.ts
export const tokens = {
  color: {
    bg: "#0b0b0f",
    card: "#121218",
    border: "#25273a",
    text: "#e5e7eb",
    sub: "#9ca3af",
    accent: "#e6403a",
    success: "#10b981",
    danger: "#ef4444",
  },
  radius: {
    xs: 8,
    sm: 10,
    md: 12,
    lg: 16,
    xl: 20,
    pill: 999,
  },
  space: {
    xs: 6,
    sm: 8,
    md: 12,
    lg: 16,
    xl: 24,
    xxl: 32,
  },
  font: {
    // trocamos assim que você mandar as famílias/weights do app antigo
    regular: "System",
    medium: "System",
    bold: "System",
  },
  shadow: {
    card: { elevation: 3, shadowOpacity: 0.15, shadowRadius: 6, shadowOffset: { width: 0, height: 3 } },
  },
};
export type Tokens = typeof tokens;



2) UI base (botão, campo, cartão, header) — src/ui/index.tsx


// src/ui/index.tsx
import React, { PropsWithChildren } from "react";
import { View, Text, Pressable, TextInput, StyleSheet, ViewStyle, TextStyle, TextInputProps } from "react-native";
import { tokens as t } from "../theme/tokens";

export function Screen({ children }: PropsWithChildren) {
  return <View style={{ flex: 1, backgroundColor: t.color.bg, padding: t.space.lg }}>{children}</View>;
}

export function Header({ title, subtitle }: { title: string; subtitle?: string }) {
  return (
    <View style={{ marginBottom: t.space.lg }}>
      <Text style={{ color: t.color.text, fontSize: 22, fontWeight: "700" }}>{title}</Text>
      {!!subtitle && <Text style={{ color: t.color.sub, marginTop: 4 }}>{subtitle}</Text>}
    </View>
  );
}

export function Card({ children, style }: PropsWithChildren<{ style?: ViewStyle }>) {
  return (
    <View style={[styles.card, style]}>
      {children}
    </View>
  );
}

export function Button({
  label, onPress, variant = "primary", style, textStyle,
}: { label: string; onPress: () => void; variant?: "primary" | "ghost"; style?: ViewStyle; textStyle?: TextStyle }) {
  const bg = variant === "primary" ? t.color.accent : "transparent";
  const color = variant === "primary" ? "#fff" : t.color.text;
  return (
    <Pressable onPress={onPress} style={[styles.btn, { backgroundColor: bg, borderColor: t.color.border }, style]}>
      <Text style={[{ color, fontWeight: "700" }, textStyle]}>{label}</Text>
    </Pressable>
  );
}

export function Field({
  label, value, onChangeText, placeholder, keyboardType,
}: { label: string } & TextInputProps) {
  return (
    <View style={{ flex: 1 }}>
      <Text style={{ color: t.color.text, marginBottom: 6, fontWeight: "600" }}>{label}</Text>
      <TextInput
        style={styles.input}
        value={value}
        onChangeText={onChangeText}
        placeholder={placeholder}
        placeholderTextColor={t.color.sub}
        keyboardType={keyboardType}
        autoCapitalize="none"
        autoCorrect={false}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: t.color.card,
    borderWidth: 1,
    borderColor: t.color.border,
    borderRadius: t.radius.lg,
    overflow: "hidden",
    ...t.shadow.card,
  },
  btn: {
    paddingHorizontal: t.space.lg,
    paddingVertical: t.space.sm + 2,
    borderRadius: t.radius.md,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  input: {
    backgroundColor: t.color.card,
    borderWidth: 1,
    borderColor: t.color.border,
    borderRadius: t.radius.md,
    paddingHorizontal: t.space.md,
    paddingVertical: t.space.sm,
    color: t.color.text,
  },
});



3) CameraScreen reestilizada usando os componentes


Substitua sua tela atual por esta versão (funcionalidade idêntica; visual padronizado pelos tokens):


// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { View, Text, Image, AppState, AppStateStatus, Platform, NativeSyntheticEvent, ImageErrorEventData, StyleSheet } from "react-native";
import { WebView } from "react-native-webview";
import type { WebViewErrorEvent, WebViewHttpErrorEvent } from "react-native-webview/lib/WebViewTypes";
import { Screen, Header, Card, Button, Field } from "../ui";
import { tokens as t } from "../theme/tokens";

type Mode = "mjpeg" | "snapshot";

export default function CameraScreen() {
  const [ip, setIp] = useState("192.168.3.3");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [connected, setConnected] = useState("—");
  const [lastErr, setLastErr] = useState("");

  const [snapUri, setSnapUri] = useState("");
  const timerRef = useRef<number | null>(null);
  const appState = useRef(AppState.currentState);

  const base80 = useMemo(() => `http://${ip}`, [ip]);
  const base81 = useMemo(() => `http://${ip}:81`, [ip]);
  const statusUrl = useMemo(() => `${base80}/status`, [base80]);
  const snapshotUrl = useMemo(() => `${base80}/capture`, [base80]);
  const streamUrl = useMemo(() => `${base81}/stream`, [base81]);

  const clearTimer = useCallback(() => {
    if (timerRef.current !== null) { clearInterval(timerRef.current); timerRef.current = null; }
  }, []);
  const startSnapshotLoop = useCallback(() => {
    clearTimer();
    timerRef.current = setInterval(() => setSnapUri(`${snapshotUrl}?ts=${Date.now()}`), 125) as unknown as number;
  }, [snapshotUrl, clearTimer]);

  useEffect(() => {
    const sub = AppState.addEventListener("change", (next: AppStateStatus) => {
      if (appState.current.match(/inactive|background/) && next === "active" && mode === "snapshot") startSnapshotLoop();
      if (next.match(/inactive|background/)) clearTimer();
      appState.current = next;
    });
    return () => { sub.remove(); clearTimer(); };
  }, [mode, startSnapshotLoop, clearTimer]);

  useEffect(() => {
    setLastErr("");
    if (mode === "snapshot") startSnapshotLoop(); else clearTimer();
    return () => clearTimer();
  }, [mode, startSnapshotLoop, clearTimer]);

  const checkStatus = useCallback(async () => {
    try {
      const res = await fetch(statusUrl);
      const txt = await res.text();
      setConnected(`OK (${txt.slice(0, 60)}${txt.length > 60 ? "..." : ""})`);
    } catch (e) {
      const err = e as Error;
      setConnected("Falhou");
      setLastErr(err?.message ?? String(e));
    }
  }, [statusUrl]);

  useEffect(() => { if (ip) checkStatus(); }, [ip, checkStatus]);

  const onWvError = useCallback((e: WebViewErrorEvent) => setLastErr(`WebView: ${e.nativeEvent.description}`), []);
  const onWvHttpError = useCallback((e: WebViewHttpErrorEvent) => setLastErr(`HTTP ${e.nativeEvent.statusCode}`), []);
  const onImgError = useCallback((e: NativeSyntheticEvent<ImageErrorEventData>) => setLastErr(`Snapshot: ${e.nativeEvent.error}`), []);

  return (
    <Screen>
      <Header title="Câmera" subtitle="Visual ao estilo do app antigo (tokens prontos para ajuste)" />

      <View style={{ flexDirection: "row", gap: t.space.sm, alignItems: "flex-end" }}>
        <Field label="ESP IP" value={ip} onChangeText={setIp}
               placeholder="ex.: 192.168.3.3"
               keyboardType={Platform.OS === "android" ? "numeric" : "numbers-and-punctuation"} />
        <Button label="Testar" onPress={checkStatus} />
      </View>

      <View style={{ flexDirection: "row", gap: t.space.sm, marginTop: t.space.sm }}>
        <Button label="MJPEG" onPress={() => setMode("mjpeg")} variant={mode === "mjpeg" ? "primary" : "ghost"} />
        <Button label="Snapshot" onPress={() => setMode("snapshot")} variant={mode === "snapshot" ? "primary" : "ghost"} />
      </View>

      <Card style={{ flex: 1, marginTop: t.space.md }}>
        {mode === "mjpeg" ? (
          <WebView
            source={{ uri: streamUrl }}
            style={{ width: "100%", height: "100%" }}
            allowsInlineMediaPlayback
            mediaPlaybackRequiresUserAction={false}
            allowUniversalAccessFromFileURLs
            onError={onWvError}
            onHttpError={onWvHttpError}
          />
        ) : (
          <Image
            source={{ uri: snapUri || `${snapshotUrl}?ts=${Date.now()}` }}
            style={{ width: "100%", height: "100%" }}
            resizeMode="contain"
            onError={onImgError}
          />
        )}
      </Card>

      <View style={{ marginTop: t.space.sm }}>
        <Text style={styles.meta}>Status: <Text style={{ color: t.color.success }}>{connected}</Text></Text>
        <Text style={styles.meta}>Stream: <Text style={{ color: t.color.sub }}>{streamUrl}</Text></Text>
        <Text style={styles.meta}>Snapshot: <Text style={{ color: t.color.sub }}>{snapshotUrl}</Text></Text>
        {!!lastErr && <Text style={[styles.meta, { color: t.color.danger }]}>Erro: {lastErr}</Text>}
      </View>
    </Screen>
  );
}

const styles = StyleSheet.create({
  meta: { color: t.color.text, fontSize: 12 },
});




como vamos “copiar” o design antigo




assim que você me mandar os arquivos do tema antigo, eu só edito tokens.ts (cores, radius, shadows, tipografia) e, se precisar, ajusto o Button, Card e Field pra bater 100% com o seu visual (bordas, ícones, padding, etc.).


a CameraScreen já está usando esses componentes — então o app inteiro “troca de roupa” com pouca mudança.




manda a primeira tela/estilos do app antigo e eu já deixo os tokens idênticos 👌








































App.tsx

import React from "react";
import { NavigationContainer, DefaultTheme, Theme } from "@react-navigation/native";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { Ionicons } from "@expo/vector-icons";
import { LogBox } from "react-native";
LogBox.ignoreLogs(["useInsertionEffect must not schedule updates"]);

import HomeScreen from "./src/screens/HomeScreen";
import CameraScreen from "./src/screens/CameraScreen";
import DashboardScreen from "./src/screens/DashboardScreen";
import SettingsScreen from "./src/screens/SettingsScreen";

import { LanguageProvider, useLanguage } from "./src/context/LanguageContext";

export type TabParamList = {
  Home: undefined;
  Camera: undefined;
  Dashboard: undefined;
  Settings: undefined;
};

const Tab = createBottomTabNavigator<TabParamList>();

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
};

const DarkThemeHB: Theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: PALETTE.bg,
    primary: PALETTE.red,
    card: PALETTE.card,
    text: PALETTE.white,
    border: PALETTE.border,
    notification: PALETTE.red,
  },
};

// Traduções simples
const labels = {
  pt: { home: "Início", camera: "Câmera", dashboard: "Dashboard", settings: "Ajustes" },
  en: { home: "Home", camera: "Camera", dashboard: "Dashboard", settings: "Settings" },
  es: { home: "Inicio", camera: "Cámara", dashboard: "Panel", settings: "Ajustes" },
};

function AppNavigator() {
  const { lang } = useLanguage();
  const L = labels[lang];

  return (
    <NavigationContainer theme={DarkThemeHB}>
      {/* key={lang} força o TabNavigator a reconfigurar rótulos/títulos ao mudar o idioma */}
      <Tab.Navigator
        key={lang}
        initialRouteName="Home"
        screenOptions={({ route }) => ({
          headerStyle: { backgroundColor: PALETTE.card },
          headerTintColor: PALETTE.white,
          tabBarStyle: { backgroundColor: PALETTE.bg, borderTopColor: PALETTE.border },
          tabBarActiveTintColor: PALETTE.red,
          tabBarInactiveTintColor: "#9c9c9c",
          tabBarIcon: ({ color, size }) => {
            const icons: Record<keyof TabParamList, keyof typeof Ionicons.glyphMap> = {
              Home: "home",
              Camera: "videocam",
              Dashboard: "pulse",
              Settings: "settings",
              
            };
            return <Ionicons name={icons[route.name as keyof TabParamList]} size={size} color={color} />;
          },
        })}
      >
        <Tab.Screen
          name="Home"
          component={HomeScreen}
          // options como FUNÇÃO, para recomputar com L atualizado
          options={() => ({ title: L.home, tabBarLabel: L.home })}
        />
        <Tab.Screen
          name="Camera"
          component={CameraScreen}
          options={() => ({ title: L.camera, tabBarLabel: L.camera })}
        />
        <Tab.Screen
          name="Dashboard"
          component={DashboardScreen}
          options={() => ({ title: L.dashboard, tabBarLabel: L.dashboard })}
        />
        <Tab.Screen
          name="Settings"
          component={SettingsScreen}
          options={() => ({ title: L.settings, tabBarLabel: L.settings })}
        />
      </Tab.Navigator>
    </NavigationContainer>
  );
}

export default function App() {
  return (
    <LanguageProvider>
      <AppNavigator />
    </LanguageProvider>
  );
}











// src/screens/CameraScreen.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { View, Text, TextInput, Pressable, StyleSheet, Image, AppState, AppStateStatus } from "react-native";
import { WebView } from "react-native-webview";

type Mode = "mjpeg" | "snapshot";

const PALETTE = { bg: "#0b0b0f", card: "#121218", border: "#25273a", accent: "#e6403a", text: "#e5e7eb" };

// Utilitário de timeout para fetch
async function fetchWithTimeout(url: string, ms = 2000) {
  const ctrl = new AbortController();
  const to = setTimeout(() => ctrl.abort(), ms);
  try {
    const r = await fetch(url, { method: "GET", signal: ctrl.signal });
    return r;
  } finally {
    clearTimeout(to);
  }
}

export default function CameraScreen() {
  const [ip, setIp] = useState("192.168.4.1"); // coloque o IP do seu ESP
  const [status, setStatus] = useState("Aguardando IP");
  const [mode, setMode] = useState<Mode>("mjpeg");
  const [streamURL, setStreamURL] = useState<string>("");
  const [snapshotURL, setSnapshotURL] = useState<string>("");
  const [snapTick, setSnapTick] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  const snapTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const appState = useRef<AppStateStatus>(AppState.currentState);

  // Candidatos típicos do firmware “teste esp32”
  const streamCandidates = useMemo(() => {
    const base = (ip || "").trim();
    if (!base) return [];
    return [
      `http://${base}:81/stream`,   // padrão do exemplo oficial
      `http://${base}/stream`,      // alguns firmwares servem na 80
      `http://${base}:80/stream`,
      `http://${base}:81/mjpeg`,    // variações
      `http://${base}/mjpeg`,
    ];
  }, [ip]);

  const snapshotCandidates = useMemo(() => {
    const base = (ip || "").trim();
    if (!base) return [];
    return [
      `http://${base}/capture`,     // padrão do exemplo oficial
      `http://${base}/snapshot`,
      `http://${base}:81/capture`,
      `http://${base}:81/snapshot`,
      `http://${base}:80/capture`,
      `http://${base}:80/snapshot`,
    ];
  }, [ip]);

  // Loop do snapshot (fallback)
  const startSnapshotLoop = useCallback(() => {
    if (snapTimerRef.current) return;
    snapTimerRef.current = setInterval(() => setSnapTick((t) => (t + 1) % 1_000_000), 200); // ~5 fps estável
  }, []);
  const stopSnapshotLoop = useCallback(() => {
    if (!snapTimerRef.current) return;
    clearInterval(snapTimerRef.current);
    snapTimerRef.current = null;
  }, []);
  useEffect(() => {
    if (mode === "snapshot" && snapshotURL) startSnapshotLoop();
    else stopSnapshotLoop();
    return stopSnapshotLoop;
  }, [mode, snapshotURL, startSnapshotLoop, stopSnapshotLoop]);

  // Pausar ao ir para background
  useEffect(() => {
    const sub = AppState.addEventListener("change", (next) => {
      const prev = appState.current;
      appState.current = next;
      if (prev.match(/active/) && next.match(/inactive|background/)) {
        stopSnapshotLoop();
        setIsRunning(false);
      } else if (prev.match(/inactive|background/) && next === "active") {
        if (mode === "snapshot" && snapshotURL) startSnapshotLoop();
        if (streamURL || snapshotURL) setIsRunning(true);
      }
    });
    return () => sub.remove();
  }, [mode, snapshotURL, streamURL, startSnapshotLoop, stopSnapshotLoop]);

  // Teste/auto-detecção
  const testConnection = useCallback(async () => {
    const target = (ip || "").trim();
    if (!target) {
      setStatus("Informe o IP do ESP");
      return;
    }
    setStatus("Testando...");
    setIsRunning(false);
    stopSnapshotLoop();
    setStreamURL("");
    setSnapshotURL("");

    // 1) Tentar candidatos de MJPEG
    for (const u of streamCandidates) {
      try {
        const r = await fetchWithTimeout(u, 2000);
        if (r.ok) {
          setStreamURL(u);
          setMode("mjpeg");
          setStatus(`Conectado (MJPEG): ${u}`);
          setIsRunning(true);
          return;
        }
      } catch {}
    }

    // 2) Fallback: tentar snapshot
    for (const u of snapshotCandidates) {
      try {
        const r = await fetchWithTimeout(u, 2000);
        if (r.ok) {
          setSnapshotURL(u);
          setMode("snapshot");
          setStatus(`Conectado (Snapshot): ${u}`);
          setIsRunning(true);
          startSnapshotLoop();
          return;
        }
      } catch {}
    }

    setStatus("Falha ao conectar — verifique IP, porta 81/80 e rotas (/stream ou /capture).");
    setIsRunning(false);
  }, [ip, streamCandidates, snapshotCandidates, startSnapshotLoop, stopSnapshotLoop]);

  // HTML que carrega o MJPEG com auto-reconnect
  const mjpegHTML = useMemo(() => {
    if (!streamURL) return "";
    return `
      <!doctype html>
      <html><head><meta name="viewport" content="width=device-width, initial-scale=1"/>
      <style>
        html,body{margin:0;padding:0;background:#000;height:100%;overflow:hidden;}
        #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;}
        img{max-width:100vw;max-height:100vh;object-fit:contain;}
        #badge{position:fixed;left:8px;bottom:8px;padding:4px 8px;border-radius:8px;
               background:#121218;color:#e5e7eb;font-family:system-ui,Arial,sans-serif;font-size:12px;opacity:.7}
      </style></head>
      <body>
        <div id="wrap"><img id="mjpeg" src="${streamURL}"/></div>
        <div id="badge">${streamURL}</div>
        <script>
          const img = document.getElementById('mjpeg');
          let backoff=800;
          img.addEventListener('error',()=>{
            setTimeout(()=>{ img.src='${streamURL}?_='+Date.now(); }, backoff);
            backoff = Math.min(backoff*2, 4000);
          });
        </script>
      </body></html>
    `.trim();
  }, [streamURL]);

  const snapshotURI = useMemo(
    () => (snapshotURL ? `${snapshotURL}?_=${snapTick}` : ""),
    [snapshotURL, snapTick]
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>ESP32-CAM Viewer</Text>

      <View style={styles.row}>
        <Text style={styles.label}>ESP IP</Text>
        <TextInput
          value={ip}
          onChangeText={setIp}
          placeholder="ex.: 192.168.3.3"
          placeholderTextColor="#6b7280"
          autoCapitalize="none"
          autoCorrect={false}
          style={styles.input}
        />
        <Pressable style={styles.button} onPress={testConnection}>
          <Text style={styles.buttonText}>Testar</Text>
        </Pressable>
      </View>

      <Text style={styles.status}>Status: {status} {isRunning ? " | OK" : ""}</Text>

      <View style={styles.viewer}>
        {isRunning ? (
          mode === "mjpeg" && streamURL ? (
            <WebView
              originWhitelist={["*"]}
              source={{ html: mjpegHTML, baseUrl: streamURL }}
              javaScriptEnabled
              domStorageEnabled
              allowsInlineMediaPlayback
              mediaPlaybackRequiresUserAction={false}
              allowsFullscreenVideo={false}
              mixedContentMode="always"                         // Android: libera HTTP claro
              androidHardwareAccelerationEnabled
              setSupportMultipleWindows={false}
              onError={() => {
                // se falhar, tenta cair automaticamente para snapshot candidates
                setStatus("MJPEG falhou — alternando para Snapshot...");
                setMode("snapshot");
                // escolhe o melhor snapshot disponível já conhecido ou o primeiro candidato
                setSnapshotURL((prev) => prev || snapshotCandidates[0] || "");
                startSnapshotLoop();
              }}
              style={styles.webview}
            />
          ) : (
            <Image
              source={{ uri: snapshotURI }}
              resizeMode="contain"
              style={styles.image}
              onError={() => setStatus("Erro no snapshot — verifique /capture ou /snapshot")}
            />
          )
        ) : (
          <View style={styles.placeholder}>
            <Text style={{ color: PALETTE.text, opacity: 0.7, textAlign: "center" }}>
              Informe o IP e toque em “Testar”. A tela tenta automaticamente
              <Text> :81/stream → /stream → /capture.</Text>
            </Text>
          </View>
        )}
      </View>

      {isRunning ? (
        <View style={styles.footerRow}>
          <Pressable
            style={[styles.smallBtn, mode === "mjpeg" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("mjpeg"); setStatus("Tentando MJPEG /stream..."); }}
          >
            <Text style={styles.smallBtnText}>Usar MJPEG</Text>
          </Pressable>
          <Pressable
            style={[styles.smallBtn, mode === "snapshot" ? styles.smallBtnActive : null]}
            onPress={() => { setMode("snapshot"); setStatus("Usando Snapshot (/capture)"); }}
          >
            <Text style={styles.smallBtnText}>Usar Snapshot</Text>
          </Pressable>
        </View>
      ) : null}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 16, gap: 12 },
  title: { color: PALETTE.text, fontSize: 20, fontWeight: "700" },
  row: { flexDirection: "row", alignItems: "center", gap: 8 },
  label: { color: PALETTE.text },
  input: {
    flex: 1, backgroundColor: PALETTE.card, color: PALETTE.text,
    borderWidth: 1, borderColor: PALETTE.border, borderRadius: 10,
    paddingHorizontal: 10, paddingVertical: 8,
  },
  button: { backgroundColor: PALETTE.accent, paddingHorizontal: 14, paddingVertical: 10, borderRadius: 10 },
  buttonText: { color: "#fff", fontWeight: "700" },
  status: { color: PALETTE.text, opacity: 0.9 },
  viewer: {
    flex: 1, backgroundColor: "#000", borderRadius: 12, overflow: "hidden",
    borderWidth: 1, borderColor: PALETTE.border,
  },
  webview: { flex: 1, backgroundColor: "#000" },
  image: { width: "100%", height: "100%" },
  placeholder: { flex: 1, alignItems: "center", justifyContent: "center", padding: 24 },
  footerRow: { flexDirection: "row", gap: 10, justifyContent: "center" },
  smallBtn: {
    paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1,
    borderColor: PALETTE.border, backgroundColor: PALETTE.card,
  },
  smallBtnActive: { borderColor: PALETTE.accent },
  smallBtnText: { color: PALETTE.text, fontWeight: "600" },
});










HomeScreen.tsx

import { View, Text, StyleSheet, Pressable, Dimensions, Image } from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import type { BottomTabNavigationProp } from "@react-navigation/bottom-tabs";
import type { TabParamList } from "../../App";
import { useLanguage } from "../context/LanguageContext";

type Nav = BottomTabNavigationProp<TabParamList>;
const W = Dimensions.get("window").width;
const CARD = W / 2 - 28;

const PALETTE = {
  bg: "#000000",
  card: "#0d0d0d",
  border: "#1a1a1a",
  red: "#E53B2F",
  redSoft: "#FF5A4D",
  white: "#FFFFFF",
  textSoft: "#E6E6E6",
};

const texts = {
  pt: { title: "HydroBot", sub: "Monitoramento e Controle", cam: "Câmera", dash: "Dashboard", hint: "Use o rodapé para navegar entre as seções" },
  en: { title: "HydroBot", sub: "Monitoring & Control", cam: "Camera", dash: "Dashboard", hint: "Use the footer to navigate" },
  es: { title: "HydroBot", sub: "Monitoreo y Control", cam: "Cámara", dash: "Panel", hint: "Usa el pie para navegar" },
};

export default function HomeScreen() {
  const navigation = useNavigation<Nav>();
  const { lang } = useLanguage();
  const T = texts[lang];

  const tiles = [
    { key: "Camera" as const, label: T.cam, icon: "videocam" as const, color: PALETTE.red },
    { key: "Dashboard" as const, label: T.dash, icon: "pulse" as const, color: PALETTE.redSoft },
  ];

  return (
    <View style={styles.container}>
      <View style={styles.hero}>
        <Image source={require("../../assets/logo.png")} style={styles.logo} resizeMode="contain" />
        <Text style={styles.title}>{T.title}</Text>
        <Text style={styles.sub}>{T.sub}</Text>
      </View>

      <View style={styles.grid}>
        {tiles.map((t) => (
          <Pressable
            key={t.key}
            onPress={() => navigation.navigate(t.key)}
            style={({ pressed }) => [
              styles.tile,
              { width: CARD, height: CARD, borderColor: t.color },
              pressed && { transform: [{ scale: 0.98 }] },
            ]}
          >
            <View style={[styles.tileInner, { backgroundColor: t.color }]}>
              <Ionicons name={t.icon} size={42} color={PALETTE.white} />
            </View>
            <Text style={styles.tileLabel}>{t.label}</Text>
          </Pressable>
        ))}
      </View>

      <Text style={styles.hint}>{T.hint}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: PALETTE.bg, padding: 18 },
  hero: { alignItems: "center", marginTop: 6, marginBottom: 16 },
  logo: { width: 120, height: 120, marginBottom: 6 },
  title: { color: PALETTE.white, fontSize: 24, fontWeight: "800" },
  sub: { color: PALETTE.textSoft, fontSize: 12 },
  grid: { flexDirection: "row", flexWrap: "wrap", justifyContent: "space-between", rowGap: 16 },
  tile: { borderRadius: 18, borderWidth: 2, backgroundColor: PALETTE.card, overflow: "hidden" },
  tileInner: { flex: 1, alignItems: "center", justifyContent: "center" },
  tileLabel: { position: "absolute", bottom: 8, width: "100%", textAlign: "center", color: PALETTE.white, fontWeight: "700", fontSize: 16 },
  hint: { textAlign: "center", color: "#9c9c9c", marginTop: 12, fontSize: 12 },
});
